
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:28:17.159] plan(): Setting new future strategy stack:
[09:28:17.159] List of future strategies:
[09:28:17.159] 1. sequential:
[09:28:17.159]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.159]    - tweaked: FALSE
[09:28:17.159]    - call: future::plan("sequential")
[09:28:17.172] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[09:28:17.227] plan(): Setting new future strategy stack:
[09:28:17.227] List of future strategies:
[09:28:17.227] 1. sequential:
[09:28:17.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.227]    - tweaked: FALSE
[09:28:17.227]    - call: plan(strategy)
[09:28:17.238] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[09:28:17.239] getGlobalsAndPackagesXApply() ...
[09:28:17.240]  - future.globals: TRUE
[09:28:17.240] getGlobalsAndPackages() ...
[09:28:17.240] Searching for globals...
[09:28:17.277] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:17.277] Searching for globals ... DONE
[09:28:17.277] Resolving globals: FALSE
[09:28:17.279] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:17.280] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:17.280] - globals: [1] ‘FUN’
[09:28:17.280] 
[09:28:17.280] getGlobalsAndPackages() ... DONE
[09:28:17.280]  - globals found/used: [n=1] ‘FUN’
[09:28:17.280]  - needed namespaces: [n=0] 
[09:28:17.281] Finding globals ... DONE
[09:28:17.281]  - use_args: TRUE
[09:28:17.281]  - Getting '...' globals ...
[09:28:17.282] resolve() on list ...
[09:28:17.282]  recursive: 0
[09:28:17.282]  length: 1
[09:28:17.283]  elements: ‘...’
[09:28:17.283]  length: 0 (resolved future 1)
[09:28:17.283] resolve() on list ... DONE
[09:28:17.283]    - '...' content: [n=0] 
[09:28:17.283] List of 1
[09:28:17.283]  $ ...: list()
[09:28:17.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.283]  - attr(*, "where")=List of 1
[09:28:17.283]   ..$ ...:<environment: 0x559ba39b28d0> 
[09:28:17.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.283]  - attr(*, "resolved")= logi TRUE
[09:28:17.283]  - attr(*, "total_size")= num NA
[09:28:17.287]  - Getting '...' globals ... DONE
[09:28:17.287] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.288] List of 2
[09:28:17.288]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.288]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.288]  $ ...          : list()
[09:28:17.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.288]  - attr(*, "where")=List of 2
[09:28:17.288]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.288]   ..$ ...          :<environment: 0x559ba39b28d0> 
[09:28:17.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.288]  - attr(*, "resolved")= logi FALSE
[09:28:17.288]  - attr(*, "total_size")= num 354224
[09:28:17.290] Packages to be attached in all futures: [n=0] 
[09:28:17.290] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.291] future_lapply() ...
[09:28:17.320] Number of chunks: 1
[09:28:17.320] getGlobalsAndPackagesXApply() ...
[09:28:17.320]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.320]  - use_args: TRUE
[09:28:17.320] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.321] List of 2
[09:28:17.321]  $ ...          : list()
[09:28:17.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.321]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.321]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.321]  - attr(*, "where")=List of 2
[09:28:17.321]   ..$ ...          :<environment: 0x559ba39b28d0> 
[09:28:17.321]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.321]  - attr(*, "resolved")= logi FALSE
[09:28:17.321]  - attr(*, "total_size")= num NA
[09:28:17.324] Packages to be attached in all futures: [n=0] 
[09:28:17.324] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.324] Number of futures (= number of chunks): 1
[09:28:17.324] Launching 1 futures (chunks) ...
[09:28:17.324] Chunk #1 of 1 ...
[09:28:17.325]  - seeds: <none>
[09:28:17.325]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.325] getGlobalsAndPackages() ...
[09:28:17.325] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.325] Resolving globals: FALSE
[09:28:17.325] Tweak future expression to call with '...' arguments ...
[09:28:17.325] {
[09:28:17.325]     do.call(function(...) {
[09:28:17.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.325]             on.exit(options(oopts), add = TRUE)
[09:28:17.325]         }
[09:28:17.325]         {
[09:28:17.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.325]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.325]             })
[09:28:17.325]         }
[09:28:17.325]     }, args = future.call.arguments)
[09:28:17.325] }
[09:28:17.326] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.326] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.326] 
[09:28:17.326] getGlobalsAndPackages() ... DONE
[09:28:17.327] run() for ‘Future’ ...
[09:28:17.327] - state: ‘created’
[09:28:17.327] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.328]   - Field: ‘label’
[09:28:17.328]   - Field: ‘local’
[09:28:17.328]   - Field: ‘owner’
[09:28:17.329]   - Field: ‘envir’
[09:28:17.329]   - Field: ‘packages’
[09:28:17.329]   - Field: ‘gc’
[09:28:17.329]   - Field: ‘conditions’
[09:28:17.329]   - Field: ‘expr’
[09:28:17.329]   - Field: ‘uuid’
[09:28:17.330]   - Field: ‘seed’
[09:28:17.330]   - Field: ‘version’
[09:28:17.330]   - Field: ‘result’
[09:28:17.330]   - Field: ‘asynchronous’
[09:28:17.330]   - Field: ‘calls’
[09:28:17.330]   - Field: ‘globals’
[09:28:17.330]   - Field: ‘stdout’
[09:28:17.330]   - Field: ‘earlySignal’
[09:28:17.330]   - Field: ‘lazy’
[09:28:17.330]   - Field: ‘state’
[09:28:17.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.331] - Launch lazy future ...
[09:28:17.331] Packages needed by the future expression (n = 0): <none>
[09:28:17.331] Packages needed by future strategies (n = 0): <none>
[09:28:17.332] {
[09:28:17.332]     {
[09:28:17.332]         {
[09:28:17.332]             ...future.startTime <- base::Sys.time()
[09:28:17.332]             {
[09:28:17.332]                 {
[09:28:17.332]                   {
[09:28:17.332]                     base::local({
[09:28:17.332]                       has_future <- base::requireNamespace("future", 
[09:28:17.332]                         quietly = TRUE)
[09:28:17.332]                       if (has_future) {
[09:28:17.332]                         ns <- base::getNamespace("future")
[09:28:17.332]                         version <- ns[[".package"]][["version"]]
[09:28:17.332]                         if (is.null(version)) 
[09:28:17.332]                           version <- utils::packageVersion("future")
[09:28:17.332]                       }
[09:28:17.332]                       else {
[09:28:17.332]                         version <- NULL
[09:28:17.332]                       }
[09:28:17.332]                       if (!has_future || version < "1.8.0") {
[09:28:17.332]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.332]                           "", base::R.version$version.string), 
[09:28:17.332]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.332]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.332]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.332]                             "release", "version")], collapse = " "), 
[09:28:17.332]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.332]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.332]                           info)
[09:28:17.332]                         info <- base::paste(info, collapse = "; ")
[09:28:17.332]                         if (!has_future) {
[09:28:17.332]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.332]                             info)
[09:28:17.332]                         }
[09:28:17.332]                         else {
[09:28:17.332]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.332]                             info, version)
[09:28:17.332]                         }
[09:28:17.332]                         base::stop(msg)
[09:28:17.332]                       }
[09:28:17.332]                     })
[09:28:17.332]                   }
[09:28:17.332]                   ...future.strategy.old <- future::plan("list")
[09:28:17.332]                   options(future.plan = NULL)
[09:28:17.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.332]                 }
[09:28:17.332]                 ...future.workdir <- getwd()
[09:28:17.332]             }
[09:28:17.332]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.332]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.332]         }
[09:28:17.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.332]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.332]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.332]             base::names(...future.oldOptions))
[09:28:17.332]     }
[09:28:17.332]     if (FALSE) {
[09:28:17.332]     }
[09:28:17.332]     else {
[09:28:17.332]         if (TRUE) {
[09:28:17.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.332]                 open = "w")
[09:28:17.332]         }
[09:28:17.332]         else {
[09:28:17.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.332]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.332]         }
[09:28:17.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.332]             base::sink(type = "output", split = FALSE)
[09:28:17.332]             base::close(...future.stdout)
[09:28:17.332]         }, add = TRUE)
[09:28:17.332]     }
[09:28:17.332]     ...future.frame <- base::sys.nframe()
[09:28:17.332]     ...future.conditions <- base::list()
[09:28:17.332]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.332]     if (FALSE) {
[09:28:17.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.332]     }
[09:28:17.332]     ...future.result <- base::tryCatch({
[09:28:17.332]         base::withCallingHandlers({
[09:28:17.332]             ...future.value <- base::withVisible(base::local({
[09:28:17.332]                 do.call(function(...) {
[09:28:17.332]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.332]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.332]                     ...future.globals.maxSize)) {
[09:28:17.332]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.332]                     on.exit(options(oopts), add = TRUE)
[09:28:17.332]                   }
[09:28:17.332]                   {
[09:28:17.332]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.332]                       FUN = function(jj) {
[09:28:17.332]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.332]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.332]                       })
[09:28:17.332]                   }
[09:28:17.332]                 }, args = future.call.arguments)
[09:28:17.332]             }))
[09:28:17.332]             future::FutureResult(value = ...future.value$value, 
[09:28:17.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.332]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.332]                     ...future.globalenv.names))
[09:28:17.332]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.332]         }, condition = base::local({
[09:28:17.332]             c <- base::c
[09:28:17.332]             inherits <- base::inherits
[09:28:17.332]             invokeRestart <- base::invokeRestart
[09:28:17.332]             length <- base::length
[09:28:17.332]             list <- base::list
[09:28:17.332]             seq.int <- base::seq.int
[09:28:17.332]             signalCondition <- base::signalCondition
[09:28:17.332]             sys.calls <- base::sys.calls
[09:28:17.332]             `[[` <- base::`[[`
[09:28:17.332]             `+` <- base::`+`
[09:28:17.332]             `<<-` <- base::`<<-`
[09:28:17.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.332]                   3L)]
[09:28:17.332]             }
[09:28:17.332]             function(cond) {
[09:28:17.332]                 is_error <- inherits(cond, "error")
[09:28:17.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.332]                   NULL)
[09:28:17.332]                 if (is_error) {
[09:28:17.332]                   sessionInformation <- function() {
[09:28:17.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.332]                       search = base::search(), system = base::Sys.info())
[09:28:17.332]                   }
[09:28:17.332]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.332]                     cond$call), session = sessionInformation(), 
[09:28:17.332]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.332]                   signalCondition(cond)
[09:28:17.332]                 }
[09:28:17.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.332]                 "immediateCondition"))) {
[09:28:17.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.332]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.332]                   if (TRUE && !signal) {
[09:28:17.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.332]                     {
[09:28:17.332]                       inherits <- base::inherits
[09:28:17.332]                       invokeRestart <- base::invokeRestart
[09:28:17.332]                       is.null <- base::is.null
[09:28:17.332]                       muffled <- FALSE
[09:28:17.332]                       if (inherits(cond, "message")) {
[09:28:17.332]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.332]                         if (muffled) 
[09:28:17.332]                           invokeRestart("muffleMessage")
[09:28:17.332]                       }
[09:28:17.332]                       else if (inherits(cond, "warning")) {
[09:28:17.332]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.332]                         if (muffled) 
[09:28:17.332]                           invokeRestart("muffleWarning")
[09:28:17.332]                       }
[09:28:17.332]                       else if (inherits(cond, "condition")) {
[09:28:17.332]                         if (!is.null(pattern)) {
[09:28:17.332]                           computeRestarts <- base::computeRestarts
[09:28:17.332]                           grepl <- base::grepl
[09:28:17.332]                           restarts <- computeRestarts(cond)
[09:28:17.332]                           for (restart in restarts) {
[09:28:17.332]                             name <- restart$name
[09:28:17.332]                             if (is.null(name)) 
[09:28:17.332]                               next
[09:28:17.332]                             if (!grepl(pattern, name)) 
[09:28:17.332]                               next
[09:28:17.332]                             invokeRestart(restart)
[09:28:17.332]                             muffled <- TRUE
[09:28:17.332]                             break
[09:28:17.332]                           }
[09:28:17.332]                         }
[09:28:17.332]                       }
[09:28:17.332]                       invisible(muffled)
[09:28:17.332]                     }
[09:28:17.332]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.332]                   }
[09:28:17.332]                 }
[09:28:17.332]                 else {
[09:28:17.332]                   if (TRUE) {
[09:28:17.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.332]                     {
[09:28:17.332]                       inherits <- base::inherits
[09:28:17.332]                       invokeRestart <- base::invokeRestart
[09:28:17.332]                       is.null <- base::is.null
[09:28:17.332]                       muffled <- FALSE
[09:28:17.332]                       if (inherits(cond, "message")) {
[09:28:17.332]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.332]                         if (muffled) 
[09:28:17.332]                           invokeRestart("muffleMessage")
[09:28:17.332]                       }
[09:28:17.332]                       else if (inherits(cond, "warning")) {
[09:28:17.332]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.332]                         if (muffled) 
[09:28:17.332]                           invokeRestart("muffleWarning")
[09:28:17.332]                       }
[09:28:17.332]                       else if (inherits(cond, "condition")) {
[09:28:17.332]                         if (!is.null(pattern)) {
[09:28:17.332]                           computeRestarts <- base::computeRestarts
[09:28:17.332]                           grepl <- base::grepl
[09:28:17.332]                           restarts <- computeRestarts(cond)
[09:28:17.332]                           for (restart in restarts) {
[09:28:17.332]                             name <- restart$name
[09:28:17.332]                             if (is.null(name)) 
[09:28:17.332]                               next
[09:28:17.332]                             if (!grepl(pattern, name)) 
[09:28:17.332]                               next
[09:28:17.332]                             invokeRestart(restart)
[09:28:17.332]                             muffled <- TRUE
[09:28:17.332]                             break
[09:28:17.332]                           }
[09:28:17.332]                         }
[09:28:17.332]                       }
[09:28:17.332]                       invisible(muffled)
[09:28:17.332]                     }
[09:28:17.332]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.332]                   }
[09:28:17.332]                 }
[09:28:17.332]             }
[09:28:17.332]         }))
[09:28:17.332]     }, error = function(ex) {
[09:28:17.332]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.332]                 ...future.rng), started = ...future.startTime, 
[09:28:17.332]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.332]             version = "1.8"), class = "FutureResult")
[09:28:17.332]     }, finally = {
[09:28:17.332]         if (!identical(...future.workdir, getwd())) 
[09:28:17.332]             setwd(...future.workdir)
[09:28:17.332]         {
[09:28:17.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.332]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.332]             }
[09:28:17.332]             base::options(...future.oldOptions)
[09:28:17.332]             if (.Platform$OS.type == "windows") {
[09:28:17.332]                 old_names <- names(...future.oldEnvVars)
[09:28:17.332]                 envs <- base::Sys.getenv()
[09:28:17.332]                 names <- names(envs)
[09:28:17.332]                 common <- intersect(names, old_names)
[09:28:17.332]                 added <- setdiff(names, old_names)
[09:28:17.332]                 removed <- setdiff(old_names, names)
[09:28:17.332]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.332]                   envs[common]]
[09:28:17.332]                 NAMES <- toupper(changed)
[09:28:17.332]                 args <- list()
[09:28:17.332]                 for (kk in seq_along(NAMES)) {
[09:28:17.332]                   name <- changed[[kk]]
[09:28:17.332]                   NAME <- NAMES[[kk]]
[09:28:17.332]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.332]                     next
[09:28:17.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.332]                 }
[09:28:17.332]                 NAMES <- toupper(added)
[09:28:17.332]                 for (kk in seq_along(NAMES)) {
[09:28:17.332]                   name <- added[[kk]]
[09:28:17.332]                   NAME <- NAMES[[kk]]
[09:28:17.332]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.332]                     next
[09:28:17.332]                   args[[name]] <- ""
[09:28:17.332]                 }
[09:28:17.332]                 NAMES <- toupper(removed)
[09:28:17.332]                 for (kk in seq_along(NAMES)) {
[09:28:17.332]                   name <- removed[[kk]]
[09:28:17.332]                   NAME <- NAMES[[kk]]
[09:28:17.332]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.332]                     next
[09:28:17.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.332]                 }
[09:28:17.332]                 if (length(args) > 0) 
[09:28:17.332]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.332]             }
[09:28:17.332]             else {
[09:28:17.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.332]             }
[09:28:17.332]             {
[09:28:17.332]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.332]                   0L) {
[09:28:17.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.332]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.332]                   base::options(opts)
[09:28:17.332]                 }
[09:28:17.332]                 {
[09:28:17.332]                   {
[09:28:17.332]                     NULL
[09:28:17.332]                     RNGkind("Mersenne-Twister")
[09:28:17.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.332]                       inherits = FALSE)
[09:28:17.332]                   }
[09:28:17.332]                   options(future.plan = NULL)
[09:28:17.332]                   if (is.na(NA_character_)) 
[09:28:17.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.332]                     .init = FALSE)
[09:28:17.332]                 }
[09:28:17.332]             }
[09:28:17.332]         }
[09:28:17.332]     })
[09:28:17.332]     if (TRUE) {
[09:28:17.332]         base::sink(type = "output", split = FALSE)
[09:28:17.332]         if (TRUE) {
[09:28:17.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.332]         }
[09:28:17.332]         else {
[09:28:17.332]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.332]         }
[09:28:17.332]         base::close(...future.stdout)
[09:28:17.332]         ...future.stdout <- NULL
[09:28:17.332]     }
[09:28:17.332]     ...future.result$conditions <- ...future.conditions
[09:28:17.332]     ...future.result$finished <- base::Sys.time()
[09:28:17.332]     ...future.result
[09:28:17.332] }
[09:28:17.334] assign_globals() ...
[09:28:17.334] List of 5
[09:28:17.334]  $ future.call.arguments    : list()
[09:28:17.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.334]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.334]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.334]  $ ...future.elements_ii    :List of 2
[09:28:17.334]   ..$ : num [1:4] 1 3 1 7
[09:28:17.334]   ..$ : num [1:4] 2 4 6 8
[09:28:17.334]  $ ...future.seeds_ii       : NULL
[09:28:17.334]  $ ...future.globals.maxSize: num Inf
[09:28:17.334]  - attr(*, "resolved")= logi FALSE
[09:28:17.334]  - attr(*, "total_size")= num NA
[09:28:17.334]  - attr(*, "where")=List of 5
[09:28:17.334]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.334]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.334]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.334]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.334]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.334]  - attr(*, "already-done")= logi TRUE
[09:28:17.339] - copied ‘future.call.arguments’ to environment
[09:28:17.339] - copied ‘...future.FUN’ to environment
[09:28:17.339] - copied ‘...future.elements_ii’ to environment
[09:28:17.339] - copied ‘...future.seeds_ii’ to environment
[09:28:17.339] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.339] assign_globals() ... done
[09:28:17.340] plan(): Setting new future strategy stack:
[09:28:17.340] List of future strategies:
[09:28:17.340] 1. sequential:
[09:28:17.340]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.340]    - tweaked: FALSE
[09:28:17.340]    - call: NULL
[09:28:17.340] plan(): nbrOfWorkers() = 1
[09:28:17.341] plan(): Setting new future strategy stack:
[09:28:17.341] List of future strategies:
[09:28:17.341] 1. sequential:
[09:28:17.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.341]    - tweaked: FALSE
[09:28:17.341]    - call: plan(strategy)
[09:28:17.342] plan(): nbrOfWorkers() = 1
[09:28:17.342] SequentialFuture started (and completed)
[09:28:17.342] - Launch lazy future ... done
[09:28:17.343] run() for ‘SequentialFuture’ ... done
[09:28:17.343] Created future:
[09:28:17.343] SequentialFuture:
[09:28:17.343] Label: ‘future_apply-1’
[09:28:17.343] Expression:
[09:28:17.343] {
[09:28:17.343]     do.call(function(...) {
[09:28:17.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.343]             on.exit(options(oopts), add = TRUE)
[09:28:17.343]         }
[09:28:17.343]         {
[09:28:17.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.343]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.343]             })
[09:28:17.343]         }
[09:28:17.343]     }, args = future.call.arguments)
[09:28:17.343] }
[09:28:17.343] Lazy evaluation: FALSE
[09:28:17.343] Asynchronous evaluation: FALSE
[09:28:17.343] Local evaluation: TRUE
[09:28:17.343] Environment: R_GlobalEnv
[09:28:17.343] Capture standard output: TRUE
[09:28:17.343] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.343] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.343] Packages: <none>
[09:28:17.343] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.343] Resolved: TRUE
[09:28:17.343] Value: 2.21 KiB of class ‘list’
[09:28:17.343] Early signaling: FALSE
[09:28:17.343] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.343] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.344] Chunk #1 of 1 ... DONE
[09:28:17.344] Launching 1 futures (chunks) ... DONE
[09:28:17.344] Resolving 1 futures (chunks) ...
[09:28:17.345] resolve() on list ...
[09:28:17.345]  recursive: 0
[09:28:17.345]  length: 1
[09:28:17.345] 
[09:28:17.345] resolved() for ‘SequentialFuture’ ...
[09:28:17.345] - state: ‘finished’
[09:28:17.345] - run: TRUE
[09:28:17.345] - result: ‘FutureResult’
[09:28:17.345] resolved() for ‘SequentialFuture’ ... done
[09:28:17.345] Future #1
[09:28:17.346] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.346] - nx: 1
[09:28:17.346] - relay: TRUE
[09:28:17.346] - stdout: TRUE
[09:28:17.346] - signal: TRUE
[09:28:17.346] - resignal: FALSE
[09:28:17.346] - force: TRUE
[09:28:17.346] - relayed: [n=1] FALSE
[09:28:17.346] - queued futures: [n=1] FALSE
[09:28:17.347]  - until=1
[09:28:17.347]  - relaying element #1
[09:28:17.347] - relayed: [n=1] TRUE
[09:28:17.347] - queued futures: [n=1] TRUE
[09:28:17.347] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.347]  length: 0 (resolved future 1)
[09:28:17.347] Relaying remaining futures
[09:28:17.347] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.347] - nx: 1
[09:28:17.348] - relay: TRUE
[09:28:17.348] - stdout: TRUE
[09:28:17.348] - signal: TRUE
[09:28:17.348] - resignal: FALSE
[09:28:17.348] - force: TRUE
[09:28:17.348] - relayed: [n=1] TRUE
[09:28:17.348] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.348] - relayed: [n=1] TRUE
[09:28:17.348] - queued futures: [n=1] TRUE
[09:28:17.348] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.348] resolve() on list ... DONE
[09:28:17.349]  - Number of value chunks collected: 1
[09:28:17.349] Resolving 1 futures (chunks) ... DONE
[09:28:17.349] Reducing values from 1 chunks ...
[09:28:17.349]  - Number of values collected after concatenation: 2
[09:28:17.349]  - Number of values expected: 2
[09:28:17.349] Reducing values from 1 chunks ... DONE
[09:28:17.349] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:17.350] getGlobalsAndPackagesXApply() ...
[09:28:17.350]  - future.globals: TRUE
[09:28:17.350] getGlobalsAndPackages() ...
[09:28:17.350] Searching for globals...
[09:28:17.381] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:17.381] Searching for globals ... DONE
[09:28:17.381] Resolving globals: FALSE
[09:28:17.383] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:17.383] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:17.383] - globals: [1] ‘FUN’
[09:28:17.383] 
[09:28:17.383] getGlobalsAndPackages() ... DONE
[09:28:17.383]  - globals found/used: [n=1] ‘FUN’
[09:28:17.384]  - needed namespaces: [n=0] 
[09:28:17.384] Finding globals ... DONE
[09:28:17.384]  - use_args: TRUE
[09:28:17.384]  - Getting '...' globals ...
[09:28:17.384] resolve() on list ...
[09:28:17.384]  recursive: 0
[09:28:17.384]  length: 1
[09:28:17.384]  elements: ‘...’
[09:28:17.384]  length: 0 (resolved future 1)
[09:28:17.385] resolve() on list ... DONE
[09:28:17.385]    - '...' content: [n=0] 
[09:28:17.385] List of 1
[09:28:17.385]  $ ...: list()
[09:28:17.385]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.385]  - attr(*, "where")=List of 1
[09:28:17.385]   ..$ ...:<environment: 0x559ba442b940> 
[09:28:17.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.385]  - attr(*, "resolved")= logi TRUE
[09:28:17.385]  - attr(*, "total_size")= num NA
[09:28:17.387]  - Getting '...' globals ... DONE
[09:28:17.387] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.387] List of 2
[09:28:17.387]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.387]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.387]  $ ...          : list()
[09:28:17.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.387]  - attr(*, "where")=List of 2
[09:28:17.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.387]   ..$ ...          :<environment: 0x559ba442b940> 
[09:28:17.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.387]  - attr(*, "resolved")= logi FALSE
[09:28:17.387]  - attr(*, "total_size")= num 354224
[09:28:17.390] Packages to be attached in all futures: [n=0] 
[09:28:17.390] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.390] future_lapply() ...
[09:28:17.419] Number of chunks: 1
[09:28:17.419] getGlobalsAndPackagesXApply() ...
[09:28:17.419]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.419]  - use_args: TRUE
[09:28:17.419] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.419] List of 2
[09:28:17.419]  $ ...          : list()
[09:28:17.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.419]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.419]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.419]  - attr(*, "where")=List of 2
[09:28:17.419]   ..$ ...          :<environment: 0x559ba442b940> 
[09:28:17.419]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.419]  - attr(*, "resolved")= logi FALSE
[09:28:17.419]  - attr(*, "total_size")= num NA
[09:28:17.422] Packages to be attached in all futures: [n=0] 
[09:28:17.422] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.422] Number of futures (= number of chunks): 1
[09:28:17.422] Launching 1 futures (chunks) ...
[09:28:17.423] Chunk #1 of 1 ...
[09:28:17.423]  - seeds: <none>
[09:28:17.423]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.423] getGlobalsAndPackages() ...
[09:28:17.423] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.423] Resolving globals: FALSE
[09:28:17.423] Tweak future expression to call with '...' arguments ...
[09:28:17.423] {
[09:28:17.423]     do.call(function(...) {
[09:28:17.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.423]             on.exit(options(oopts), add = TRUE)
[09:28:17.423]         }
[09:28:17.423]         {
[09:28:17.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.423]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.423]             })
[09:28:17.423]         }
[09:28:17.423]     }, args = future.call.arguments)
[09:28:17.423] }
[09:28:17.424] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.424] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.424] 
[09:28:17.424] getGlobalsAndPackages() ... DONE
[09:28:17.424] run() for ‘Future’ ...
[09:28:17.424] - state: ‘created’
[09:28:17.425] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.425] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.425] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.425]   - Field: ‘label’
[09:28:17.425]   - Field: ‘local’
[09:28:17.425]   - Field: ‘owner’
[09:28:17.425]   - Field: ‘envir’
[09:28:17.425]   - Field: ‘packages’
[09:28:17.425]   - Field: ‘gc’
[09:28:17.426]   - Field: ‘conditions’
[09:28:17.426]   - Field: ‘expr’
[09:28:17.426]   - Field: ‘uuid’
[09:28:17.426]   - Field: ‘seed’
[09:28:17.426]   - Field: ‘version’
[09:28:17.426]   - Field: ‘result’
[09:28:17.426]   - Field: ‘asynchronous’
[09:28:17.426]   - Field: ‘calls’
[09:28:17.426]   - Field: ‘globals’
[09:28:17.426]   - Field: ‘stdout’
[09:28:17.426]   - Field: ‘earlySignal’
[09:28:17.427]   - Field: ‘lazy’
[09:28:17.427]   - Field: ‘state’
[09:28:17.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.427] - Launch lazy future ...
[09:28:17.427] Packages needed by the future expression (n = 0): <none>
[09:28:17.427] Packages needed by future strategies (n = 0): <none>
[09:28:17.427] {
[09:28:17.427]     {
[09:28:17.427]         {
[09:28:17.427]             ...future.startTime <- base::Sys.time()
[09:28:17.427]             {
[09:28:17.427]                 {
[09:28:17.427]                   {
[09:28:17.427]                     base::local({
[09:28:17.427]                       has_future <- base::requireNamespace("future", 
[09:28:17.427]                         quietly = TRUE)
[09:28:17.427]                       if (has_future) {
[09:28:17.427]                         ns <- base::getNamespace("future")
[09:28:17.427]                         version <- ns[[".package"]][["version"]]
[09:28:17.427]                         if (is.null(version)) 
[09:28:17.427]                           version <- utils::packageVersion("future")
[09:28:17.427]                       }
[09:28:17.427]                       else {
[09:28:17.427]                         version <- NULL
[09:28:17.427]                       }
[09:28:17.427]                       if (!has_future || version < "1.8.0") {
[09:28:17.427]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.427]                           "", base::R.version$version.string), 
[09:28:17.427]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.427]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.427]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.427]                             "release", "version")], collapse = " "), 
[09:28:17.427]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.427]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.427]                           info)
[09:28:17.427]                         info <- base::paste(info, collapse = "; ")
[09:28:17.427]                         if (!has_future) {
[09:28:17.427]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.427]                             info)
[09:28:17.427]                         }
[09:28:17.427]                         else {
[09:28:17.427]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.427]                             info, version)
[09:28:17.427]                         }
[09:28:17.427]                         base::stop(msg)
[09:28:17.427]                       }
[09:28:17.427]                     })
[09:28:17.427]                   }
[09:28:17.427]                   ...future.strategy.old <- future::plan("list")
[09:28:17.427]                   options(future.plan = NULL)
[09:28:17.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.427]                 }
[09:28:17.427]                 ...future.workdir <- getwd()
[09:28:17.427]             }
[09:28:17.427]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.427]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.427]         }
[09:28:17.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.427]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.427]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.427]             base::names(...future.oldOptions))
[09:28:17.427]     }
[09:28:17.427]     if (FALSE) {
[09:28:17.427]     }
[09:28:17.427]     else {
[09:28:17.427]         if (TRUE) {
[09:28:17.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.427]                 open = "w")
[09:28:17.427]         }
[09:28:17.427]         else {
[09:28:17.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.427]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.427]         }
[09:28:17.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.427]             base::sink(type = "output", split = FALSE)
[09:28:17.427]             base::close(...future.stdout)
[09:28:17.427]         }, add = TRUE)
[09:28:17.427]     }
[09:28:17.427]     ...future.frame <- base::sys.nframe()
[09:28:17.427]     ...future.conditions <- base::list()
[09:28:17.427]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.427]     if (FALSE) {
[09:28:17.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.427]     }
[09:28:17.427]     ...future.result <- base::tryCatch({
[09:28:17.427]         base::withCallingHandlers({
[09:28:17.427]             ...future.value <- base::withVisible(base::local({
[09:28:17.427]                 do.call(function(...) {
[09:28:17.427]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.427]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.427]                     ...future.globals.maxSize)) {
[09:28:17.427]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.427]                     on.exit(options(oopts), add = TRUE)
[09:28:17.427]                   }
[09:28:17.427]                   {
[09:28:17.427]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.427]                       FUN = function(jj) {
[09:28:17.427]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.427]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.427]                       })
[09:28:17.427]                   }
[09:28:17.427]                 }, args = future.call.arguments)
[09:28:17.427]             }))
[09:28:17.427]             future::FutureResult(value = ...future.value$value, 
[09:28:17.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.427]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.427]                     ...future.globalenv.names))
[09:28:17.427]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.427]         }, condition = base::local({
[09:28:17.427]             c <- base::c
[09:28:17.427]             inherits <- base::inherits
[09:28:17.427]             invokeRestart <- base::invokeRestart
[09:28:17.427]             length <- base::length
[09:28:17.427]             list <- base::list
[09:28:17.427]             seq.int <- base::seq.int
[09:28:17.427]             signalCondition <- base::signalCondition
[09:28:17.427]             sys.calls <- base::sys.calls
[09:28:17.427]             `[[` <- base::`[[`
[09:28:17.427]             `+` <- base::`+`
[09:28:17.427]             `<<-` <- base::`<<-`
[09:28:17.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.427]                   3L)]
[09:28:17.427]             }
[09:28:17.427]             function(cond) {
[09:28:17.427]                 is_error <- inherits(cond, "error")
[09:28:17.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.427]                   NULL)
[09:28:17.427]                 if (is_error) {
[09:28:17.427]                   sessionInformation <- function() {
[09:28:17.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.427]                       search = base::search(), system = base::Sys.info())
[09:28:17.427]                   }
[09:28:17.427]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.427]                     cond$call), session = sessionInformation(), 
[09:28:17.427]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.427]                   signalCondition(cond)
[09:28:17.427]                 }
[09:28:17.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.427]                 "immediateCondition"))) {
[09:28:17.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.427]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.427]                   if (TRUE && !signal) {
[09:28:17.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.427]                     {
[09:28:17.427]                       inherits <- base::inherits
[09:28:17.427]                       invokeRestart <- base::invokeRestart
[09:28:17.427]                       is.null <- base::is.null
[09:28:17.427]                       muffled <- FALSE
[09:28:17.427]                       if (inherits(cond, "message")) {
[09:28:17.427]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.427]                         if (muffled) 
[09:28:17.427]                           invokeRestart("muffleMessage")
[09:28:17.427]                       }
[09:28:17.427]                       else if (inherits(cond, "warning")) {
[09:28:17.427]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.427]                         if (muffled) 
[09:28:17.427]                           invokeRestart("muffleWarning")
[09:28:17.427]                       }
[09:28:17.427]                       else if (inherits(cond, "condition")) {
[09:28:17.427]                         if (!is.null(pattern)) {
[09:28:17.427]                           computeRestarts <- base::computeRestarts
[09:28:17.427]                           grepl <- base::grepl
[09:28:17.427]                           restarts <- computeRestarts(cond)
[09:28:17.427]                           for (restart in restarts) {
[09:28:17.427]                             name <- restart$name
[09:28:17.427]                             if (is.null(name)) 
[09:28:17.427]                               next
[09:28:17.427]                             if (!grepl(pattern, name)) 
[09:28:17.427]                               next
[09:28:17.427]                             invokeRestart(restart)
[09:28:17.427]                             muffled <- TRUE
[09:28:17.427]                             break
[09:28:17.427]                           }
[09:28:17.427]                         }
[09:28:17.427]                       }
[09:28:17.427]                       invisible(muffled)
[09:28:17.427]                     }
[09:28:17.427]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.427]                   }
[09:28:17.427]                 }
[09:28:17.427]                 else {
[09:28:17.427]                   if (TRUE) {
[09:28:17.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.427]                     {
[09:28:17.427]                       inherits <- base::inherits
[09:28:17.427]                       invokeRestart <- base::invokeRestart
[09:28:17.427]                       is.null <- base::is.null
[09:28:17.427]                       muffled <- FALSE
[09:28:17.427]                       if (inherits(cond, "message")) {
[09:28:17.427]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.427]                         if (muffled) 
[09:28:17.427]                           invokeRestart("muffleMessage")
[09:28:17.427]                       }
[09:28:17.427]                       else if (inherits(cond, "warning")) {
[09:28:17.427]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.427]                         if (muffled) 
[09:28:17.427]                           invokeRestart("muffleWarning")
[09:28:17.427]                       }
[09:28:17.427]                       else if (inherits(cond, "condition")) {
[09:28:17.427]                         if (!is.null(pattern)) {
[09:28:17.427]                           computeRestarts <- base::computeRestarts
[09:28:17.427]                           grepl <- base::grepl
[09:28:17.427]                           restarts <- computeRestarts(cond)
[09:28:17.427]                           for (restart in restarts) {
[09:28:17.427]                             name <- restart$name
[09:28:17.427]                             if (is.null(name)) 
[09:28:17.427]                               next
[09:28:17.427]                             if (!grepl(pattern, name)) 
[09:28:17.427]                               next
[09:28:17.427]                             invokeRestart(restart)
[09:28:17.427]                             muffled <- TRUE
[09:28:17.427]                             break
[09:28:17.427]                           }
[09:28:17.427]                         }
[09:28:17.427]                       }
[09:28:17.427]                       invisible(muffled)
[09:28:17.427]                     }
[09:28:17.427]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.427]                   }
[09:28:17.427]                 }
[09:28:17.427]             }
[09:28:17.427]         }))
[09:28:17.427]     }, error = function(ex) {
[09:28:17.427]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.427]                 ...future.rng), started = ...future.startTime, 
[09:28:17.427]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.427]             version = "1.8"), class = "FutureResult")
[09:28:17.427]     }, finally = {
[09:28:17.427]         if (!identical(...future.workdir, getwd())) 
[09:28:17.427]             setwd(...future.workdir)
[09:28:17.427]         {
[09:28:17.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.427]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.427]             }
[09:28:17.427]             base::options(...future.oldOptions)
[09:28:17.427]             if (.Platform$OS.type == "windows") {
[09:28:17.427]                 old_names <- names(...future.oldEnvVars)
[09:28:17.427]                 envs <- base::Sys.getenv()
[09:28:17.427]                 names <- names(envs)
[09:28:17.427]                 common <- intersect(names, old_names)
[09:28:17.427]                 added <- setdiff(names, old_names)
[09:28:17.427]                 removed <- setdiff(old_names, names)
[09:28:17.427]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.427]                   envs[common]]
[09:28:17.427]                 NAMES <- toupper(changed)
[09:28:17.427]                 args <- list()
[09:28:17.427]                 for (kk in seq_along(NAMES)) {
[09:28:17.427]                   name <- changed[[kk]]
[09:28:17.427]                   NAME <- NAMES[[kk]]
[09:28:17.427]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.427]                     next
[09:28:17.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.427]                 }
[09:28:17.427]                 NAMES <- toupper(added)
[09:28:17.427]                 for (kk in seq_along(NAMES)) {
[09:28:17.427]                   name <- added[[kk]]
[09:28:17.427]                   NAME <- NAMES[[kk]]
[09:28:17.427]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.427]                     next
[09:28:17.427]                   args[[name]] <- ""
[09:28:17.427]                 }
[09:28:17.427]                 NAMES <- toupper(removed)
[09:28:17.427]                 for (kk in seq_along(NAMES)) {
[09:28:17.427]                   name <- removed[[kk]]
[09:28:17.427]                   NAME <- NAMES[[kk]]
[09:28:17.427]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.427]                     next
[09:28:17.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.427]                 }
[09:28:17.427]                 if (length(args) > 0) 
[09:28:17.427]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.427]             }
[09:28:17.427]             else {
[09:28:17.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.427]             }
[09:28:17.427]             {
[09:28:17.427]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.427]                   0L) {
[09:28:17.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.427]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.427]                   base::options(opts)
[09:28:17.427]                 }
[09:28:17.427]                 {
[09:28:17.427]                   {
[09:28:17.427]                     NULL
[09:28:17.427]                     RNGkind("Mersenne-Twister")
[09:28:17.427]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.427]                       inherits = FALSE)
[09:28:17.427]                   }
[09:28:17.427]                   options(future.plan = NULL)
[09:28:17.427]                   if (is.na(NA_character_)) 
[09:28:17.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.427]                     .init = FALSE)
[09:28:17.427]                 }
[09:28:17.427]             }
[09:28:17.427]         }
[09:28:17.427]     })
[09:28:17.427]     if (TRUE) {
[09:28:17.427]         base::sink(type = "output", split = FALSE)
[09:28:17.427]         if (TRUE) {
[09:28:17.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.427]         }
[09:28:17.427]         else {
[09:28:17.427]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.427]         }
[09:28:17.427]         base::close(...future.stdout)
[09:28:17.427]         ...future.stdout <- NULL
[09:28:17.427]     }
[09:28:17.427]     ...future.result$conditions <- ...future.conditions
[09:28:17.427]     ...future.result$finished <- base::Sys.time()
[09:28:17.427]     ...future.result
[09:28:17.427] }
[09:28:17.429] assign_globals() ...
[09:28:17.429] List of 5
[09:28:17.429]  $ future.call.arguments    : list()
[09:28:17.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.429]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.429]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.429]  $ ...future.elements_ii    :List of 2
[09:28:17.429]   ..$ : num [1:4] 1 3 1 7
[09:28:17.429]   ..$ : num [1:4] 2 4 6 8
[09:28:17.429]  $ ...future.seeds_ii       : NULL
[09:28:17.429]  $ ...future.globals.maxSize: num Inf
[09:28:17.429]  - attr(*, "resolved")= logi FALSE
[09:28:17.429]  - attr(*, "total_size")= num NA
[09:28:17.429]  - attr(*, "where")=List of 5
[09:28:17.429]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.429]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.429]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.429]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.429]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.429]  - attr(*, "already-done")= logi TRUE
[09:28:17.435] - copied ‘future.call.arguments’ to environment
[09:28:17.435] - copied ‘...future.FUN’ to environment
[09:28:17.435] - copied ‘...future.elements_ii’ to environment
[09:28:17.435] - copied ‘...future.seeds_ii’ to environment
[09:28:17.435] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.435] assign_globals() ... done
[09:28:17.435] plan(): Setting new future strategy stack:
[09:28:17.436] List of future strategies:
[09:28:17.436] 1. sequential:
[09:28:17.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.436]    - tweaked: FALSE
[09:28:17.436]    - call: NULL
[09:28:17.436] plan(): nbrOfWorkers() = 1
[09:28:17.437] plan(): Setting new future strategy stack:
[09:28:17.437] List of future strategies:
[09:28:17.437] 1. sequential:
[09:28:17.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.437]    - tweaked: FALSE
[09:28:17.437]    - call: plan(strategy)
[09:28:17.437] plan(): nbrOfWorkers() = 1
[09:28:17.438] SequentialFuture started (and completed)
[09:28:17.438] - Launch lazy future ... done
[09:28:17.438] run() for ‘SequentialFuture’ ... done
[09:28:17.438] Created future:
[09:28:17.438] SequentialFuture:
[09:28:17.438] Label: ‘future_apply-1’
[09:28:17.438] Expression:
[09:28:17.438] {
[09:28:17.438]     do.call(function(...) {
[09:28:17.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.438]             on.exit(options(oopts), add = TRUE)
[09:28:17.438]         }
[09:28:17.438]         {
[09:28:17.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.438]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.438]             })
[09:28:17.438]         }
[09:28:17.438]     }, args = future.call.arguments)
[09:28:17.438] }
[09:28:17.438] Lazy evaluation: FALSE
[09:28:17.438] Asynchronous evaluation: FALSE
[09:28:17.438] Local evaluation: TRUE
[09:28:17.438] Environment: R_GlobalEnv
[09:28:17.438] Capture standard output: TRUE
[09:28:17.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.438] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.438] Packages: <none>
[09:28:17.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.438] Resolved: TRUE
[09:28:17.438] Value: 2.21 KiB of class ‘list’
[09:28:17.438] Early signaling: FALSE
[09:28:17.438] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.438] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.439] Chunk #1 of 1 ... DONE
[09:28:17.439] Launching 1 futures (chunks) ... DONE
[09:28:17.439] Resolving 1 futures (chunks) ...
[09:28:17.439] resolve() on list ...
[09:28:17.439]  recursive: 0
[09:28:17.439]  length: 1
[09:28:17.439] 
[09:28:17.439] resolved() for ‘SequentialFuture’ ...
[09:28:17.440] - state: ‘finished’
[09:28:17.440] - run: TRUE
[09:28:17.440] - result: ‘FutureResult’
[09:28:17.440] resolved() for ‘SequentialFuture’ ... done
[09:28:17.440] Future #1
[09:28:17.440] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.440] - nx: 1
[09:28:17.440] - relay: TRUE
[09:28:17.440] - stdout: TRUE
[09:28:17.440] - signal: TRUE
[09:28:17.440] - resignal: FALSE
[09:28:17.441] - force: TRUE
[09:28:17.441] - relayed: [n=1] FALSE
[09:28:17.441] - queued futures: [n=1] FALSE
[09:28:17.441]  - until=1
[09:28:17.441]  - relaying element #1
[09:28:17.441] - relayed: [n=1] TRUE
[09:28:17.441] - queued futures: [n=1] TRUE
[09:28:17.441] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.441]  length: 0 (resolved future 1)
[09:28:17.441] Relaying remaining futures
[09:28:17.441] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.442] - nx: 1
[09:28:17.442] - relay: TRUE
[09:28:17.442] - stdout: TRUE
[09:28:17.442] - signal: TRUE
[09:28:17.442] - resignal: FALSE
[09:28:17.442] - force: TRUE
[09:28:17.442] - relayed: [n=1] TRUE
[09:28:17.442] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.442] - relayed: [n=1] TRUE
[09:28:17.442] - queued futures: [n=1] TRUE
[09:28:17.442] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.442] resolve() on list ... DONE
[09:28:17.443]  - Number of value chunks collected: 1
[09:28:17.443] Resolving 1 futures (chunks) ... DONE
[09:28:17.443] Reducing values from 1 chunks ...
[09:28:17.443]  - Number of values collected after concatenation: 2
[09:28:17.443]  - Number of values expected: 2
[09:28:17.443] Reducing values from 1 chunks ... DONE
[09:28:17.443] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:17.445] getGlobalsAndPackagesXApply() ...
[09:28:17.445]  - future.globals: TRUE
[09:28:17.445] getGlobalsAndPackages() ...
[09:28:17.445] Searching for globals...
[09:28:17.446] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:17.447] Searching for globals ... DONE
[09:28:17.447] Resolving globals: FALSE
[09:28:17.447] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:17.447] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:17.447] - globals: [1] ‘FUN’
[09:28:17.447] - packages: [1] ‘stats’
[09:28:17.448] getGlobalsAndPackages() ... DONE
[09:28:17.448]  - globals found/used: [n=1] ‘FUN’
[09:28:17.448]  - needed namespaces: [n=1] ‘stats’
[09:28:17.448] Finding globals ... DONE
[09:28:17.448]  - use_args: TRUE
[09:28:17.448]  - Getting '...' globals ...
[09:28:17.448] resolve() on list ...
[09:28:17.448]  recursive: 0
[09:28:17.448]  length: 1
[09:28:17.449]  elements: ‘...’
[09:28:17.449]  length: 0 (resolved future 1)
[09:28:17.449] resolve() on list ... DONE
[09:28:17.449]    - '...' content: [n=0] 
[09:28:17.449] List of 1
[09:28:17.449]  $ ...: list()
[09:28:17.449]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.449]  - attr(*, "where")=List of 1
[09:28:17.449]   ..$ ...:<environment: 0x559ba418a8c0> 
[09:28:17.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.449]  - attr(*, "resolved")= logi TRUE
[09:28:17.449]  - attr(*, "total_size")= num NA
[09:28:17.451]  - Getting '...' globals ... DONE
[09:28:17.451] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.451] List of 2
[09:28:17.451]  $ ...future.FUN:function (x, ...)  
[09:28:17.451]  $ ...          : list()
[09:28:17.451]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.451]  - attr(*, "where")=List of 2
[09:28:17.451]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.451]   ..$ ...          :<environment: 0x559ba418a8c0> 
[09:28:17.451]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.451]  - attr(*, "resolved")= logi FALSE
[09:28:17.451]  - attr(*, "total_size")= num 1248
[09:28:17.454] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:17.454] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.454] future_lapply() ...
[09:28:17.455] Number of chunks: 1
[09:28:17.456] getGlobalsAndPackagesXApply() ...
[09:28:17.456]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.456]  - use_args: TRUE
[09:28:17.456] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.456] List of 2
[09:28:17.456]  $ ...          : list()
[09:28:17.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.456]  $ ...future.FUN:function (x, ...)  
[09:28:17.456]  - attr(*, "where")=List of 2
[09:28:17.456]   ..$ ...          :<environment: 0x559ba418a8c0> 
[09:28:17.456]   ..$ ...future.FUN:<environment: namespace:stats> 
[09:28:17.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.456]  - attr(*, "resolved")= logi FALSE
[09:28:17.456]  - attr(*, "total_size")= num NA
[09:28:17.459] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:17.459] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.459] Number of futures (= number of chunks): 1
[09:28:17.459] Launching 1 futures (chunks) ...
[09:28:17.459] Chunk #1 of 1 ...
[09:28:17.459]  - seeds: <none>
[09:28:17.459]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.459] getGlobalsAndPackages() ...
[09:28:17.459] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.459] Resolving globals: FALSE
[09:28:17.460] Tweak future expression to call with '...' arguments ...
[09:28:17.460] {
[09:28:17.460]     do.call(function(...) {
[09:28:17.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.460]             on.exit(options(oopts), add = TRUE)
[09:28:17.460]         }
[09:28:17.460]         {
[09:28:17.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.460]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.460]             })
[09:28:17.460]         }
[09:28:17.460]     }, args = future.call.arguments)
[09:28:17.460] }
[09:28:17.460] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.460] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.460] - packages: [1] ‘stats’
[09:28:17.461] getGlobalsAndPackages() ... DONE
[09:28:17.461] run() for ‘Future’ ...
[09:28:17.461] - state: ‘created’
[09:28:17.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.461] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.461]   - Field: ‘label’
[09:28:17.462]   - Field: ‘local’
[09:28:17.462]   - Field: ‘owner’
[09:28:17.462]   - Field: ‘envir’
[09:28:17.462]   - Field: ‘packages’
[09:28:17.462]   - Field: ‘gc’
[09:28:17.462]   - Field: ‘conditions’
[09:28:17.462]   - Field: ‘expr’
[09:28:17.462]   - Field: ‘uuid’
[09:28:17.462]   - Field: ‘seed’
[09:28:17.462]   - Field: ‘version’
[09:28:17.462]   - Field: ‘result’
[09:28:17.462]   - Field: ‘asynchronous’
[09:28:17.463]   - Field: ‘calls’
[09:28:17.463]   - Field: ‘globals’
[09:28:17.463]   - Field: ‘stdout’
[09:28:17.463]   - Field: ‘earlySignal’
[09:28:17.463]   - Field: ‘lazy’
[09:28:17.463]   - Field: ‘state’
[09:28:17.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.463] - Launch lazy future ...
[09:28:17.463] Packages needed by the future expression (n = 1): ‘stats’
[09:28:17.463] Packages needed by future strategies (n = 0): <none>
[09:28:17.464] {
[09:28:17.464]     {
[09:28:17.464]         {
[09:28:17.464]             ...future.startTime <- base::Sys.time()
[09:28:17.464]             {
[09:28:17.464]                 {
[09:28:17.464]                   {
[09:28:17.464]                     {
[09:28:17.464]                       base::local({
[09:28:17.464]                         has_future <- base::requireNamespace("future", 
[09:28:17.464]                           quietly = TRUE)
[09:28:17.464]                         if (has_future) {
[09:28:17.464]                           ns <- base::getNamespace("future")
[09:28:17.464]                           version <- ns[[".package"]][["version"]]
[09:28:17.464]                           if (is.null(version)) 
[09:28:17.464]                             version <- utils::packageVersion("future")
[09:28:17.464]                         }
[09:28:17.464]                         else {
[09:28:17.464]                           version <- NULL
[09:28:17.464]                         }
[09:28:17.464]                         if (!has_future || version < "1.8.0") {
[09:28:17.464]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.464]                             "", base::R.version$version.string), 
[09:28:17.464]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:17.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.464]                               "release", "version")], collapse = " "), 
[09:28:17.464]                             hostname = base::Sys.info()[["nodename"]])
[09:28:17.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.464]                             info)
[09:28:17.464]                           info <- base::paste(info, collapse = "; ")
[09:28:17.464]                           if (!has_future) {
[09:28:17.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.464]                               info)
[09:28:17.464]                           }
[09:28:17.464]                           else {
[09:28:17.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.464]                               info, version)
[09:28:17.464]                           }
[09:28:17.464]                           base::stop(msg)
[09:28:17.464]                         }
[09:28:17.464]                       })
[09:28:17.464]                     }
[09:28:17.464]                     base::local({
[09:28:17.464]                       for (pkg in "stats") {
[09:28:17.464]                         base::loadNamespace(pkg)
[09:28:17.464]                         base::library(pkg, character.only = TRUE)
[09:28:17.464]                       }
[09:28:17.464]                     })
[09:28:17.464]                   }
[09:28:17.464]                   ...future.strategy.old <- future::plan("list")
[09:28:17.464]                   options(future.plan = NULL)
[09:28:17.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.464]                 }
[09:28:17.464]                 ...future.workdir <- getwd()
[09:28:17.464]             }
[09:28:17.464]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.464]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.464]         }
[09:28:17.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.464]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.464]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.464]             base::names(...future.oldOptions))
[09:28:17.464]     }
[09:28:17.464]     if (FALSE) {
[09:28:17.464]     }
[09:28:17.464]     else {
[09:28:17.464]         if (TRUE) {
[09:28:17.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.464]                 open = "w")
[09:28:17.464]         }
[09:28:17.464]         else {
[09:28:17.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.464]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.464]         }
[09:28:17.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.464]             base::sink(type = "output", split = FALSE)
[09:28:17.464]             base::close(...future.stdout)
[09:28:17.464]         }, add = TRUE)
[09:28:17.464]     }
[09:28:17.464]     ...future.frame <- base::sys.nframe()
[09:28:17.464]     ...future.conditions <- base::list()
[09:28:17.464]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.464]     if (FALSE) {
[09:28:17.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.464]     }
[09:28:17.464]     ...future.result <- base::tryCatch({
[09:28:17.464]         base::withCallingHandlers({
[09:28:17.464]             ...future.value <- base::withVisible(base::local({
[09:28:17.464]                 do.call(function(...) {
[09:28:17.464]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.464]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.464]                     ...future.globals.maxSize)) {
[09:28:17.464]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.464]                     on.exit(options(oopts), add = TRUE)
[09:28:17.464]                   }
[09:28:17.464]                   {
[09:28:17.464]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.464]                       FUN = function(jj) {
[09:28:17.464]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.464]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.464]                       })
[09:28:17.464]                   }
[09:28:17.464]                 }, args = future.call.arguments)
[09:28:17.464]             }))
[09:28:17.464]             future::FutureResult(value = ...future.value$value, 
[09:28:17.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.464]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.464]                     ...future.globalenv.names))
[09:28:17.464]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.464]         }, condition = base::local({
[09:28:17.464]             c <- base::c
[09:28:17.464]             inherits <- base::inherits
[09:28:17.464]             invokeRestart <- base::invokeRestart
[09:28:17.464]             length <- base::length
[09:28:17.464]             list <- base::list
[09:28:17.464]             seq.int <- base::seq.int
[09:28:17.464]             signalCondition <- base::signalCondition
[09:28:17.464]             sys.calls <- base::sys.calls
[09:28:17.464]             `[[` <- base::`[[`
[09:28:17.464]             `+` <- base::`+`
[09:28:17.464]             `<<-` <- base::`<<-`
[09:28:17.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.464]                   3L)]
[09:28:17.464]             }
[09:28:17.464]             function(cond) {
[09:28:17.464]                 is_error <- inherits(cond, "error")
[09:28:17.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.464]                   NULL)
[09:28:17.464]                 if (is_error) {
[09:28:17.464]                   sessionInformation <- function() {
[09:28:17.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.464]                       search = base::search(), system = base::Sys.info())
[09:28:17.464]                   }
[09:28:17.464]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.464]                     cond$call), session = sessionInformation(), 
[09:28:17.464]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.464]                   signalCondition(cond)
[09:28:17.464]                 }
[09:28:17.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.464]                 "immediateCondition"))) {
[09:28:17.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.464]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.464]                   if (TRUE && !signal) {
[09:28:17.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.464]                     {
[09:28:17.464]                       inherits <- base::inherits
[09:28:17.464]                       invokeRestart <- base::invokeRestart
[09:28:17.464]                       is.null <- base::is.null
[09:28:17.464]                       muffled <- FALSE
[09:28:17.464]                       if (inherits(cond, "message")) {
[09:28:17.464]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.464]                         if (muffled) 
[09:28:17.464]                           invokeRestart("muffleMessage")
[09:28:17.464]                       }
[09:28:17.464]                       else if (inherits(cond, "warning")) {
[09:28:17.464]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.464]                         if (muffled) 
[09:28:17.464]                           invokeRestart("muffleWarning")
[09:28:17.464]                       }
[09:28:17.464]                       else if (inherits(cond, "condition")) {
[09:28:17.464]                         if (!is.null(pattern)) {
[09:28:17.464]                           computeRestarts <- base::computeRestarts
[09:28:17.464]                           grepl <- base::grepl
[09:28:17.464]                           restarts <- computeRestarts(cond)
[09:28:17.464]                           for (restart in restarts) {
[09:28:17.464]                             name <- restart$name
[09:28:17.464]                             if (is.null(name)) 
[09:28:17.464]                               next
[09:28:17.464]                             if (!grepl(pattern, name)) 
[09:28:17.464]                               next
[09:28:17.464]                             invokeRestart(restart)
[09:28:17.464]                             muffled <- TRUE
[09:28:17.464]                             break
[09:28:17.464]                           }
[09:28:17.464]                         }
[09:28:17.464]                       }
[09:28:17.464]                       invisible(muffled)
[09:28:17.464]                     }
[09:28:17.464]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.464]                   }
[09:28:17.464]                 }
[09:28:17.464]                 else {
[09:28:17.464]                   if (TRUE) {
[09:28:17.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.464]                     {
[09:28:17.464]                       inherits <- base::inherits
[09:28:17.464]                       invokeRestart <- base::invokeRestart
[09:28:17.464]                       is.null <- base::is.null
[09:28:17.464]                       muffled <- FALSE
[09:28:17.464]                       if (inherits(cond, "message")) {
[09:28:17.464]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.464]                         if (muffled) 
[09:28:17.464]                           invokeRestart("muffleMessage")
[09:28:17.464]                       }
[09:28:17.464]                       else if (inherits(cond, "warning")) {
[09:28:17.464]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.464]                         if (muffled) 
[09:28:17.464]                           invokeRestart("muffleWarning")
[09:28:17.464]                       }
[09:28:17.464]                       else if (inherits(cond, "condition")) {
[09:28:17.464]                         if (!is.null(pattern)) {
[09:28:17.464]                           computeRestarts <- base::computeRestarts
[09:28:17.464]                           grepl <- base::grepl
[09:28:17.464]                           restarts <- computeRestarts(cond)
[09:28:17.464]                           for (restart in restarts) {
[09:28:17.464]                             name <- restart$name
[09:28:17.464]                             if (is.null(name)) 
[09:28:17.464]                               next
[09:28:17.464]                             if (!grepl(pattern, name)) 
[09:28:17.464]                               next
[09:28:17.464]                             invokeRestart(restart)
[09:28:17.464]                             muffled <- TRUE
[09:28:17.464]                             break
[09:28:17.464]                           }
[09:28:17.464]                         }
[09:28:17.464]                       }
[09:28:17.464]                       invisible(muffled)
[09:28:17.464]                     }
[09:28:17.464]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.464]                   }
[09:28:17.464]                 }
[09:28:17.464]             }
[09:28:17.464]         }))
[09:28:17.464]     }, error = function(ex) {
[09:28:17.464]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.464]                 ...future.rng), started = ...future.startTime, 
[09:28:17.464]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.464]             version = "1.8"), class = "FutureResult")
[09:28:17.464]     }, finally = {
[09:28:17.464]         if (!identical(...future.workdir, getwd())) 
[09:28:17.464]             setwd(...future.workdir)
[09:28:17.464]         {
[09:28:17.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.464]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.464]             }
[09:28:17.464]             base::options(...future.oldOptions)
[09:28:17.464]             if (.Platform$OS.type == "windows") {
[09:28:17.464]                 old_names <- names(...future.oldEnvVars)
[09:28:17.464]                 envs <- base::Sys.getenv()
[09:28:17.464]                 names <- names(envs)
[09:28:17.464]                 common <- intersect(names, old_names)
[09:28:17.464]                 added <- setdiff(names, old_names)
[09:28:17.464]                 removed <- setdiff(old_names, names)
[09:28:17.464]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.464]                   envs[common]]
[09:28:17.464]                 NAMES <- toupper(changed)
[09:28:17.464]                 args <- list()
[09:28:17.464]                 for (kk in seq_along(NAMES)) {
[09:28:17.464]                   name <- changed[[kk]]
[09:28:17.464]                   NAME <- NAMES[[kk]]
[09:28:17.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.464]                     next
[09:28:17.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.464]                 }
[09:28:17.464]                 NAMES <- toupper(added)
[09:28:17.464]                 for (kk in seq_along(NAMES)) {
[09:28:17.464]                   name <- added[[kk]]
[09:28:17.464]                   NAME <- NAMES[[kk]]
[09:28:17.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.464]                     next
[09:28:17.464]                   args[[name]] <- ""
[09:28:17.464]                 }
[09:28:17.464]                 NAMES <- toupper(removed)
[09:28:17.464]                 for (kk in seq_along(NAMES)) {
[09:28:17.464]                   name <- removed[[kk]]
[09:28:17.464]                   NAME <- NAMES[[kk]]
[09:28:17.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.464]                     next
[09:28:17.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.464]                 }
[09:28:17.464]                 if (length(args) > 0) 
[09:28:17.464]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.464]             }
[09:28:17.464]             else {
[09:28:17.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.464]             }
[09:28:17.464]             {
[09:28:17.464]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.464]                   0L) {
[09:28:17.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.464]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.464]                   base::options(opts)
[09:28:17.464]                 }
[09:28:17.464]                 {
[09:28:17.464]                   {
[09:28:17.464]                     NULL
[09:28:17.464]                     RNGkind("Mersenne-Twister")
[09:28:17.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.464]                       inherits = FALSE)
[09:28:17.464]                   }
[09:28:17.464]                   options(future.plan = NULL)
[09:28:17.464]                   if (is.na(NA_character_)) 
[09:28:17.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.464]                     .init = FALSE)
[09:28:17.464]                 }
[09:28:17.464]             }
[09:28:17.464]         }
[09:28:17.464]     })
[09:28:17.464]     if (TRUE) {
[09:28:17.464]         base::sink(type = "output", split = FALSE)
[09:28:17.464]         if (TRUE) {
[09:28:17.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.464]         }
[09:28:17.464]         else {
[09:28:17.464]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.464]         }
[09:28:17.464]         base::close(...future.stdout)
[09:28:17.464]         ...future.stdout <- NULL
[09:28:17.464]     }
[09:28:17.464]     ...future.result$conditions <- ...future.conditions
[09:28:17.464]     ...future.result$finished <- base::Sys.time()
[09:28:17.464]     ...future.result
[09:28:17.464] }
[09:28:17.465] assign_globals() ...
[09:28:17.466] List of 5
[09:28:17.466]  $ future.call.arguments    : list()
[09:28:17.466]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.466]  $ ...future.FUN            :function (x, ...)  
[09:28:17.466]  $ ...future.elements_ii    :List of 2
[09:28:17.466]   ..$ : num [1:4] 1 3 1 7
[09:28:17.466]   ..$ : num [1:4] 2 4 6 8
[09:28:17.466]  $ ...future.seeds_ii       : NULL
[09:28:17.466]  $ ...future.globals.maxSize: num Inf
[09:28:17.466]  - attr(*, "resolved")= logi FALSE
[09:28:17.466]  - attr(*, "total_size")= num NA
[09:28:17.466]  - attr(*, "where")=List of 5
[09:28:17.466]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.466]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.466]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.466]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.466]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.466]  - attr(*, "already-done")= logi TRUE
[09:28:17.470] - copied ‘future.call.arguments’ to environment
[09:28:17.470] - copied ‘...future.FUN’ to environment
[09:28:17.470] - copied ‘...future.elements_ii’ to environment
[09:28:17.470] - copied ‘...future.seeds_ii’ to environment
[09:28:17.470] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.471] assign_globals() ... done
[09:28:17.471] plan(): Setting new future strategy stack:
[09:28:17.471] List of future strategies:
[09:28:17.471] 1. sequential:
[09:28:17.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.471]    - tweaked: FALSE
[09:28:17.471]    - call: NULL
[09:28:17.471] plan(): nbrOfWorkers() = 1
[09:28:17.472] plan(): Setting new future strategy stack:
[09:28:17.472] List of future strategies:
[09:28:17.472] 1. sequential:
[09:28:17.472]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.472]    - tweaked: FALSE
[09:28:17.472]    - call: plan(strategy)
[09:28:17.473] plan(): nbrOfWorkers() = 1
[09:28:17.473] SequentialFuture started (and completed)
[09:28:17.473] - Launch lazy future ... done
[09:28:17.473] run() for ‘SequentialFuture’ ... done
[09:28:17.473] Created future:
[09:28:17.473] SequentialFuture:
[09:28:17.473] Label: ‘future_apply-1’
[09:28:17.473] Expression:
[09:28:17.473] {
[09:28:17.473]     do.call(function(...) {
[09:28:17.473]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.473]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.473]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.473]             on.exit(options(oopts), add = TRUE)
[09:28:17.473]         }
[09:28:17.473]         {
[09:28:17.473]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.473]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.473]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.473]             })
[09:28:17.473]         }
[09:28:17.473]     }, args = future.call.arguments)
[09:28:17.473] }
[09:28:17.473] Lazy evaluation: FALSE
[09:28:17.473] Asynchronous evaluation: FALSE
[09:28:17.473] Local evaluation: TRUE
[09:28:17.473] Environment: R_GlobalEnv
[09:28:17.473] Capture standard output: TRUE
[09:28:17.473] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.473] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.473] Packages: 1 packages (‘stats’)
[09:28:17.473] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.473] Resolved: TRUE
[09:28:17.473] Value: 1.14 KiB of class ‘list’
[09:28:17.473] Early signaling: FALSE
[09:28:17.473] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.473] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.474] Chunk #1 of 1 ... DONE
[09:28:17.474] Launching 1 futures (chunks) ... DONE
[09:28:17.474] Resolving 1 futures (chunks) ...
[09:28:17.475] resolve() on list ...
[09:28:17.475]  recursive: 0
[09:28:17.475]  length: 1
[09:28:17.475] 
[09:28:17.475] resolved() for ‘SequentialFuture’ ...
[09:28:17.475] - state: ‘finished’
[09:28:17.475] - run: TRUE
[09:28:17.475] - result: ‘FutureResult’
[09:28:17.475] resolved() for ‘SequentialFuture’ ... done
[09:28:17.475] Future #1
[09:28:17.475] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.475] - nx: 1
[09:28:17.476] - relay: TRUE
[09:28:17.476] - stdout: TRUE
[09:28:17.476] - signal: TRUE
[09:28:17.476] - resignal: FALSE
[09:28:17.476] - force: TRUE
[09:28:17.476] - relayed: [n=1] FALSE
[09:28:17.476] - queued futures: [n=1] FALSE
[09:28:17.476]  - until=1
[09:28:17.476]  - relaying element #1
[09:28:17.476] - relayed: [n=1] TRUE
[09:28:17.476] - queued futures: [n=1] TRUE
[09:28:17.477] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.477]  length: 0 (resolved future 1)
[09:28:17.477] Relaying remaining futures
[09:28:17.477] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.477] - nx: 1
[09:28:17.477] - relay: TRUE
[09:28:17.477] - stdout: TRUE
[09:28:17.477] - signal: TRUE
[09:28:17.477] - resignal: FALSE
[09:28:17.478] - force: TRUE
[09:28:17.478] - relayed: [n=1] TRUE
[09:28:17.478] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.478] - relayed: [n=1] TRUE
[09:28:17.478] - queued futures: [n=1] TRUE
[09:28:17.479] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.479] resolve() on list ... DONE
[09:28:17.479]  - Number of value chunks collected: 1
[09:28:17.479] Resolving 1 futures (chunks) ... DONE
[09:28:17.479] Reducing values from 1 chunks ...
[09:28:17.479]  - Number of values collected after concatenation: 2
[09:28:17.479]  - Number of values expected: 2
[09:28:17.479] Reducing values from 1 chunks ... DONE
[09:28:17.479] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[09:28:17.480] getGlobalsAndPackagesXApply() ...
[09:28:17.480]  - future.globals: TRUE
[09:28:17.480] getGlobalsAndPackages() ...
[09:28:17.480] Searching for globals...
[09:28:17.481] - globals found: [1] ‘FUN’
[09:28:17.481] Searching for globals ... DONE
[09:28:17.481] Resolving globals: FALSE
[09:28:17.482] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:17.482] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:17.482] - globals: [1] ‘FUN’
[09:28:17.482] 
[09:28:17.482] getGlobalsAndPackages() ... DONE
[09:28:17.482]  - globals found/used: [n=1] ‘FUN’
[09:28:17.482]  - needed namespaces: [n=0] 
[09:28:17.482] Finding globals ... DONE
[09:28:17.483]  - use_args: TRUE
[09:28:17.483]  - Getting '...' globals ...
[09:28:17.483] resolve() on list ...
[09:28:17.483]  recursive: 0
[09:28:17.483]  length: 1
[09:28:17.483]  elements: ‘...’
[09:28:17.483]  length: 0 (resolved future 1)
[09:28:17.483] resolve() on list ... DONE
[09:28:17.483]    - '...' content: [n=0] 
[09:28:17.483] List of 1
[09:28:17.483]  $ ...: list()
[09:28:17.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.483]  - attr(*, "where")=List of 1
[09:28:17.483]   ..$ ...:<environment: 0x559ba2a9a4b0> 
[09:28:17.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.483]  - attr(*, "resolved")= logi TRUE
[09:28:17.483]  - attr(*, "total_size")= num NA
[09:28:17.486]  - Getting '...' globals ... DONE
[09:28:17.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.486] List of 2
[09:28:17.486]  $ ...future.FUN:function (x)  
[09:28:17.486]  $ ...          : list()
[09:28:17.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.486]  - attr(*, "where")=List of 2
[09:28:17.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.486]   ..$ ...          :<environment: 0x559ba2a9a4b0> 
[09:28:17.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.486]  - attr(*, "resolved")= logi FALSE
[09:28:17.486]  - attr(*, "total_size")= num 848
[09:28:17.488] Packages to be attached in all futures: [n=0] 
[09:28:17.489] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.489] future_lapply() ...
[09:28:17.489] Number of chunks: 1
[09:28:17.489] getGlobalsAndPackagesXApply() ...
[09:28:17.489]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.489]  - use_args: TRUE
[09:28:17.490] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.490] List of 2
[09:28:17.490]  $ ...          : list()
[09:28:17.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.490]  $ ...future.FUN:function (x)  
[09:28:17.490]  - attr(*, "where")=List of 2
[09:28:17.490]   ..$ ...          :<environment: 0x559ba2a9a4b0> 
[09:28:17.490]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.490]  - attr(*, "resolved")= logi FALSE
[09:28:17.490]  - attr(*, "total_size")= num NA
[09:28:17.493] Packages to be attached in all futures: [n=0] 
[09:28:17.493] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.493] Number of futures (= number of chunks): 1
[09:28:17.493] Launching 1 futures (chunks) ...
[09:28:17.493] Chunk #1 of 1 ...
[09:28:17.493]  - seeds: <none>
[09:28:17.493]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.493] getGlobalsAndPackages() ...
[09:28:17.493] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.493] Resolving globals: FALSE
[09:28:17.494] Tweak future expression to call with '...' arguments ...
[09:28:17.494] {
[09:28:17.494]     do.call(function(...) {
[09:28:17.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.494]             on.exit(options(oopts), add = TRUE)
[09:28:17.494]         }
[09:28:17.494]         {
[09:28:17.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.494]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.494]             })
[09:28:17.494]         }
[09:28:17.494]     }, args = future.call.arguments)
[09:28:17.494] }
[09:28:17.494] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.494] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.494] 
[09:28:17.494] getGlobalsAndPackages() ... DONE
[09:28:17.495] run() for ‘Future’ ...
[09:28:17.495] - state: ‘created’
[09:28:17.495] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.495] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.495]   - Field: ‘label’
[09:28:17.495]   - Field: ‘local’
[09:28:17.496]   - Field: ‘owner’
[09:28:17.496]   - Field: ‘envir’
[09:28:17.496]   - Field: ‘packages’
[09:28:17.496]   - Field: ‘gc’
[09:28:17.496]   - Field: ‘conditions’
[09:28:17.496]   - Field: ‘expr’
[09:28:17.496]   - Field: ‘uuid’
[09:28:17.496]   - Field: ‘seed’
[09:28:17.496]   - Field: ‘version’
[09:28:17.496]   - Field: ‘result’
[09:28:17.496]   - Field: ‘asynchronous’
[09:28:17.497]   - Field: ‘calls’
[09:28:17.497]   - Field: ‘globals’
[09:28:17.497]   - Field: ‘stdout’
[09:28:17.497]   - Field: ‘earlySignal’
[09:28:17.497]   - Field: ‘lazy’
[09:28:17.497]   - Field: ‘state’
[09:28:17.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.497] - Launch lazy future ...
[09:28:17.497] Packages needed by the future expression (n = 0): <none>
[09:28:17.497] Packages needed by future strategies (n = 0): <none>
[09:28:17.498] {
[09:28:17.498]     {
[09:28:17.498]         {
[09:28:17.498]             ...future.startTime <- base::Sys.time()
[09:28:17.498]             {
[09:28:17.498]                 {
[09:28:17.498]                   {
[09:28:17.498]                     base::local({
[09:28:17.498]                       has_future <- base::requireNamespace("future", 
[09:28:17.498]                         quietly = TRUE)
[09:28:17.498]                       if (has_future) {
[09:28:17.498]                         ns <- base::getNamespace("future")
[09:28:17.498]                         version <- ns[[".package"]][["version"]]
[09:28:17.498]                         if (is.null(version)) 
[09:28:17.498]                           version <- utils::packageVersion("future")
[09:28:17.498]                       }
[09:28:17.498]                       else {
[09:28:17.498]                         version <- NULL
[09:28:17.498]                       }
[09:28:17.498]                       if (!has_future || version < "1.8.0") {
[09:28:17.498]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.498]                           "", base::R.version$version.string), 
[09:28:17.498]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.498]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.498]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.498]                             "release", "version")], collapse = " "), 
[09:28:17.498]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.498]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.498]                           info)
[09:28:17.498]                         info <- base::paste(info, collapse = "; ")
[09:28:17.498]                         if (!has_future) {
[09:28:17.498]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.498]                             info)
[09:28:17.498]                         }
[09:28:17.498]                         else {
[09:28:17.498]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.498]                             info, version)
[09:28:17.498]                         }
[09:28:17.498]                         base::stop(msg)
[09:28:17.498]                       }
[09:28:17.498]                     })
[09:28:17.498]                   }
[09:28:17.498]                   ...future.strategy.old <- future::plan("list")
[09:28:17.498]                   options(future.plan = NULL)
[09:28:17.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.498]                 }
[09:28:17.498]                 ...future.workdir <- getwd()
[09:28:17.498]             }
[09:28:17.498]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.498]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.498]         }
[09:28:17.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.498]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.498]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.498]             base::names(...future.oldOptions))
[09:28:17.498]     }
[09:28:17.498]     if (FALSE) {
[09:28:17.498]     }
[09:28:17.498]     else {
[09:28:17.498]         if (TRUE) {
[09:28:17.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.498]                 open = "w")
[09:28:17.498]         }
[09:28:17.498]         else {
[09:28:17.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.498]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.498]         }
[09:28:17.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.498]             base::sink(type = "output", split = FALSE)
[09:28:17.498]             base::close(...future.stdout)
[09:28:17.498]         }, add = TRUE)
[09:28:17.498]     }
[09:28:17.498]     ...future.frame <- base::sys.nframe()
[09:28:17.498]     ...future.conditions <- base::list()
[09:28:17.498]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.498]     if (FALSE) {
[09:28:17.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.498]     }
[09:28:17.498]     ...future.result <- base::tryCatch({
[09:28:17.498]         base::withCallingHandlers({
[09:28:17.498]             ...future.value <- base::withVisible(base::local({
[09:28:17.498]                 do.call(function(...) {
[09:28:17.498]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.498]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.498]                     ...future.globals.maxSize)) {
[09:28:17.498]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.498]                     on.exit(options(oopts), add = TRUE)
[09:28:17.498]                   }
[09:28:17.498]                   {
[09:28:17.498]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.498]                       FUN = function(jj) {
[09:28:17.498]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.498]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.498]                       })
[09:28:17.498]                   }
[09:28:17.498]                 }, args = future.call.arguments)
[09:28:17.498]             }))
[09:28:17.498]             future::FutureResult(value = ...future.value$value, 
[09:28:17.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.498]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.498]                     ...future.globalenv.names))
[09:28:17.498]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.498]         }, condition = base::local({
[09:28:17.498]             c <- base::c
[09:28:17.498]             inherits <- base::inherits
[09:28:17.498]             invokeRestart <- base::invokeRestart
[09:28:17.498]             length <- base::length
[09:28:17.498]             list <- base::list
[09:28:17.498]             seq.int <- base::seq.int
[09:28:17.498]             signalCondition <- base::signalCondition
[09:28:17.498]             sys.calls <- base::sys.calls
[09:28:17.498]             `[[` <- base::`[[`
[09:28:17.498]             `+` <- base::`+`
[09:28:17.498]             `<<-` <- base::`<<-`
[09:28:17.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.498]                   3L)]
[09:28:17.498]             }
[09:28:17.498]             function(cond) {
[09:28:17.498]                 is_error <- inherits(cond, "error")
[09:28:17.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.498]                   NULL)
[09:28:17.498]                 if (is_error) {
[09:28:17.498]                   sessionInformation <- function() {
[09:28:17.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.498]                       search = base::search(), system = base::Sys.info())
[09:28:17.498]                   }
[09:28:17.498]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.498]                     cond$call), session = sessionInformation(), 
[09:28:17.498]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.498]                   signalCondition(cond)
[09:28:17.498]                 }
[09:28:17.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.498]                 "immediateCondition"))) {
[09:28:17.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.498]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.498]                   if (TRUE && !signal) {
[09:28:17.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.498]                     {
[09:28:17.498]                       inherits <- base::inherits
[09:28:17.498]                       invokeRestart <- base::invokeRestart
[09:28:17.498]                       is.null <- base::is.null
[09:28:17.498]                       muffled <- FALSE
[09:28:17.498]                       if (inherits(cond, "message")) {
[09:28:17.498]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.498]                         if (muffled) 
[09:28:17.498]                           invokeRestart("muffleMessage")
[09:28:17.498]                       }
[09:28:17.498]                       else if (inherits(cond, "warning")) {
[09:28:17.498]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.498]                         if (muffled) 
[09:28:17.498]                           invokeRestart("muffleWarning")
[09:28:17.498]                       }
[09:28:17.498]                       else if (inherits(cond, "condition")) {
[09:28:17.498]                         if (!is.null(pattern)) {
[09:28:17.498]                           computeRestarts <- base::computeRestarts
[09:28:17.498]                           grepl <- base::grepl
[09:28:17.498]                           restarts <- computeRestarts(cond)
[09:28:17.498]                           for (restart in restarts) {
[09:28:17.498]                             name <- restart$name
[09:28:17.498]                             if (is.null(name)) 
[09:28:17.498]                               next
[09:28:17.498]                             if (!grepl(pattern, name)) 
[09:28:17.498]                               next
[09:28:17.498]                             invokeRestart(restart)
[09:28:17.498]                             muffled <- TRUE
[09:28:17.498]                             break
[09:28:17.498]                           }
[09:28:17.498]                         }
[09:28:17.498]                       }
[09:28:17.498]                       invisible(muffled)
[09:28:17.498]                     }
[09:28:17.498]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.498]                   }
[09:28:17.498]                 }
[09:28:17.498]                 else {
[09:28:17.498]                   if (TRUE) {
[09:28:17.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.498]                     {
[09:28:17.498]                       inherits <- base::inherits
[09:28:17.498]                       invokeRestart <- base::invokeRestart
[09:28:17.498]                       is.null <- base::is.null
[09:28:17.498]                       muffled <- FALSE
[09:28:17.498]                       if (inherits(cond, "message")) {
[09:28:17.498]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.498]                         if (muffled) 
[09:28:17.498]                           invokeRestart("muffleMessage")
[09:28:17.498]                       }
[09:28:17.498]                       else if (inherits(cond, "warning")) {
[09:28:17.498]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.498]                         if (muffled) 
[09:28:17.498]                           invokeRestart("muffleWarning")
[09:28:17.498]                       }
[09:28:17.498]                       else if (inherits(cond, "condition")) {
[09:28:17.498]                         if (!is.null(pattern)) {
[09:28:17.498]                           computeRestarts <- base::computeRestarts
[09:28:17.498]                           grepl <- base::grepl
[09:28:17.498]                           restarts <- computeRestarts(cond)
[09:28:17.498]                           for (restart in restarts) {
[09:28:17.498]                             name <- restart$name
[09:28:17.498]                             if (is.null(name)) 
[09:28:17.498]                               next
[09:28:17.498]                             if (!grepl(pattern, name)) 
[09:28:17.498]                               next
[09:28:17.498]                             invokeRestart(restart)
[09:28:17.498]                             muffled <- TRUE
[09:28:17.498]                             break
[09:28:17.498]                           }
[09:28:17.498]                         }
[09:28:17.498]                       }
[09:28:17.498]                       invisible(muffled)
[09:28:17.498]                     }
[09:28:17.498]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.498]                   }
[09:28:17.498]                 }
[09:28:17.498]             }
[09:28:17.498]         }))
[09:28:17.498]     }, error = function(ex) {
[09:28:17.498]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.498]                 ...future.rng), started = ...future.startTime, 
[09:28:17.498]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.498]             version = "1.8"), class = "FutureResult")
[09:28:17.498]     }, finally = {
[09:28:17.498]         if (!identical(...future.workdir, getwd())) 
[09:28:17.498]             setwd(...future.workdir)
[09:28:17.498]         {
[09:28:17.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.498]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.498]             }
[09:28:17.498]             base::options(...future.oldOptions)
[09:28:17.498]             if (.Platform$OS.type == "windows") {
[09:28:17.498]                 old_names <- names(...future.oldEnvVars)
[09:28:17.498]                 envs <- base::Sys.getenv()
[09:28:17.498]                 names <- names(envs)
[09:28:17.498]                 common <- intersect(names, old_names)
[09:28:17.498]                 added <- setdiff(names, old_names)
[09:28:17.498]                 removed <- setdiff(old_names, names)
[09:28:17.498]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.498]                   envs[common]]
[09:28:17.498]                 NAMES <- toupper(changed)
[09:28:17.498]                 args <- list()
[09:28:17.498]                 for (kk in seq_along(NAMES)) {
[09:28:17.498]                   name <- changed[[kk]]
[09:28:17.498]                   NAME <- NAMES[[kk]]
[09:28:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.498]                     next
[09:28:17.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.498]                 }
[09:28:17.498]                 NAMES <- toupper(added)
[09:28:17.498]                 for (kk in seq_along(NAMES)) {
[09:28:17.498]                   name <- added[[kk]]
[09:28:17.498]                   NAME <- NAMES[[kk]]
[09:28:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.498]                     next
[09:28:17.498]                   args[[name]] <- ""
[09:28:17.498]                 }
[09:28:17.498]                 NAMES <- toupper(removed)
[09:28:17.498]                 for (kk in seq_along(NAMES)) {
[09:28:17.498]                   name <- removed[[kk]]
[09:28:17.498]                   NAME <- NAMES[[kk]]
[09:28:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.498]                     next
[09:28:17.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.498]                 }
[09:28:17.498]                 if (length(args) > 0) 
[09:28:17.498]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.498]             }
[09:28:17.498]             else {
[09:28:17.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.498]             }
[09:28:17.498]             {
[09:28:17.498]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.498]                   0L) {
[09:28:17.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.498]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.498]                   base::options(opts)
[09:28:17.498]                 }
[09:28:17.498]                 {
[09:28:17.498]                   {
[09:28:17.498]                     NULL
[09:28:17.498]                     RNGkind("Mersenne-Twister")
[09:28:17.498]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.498]                       inherits = FALSE)
[09:28:17.498]                   }
[09:28:17.498]                   options(future.plan = NULL)
[09:28:17.498]                   if (is.na(NA_character_)) 
[09:28:17.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.498]                     .init = FALSE)
[09:28:17.498]                 }
[09:28:17.498]             }
[09:28:17.498]         }
[09:28:17.498]     })
[09:28:17.498]     if (TRUE) {
[09:28:17.498]         base::sink(type = "output", split = FALSE)
[09:28:17.498]         if (TRUE) {
[09:28:17.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.498]         }
[09:28:17.498]         else {
[09:28:17.498]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.498]         }
[09:28:17.498]         base::close(...future.stdout)
[09:28:17.498]         ...future.stdout <- NULL
[09:28:17.498]     }
[09:28:17.498]     ...future.result$conditions <- ...future.conditions
[09:28:17.498]     ...future.result$finished <- base::Sys.time()
[09:28:17.498]     ...future.result
[09:28:17.498] }
[09:28:17.500] assign_globals() ...
[09:28:17.500] List of 5
[09:28:17.500]  $ future.call.arguments    : list()
[09:28:17.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.500]  $ ...future.FUN            :function (x)  
[09:28:17.500]  $ ...future.elements_ii    :List of 2
[09:28:17.500]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:17.500]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:17.500]  $ ...future.seeds_ii       : NULL
[09:28:17.500]  $ ...future.globals.maxSize: num Inf
[09:28:17.500]  - attr(*, "resolved")= logi FALSE
[09:28:17.500]  - attr(*, "total_size")= num NA
[09:28:17.500]  - attr(*, "where")=List of 5
[09:28:17.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.500]  - attr(*, "already-done")= logi TRUE
[09:28:17.505] - copied ‘future.call.arguments’ to environment
[09:28:17.505] - copied ‘...future.FUN’ to environment
[09:28:17.505] - copied ‘...future.elements_ii’ to environment
[09:28:17.506] - copied ‘...future.seeds_ii’ to environment
[09:28:17.506] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.506] assign_globals() ... done
[09:28:17.506] plan(): Setting new future strategy stack:
[09:28:17.506] List of future strategies:
[09:28:17.506] 1. sequential:
[09:28:17.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.506]    - tweaked: FALSE
[09:28:17.506]    - call: NULL
[09:28:17.506] plan(): nbrOfWorkers() = 1
[09:28:17.507] plan(): Setting new future strategy stack:
[09:28:17.507] List of future strategies:
[09:28:17.507] 1. sequential:
[09:28:17.507]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.507]    - tweaked: FALSE
[09:28:17.507]    - call: plan(strategy)
[09:28:17.508] plan(): nbrOfWorkers() = 1
[09:28:17.508] SequentialFuture started (and completed)
[09:28:17.508] - Launch lazy future ... done
[09:28:17.508] run() for ‘SequentialFuture’ ... done
[09:28:17.508] Created future:
[09:28:17.508] SequentialFuture:
[09:28:17.508] Label: ‘future_apply-1’
[09:28:17.508] Expression:
[09:28:17.508] {
[09:28:17.508]     do.call(function(...) {
[09:28:17.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.508]             on.exit(options(oopts), add = TRUE)
[09:28:17.508]         }
[09:28:17.508]         {
[09:28:17.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.508]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.508]             })
[09:28:17.508]         }
[09:28:17.508]     }, args = future.call.arguments)
[09:28:17.508] }
[09:28:17.508] Lazy evaluation: FALSE
[09:28:17.508] Asynchronous evaluation: FALSE
[09:28:17.508] Local evaluation: TRUE
[09:28:17.508] Environment: R_GlobalEnv
[09:28:17.508] Capture standard output: TRUE
[09:28:17.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.508] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.508] Packages: <none>
[09:28:17.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.508] Resolved: TRUE
[09:28:17.508] Value: 224 bytes of class ‘list’
[09:28:17.508] Early signaling: FALSE
[09:28:17.508] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.508] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.509] Chunk #1 of 1 ... DONE
[09:28:17.509] Launching 1 futures (chunks) ... DONE
[09:28:17.509] Resolving 1 futures (chunks) ...
[09:28:17.509] resolve() on list ...
[09:28:17.509]  recursive: 0
[09:28:17.509]  length: 1
[09:28:17.510] 
[09:28:17.510] resolved() for ‘SequentialFuture’ ...
[09:28:17.510] - state: ‘finished’
[09:28:17.510] - run: TRUE
[09:28:17.510] - result: ‘FutureResult’
[09:28:17.510] resolved() for ‘SequentialFuture’ ... done
[09:28:17.510] Future #1
[09:28:17.510] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.510] - nx: 1
[09:28:17.510] - relay: TRUE
[09:28:17.510] - stdout: TRUE
[09:28:17.511] - signal: TRUE
[09:28:17.511] - resignal: FALSE
[09:28:17.511] - force: TRUE
[09:28:17.511] - relayed: [n=1] FALSE
[09:28:17.511] - queued futures: [n=1] FALSE
[09:28:17.511]  - until=1
[09:28:17.511]  - relaying element #1
[09:28:17.511] - relayed: [n=1] TRUE
[09:28:17.511] - queued futures: [n=1] TRUE
[09:28:17.511] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.511]  length: 0 (resolved future 1)
[09:28:17.512] Relaying remaining futures
[09:28:17.512] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.512] - nx: 1
[09:28:17.512] - relay: TRUE
[09:28:17.512] - stdout: TRUE
[09:28:17.512] - signal: TRUE
[09:28:17.512] - resignal: FALSE
[09:28:17.512] - force: TRUE
[09:28:17.512] - relayed: [n=1] TRUE
[09:28:17.512] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.512] - relayed: [n=1] TRUE
[09:28:17.512] - queued futures: [n=1] TRUE
[09:28:17.513] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.513] resolve() on list ... DONE
[09:28:17.513]  - Number of value chunks collected: 1
[09:28:17.513] Resolving 1 futures (chunks) ... DONE
[09:28:17.513] Reducing values from 1 chunks ...
[09:28:17.513]  - Number of values collected after concatenation: 2
[09:28:17.513]  - Number of values expected: 2
[09:28:17.513] Reducing values from 1 chunks ... DONE
[09:28:17.513] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[09:28:17.514] getGlobalsAndPackagesXApply() ...
[09:28:17.514]  - future.globals: TRUE
[09:28:17.514] getGlobalsAndPackages() ...
[09:28:17.514] Searching for globals...
[09:28:17.515] - globals found: [1] ‘FUN’
[09:28:17.515] Searching for globals ... DONE
[09:28:17.515] Resolving globals: FALSE
[09:28:17.515] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:17.516] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:17.516] - globals: [1] ‘FUN’
[09:28:17.516] 
[09:28:17.516] getGlobalsAndPackages() ... DONE
[09:28:17.516]  - globals found/used: [n=1] ‘FUN’
[09:28:17.516]  - needed namespaces: [n=0] 
[09:28:17.516] Finding globals ... DONE
[09:28:17.516]  - use_args: TRUE
[09:28:17.516]  - Getting '...' globals ...
[09:28:17.517] resolve() on list ...
[09:28:17.517]  recursive: 0
[09:28:17.517]  length: 1
[09:28:17.517]  elements: ‘...’
[09:28:17.517]  length: 0 (resolved future 1)
[09:28:17.517] resolve() on list ... DONE
[09:28:17.517]    - '...' content: [n=0] 
[09:28:17.517] List of 1
[09:28:17.517]  $ ...: list()
[09:28:17.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.517]  - attr(*, "where")=List of 1
[09:28:17.517]   ..$ ...:<environment: 0x559ba4238f68> 
[09:28:17.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.517]  - attr(*, "resolved")= logi TRUE
[09:28:17.517]  - attr(*, "total_size")= num NA
[09:28:17.519]  - Getting '...' globals ... DONE
[09:28:17.520] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.520] List of 2
[09:28:17.520]  $ ...future.FUN:function (x)  
[09:28:17.520]  $ ...          : list()
[09:28:17.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.520]  - attr(*, "where")=List of 2
[09:28:17.520]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.520]   ..$ ...          :<environment: 0x559ba4238f68> 
[09:28:17.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.520]  - attr(*, "resolved")= logi FALSE
[09:28:17.520]  - attr(*, "total_size")= num 848
[09:28:17.523] Packages to be attached in all futures: [n=0] 
[09:28:17.523] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.523] future_lapply() ...
[09:28:17.524] Number of chunks: 1
[09:28:17.524] getGlobalsAndPackagesXApply() ...
[09:28:17.524]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.524]  - use_args: TRUE
[09:28:17.524] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.524] List of 2
[09:28:17.524]  $ ...          : list()
[09:28:17.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.524]  $ ...future.FUN:function (x)  
[09:28:17.524]  - attr(*, "where")=List of 2
[09:28:17.524]   ..$ ...          :<environment: 0x559ba4238f68> 
[09:28:17.524]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.524]  - attr(*, "resolved")= logi FALSE
[09:28:17.524]  - attr(*, "total_size")= num NA
[09:28:17.527] Packages to be attached in all futures: [n=0] 
[09:28:17.527] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.527] Number of futures (= number of chunks): 1
[09:28:17.527] Launching 1 futures (chunks) ...
[09:28:17.527] Chunk #1 of 1 ...
[09:28:17.528]  - seeds: <none>
[09:28:17.528]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.528] getGlobalsAndPackages() ...
[09:28:17.528] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.528] Resolving globals: FALSE
[09:28:17.528] Tweak future expression to call with '...' arguments ...
[09:28:17.528] {
[09:28:17.528]     do.call(function(...) {
[09:28:17.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.528]             on.exit(options(oopts), add = TRUE)
[09:28:17.528]         }
[09:28:17.528]         {
[09:28:17.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.528]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.528]             })
[09:28:17.528]         }
[09:28:17.528]     }, args = future.call.arguments)
[09:28:17.528] }
[09:28:17.528] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.529] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.529] 
[09:28:17.529] getGlobalsAndPackages() ... DONE
[09:28:17.529] run() for ‘Future’ ...
[09:28:17.529] - state: ‘created’
[09:28:17.529] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.530] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.530]   - Field: ‘label’
[09:28:17.530]   - Field: ‘local’
[09:28:17.530]   - Field: ‘owner’
[09:28:17.530]   - Field: ‘envir’
[09:28:17.530]   - Field: ‘packages’
[09:28:17.530]   - Field: ‘gc’
[09:28:17.530]   - Field: ‘conditions’
[09:28:17.530]   - Field: ‘expr’
[09:28:17.531]   - Field: ‘uuid’
[09:28:17.531]   - Field: ‘seed’
[09:28:17.531]   - Field: ‘version’
[09:28:17.531]   - Field: ‘result’
[09:28:17.531]   - Field: ‘asynchronous’
[09:28:17.531]   - Field: ‘calls’
[09:28:17.531]   - Field: ‘globals’
[09:28:17.531]   - Field: ‘stdout’
[09:28:17.531]   - Field: ‘earlySignal’
[09:28:17.531]   - Field: ‘lazy’
[09:28:17.531]   - Field: ‘state’
[09:28:17.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.532] - Launch lazy future ...
[09:28:17.532] Packages needed by the future expression (n = 0): <none>
[09:28:17.532] Packages needed by future strategies (n = 0): <none>
[09:28:17.532] {
[09:28:17.532]     {
[09:28:17.532]         {
[09:28:17.532]             ...future.startTime <- base::Sys.time()
[09:28:17.532]             {
[09:28:17.532]                 {
[09:28:17.532]                   {
[09:28:17.532]                     base::local({
[09:28:17.532]                       has_future <- base::requireNamespace("future", 
[09:28:17.532]                         quietly = TRUE)
[09:28:17.532]                       if (has_future) {
[09:28:17.532]                         ns <- base::getNamespace("future")
[09:28:17.532]                         version <- ns[[".package"]][["version"]]
[09:28:17.532]                         if (is.null(version)) 
[09:28:17.532]                           version <- utils::packageVersion("future")
[09:28:17.532]                       }
[09:28:17.532]                       else {
[09:28:17.532]                         version <- NULL
[09:28:17.532]                       }
[09:28:17.532]                       if (!has_future || version < "1.8.0") {
[09:28:17.532]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.532]                           "", base::R.version$version.string), 
[09:28:17.532]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.532]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.532]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.532]                             "release", "version")], collapse = " "), 
[09:28:17.532]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.532]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.532]                           info)
[09:28:17.532]                         info <- base::paste(info, collapse = "; ")
[09:28:17.532]                         if (!has_future) {
[09:28:17.532]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.532]                             info)
[09:28:17.532]                         }
[09:28:17.532]                         else {
[09:28:17.532]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.532]                             info, version)
[09:28:17.532]                         }
[09:28:17.532]                         base::stop(msg)
[09:28:17.532]                       }
[09:28:17.532]                     })
[09:28:17.532]                   }
[09:28:17.532]                   ...future.strategy.old <- future::plan("list")
[09:28:17.532]                   options(future.plan = NULL)
[09:28:17.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.532]                 }
[09:28:17.532]                 ...future.workdir <- getwd()
[09:28:17.532]             }
[09:28:17.532]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.532]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.532]         }
[09:28:17.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.532]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.532]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.532]             base::names(...future.oldOptions))
[09:28:17.532]     }
[09:28:17.532]     if (FALSE) {
[09:28:17.532]     }
[09:28:17.532]     else {
[09:28:17.532]         if (TRUE) {
[09:28:17.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.532]                 open = "w")
[09:28:17.532]         }
[09:28:17.532]         else {
[09:28:17.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.532]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.532]         }
[09:28:17.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.532]             base::sink(type = "output", split = FALSE)
[09:28:17.532]             base::close(...future.stdout)
[09:28:17.532]         }, add = TRUE)
[09:28:17.532]     }
[09:28:17.532]     ...future.frame <- base::sys.nframe()
[09:28:17.532]     ...future.conditions <- base::list()
[09:28:17.532]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.532]     if (FALSE) {
[09:28:17.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.532]     }
[09:28:17.532]     ...future.result <- base::tryCatch({
[09:28:17.532]         base::withCallingHandlers({
[09:28:17.532]             ...future.value <- base::withVisible(base::local({
[09:28:17.532]                 do.call(function(...) {
[09:28:17.532]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.532]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.532]                     ...future.globals.maxSize)) {
[09:28:17.532]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.532]                     on.exit(options(oopts), add = TRUE)
[09:28:17.532]                   }
[09:28:17.532]                   {
[09:28:17.532]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.532]                       FUN = function(jj) {
[09:28:17.532]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.532]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.532]                       })
[09:28:17.532]                   }
[09:28:17.532]                 }, args = future.call.arguments)
[09:28:17.532]             }))
[09:28:17.532]             future::FutureResult(value = ...future.value$value, 
[09:28:17.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.532]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.532]                     ...future.globalenv.names))
[09:28:17.532]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.532]         }, condition = base::local({
[09:28:17.532]             c <- base::c
[09:28:17.532]             inherits <- base::inherits
[09:28:17.532]             invokeRestart <- base::invokeRestart
[09:28:17.532]             length <- base::length
[09:28:17.532]             list <- base::list
[09:28:17.532]             seq.int <- base::seq.int
[09:28:17.532]             signalCondition <- base::signalCondition
[09:28:17.532]             sys.calls <- base::sys.calls
[09:28:17.532]             `[[` <- base::`[[`
[09:28:17.532]             `+` <- base::`+`
[09:28:17.532]             `<<-` <- base::`<<-`
[09:28:17.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.532]                   3L)]
[09:28:17.532]             }
[09:28:17.532]             function(cond) {
[09:28:17.532]                 is_error <- inherits(cond, "error")
[09:28:17.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.532]                   NULL)
[09:28:17.532]                 if (is_error) {
[09:28:17.532]                   sessionInformation <- function() {
[09:28:17.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.532]                       search = base::search(), system = base::Sys.info())
[09:28:17.532]                   }
[09:28:17.532]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.532]                     cond$call), session = sessionInformation(), 
[09:28:17.532]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.532]                   signalCondition(cond)
[09:28:17.532]                 }
[09:28:17.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.532]                 "immediateCondition"))) {
[09:28:17.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.532]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.532]                   if (TRUE && !signal) {
[09:28:17.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.532]                     {
[09:28:17.532]                       inherits <- base::inherits
[09:28:17.532]                       invokeRestart <- base::invokeRestart
[09:28:17.532]                       is.null <- base::is.null
[09:28:17.532]                       muffled <- FALSE
[09:28:17.532]                       if (inherits(cond, "message")) {
[09:28:17.532]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.532]                         if (muffled) 
[09:28:17.532]                           invokeRestart("muffleMessage")
[09:28:17.532]                       }
[09:28:17.532]                       else if (inherits(cond, "warning")) {
[09:28:17.532]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.532]                         if (muffled) 
[09:28:17.532]                           invokeRestart("muffleWarning")
[09:28:17.532]                       }
[09:28:17.532]                       else if (inherits(cond, "condition")) {
[09:28:17.532]                         if (!is.null(pattern)) {
[09:28:17.532]                           computeRestarts <- base::computeRestarts
[09:28:17.532]                           grepl <- base::grepl
[09:28:17.532]                           restarts <- computeRestarts(cond)
[09:28:17.532]                           for (restart in restarts) {
[09:28:17.532]                             name <- restart$name
[09:28:17.532]                             if (is.null(name)) 
[09:28:17.532]                               next
[09:28:17.532]                             if (!grepl(pattern, name)) 
[09:28:17.532]                               next
[09:28:17.532]                             invokeRestart(restart)
[09:28:17.532]                             muffled <- TRUE
[09:28:17.532]                             break
[09:28:17.532]                           }
[09:28:17.532]                         }
[09:28:17.532]                       }
[09:28:17.532]                       invisible(muffled)
[09:28:17.532]                     }
[09:28:17.532]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.532]                   }
[09:28:17.532]                 }
[09:28:17.532]                 else {
[09:28:17.532]                   if (TRUE) {
[09:28:17.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.532]                     {
[09:28:17.532]                       inherits <- base::inherits
[09:28:17.532]                       invokeRestart <- base::invokeRestart
[09:28:17.532]                       is.null <- base::is.null
[09:28:17.532]                       muffled <- FALSE
[09:28:17.532]                       if (inherits(cond, "message")) {
[09:28:17.532]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.532]                         if (muffled) 
[09:28:17.532]                           invokeRestart("muffleMessage")
[09:28:17.532]                       }
[09:28:17.532]                       else if (inherits(cond, "warning")) {
[09:28:17.532]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.532]                         if (muffled) 
[09:28:17.532]                           invokeRestart("muffleWarning")
[09:28:17.532]                       }
[09:28:17.532]                       else if (inherits(cond, "condition")) {
[09:28:17.532]                         if (!is.null(pattern)) {
[09:28:17.532]                           computeRestarts <- base::computeRestarts
[09:28:17.532]                           grepl <- base::grepl
[09:28:17.532]                           restarts <- computeRestarts(cond)
[09:28:17.532]                           for (restart in restarts) {
[09:28:17.532]                             name <- restart$name
[09:28:17.532]                             if (is.null(name)) 
[09:28:17.532]                               next
[09:28:17.532]                             if (!grepl(pattern, name)) 
[09:28:17.532]                               next
[09:28:17.532]                             invokeRestart(restart)
[09:28:17.532]                             muffled <- TRUE
[09:28:17.532]                             break
[09:28:17.532]                           }
[09:28:17.532]                         }
[09:28:17.532]                       }
[09:28:17.532]                       invisible(muffled)
[09:28:17.532]                     }
[09:28:17.532]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.532]                   }
[09:28:17.532]                 }
[09:28:17.532]             }
[09:28:17.532]         }))
[09:28:17.532]     }, error = function(ex) {
[09:28:17.532]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.532]                 ...future.rng), started = ...future.startTime, 
[09:28:17.532]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.532]             version = "1.8"), class = "FutureResult")
[09:28:17.532]     }, finally = {
[09:28:17.532]         if (!identical(...future.workdir, getwd())) 
[09:28:17.532]             setwd(...future.workdir)
[09:28:17.532]         {
[09:28:17.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.532]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.532]             }
[09:28:17.532]             base::options(...future.oldOptions)
[09:28:17.532]             if (.Platform$OS.type == "windows") {
[09:28:17.532]                 old_names <- names(...future.oldEnvVars)
[09:28:17.532]                 envs <- base::Sys.getenv()
[09:28:17.532]                 names <- names(envs)
[09:28:17.532]                 common <- intersect(names, old_names)
[09:28:17.532]                 added <- setdiff(names, old_names)
[09:28:17.532]                 removed <- setdiff(old_names, names)
[09:28:17.532]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.532]                   envs[common]]
[09:28:17.532]                 NAMES <- toupper(changed)
[09:28:17.532]                 args <- list()
[09:28:17.532]                 for (kk in seq_along(NAMES)) {
[09:28:17.532]                   name <- changed[[kk]]
[09:28:17.532]                   NAME <- NAMES[[kk]]
[09:28:17.532]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.532]                     next
[09:28:17.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.532]                 }
[09:28:17.532]                 NAMES <- toupper(added)
[09:28:17.532]                 for (kk in seq_along(NAMES)) {
[09:28:17.532]                   name <- added[[kk]]
[09:28:17.532]                   NAME <- NAMES[[kk]]
[09:28:17.532]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.532]                     next
[09:28:17.532]                   args[[name]] <- ""
[09:28:17.532]                 }
[09:28:17.532]                 NAMES <- toupper(removed)
[09:28:17.532]                 for (kk in seq_along(NAMES)) {
[09:28:17.532]                   name <- removed[[kk]]
[09:28:17.532]                   NAME <- NAMES[[kk]]
[09:28:17.532]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.532]                     next
[09:28:17.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.532]                 }
[09:28:17.532]                 if (length(args) > 0) 
[09:28:17.532]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.532]             }
[09:28:17.532]             else {
[09:28:17.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.532]             }
[09:28:17.532]             {
[09:28:17.532]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.532]                   0L) {
[09:28:17.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.532]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.532]                   base::options(opts)
[09:28:17.532]                 }
[09:28:17.532]                 {
[09:28:17.532]                   {
[09:28:17.532]                     NULL
[09:28:17.532]                     RNGkind("Mersenne-Twister")
[09:28:17.532]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.532]                       inherits = FALSE)
[09:28:17.532]                   }
[09:28:17.532]                   options(future.plan = NULL)
[09:28:17.532]                   if (is.na(NA_character_)) 
[09:28:17.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.532]                     .init = FALSE)
[09:28:17.532]                 }
[09:28:17.532]             }
[09:28:17.532]         }
[09:28:17.532]     })
[09:28:17.532]     if (TRUE) {
[09:28:17.532]         base::sink(type = "output", split = FALSE)
[09:28:17.532]         if (TRUE) {
[09:28:17.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.532]         }
[09:28:17.532]         else {
[09:28:17.532]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.532]         }
[09:28:17.532]         base::close(...future.stdout)
[09:28:17.532]         ...future.stdout <- NULL
[09:28:17.532]     }
[09:28:17.532]     ...future.result$conditions <- ...future.conditions
[09:28:17.532]     ...future.result$finished <- base::Sys.time()
[09:28:17.532]     ...future.result
[09:28:17.532] }
[09:28:17.534] assign_globals() ...
[09:28:17.534] List of 5
[09:28:17.534]  $ future.call.arguments    : list()
[09:28:17.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.534]  $ ...future.FUN            :function (x)  
[09:28:17.534]  $ ...future.elements_ii    :List of 6
[09:28:17.534]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:17.534]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:17.534]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:17.534]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:17.534]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:17.534]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:17.534]  $ ...future.seeds_ii       : NULL
[09:28:17.534]  $ ...future.globals.maxSize: num Inf
[09:28:17.534]  - attr(*, "resolved")= logi FALSE
[09:28:17.534]  - attr(*, "total_size")= num NA
[09:28:17.534]  - attr(*, "where")=List of 5
[09:28:17.534]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.534]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.534]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.534]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.534]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.534]  - attr(*, "already-done")= logi TRUE
[09:28:17.540] - copied ‘future.call.arguments’ to environment
[09:28:17.540] - copied ‘...future.FUN’ to environment
[09:28:17.540] - copied ‘...future.elements_ii’ to environment
[09:28:17.540] - copied ‘...future.seeds_ii’ to environment
[09:28:17.540] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.540] assign_globals() ... done
[09:28:17.540] plan(): Setting new future strategy stack:
[09:28:17.540] List of future strategies:
[09:28:17.540] 1. sequential:
[09:28:17.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.540]    - tweaked: FALSE
[09:28:17.540]    - call: NULL
[09:28:17.541] plan(): nbrOfWorkers() = 1
[09:28:17.542] plan(): Setting new future strategy stack:
[09:28:17.542] List of future strategies:
[09:28:17.542] 1. sequential:
[09:28:17.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.542]    - tweaked: FALSE
[09:28:17.542]    - call: plan(strategy)
[09:28:17.542] plan(): nbrOfWorkers() = 1
[09:28:17.542] SequentialFuture started (and completed)
[09:28:17.542] - Launch lazy future ... done
[09:28:17.542] run() for ‘SequentialFuture’ ... done
[09:28:17.543] Created future:
[09:28:17.543] SequentialFuture:
[09:28:17.543] Label: ‘future_apply-1’
[09:28:17.543] Expression:
[09:28:17.543] {
[09:28:17.543]     do.call(function(...) {
[09:28:17.543]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.543]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.543]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.543]             on.exit(options(oopts), add = TRUE)
[09:28:17.543]         }
[09:28:17.543]         {
[09:28:17.543]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.543]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.543]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.543]             })
[09:28:17.543]         }
[09:28:17.543]     }, args = future.call.arguments)
[09:28:17.543] }
[09:28:17.543] Lazy evaluation: FALSE
[09:28:17.543] Asynchronous evaluation: FALSE
[09:28:17.543] Local evaluation: TRUE
[09:28:17.543] Environment: R_GlobalEnv
[09:28:17.543] Capture standard output: TRUE
[09:28:17.543] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.543] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.543] Packages: <none>
[09:28:17.543] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.543] Resolved: TRUE
[09:28:17.543] Value: 672 bytes of class ‘list’
[09:28:17.543] Early signaling: FALSE
[09:28:17.543] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.543] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.544] Chunk #1 of 1 ... DONE
[09:28:17.544] Launching 1 futures (chunks) ... DONE
[09:28:17.544] Resolving 1 futures (chunks) ...
[09:28:17.544] resolve() on list ...
[09:28:17.544]  recursive: 0
[09:28:17.544]  length: 1
[09:28:17.544] 
[09:28:17.544] resolved() for ‘SequentialFuture’ ...
[09:28:17.545] - state: ‘finished’
[09:28:17.545] - run: TRUE
[09:28:17.545] - result: ‘FutureResult’
[09:28:17.545] resolved() for ‘SequentialFuture’ ... done
[09:28:17.546] Future #1
[09:28:17.546] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.546] - nx: 1
[09:28:17.546] - relay: TRUE
[09:28:17.546] - stdout: TRUE
[09:28:17.546] - signal: TRUE
[09:28:17.546] - resignal: FALSE
[09:28:17.546] - force: TRUE
[09:28:17.546] - relayed: [n=1] FALSE
[09:28:17.546] - queued futures: [n=1] FALSE
[09:28:17.546]  - until=1
[09:28:17.547]  - relaying element #1
[09:28:17.547] - relayed: [n=1] TRUE
[09:28:17.547] - queued futures: [n=1] TRUE
[09:28:17.547] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.547]  length: 0 (resolved future 1)
[09:28:17.547] Relaying remaining futures
[09:28:17.547] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.547] - nx: 1
[09:28:17.547] - relay: TRUE
[09:28:17.547] - stdout: TRUE
[09:28:17.547] - signal: TRUE
[09:28:17.548] - resignal: FALSE
[09:28:17.548] - force: TRUE
[09:28:17.548] - relayed: [n=1] TRUE
[09:28:17.548] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.548] - relayed: [n=1] TRUE
[09:28:17.548] - queued futures: [n=1] TRUE
[09:28:17.548] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.548] resolve() on list ... DONE
[09:28:17.548]  - Number of value chunks collected: 1
[09:28:17.548] Resolving 1 futures (chunks) ... DONE
[09:28:17.549] Reducing values from 1 chunks ...
[09:28:17.549]  - Number of values collected after concatenation: 6
[09:28:17.549]  - Number of values expected: 6
[09:28:17.549] Reducing values from 1 chunks ... DONE
[09:28:17.549] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[09:28:17.549] getGlobalsAndPackagesXApply() ...
[09:28:17.549]  - future.globals: TRUE
[09:28:17.550] getGlobalsAndPackages() ...
[09:28:17.550] Searching for globals...
[09:28:17.551] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[09:28:17.551] Searching for globals ... DONE
[09:28:17.551] Resolving globals: FALSE
[09:28:17.551] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[09:28:17.552] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[09:28:17.552] - globals: [1] ‘FUN’
[09:28:17.552] 
[09:28:17.552] getGlobalsAndPackages() ... DONE
[09:28:17.552]  - globals found/used: [n=1] ‘FUN’
[09:28:17.552]  - needed namespaces: [n=0] 
[09:28:17.552] Finding globals ... DONE
[09:28:17.552]  - use_args: TRUE
[09:28:17.552]  - Getting '...' globals ...
[09:28:17.553] resolve() on list ...
[09:28:17.553]  recursive: 0
[09:28:17.553]  length: 1
[09:28:17.553]  elements: ‘...’
[09:28:17.553]  length: 0 (resolved future 1)
[09:28:17.553] resolve() on list ... DONE
[09:28:17.553]    - '...' content: [n=0] 
[09:28:17.553] List of 1
[09:28:17.553]  $ ...: list()
[09:28:17.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.553]  - attr(*, "where")=List of 1
[09:28:17.553]   ..$ ...:<environment: 0x559ba1f04a18> 
[09:28:17.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.553]  - attr(*, "resolved")= logi TRUE
[09:28:17.553]  - attr(*, "total_size")= num NA
[09:28:17.556]  - Getting '...' globals ... DONE
[09:28:17.556] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.556] List of 2
[09:28:17.556]  $ ...future.FUN:function (x)  
[09:28:17.556]  $ ...          : list()
[09:28:17.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.556]  - attr(*, "where")=List of 2
[09:28:17.556]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.556]   ..$ ...          :<environment: 0x559ba1f04a18> 
[09:28:17.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.556]  - attr(*, "resolved")= logi FALSE
[09:28:17.556]  - attr(*, "total_size")= num 1768
[09:28:17.558] Packages to be attached in all futures: [n=0] 
[09:28:17.558] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.559] future_lapply() ...
[09:28:17.559] Number of chunks: 1
[09:28:17.559] getGlobalsAndPackagesXApply() ...
[09:28:17.559]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.559]  - use_args: TRUE
[09:28:17.559] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.560] List of 2
[09:28:17.560]  $ ...          : list()
[09:28:17.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.560]  $ ...future.FUN:function (x)  
[09:28:17.560]  - attr(*, "where")=List of 2
[09:28:17.560]   ..$ ...          :<environment: 0x559ba1f04a18> 
[09:28:17.560]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:17.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.560]  - attr(*, "resolved")= logi FALSE
[09:28:17.560]  - attr(*, "total_size")= num NA
[09:28:17.562] Packages to be attached in all futures: [n=0] 
[09:28:17.562] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.562] Number of futures (= number of chunks): 1
[09:28:17.562] Launching 1 futures (chunks) ...
[09:28:17.562] Chunk #1 of 1 ...
[09:28:17.563]  - seeds: <none>
[09:28:17.563]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.563] getGlobalsAndPackages() ...
[09:28:17.563] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.563] Resolving globals: FALSE
[09:28:17.563] Tweak future expression to call with '...' arguments ...
[09:28:17.563] {
[09:28:17.563]     do.call(function(...) {
[09:28:17.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.563]             on.exit(options(oopts), add = TRUE)
[09:28:17.563]         }
[09:28:17.563]         {
[09:28:17.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.563]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.563]             })
[09:28:17.563]         }
[09:28:17.563]     }, args = future.call.arguments)
[09:28:17.563] }
[09:28:17.563] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.564] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.564] 
[09:28:17.564] getGlobalsAndPackages() ... DONE
[09:28:17.564] run() for ‘Future’ ...
[09:28:17.564] - state: ‘created’
[09:28:17.564] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.565] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.565]   - Field: ‘label’
[09:28:17.565]   - Field: ‘local’
[09:28:17.565]   - Field: ‘owner’
[09:28:17.565]   - Field: ‘envir’
[09:28:17.565]   - Field: ‘packages’
[09:28:17.565]   - Field: ‘gc’
[09:28:17.566]   - Field: ‘conditions’
[09:28:17.566]   - Field: ‘expr’
[09:28:17.566]   - Field: ‘uuid’
[09:28:17.567]   - Field: ‘seed’
[09:28:17.567]   - Field: ‘version’
[09:28:17.567]   - Field: ‘result’
[09:28:17.567]   - Field: ‘asynchronous’
[09:28:17.567]   - Field: ‘calls’
[09:28:17.567]   - Field: ‘globals’
[09:28:17.567]   - Field: ‘stdout’
[09:28:17.567]   - Field: ‘earlySignal’
[09:28:17.567]   - Field: ‘lazy’
[09:28:17.567]   - Field: ‘state’
[09:28:17.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.568] - Launch lazy future ...
[09:28:17.568] Packages needed by the future expression (n = 0): <none>
[09:28:17.568] Packages needed by future strategies (n = 0): <none>
[09:28:17.568] {
[09:28:17.568]     {
[09:28:17.568]         {
[09:28:17.568]             ...future.startTime <- base::Sys.time()
[09:28:17.568]             {
[09:28:17.568]                 {
[09:28:17.568]                   {
[09:28:17.568]                     base::local({
[09:28:17.568]                       has_future <- base::requireNamespace("future", 
[09:28:17.568]                         quietly = TRUE)
[09:28:17.568]                       if (has_future) {
[09:28:17.568]                         ns <- base::getNamespace("future")
[09:28:17.568]                         version <- ns[[".package"]][["version"]]
[09:28:17.568]                         if (is.null(version)) 
[09:28:17.568]                           version <- utils::packageVersion("future")
[09:28:17.568]                       }
[09:28:17.568]                       else {
[09:28:17.568]                         version <- NULL
[09:28:17.568]                       }
[09:28:17.568]                       if (!has_future || version < "1.8.0") {
[09:28:17.568]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.568]                           "", base::R.version$version.string), 
[09:28:17.568]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.568]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.568]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.568]                             "release", "version")], collapse = " "), 
[09:28:17.568]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.568]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.568]                           info)
[09:28:17.568]                         info <- base::paste(info, collapse = "; ")
[09:28:17.568]                         if (!has_future) {
[09:28:17.568]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.568]                             info)
[09:28:17.568]                         }
[09:28:17.568]                         else {
[09:28:17.568]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.568]                             info, version)
[09:28:17.568]                         }
[09:28:17.568]                         base::stop(msg)
[09:28:17.568]                       }
[09:28:17.568]                     })
[09:28:17.568]                   }
[09:28:17.568]                   ...future.strategy.old <- future::plan("list")
[09:28:17.568]                   options(future.plan = NULL)
[09:28:17.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.568]                 }
[09:28:17.568]                 ...future.workdir <- getwd()
[09:28:17.568]             }
[09:28:17.568]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.568]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.568]         }
[09:28:17.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.568]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.568]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.568]             base::names(...future.oldOptions))
[09:28:17.568]     }
[09:28:17.568]     if (FALSE) {
[09:28:17.568]     }
[09:28:17.568]     else {
[09:28:17.568]         if (TRUE) {
[09:28:17.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.568]                 open = "w")
[09:28:17.568]         }
[09:28:17.568]         else {
[09:28:17.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.568]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.568]         }
[09:28:17.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.568]             base::sink(type = "output", split = FALSE)
[09:28:17.568]             base::close(...future.stdout)
[09:28:17.568]         }, add = TRUE)
[09:28:17.568]     }
[09:28:17.568]     ...future.frame <- base::sys.nframe()
[09:28:17.568]     ...future.conditions <- base::list()
[09:28:17.568]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.568]     if (FALSE) {
[09:28:17.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.568]     }
[09:28:17.568]     ...future.result <- base::tryCatch({
[09:28:17.568]         base::withCallingHandlers({
[09:28:17.568]             ...future.value <- base::withVisible(base::local({
[09:28:17.568]                 do.call(function(...) {
[09:28:17.568]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.568]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.568]                     ...future.globals.maxSize)) {
[09:28:17.568]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.568]                     on.exit(options(oopts), add = TRUE)
[09:28:17.568]                   }
[09:28:17.568]                   {
[09:28:17.568]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.568]                       FUN = function(jj) {
[09:28:17.568]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.568]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.568]                       })
[09:28:17.568]                   }
[09:28:17.568]                 }, args = future.call.arguments)
[09:28:17.568]             }))
[09:28:17.568]             future::FutureResult(value = ...future.value$value, 
[09:28:17.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.568]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.568]                     ...future.globalenv.names))
[09:28:17.568]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.568]         }, condition = base::local({
[09:28:17.568]             c <- base::c
[09:28:17.568]             inherits <- base::inherits
[09:28:17.568]             invokeRestart <- base::invokeRestart
[09:28:17.568]             length <- base::length
[09:28:17.568]             list <- base::list
[09:28:17.568]             seq.int <- base::seq.int
[09:28:17.568]             signalCondition <- base::signalCondition
[09:28:17.568]             sys.calls <- base::sys.calls
[09:28:17.568]             `[[` <- base::`[[`
[09:28:17.568]             `+` <- base::`+`
[09:28:17.568]             `<<-` <- base::`<<-`
[09:28:17.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.568]                   3L)]
[09:28:17.568]             }
[09:28:17.568]             function(cond) {
[09:28:17.568]                 is_error <- inherits(cond, "error")
[09:28:17.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.568]                   NULL)
[09:28:17.568]                 if (is_error) {
[09:28:17.568]                   sessionInformation <- function() {
[09:28:17.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.568]                       search = base::search(), system = base::Sys.info())
[09:28:17.568]                   }
[09:28:17.568]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.568]                     cond$call), session = sessionInformation(), 
[09:28:17.568]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.568]                   signalCondition(cond)
[09:28:17.568]                 }
[09:28:17.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.568]                 "immediateCondition"))) {
[09:28:17.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.568]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.568]                   if (TRUE && !signal) {
[09:28:17.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.568]                     {
[09:28:17.568]                       inherits <- base::inherits
[09:28:17.568]                       invokeRestart <- base::invokeRestart
[09:28:17.568]                       is.null <- base::is.null
[09:28:17.568]                       muffled <- FALSE
[09:28:17.568]                       if (inherits(cond, "message")) {
[09:28:17.568]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.568]                         if (muffled) 
[09:28:17.568]                           invokeRestart("muffleMessage")
[09:28:17.568]                       }
[09:28:17.568]                       else if (inherits(cond, "warning")) {
[09:28:17.568]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.568]                         if (muffled) 
[09:28:17.568]                           invokeRestart("muffleWarning")
[09:28:17.568]                       }
[09:28:17.568]                       else if (inherits(cond, "condition")) {
[09:28:17.568]                         if (!is.null(pattern)) {
[09:28:17.568]                           computeRestarts <- base::computeRestarts
[09:28:17.568]                           grepl <- base::grepl
[09:28:17.568]                           restarts <- computeRestarts(cond)
[09:28:17.568]                           for (restart in restarts) {
[09:28:17.568]                             name <- restart$name
[09:28:17.568]                             if (is.null(name)) 
[09:28:17.568]                               next
[09:28:17.568]                             if (!grepl(pattern, name)) 
[09:28:17.568]                               next
[09:28:17.568]                             invokeRestart(restart)
[09:28:17.568]                             muffled <- TRUE
[09:28:17.568]                             break
[09:28:17.568]                           }
[09:28:17.568]                         }
[09:28:17.568]                       }
[09:28:17.568]                       invisible(muffled)
[09:28:17.568]                     }
[09:28:17.568]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.568]                   }
[09:28:17.568]                 }
[09:28:17.568]                 else {
[09:28:17.568]                   if (TRUE) {
[09:28:17.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.568]                     {
[09:28:17.568]                       inherits <- base::inherits
[09:28:17.568]                       invokeRestart <- base::invokeRestart
[09:28:17.568]                       is.null <- base::is.null
[09:28:17.568]                       muffled <- FALSE
[09:28:17.568]                       if (inherits(cond, "message")) {
[09:28:17.568]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.568]                         if (muffled) 
[09:28:17.568]                           invokeRestart("muffleMessage")
[09:28:17.568]                       }
[09:28:17.568]                       else if (inherits(cond, "warning")) {
[09:28:17.568]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.568]                         if (muffled) 
[09:28:17.568]                           invokeRestart("muffleWarning")
[09:28:17.568]                       }
[09:28:17.568]                       else if (inherits(cond, "condition")) {
[09:28:17.568]                         if (!is.null(pattern)) {
[09:28:17.568]                           computeRestarts <- base::computeRestarts
[09:28:17.568]                           grepl <- base::grepl
[09:28:17.568]                           restarts <- computeRestarts(cond)
[09:28:17.568]                           for (restart in restarts) {
[09:28:17.568]                             name <- restart$name
[09:28:17.568]                             if (is.null(name)) 
[09:28:17.568]                               next
[09:28:17.568]                             if (!grepl(pattern, name)) 
[09:28:17.568]                               next
[09:28:17.568]                             invokeRestart(restart)
[09:28:17.568]                             muffled <- TRUE
[09:28:17.568]                             break
[09:28:17.568]                           }
[09:28:17.568]                         }
[09:28:17.568]                       }
[09:28:17.568]                       invisible(muffled)
[09:28:17.568]                     }
[09:28:17.568]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.568]                   }
[09:28:17.568]                 }
[09:28:17.568]             }
[09:28:17.568]         }))
[09:28:17.568]     }, error = function(ex) {
[09:28:17.568]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.568]                 ...future.rng), started = ...future.startTime, 
[09:28:17.568]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.568]             version = "1.8"), class = "FutureResult")
[09:28:17.568]     }, finally = {
[09:28:17.568]         if (!identical(...future.workdir, getwd())) 
[09:28:17.568]             setwd(...future.workdir)
[09:28:17.568]         {
[09:28:17.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.568]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.568]             }
[09:28:17.568]             base::options(...future.oldOptions)
[09:28:17.568]             if (.Platform$OS.type == "windows") {
[09:28:17.568]                 old_names <- names(...future.oldEnvVars)
[09:28:17.568]                 envs <- base::Sys.getenv()
[09:28:17.568]                 names <- names(envs)
[09:28:17.568]                 common <- intersect(names, old_names)
[09:28:17.568]                 added <- setdiff(names, old_names)
[09:28:17.568]                 removed <- setdiff(old_names, names)
[09:28:17.568]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.568]                   envs[common]]
[09:28:17.568]                 NAMES <- toupper(changed)
[09:28:17.568]                 args <- list()
[09:28:17.568]                 for (kk in seq_along(NAMES)) {
[09:28:17.568]                   name <- changed[[kk]]
[09:28:17.568]                   NAME <- NAMES[[kk]]
[09:28:17.568]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.568]                     next
[09:28:17.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.568]                 }
[09:28:17.568]                 NAMES <- toupper(added)
[09:28:17.568]                 for (kk in seq_along(NAMES)) {
[09:28:17.568]                   name <- added[[kk]]
[09:28:17.568]                   NAME <- NAMES[[kk]]
[09:28:17.568]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.568]                     next
[09:28:17.568]                   args[[name]] <- ""
[09:28:17.568]                 }
[09:28:17.568]                 NAMES <- toupper(removed)
[09:28:17.568]                 for (kk in seq_along(NAMES)) {
[09:28:17.568]                   name <- removed[[kk]]
[09:28:17.568]                   NAME <- NAMES[[kk]]
[09:28:17.568]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.568]                     next
[09:28:17.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.568]                 }
[09:28:17.568]                 if (length(args) > 0) 
[09:28:17.568]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.568]             }
[09:28:17.568]             else {
[09:28:17.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.568]             }
[09:28:17.568]             {
[09:28:17.568]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.568]                   0L) {
[09:28:17.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.568]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.568]                   base::options(opts)
[09:28:17.568]                 }
[09:28:17.568]                 {
[09:28:17.568]                   {
[09:28:17.568]                     NULL
[09:28:17.568]                     RNGkind("Mersenne-Twister")
[09:28:17.568]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.568]                       inherits = FALSE)
[09:28:17.568]                   }
[09:28:17.568]                   options(future.plan = NULL)
[09:28:17.568]                   if (is.na(NA_character_)) 
[09:28:17.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.568]                     .init = FALSE)
[09:28:17.568]                 }
[09:28:17.568]             }
[09:28:17.568]         }
[09:28:17.568]     })
[09:28:17.568]     if (TRUE) {
[09:28:17.568]         base::sink(type = "output", split = FALSE)
[09:28:17.568]         if (TRUE) {
[09:28:17.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.568]         }
[09:28:17.568]         else {
[09:28:17.568]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.568]         }
[09:28:17.568]         base::close(...future.stdout)
[09:28:17.568]         ...future.stdout <- NULL
[09:28:17.568]     }
[09:28:17.568]     ...future.result$conditions <- ...future.conditions
[09:28:17.568]     ...future.result$finished <- base::Sys.time()
[09:28:17.568]     ...future.result
[09:28:17.568] }
[09:28:17.570] assign_globals() ...
[09:28:17.570] List of 5
[09:28:17.570]  $ future.call.arguments    : list()
[09:28:17.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.570]  $ ...future.FUN            :function (x)  
[09:28:17.570]  $ ...future.elements_ii    :List of 6
[09:28:17.570]   ..$ : int [1:4] 1 7 13 19
[09:28:17.570]   ..$ : int [1:4] 2 8 14 20
[09:28:17.570]   ..$ : int [1:4] 3 9 15 21
[09:28:17.570]   ..$ : int [1:4] 4 10 16 22
[09:28:17.570]   ..$ : int [1:4] 5 11 17 23
[09:28:17.570]   ..$ : int [1:4] 6 12 18 24
[09:28:17.570]  $ ...future.seeds_ii       : NULL
[09:28:17.570]  $ ...future.globals.maxSize: num Inf
[09:28:17.570]  - attr(*, "resolved")= logi FALSE
[09:28:17.570]  - attr(*, "total_size")= num NA
[09:28:17.570]  - attr(*, "where")=List of 5
[09:28:17.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.570]  - attr(*, "already-done")= logi TRUE
[09:28:17.576] - copied ‘future.call.arguments’ to environment
[09:28:17.576] - reassign environment for ‘...future.FUN’
[09:28:17.576] - copied ‘...future.FUN’ to environment
[09:28:17.576] - copied ‘...future.elements_ii’ to environment
[09:28:17.576] - copied ‘...future.seeds_ii’ to environment
[09:28:17.576] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.576] assign_globals() ... done
[09:28:17.576] plan(): Setting new future strategy stack:
[09:28:17.576] List of future strategies:
[09:28:17.576] 1. sequential:
[09:28:17.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.576]    - tweaked: FALSE
[09:28:17.576]    - call: NULL
[09:28:17.577] plan(): nbrOfWorkers() = 1
[09:28:17.578] plan(): Setting new future strategy stack:
[09:28:17.578] List of future strategies:
[09:28:17.578] 1. sequential:
[09:28:17.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.578]    - tweaked: FALSE
[09:28:17.578]    - call: plan(strategy)
[09:28:17.578] plan(): nbrOfWorkers() = 1
[09:28:17.578] SequentialFuture started (and completed)
[09:28:17.578] - Launch lazy future ... done
[09:28:17.578] run() for ‘SequentialFuture’ ... done
[09:28:17.579] Created future:
[09:28:17.579] SequentialFuture:
[09:28:17.579] Label: ‘future_apply-1’
[09:28:17.579] Expression:
[09:28:17.579] {
[09:28:17.579]     do.call(function(...) {
[09:28:17.579]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.579]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.579]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.579]             on.exit(options(oopts), add = TRUE)
[09:28:17.579]         }
[09:28:17.579]         {
[09:28:17.579]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.579]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.579]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.579]             })
[09:28:17.579]         }
[09:28:17.579]     }, args = future.call.arguments)
[09:28:17.579] }
[09:28:17.579] Lazy evaluation: FALSE
[09:28:17.579] Asynchronous evaluation: FALSE
[09:28:17.579] Local evaluation: TRUE
[09:28:17.579] Environment: R_GlobalEnv
[09:28:17.579] Capture standard output: TRUE
[09:28:17.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.579] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.579] Packages: <none>
[09:28:17.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.579] Resolved: TRUE
[09:28:17.579] Value: 1.03 KiB of class ‘list’
[09:28:17.579] Early signaling: FALSE
[09:28:17.579] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.579] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.580] Chunk #1 of 1 ... DONE
[09:28:17.580] Launching 1 futures (chunks) ... DONE
[09:28:17.580] Resolving 1 futures (chunks) ...
[09:28:17.580] resolve() on list ...
[09:28:17.580]  recursive: 0
[09:28:17.580]  length: 1
[09:28:17.580] 
[09:28:17.580] resolved() for ‘SequentialFuture’ ...
[09:28:17.580] - state: ‘finished’
[09:28:17.580] - run: TRUE
[09:28:17.580] - result: ‘FutureResult’
[09:28:17.581] resolved() for ‘SequentialFuture’ ... done
[09:28:17.581] Future #1
[09:28:17.581] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.581] - nx: 1
[09:28:17.581] - relay: TRUE
[09:28:17.581] - stdout: TRUE
[09:28:17.581] - signal: TRUE
[09:28:17.581] - resignal: FALSE
[09:28:17.581] - force: TRUE
[09:28:17.581] - relayed: [n=1] FALSE
[09:28:17.581] - queued futures: [n=1] FALSE
[09:28:17.581]  - until=1
[09:28:17.582]  - relaying element #1
[09:28:17.582] - relayed: [n=1] TRUE
[09:28:17.582] - queued futures: [n=1] TRUE
[09:28:17.582] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.582]  length: 0 (resolved future 1)
[09:28:17.582] Relaying remaining futures
[09:28:17.582] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.582] - nx: 1
[09:28:17.582] - relay: TRUE
[09:28:17.582] - stdout: TRUE
[09:28:17.582] - signal: TRUE
[09:28:17.583] - resignal: FALSE
[09:28:17.583] - force: TRUE
[09:28:17.583] - relayed: [n=1] TRUE
[09:28:17.583] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.583] - relayed: [n=1] TRUE
[09:28:17.583] - queued futures: [n=1] TRUE
[09:28:17.583] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.583] resolve() on list ... DONE
[09:28:17.583]  - Number of value chunks collected: 1
[09:28:17.583] Resolving 1 futures (chunks) ... DONE
[09:28:17.583] Reducing values from 1 chunks ...
[09:28:17.584]  - Number of values collected after concatenation: 6
[09:28:17.584]  - Number of values expected: 6
[09:28:17.584] Reducing values from 1 chunks ... DONE
[09:28:17.584] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[09:28:17.584] getGlobalsAndPackagesXApply() ...
[09:28:17.584]  - future.globals: TRUE
[09:28:17.584] getGlobalsAndPackages() ...
[09:28:17.584] Searching for globals...
[09:28:17.585] - globals found: [1] ‘FUN’
[09:28:17.585] Searching for globals ... DONE
[09:28:17.585] Resolving globals: FALSE
[09:28:17.586] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:17.586] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:17.586] - globals: [1] ‘FUN’
[09:28:17.586] 
[09:28:17.586] getGlobalsAndPackages() ... DONE
[09:28:17.586]  - globals found/used: [n=1] ‘FUN’
[09:28:17.586]  - needed namespaces: [n=0] 
[09:28:17.587] Finding globals ... DONE
[09:28:17.587]  - use_args: TRUE
[09:28:17.587]  - Getting '...' globals ...
[09:28:17.587] resolve() on list ...
[09:28:17.587]  recursive: 0
[09:28:17.587]  length: 1
[09:28:17.587]  elements: ‘...’
[09:28:17.587]  length: 0 (resolved future 1)
[09:28:17.588] resolve() on list ... DONE
[09:28:17.588]    - '...' content: [n=0] 
[09:28:17.589] List of 1
[09:28:17.589]  $ ...: list()
[09:28:17.589]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.589]  - attr(*, "where")=List of 1
[09:28:17.589]   ..$ ...:<environment: 0x559ba4581500> 
[09:28:17.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.589]  - attr(*, "resolved")= logi TRUE
[09:28:17.589]  - attr(*, "total_size")= num NA
[09:28:17.591]  - Getting '...' globals ... DONE
[09:28:17.591] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.591] List of 2
[09:28:17.591]  $ ...future.FUN:function (x)  
[09:28:17.591]  $ ...          : list()
[09:28:17.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.591]  - attr(*, "where")=List of 2
[09:28:17.591]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.591]   ..$ ...          :<environment: 0x559ba4581500> 
[09:28:17.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.591]  - attr(*, "resolved")= logi FALSE
[09:28:17.591]  - attr(*, "total_size")= num 848
[09:28:17.593] Packages to be attached in all futures: [n=0] 
[09:28:17.594] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.594] future_lapply() ...
[09:28:17.594] Number of chunks: 1
[09:28:17.594] getGlobalsAndPackagesXApply() ...
[09:28:17.594]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.595]  - use_args: TRUE
[09:28:17.595] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.595] List of 2
[09:28:17.595]  $ ...          : list()
[09:28:17.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.595]  $ ...future.FUN:function (x)  
[09:28:17.595]  - attr(*, "where")=List of 2
[09:28:17.595]   ..$ ...          :<environment: 0x559ba4581500> 
[09:28:17.595]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.595]  - attr(*, "resolved")= logi FALSE
[09:28:17.595]  - attr(*, "total_size")= num NA
[09:28:17.598] Packages to be attached in all futures: [n=0] 
[09:28:17.598] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.598] Number of futures (= number of chunks): 1
[09:28:17.598] Launching 1 futures (chunks) ...
[09:28:17.598] Chunk #1 of 1 ...
[09:28:17.598]  - seeds: <none>
[09:28:17.598]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.598] getGlobalsAndPackages() ...
[09:28:17.598] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.599] Resolving globals: FALSE
[09:28:17.599] Tweak future expression to call with '...' arguments ...
[09:28:17.599] {
[09:28:17.599]     do.call(function(...) {
[09:28:17.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.599]             on.exit(options(oopts), add = TRUE)
[09:28:17.599]         }
[09:28:17.599]         {
[09:28:17.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.599]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.599]             })
[09:28:17.599]         }
[09:28:17.599]     }, args = future.call.arguments)
[09:28:17.599] }
[09:28:17.599] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.599] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.599] 
[09:28:17.599] getGlobalsAndPackages() ... DONE
[09:28:17.600] run() for ‘Future’ ...
[09:28:17.600] - state: ‘created’
[09:28:17.600] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.600] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.600]   - Field: ‘label’
[09:28:17.600]   - Field: ‘local’
[09:28:17.601]   - Field: ‘owner’
[09:28:17.601]   - Field: ‘envir’
[09:28:17.601]   - Field: ‘packages’
[09:28:17.601]   - Field: ‘gc’
[09:28:17.601]   - Field: ‘conditions’
[09:28:17.601]   - Field: ‘expr’
[09:28:17.601]   - Field: ‘uuid’
[09:28:17.601]   - Field: ‘seed’
[09:28:17.601]   - Field: ‘version’
[09:28:17.601]   - Field: ‘result’
[09:28:17.601]   - Field: ‘asynchronous’
[09:28:17.601]   - Field: ‘calls’
[09:28:17.602]   - Field: ‘globals’
[09:28:17.602]   - Field: ‘stdout’
[09:28:17.602]   - Field: ‘earlySignal’
[09:28:17.602]   - Field: ‘lazy’
[09:28:17.602]   - Field: ‘state’
[09:28:17.602] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.602] - Launch lazy future ...
[09:28:17.602] Packages needed by the future expression (n = 0): <none>
[09:28:17.602] Packages needed by future strategies (n = 0): <none>
[09:28:17.603] {
[09:28:17.603]     {
[09:28:17.603]         {
[09:28:17.603]             ...future.startTime <- base::Sys.time()
[09:28:17.603]             {
[09:28:17.603]                 {
[09:28:17.603]                   {
[09:28:17.603]                     base::local({
[09:28:17.603]                       has_future <- base::requireNamespace("future", 
[09:28:17.603]                         quietly = TRUE)
[09:28:17.603]                       if (has_future) {
[09:28:17.603]                         ns <- base::getNamespace("future")
[09:28:17.603]                         version <- ns[[".package"]][["version"]]
[09:28:17.603]                         if (is.null(version)) 
[09:28:17.603]                           version <- utils::packageVersion("future")
[09:28:17.603]                       }
[09:28:17.603]                       else {
[09:28:17.603]                         version <- NULL
[09:28:17.603]                       }
[09:28:17.603]                       if (!has_future || version < "1.8.0") {
[09:28:17.603]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.603]                           "", base::R.version$version.string), 
[09:28:17.603]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.603]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.603]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.603]                             "release", "version")], collapse = " "), 
[09:28:17.603]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.603]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.603]                           info)
[09:28:17.603]                         info <- base::paste(info, collapse = "; ")
[09:28:17.603]                         if (!has_future) {
[09:28:17.603]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.603]                             info)
[09:28:17.603]                         }
[09:28:17.603]                         else {
[09:28:17.603]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.603]                             info, version)
[09:28:17.603]                         }
[09:28:17.603]                         base::stop(msg)
[09:28:17.603]                       }
[09:28:17.603]                     })
[09:28:17.603]                   }
[09:28:17.603]                   ...future.strategy.old <- future::plan("list")
[09:28:17.603]                   options(future.plan = NULL)
[09:28:17.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.603]                 }
[09:28:17.603]                 ...future.workdir <- getwd()
[09:28:17.603]             }
[09:28:17.603]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.603]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.603]         }
[09:28:17.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.603]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.603]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.603]             base::names(...future.oldOptions))
[09:28:17.603]     }
[09:28:17.603]     if (FALSE) {
[09:28:17.603]     }
[09:28:17.603]     else {
[09:28:17.603]         if (TRUE) {
[09:28:17.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.603]                 open = "w")
[09:28:17.603]         }
[09:28:17.603]         else {
[09:28:17.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.603]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.603]         }
[09:28:17.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.603]             base::sink(type = "output", split = FALSE)
[09:28:17.603]             base::close(...future.stdout)
[09:28:17.603]         }, add = TRUE)
[09:28:17.603]     }
[09:28:17.603]     ...future.frame <- base::sys.nframe()
[09:28:17.603]     ...future.conditions <- base::list()
[09:28:17.603]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.603]     if (FALSE) {
[09:28:17.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.603]     }
[09:28:17.603]     ...future.result <- base::tryCatch({
[09:28:17.603]         base::withCallingHandlers({
[09:28:17.603]             ...future.value <- base::withVisible(base::local({
[09:28:17.603]                 do.call(function(...) {
[09:28:17.603]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.603]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.603]                     ...future.globals.maxSize)) {
[09:28:17.603]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.603]                     on.exit(options(oopts), add = TRUE)
[09:28:17.603]                   }
[09:28:17.603]                   {
[09:28:17.603]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.603]                       FUN = function(jj) {
[09:28:17.603]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.603]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.603]                       })
[09:28:17.603]                   }
[09:28:17.603]                 }, args = future.call.arguments)
[09:28:17.603]             }))
[09:28:17.603]             future::FutureResult(value = ...future.value$value, 
[09:28:17.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.603]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.603]                     ...future.globalenv.names))
[09:28:17.603]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.603]         }, condition = base::local({
[09:28:17.603]             c <- base::c
[09:28:17.603]             inherits <- base::inherits
[09:28:17.603]             invokeRestart <- base::invokeRestart
[09:28:17.603]             length <- base::length
[09:28:17.603]             list <- base::list
[09:28:17.603]             seq.int <- base::seq.int
[09:28:17.603]             signalCondition <- base::signalCondition
[09:28:17.603]             sys.calls <- base::sys.calls
[09:28:17.603]             `[[` <- base::`[[`
[09:28:17.603]             `+` <- base::`+`
[09:28:17.603]             `<<-` <- base::`<<-`
[09:28:17.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.603]                   3L)]
[09:28:17.603]             }
[09:28:17.603]             function(cond) {
[09:28:17.603]                 is_error <- inherits(cond, "error")
[09:28:17.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.603]                   NULL)
[09:28:17.603]                 if (is_error) {
[09:28:17.603]                   sessionInformation <- function() {
[09:28:17.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.603]                       search = base::search(), system = base::Sys.info())
[09:28:17.603]                   }
[09:28:17.603]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.603]                     cond$call), session = sessionInformation(), 
[09:28:17.603]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.603]                   signalCondition(cond)
[09:28:17.603]                 }
[09:28:17.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.603]                 "immediateCondition"))) {
[09:28:17.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.603]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.603]                   if (TRUE && !signal) {
[09:28:17.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.603]                     {
[09:28:17.603]                       inherits <- base::inherits
[09:28:17.603]                       invokeRestart <- base::invokeRestart
[09:28:17.603]                       is.null <- base::is.null
[09:28:17.603]                       muffled <- FALSE
[09:28:17.603]                       if (inherits(cond, "message")) {
[09:28:17.603]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.603]                         if (muffled) 
[09:28:17.603]                           invokeRestart("muffleMessage")
[09:28:17.603]                       }
[09:28:17.603]                       else if (inherits(cond, "warning")) {
[09:28:17.603]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.603]                         if (muffled) 
[09:28:17.603]                           invokeRestart("muffleWarning")
[09:28:17.603]                       }
[09:28:17.603]                       else if (inherits(cond, "condition")) {
[09:28:17.603]                         if (!is.null(pattern)) {
[09:28:17.603]                           computeRestarts <- base::computeRestarts
[09:28:17.603]                           grepl <- base::grepl
[09:28:17.603]                           restarts <- computeRestarts(cond)
[09:28:17.603]                           for (restart in restarts) {
[09:28:17.603]                             name <- restart$name
[09:28:17.603]                             if (is.null(name)) 
[09:28:17.603]                               next
[09:28:17.603]                             if (!grepl(pattern, name)) 
[09:28:17.603]                               next
[09:28:17.603]                             invokeRestart(restart)
[09:28:17.603]                             muffled <- TRUE
[09:28:17.603]                             break
[09:28:17.603]                           }
[09:28:17.603]                         }
[09:28:17.603]                       }
[09:28:17.603]                       invisible(muffled)
[09:28:17.603]                     }
[09:28:17.603]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.603]                   }
[09:28:17.603]                 }
[09:28:17.603]                 else {
[09:28:17.603]                   if (TRUE) {
[09:28:17.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.603]                     {
[09:28:17.603]                       inherits <- base::inherits
[09:28:17.603]                       invokeRestart <- base::invokeRestart
[09:28:17.603]                       is.null <- base::is.null
[09:28:17.603]                       muffled <- FALSE
[09:28:17.603]                       if (inherits(cond, "message")) {
[09:28:17.603]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.603]                         if (muffled) 
[09:28:17.603]                           invokeRestart("muffleMessage")
[09:28:17.603]                       }
[09:28:17.603]                       else if (inherits(cond, "warning")) {
[09:28:17.603]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.603]                         if (muffled) 
[09:28:17.603]                           invokeRestart("muffleWarning")
[09:28:17.603]                       }
[09:28:17.603]                       else if (inherits(cond, "condition")) {
[09:28:17.603]                         if (!is.null(pattern)) {
[09:28:17.603]                           computeRestarts <- base::computeRestarts
[09:28:17.603]                           grepl <- base::grepl
[09:28:17.603]                           restarts <- computeRestarts(cond)
[09:28:17.603]                           for (restart in restarts) {
[09:28:17.603]                             name <- restart$name
[09:28:17.603]                             if (is.null(name)) 
[09:28:17.603]                               next
[09:28:17.603]                             if (!grepl(pattern, name)) 
[09:28:17.603]                               next
[09:28:17.603]                             invokeRestart(restart)
[09:28:17.603]                             muffled <- TRUE
[09:28:17.603]                             break
[09:28:17.603]                           }
[09:28:17.603]                         }
[09:28:17.603]                       }
[09:28:17.603]                       invisible(muffled)
[09:28:17.603]                     }
[09:28:17.603]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.603]                   }
[09:28:17.603]                 }
[09:28:17.603]             }
[09:28:17.603]         }))
[09:28:17.603]     }, error = function(ex) {
[09:28:17.603]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.603]                 ...future.rng), started = ...future.startTime, 
[09:28:17.603]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.603]             version = "1.8"), class = "FutureResult")
[09:28:17.603]     }, finally = {
[09:28:17.603]         if (!identical(...future.workdir, getwd())) 
[09:28:17.603]             setwd(...future.workdir)
[09:28:17.603]         {
[09:28:17.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.603]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.603]             }
[09:28:17.603]             base::options(...future.oldOptions)
[09:28:17.603]             if (.Platform$OS.type == "windows") {
[09:28:17.603]                 old_names <- names(...future.oldEnvVars)
[09:28:17.603]                 envs <- base::Sys.getenv()
[09:28:17.603]                 names <- names(envs)
[09:28:17.603]                 common <- intersect(names, old_names)
[09:28:17.603]                 added <- setdiff(names, old_names)
[09:28:17.603]                 removed <- setdiff(old_names, names)
[09:28:17.603]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.603]                   envs[common]]
[09:28:17.603]                 NAMES <- toupper(changed)
[09:28:17.603]                 args <- list()
[09:28:17.603]                 for (kk in seq_along(NAMES)) {
[09:28:17.603]                   name <- changed[[kk]]
[09:28:17.603]                   NAME <- NAMES[[kk]]
[09:28:17.603]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.603]                     next
[09:28:17.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.603]                 }
[09:28:17.603]                 NAMES <- toupper(added)
[09:28:17.603]                 for (kk in seq_along(NAMES)) {
[09:28:17.603]                   name <- added[[kk]]
[09:28:17.603]                   NAME <- NAMES[[kk]]
[09:28:17.603]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.603]                     next
[09:28:17.603]                   args[[name]] <- ""
[09:28:17.603]                 }
[09:28:17.603]                 NAMES <- toupper(removed)
[09:28:17.603]                 for (kk in seq_along(NAMES)) {
[09:28:17.603]                   name <- removed[[kk]]
[09:28:17.603]                   NAME <- NAMES[[kk]]
[09:28:17.603]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.603]                     next
[09:28:17.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.603]                 }
[09:28:17.603]                 if (length(args) > 0) 
[09:28:17.603]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.603]             }
[09:28:17.603]             else {
[09:28:17.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.603]             }
[09:28:17.603]             {
[09:28:17.603]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.603]                   0L) {
[09:28:17.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.603]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.603]                   base::options(opts)
[09:28:17.603]                 }
[09:28:17.603]                 {
[09:28:17.603]                   {
[09:28:17.603]                     NULL
[09:28:17.603]                     RNGkind("Mersenne-Twister")
[09:28:17.603]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.603]                       inherits = FALSE)
[09:28:17.603]                   }
[09:28:17.603]                   options(future.plan = NULL)
[09:28:17.603]                   if (is.na(NA_character_)) 
[09:28:17.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.603]                     .init = FALSE)
[09:28:17.603]                 }
[09:28:17.603]             }
[09:28:17.603]         }
[09:28:17.603]     })
[09:28:17.603]     if (TRUE) {
[09:28:17.603]         base::sink(type = "output", split = FALSE)
[09:28:17.603]         if (TRUE) {
[09:28:17.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.603]         }
[09:28:17.603]         else {
[09:28:17.603]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.603]         }
[09:28:17.603]         base::close(...future.stdout)
[09:28:17.603]         ...future.stdout <- NULL
[09:28:17.603]     }
[09:28:17.603]     ...future.result$conditions <- ...future.conditions
[09:28:17.603]     ...future.result$finished <- base::Sys.time()
[09:28:17.603]     ...future.result
[09:28:17.603] }
[09:28:17.604] assign_globals() ...
[09:28:17.604] List of 5
[09:28:17.604]  $ future.call.arguments    : list()
[09:28:17.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.604]  $ ...future.FUN            :function (x)  
[09:28:17.604]  $ ...future.elements_ii    :List of 2
[09:28:17.604]   ..$ : int 1
[09:28:17.604]   ..$ : int 2
[09:28:17.604]  $ ...future.seeds_ii       : NULL
[09:28:17.604]  $ ...future.globals.maxSize: num Inf
[09:28:17.604]  - attr(*, "resolved")= logi FALSE
[09:28:17.604]  - attr(*, "total_size")= num NA
[09:28:17.604]  - attr(*, "where")=List of 5
[09:28:17.604]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.604]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.604]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.604]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.604]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.604]  - attr(*, "already-done")= logi TRUE
[09:28:17.631] - copied ‘future.call.arguments’ to environment
[09:28:17.631] - copied ‘...future.FUN’ to environment
[09:28:17.632] - copied ‘...future.elements_ii’ to environment
[09:28:17.632] - copied ‘...future.seeds_ii’ to environment
[09:28:17.632] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.632] assign_globals() ... done
[09:28:17.632] plan(): Setting new future strategy stack:
[09:28:17.632] List of future strategies:
[09:28:17.632] 1. sequential:
[09:28:17.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.632]    - tweaked: FALSE
[09:28:17.632]    - call: NULL
[09:28:17.633] plan(): nbrOfWorkers() = 1
[09:28:17.634] plan(): Setting new future strategy stack:
[09:28:17.634] List of future strategies:
[09:28:17.634] 1. sequential:
[09:28:17.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.634]    - tweaked: FALSE
[09:28:17.634]    - call: plan(strategy)
[09:28:17.634] plan(): nbrOfWorkers() = 1
[09:28:17.634] SequentialFuture started (and completed)
[09:28:17.634] - Launch lazy future ... done
[09:28:17.634] run() for ‘SequentialFuture’ ... done
[09:28:17.635] Created future:
[09:28:17.635] SequentialFuture:
[09:28:17.635] Label: ‘future_apply-1’
[09:28:17.635] Expression:
[09:28:17.635] {
[09:28:17.635]     do.call(function(...) {
[09:28:17.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.635]             on.exit(options(oopts), add = TRUE)
[09:28:17.635]         }
[09:28:17.635]         {
[09:28:17.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.635]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.635]             })
[09:28:17.635]         }
[09:28:17.635]     }, args = future.call.arguments)
[09:28:17.635] }
[09:28:17.635] Lazy evaluation: FALSE
[09:28:17.635] Asynchronous evaluation: FALSE
[09:28:17.635] Local evaluation: TRUE
[09:28:17.635] Environment: R_GlobalEnv
[09:28:17.635] Capture standard output: TRUE
[09:28:17.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.635] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.635] Packages: <none>
[09:28:17.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.635] Resolved: TRUE
[09:28:17.635] Value: 112 bytes of class ‘list’
[09:28:17.635] Early signaling: FALSE
[09:28:17.635] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.635] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.636] Chunk #1 of 1 ... DONE
[09:28:17.636] Launching 1 futures (chunks) ... DONE
[09:28:17.636] Resolving 1 futures (chunks) ...
[09:28:17.636] resolve() on list ...
[09:28:17.636]  recursive: 0
[09:28:17.636]  length: 1
[09:28:17.636] 
[09:28:17.636] resolved() for ‘SequentialFuture’ ...
[09:28:17.636] - state: ‘finished’
[09:28:17.636] - run: TRUE
[09:28:17.636] - result: ‘FutureResult’
[09:28:17.637] resolved() for ‘SequentialFuture’ ... done
[09:28:17.637] Future #1
[09:28:17.637] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.637] - nx: 1
[09:28:17.637] - relay: TRUE
[09:28:17.637] - stdout: TRUE
[09:28:17.637] - signal: TRUE
[09:28:17.637] - resignal: FALSE
[09:28:17.637] - force: TRUE
[09:28:17.637] - relayed: [n=1] FALSE
[09:28:17.637] - queued futures: [n=1] FALSE
[09:28:17.638]  - until=1
[09:28:17.638]  - relaying element #1
[09:28:17.638] - relayed: [n=1] TRUE
[09:28:17.638] - queued futures: [n=1] TRUE
[09:28:17.638] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.638]  length: 0 (resolved future 1)
[09:28:17.638] Relaying remaining futures
[09:28:17.638] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.638] - nx: 1
[09:28:17.638] - relay: TRUE
[09:28:17.638] - stdout: TRUE
[09:28:17.639] - signal: TRUE
[09:28:17.639] - resignal: FALSE
[09:28:17.639] - force: TRUE
[09:28:17.639] - relayed: [n=1] TRUE
[09:28:17.639] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.639] - relayed: [n=1] TRUE
[09:28:17.639] - queued futures: [n=1] TRUE
[09:28:17.639] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.639] resolve() on list ... DONE
[09:28:17.639]  - Number of value chunks collected: 1
[09:28:17.639] Resolving 1 futures (chunks) ... DONE
[09:28:17.640] Reducing values from 1 chunks ...
[09:28:17.640]  - Number of values collected after concatenation: 2
[09:28:17.640]  - Number of values expected: 2
[09:28:17.640] Reducing values from 1 chunks ... DONE
[09:28:17.640] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[09:28:17.640] getGlobalsAndPackagesXApply() ...
[09:28:17.640]  - future.globals: TRUE
[09:28:17.640] getGlobalsAndPackages() ...
[09:28:17.640] Searching for globals...
[09:28:17.641] - globals found: [1] ‘FUN’
[09:28:17.641] Searching for globals ... DONE
[09:28:17.642] Resolving globals: FALSE
[09:28:17.642] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:17.642] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:17.642] - globals: [1] ‘FUN’
[09:28:17.642] 
[09:28:17.642] getGlobalsAndPackages() ... DONE
[09:28:17.642]  - globals found/used: [n=1] ‘FUN’
[09:28:17.643]  - needed namespaces: [n=0] 
[09:28:17.643] Finding globals ... DONE
[09:28:17.643]  - use_args: TRUE
[09:28:17.643]  - Getting '...' globals ...
[09:28:17.643] resolve() on list ...
[09:28:17.643]  recursive: 0
[09:28:17.643]  length: 1
[09:28:17.643]  elements: ‘...’
[09:28:17.644]  length: 0 (resolved future 1)
[09:28:17.644] resolve() on list ... DONE
[09:28:17.644]    - '...' content: [n=0] 
[09:28:17.644] List of 1
[09:28:17.644]  $ ...: list()
[09:28:17.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.644]  - attr(*, "where")=List of 1
[09:28:17.644]   ..$ ...:<environment: 0x559ba2f1b7d8> 
[09:28:17.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.644]  - attr(*, "resolved")= logi TRUE
[09:28:17.644]  - attr(*, "total_size")= num NA
[09:28:17.646]  - Getting '...' globals ... DONE
[09:28:17.646] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.647] List of 2
[09:28:17.647]  $ ...future.FUN:function (x)  
[09:28:17.647]  $ ...          : list()
[09:28:17.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.647]  - attr(*, "where")=List of 2
[09:28:17.647]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.647]   ..$ ...          :<environment: 0x559ba2f1b7d8> 
[09:28:17.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.647]  - attr(*, "resolved")= logi FALSE
[09:28:17.647]  - attr(*, "total_size")= num 848
[09:28:17.649] Packages to be attached in all futures: [n=0] 
[09:28:17.649] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.649] future_lapply() ...
[09:28:17.650] Number of chunks: 1
[09:28:17.650] getGlobalsAndPackagesXApply() ...
[09:28:17.650]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.650]  - use_args: TRUE
[09:28:17.650] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.650] List of 2
[09:28:17.650]  $ ...          : list()
[09:28:17.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.650]  $ ...future.FUN:function (x)  
[09:28:17.650]  - attr(*, "where")=List of 2
[09:28:17.650]   ..$ ...          :<environment: 0x559ba2f1b7d8> 
[09:28:17.650]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.650]  - attr(*, "resolved")= logi FALSE
[09:28:17.650]  - attr(*, "total_size")= num NA
[09:28:17.653] Packages to be attached in all futures: [n=0] 
[09:28:17.653] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.653] Number of futures (= number of chunks): 1
[09:28:17.654] Launching 1 futures (chunks) ...
[09:28:17.654] Chunk #1 of 1 ...
[09:28:17.654]  - seeds: <none>
[09:28:17.654]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.654] getGlobalsAndPackages() ...
[09:28:17.654] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.654] Resolving globals: FALSE
[09:28:17.654] Tweak future expression to call with '...' arguments ...
[09:28:17.654] {
[09:28:17.654]     do.call(function(...) {
[09:28:17.654]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.654]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.654]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.654]             on.exit(options(oopts), add = TRUE)
[09:28:17.654]         }
[09:28:17.654]         {
[09:28:17.654]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.654]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.654]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.654]             })
[09:28:17.654]         }
[09:28:17.654]     }, args = future.call.arguments)
[09:28:17.654] }
[09:28:17.655] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.656] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.656] 
[09:28:17.656] getGlobalsAndPackages() ... DONE
[09:28:17.656] run() for ‘Future’ ...
[09:28:17.656] - state: ‘created’
[09:28:17.656] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.657] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.657]   - Field: ‘label’
[09:28:17.657]   - Field: ‘local’
[09:28:17.657]   - Field: ‘owner’
[09:28:17.657]   - Field: ‘envir’
[09:28:17.657]   - Field: ‘packages’
[09:28:17.657]   - Field: ‘gc’
[09:28:17.657]   - Field: ‘conditions’
[09:28:17.658]   - Field: ‘expr’
[09:28:17.658]   - Field: ‘uuid’
[09:28:17.658]   - Field: ‘seed’
[09:28:17.658]   - Field: ‘version’
[09:28:17.658]   - Field: ‘result’
[09:28:17.658]   - Field: ‘asynchronous’
[09:28:17.658]   - Field: ‘calls’
[09:28:17.658]   - Field: ‘globals’
[09:28:17.658]   - Field: ‘stdout’
[09:28:17.658]   - Field: ‘earlySignal’
[09:28:17.658]   - Field: ‘lazy’
[09:28:17.658]   - Field: ‘state’
[09:28:17.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.659] - Launch lazy future ...
[09:28:17.659] Packages needed by the future expression (n = 0): <none>
[09:28:17.659] Packages needed by future strategies (n = 0): <none>
[09:28:17.659] {
[09:28:17.659]     {
[09:28:17.659]         {
[09:28:17.659]             ...future.startTime <- base::Sys.time()
[09:28:17.659]             {
[09:28:17.659]                 {
[09:28:17.659]                   {
[09:28:17.659]                     base::local({
[09:28:17.659]                       has_future <- base::requireNamespace("future", 
[09:28:17.659]                         quietly = TRUE)
[09:28:17.659]                       if (has_future) {
[09:28:17.659]                         ns <- base::getNamespace("future")
[09:28:17.659]                         version <- ns[[".package"]][["version"]]
[09:28:17.659]                         if (is.null(version)) 
[09:28:17.659]                           version <- utils::packageVersion("future")
[09:28:17.659]                       }
[09:28:17.659]                       else {
[09:28:17.659]                         version <- NULL
[09:28:17.659]                       }
[09:28:17.659]                       if (!has_future || version < "1.8.0") {
[09:28:17.659]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.659]                           "", base::R.version$version.string), 
[09:28:17.659]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.659]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.659]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.659]                             "release", "version")], collapse = " "), 
[09:28:17.659]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.659]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.659]                           info)
[09:28:17.659]                         info <- base::paste(info, collapse = "; ")
[09:28:17.659]                         if (!has_future) {
[09:28:17.659]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.659]                             info)
[09:28:17.659]                         }
[09:28:17.659]                         else {
[09:28:17.659]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.659]                             info, version)
[09:28:17.659]                         }
[09:28:17.659]                         base::stop(msg)
[09:28:17.659]                       }
[09:28:17.659]                     })
[09:28:17.659]                   }
[09:28:17.659]                   ...future.strategy.old <- future::plan("list")
[09:28:17.659]                   options(future.plan = NULL)
[09:28:17.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.659]                 }
[09:28:17.659]                 ...future.workdir <- getwd()
[09:28:17.659]             }
[09:28:17.659]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.659]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.659]         }
[09:28:17.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.659]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.659]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.659]             base::names(...future.oldOptions))
[09:28:17.659]     }
[09:28:17.659]     if (FALSE) {
[09:28:17.659]     }
[09:28:17.659]     else {
[09:28:17.659]         if (TRUE) {
[09:28:17.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.659]                 open = "w")
[09:28:17.659]         }
[09:28:17.659]         else {
[09:28:17.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.659]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.659]         }
[09:28:17.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.659]             base::sink(type = "output", split = FALSE)
[09:28:17.659]             base::close(...future.stdout)
[09:28:17.659]         }, add = TRUE)
[09:28:17.659]     }
[09:28:17.659]     ...future.frame <- base::sys.nframe()
[09:28:17.659]     ...future.conditions <- base::list()
[09:28:17.659]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.659]     if (FALSE) {
[09:28:17.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.659]     }
[09:28:17.659]     ...future.result <- base::tryCatch({
[09:28:17.659]         base::withCallingHandlers({
[09:28:17.659]             ...future.value <- base::withVisible(base::local({
[09:28:17.659]                 do.call(function(...) {
[09:28:17.659]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.659]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.659]                     ...future.globals.maxSize)) {
[09:28:17.659]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.659]                     on.exit(options(oopts), add = TRUE)
[09:28:17.659]                   }
[09:28:17.659]                   {
[09:28:17.659]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.659]                       FUN = function(jj) {
[09:28:17.659]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.659]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.659]                       })
[09:28:17.659]                   }
[09:28:17.659]                 }, args = future.call.arguments)
[09:28:17.659]             }))
[09:28:17.659]             future::FutureResult(value = ...future.value$value, 
[09:28:17.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.659]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.659]                     ...future.globalenv.names))
[09:28:17.659]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.659]         }, condition = base::local({
[09:28:17.659]             c <- base::c
[09:28:17.659]             inherits <- base::inherits
[09:28:17.659]             invokeRestart <- base::invokeRestart
[09:28:17.659]             length <- base::length
[09:28:17.659]             list <- base::list
[09:28:17.659]             seq.int <- base::seq.int
[09:28:17.659]             signalCondition <- base::signalCondition
[09:28:17.659]             sys.calls <- base::sys.calls
[09:28:17.659]             `[[` <- base::`[[`
[09:28:17.659]             `+` <- base::`+`
[09:28:17.659]             `<<-` <- base::`<<-`
[09:28:17.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.659]                   3L)]
[09:28:17.659]             }
[09:28:17.659]             function(cond) {
[09:28:17.659]                 is_error <- inherits(cond, "error")
[09:28:17.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.659]                   NULL)
[09:28:17.659]                 if (is_error) {
[09:28:17.659]                   sessionInformation <- function() {
[09:28:17.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.659]                       search = base::search(), system = base::Sys.info())
[09:28:17.659]                   }
[09:28:17.659]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.659]                     cond$call), session = sessionInformation(), 
[09:28:17.659]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.659]                   signalCondition(cond)
[09:28:17.659]                 }
[09:28:17.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.659]                 "immediateCondition"))) {
[09:28:17.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.659]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.659]                   if (TRUE && !signal) {
[09:28:17.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.659]                     {
[09:28:17.659]                       inherits <- base::inherits
[09:28:17.659]                       invokeRestart <- base::invokeRestart
[09:28:17.659]                       is.null <- base::is.null
[09:28:17.659]                       muffled <- FALSE
[09:28:17.659]                       if (inherits(cond, "message")) {
[09:28:17.659]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.659]                         if (muffled) 
[09:28:17.659]                           invokeRestart("muffleMessage")
[09:28:17.659]                       }
[09:28:17.659]                       else if (inherits(cond, "warning")) {
[09:28:17.659]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.659]                         if (muffled) 
[09:28:17.659]                           invokeRestart("muffleWarning")
[09:28:17.659]                       }
[09:28:17.659]                       else if (inherits(cond, "condition")) {
[09:28:17.659]                         if (!is.null(pattern)) {
[09:28:17.659]                           computeRestarts <- base::computeRestarts
[09:28:17.659]                           grepl <- base::grepl
[09:28:17.659]                           restarts <- computeRestarts(cond)
[09:28:17.659]                           for (restart in restarts) {
[09:28:17.659]                             name <- restart$name
[09:28:17.659]                             if (is.null(name)) 
[09:28:17.659]                               next
[09:28:17.659]                             if (!grepl(pattern, name)) 
[09:28:17.659]                               next
[09:28:17.659]                             invokeRestart(restart)
[09:28:17.659]                             muffled <- TRUE
[09:28:17.659]                             break
[09:28:17.659]                           }
[09:28:17.659]                         }
[09:28:17.659]                       }
[09:28:17.659]                       invisible(muffled)
[09:28:17.659]                     }
[09:28:17.659]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.659]                   }
[09:28:17.659]                 }
[09:28:17.659]                 else {
[09:28:17.659]                   if (TRUE) {
[09:28:17.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.659]                     {
[09:28:17.659]                       inherits <- base::inherits
[09:28:17.659]                       invokeRestart <- base::invokeRestart
[09:28:17.659]                       is.null <- base::is.null
[09:28:17.659]                       muffled <- FALSE
[09:28:17.659]                       if (inherits(cond, "message")) {
[09:28:17.659]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.659]                         if (muffled) 
[09:28:17.659]                           invokeRestart("muffleMessage")
[09:28:17.659]                       }
[09:28:17.659]                       else if (inherits(cond, "warning")) {
[09:28:17.659]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.659]                         if (muffled) 
[09:28:17.659]                           invokeRestart("muffleWarning")
[09:28:17.659]                       }
[09:28:17.659]                       else if (inherits(cond, "condition")) {
[09:28:17.659]                         if (!is.null(pattern)) {
[09:28:17.659]                           computeRestarts <- base::computeRestarts
[09:28:17.659]                           grepl <- base::grepl
[09:28:17.659]                           restarts <- computeRestarts(cond)
[09:28:17.659]                           for (restart in restarts) {
[09:28:17.659]                             name <- restart$name
[09:28:17.659]                             if (is.null(name)) 
[09:28:17.659]                               next
[09:28:17.659]                             if (!grepl(pattern, name)) 
[09:28:17.659]                               next
[09:28:17.659]                             invokeRestart(restart)
[09:28:17.659]                             muffled <- TRUE
[09:28:17.659]                             break
[09:28:17.659]                           }
[09:28:17.659]                         }
[09:28:17.659]                       }
[09:28:17.659]                       invisible(muffled)
[09:28:17.659]                     }
[09:28:17.659]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.659]                   }
[09:28:17.659]                 }
[09:28:17.659]             }
[09:28:17.659]         }))
[09:28:17.659]     }, error = function(ex) {
[09:28:17.659]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.659]                 ...future.rng), started = ...future.startTime, 
[09:28:17.659]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.659]             version = "1.8"), class = "FutureResult")
[09:28:17.659]     }, finally = {
[09:28:17.659]         if (!identical(...future.workdir, getwd())) 
[09:28:17.659]             setwd(...future.workdir)
[09:28:17.659]         {
[09:28:17.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.659]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.659]             }
[09:28:17.659]             base::options(...future.oldOptions)
[09:28:17.659]             if (.Platform$OS.type == "windows") {
[09:28:17.659]                 old_names <- names(...future.oldEnvVars)
[09:28:17.659]                 envs <- base::Sys.getenv()
[09:28:17.659]                 names <- names(envs)
[09:28:17.659]                 common <- intersect(names, old_names)
[09:28:17.659]                 added <- setdiff(names, old_names)
[09:28:17.659]                 removed <- setdiff(old_names, names)
[09:28:17.659]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.659]                   envs[common]]
[09:28:17.659]                 NAMES <- toupper(changed)
[09:28:17.659]                 args <- list()
[09:28:17.659]                 for (kk in seq_along(NAMES)) {
[09:28:17.659]                   name <- changed[[kk]]
[09:28:17.659]                   NAME <- NAMES[[kk]]
[09:28:17.659]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.659]                     next
[09:28:17.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.659]                 }
[09:28:17.659]                 NAMES <- toupper(added)
[09:28:17.659]                 for (kk in seq_along(NAMES)) {
[09:28:17.659]                   name <- added[[kk]]
[09:28:17.659]                   NAME <- NAMES[[kk]]
[09:28:17.659]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.659]                     next
[09:28:17.659]                   args[[name]] <- ""
[09:28:17.659]                 }
[09:28:17.659]                 NAMES <- toupper(removed)
[09:28:17.659]                 for (kk in seq_along(NAMES)) {
[09:28:17.659]                   name <- removed[[kk]]
[09:28:17.659]                   NAME <- NAMES[[kk]]
[09:28:17.659]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.659]                     next
[09:28:17.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.659]                 }
[09:28:17.659]                 if (length(args) > 0) 
[09:28:17.659]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.659]             }
[09:28:17.659]             else {
[09:28:17.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.659]             }
[09:28:17.659]             {
[09:28:17.659]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.659]                   0L) {
[09:28:17.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.659]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.659]                   base::options(opts)
[09:28:17.659]                 }
[09:28:17.659]                 {
[09:28:17.659]                   {
[09:28:17.659]                     NULL
[09:28:17.659]                     RNGkind("Mersenne-Twister")
[09:28:17.659]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.659]                       inherits = FALSE)
[09:28:17.659]                   }
[09:28:17.659]                   options(future.plan = NULL)
[09:28:17.659]                   if (is.na(NA_character_)) 
[09:28:17.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.659]                     .init = FALSE)
[09:28:17.659]                 }
[09:28:17.659]             }
[09:28:17.659]         }
[09:28:17.659]     })
[09:28:17.659]     if (TRUE) {
[09:28:17.659]         base::sink(type = "output", split = FALSE)
[09:28:17.659]         if (TRUE) {
[09:28:17.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.659]         }
[09:28:17.659]         else {
[09:28:17.659]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.659]         }
[09:28:17.659]         base::close(...future.stdout)
[09:28:17.659]         ...future.stdout <- NULL
[09:28:17.659]     }
[09:28:17.659]     ...future.result$conditions <- ...future.conditions
[09:28:17.659]     ...future.result$finished <- base::Sys.time()
[09:28:17.659]     ...future.result
[09:28:17.659] }
[09:28:17.661] assign_globals() ...
[09:28:17.661] List of 5
[09:28:17.661]  $ future.call.arguments    : list()
[09:28:17.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.661]  $ ...future.FUN            :function (x)  
[09:28:17.661]  $ ...future.elements_ii    :List of 2
[09:28:17.661]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[09:28:17.661]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[09:28:17.661]  $ ...future.seeds_ii       : NULL
[09:28:17.661]  $ ...future.globals.maxSize: num Inf
[09:28:17.661]  - attr(*, "resolved")= logi FALSE
[09:28:17.661]  - attr(*, "total_size")= num NA
[09:28:17.661]  - attr(*, "where")=List of 5
[09:28:17.661]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.661]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.661]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.661]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.661]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.661]  - attr(*, "already-done")= logi TRUE
[09:28:17.666] - copied ‘future.call.arguments’ to environment
[09:28:17.666] - copied ‘...future.FUN’ to environment
[09:28:17.666] - copied ‘...future.elements_ii’ to environment
[09:28:17.666] - copied ‘...future.seeds_ii’ to environment
[09:28:17.666] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.666] assign_globals() ... done
[09:28:17.666] plan(): Setting new future strategy stack:
[09:28:17.667] List of future strategies:
[09:28:17.667] 1. sequential:
[09:28:17.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.667]    - tweaked: FALSE
[09:28:17.667]    - call: NULL
[09:28:17.667] plan(): nbrOfWorkers() = 1
[09:28:17.668] plan(): Setting new future strategy stack:
[09:28:17.668] List of future strategies:
[09:28:17.668] 1. sequential:
[09:28:17.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.668]    - tweaked: FALSE
[09:28:17.668]    - call: plan(strategy)
[09:28:17.668] plan(): nbrOfWorkers() = 1
[09:28:17.668] SequentialFuture started (and completed)
[09:28:17.668] - Launch lazy future ... done
[09:28:17.669] run() for ‘SequentialFuture’ ... done
[09:28:17.669] Created future:
[09:28:17.669] SequentialFuture:
[09:28:17.669] Label: ‘future_apply-1’
[09:28:17.669] Expression:
[09:28:17.669] {
[09:28:17.669]     do.call(function(...) {
[09:28:17.669]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.669]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.669]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.669]             on.exit(options(oopts), add = TRUE)
[09:28:17.669]         }
[09:28:17.669]         {
[09:28:17.669]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.669]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.669]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.669]             })
[09:28:17.669]         }
[09:28:17.669]     }, args = future.call.arguments)
[09:28:17.669] }
[09:28:17.669] Lazy evaluation: FALSE
[09:28:17.669] Asynchronous evaluation: FALSE
[09:28:17.669] Local evaluation: TRUE
[09:28:17.669] Environment: R_GlobalEnv
[09:28:17.669] Capture standard output: TRUE
[09:28:17.669] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.669] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.669] Packages: <none>
[09:28:17.669] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.669] Resolved: TRUE
[09:28:17.669] Value: 496 bytes of class ‘list’
[09:28:17.669] Early signaling: FALSE
[09:28:17.669] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.669] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.670] Chunk #1 of 1 ... DONE
[09:28:17.670] Launching 1 futures (chunks) ... DONE
[09:28:17.670] Resolving 1 futures (chunks) ...
[09:28:17.670] resolve() on list ...
[09:28:17.670]  recursive: 0
[09:28:17.670]  length: 1
[09:28:17.670] 
[09:28:17.670] resolved() for ‘SequentialFuture’ ...
[09:28:17.670] - state: ‘finished’
[09:28:17.670] - run: TRUE
[09:28:17.670] - result: ‘FutureResult’
[09:28:17.671] resolved() for ‘SequentialFuture’ ... done
[09:28:17.671] Future #1
[09:28:17.671] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.671] - nx: 1
[09:28:17.671] - relay: TRUE
[09:28:17.671] - stdout: TRUE
[09:28:17.671] - signal: TRUE
[09:28:17.671] - resignal: FALSE
[09:28:17.671] - force: TRUE
[09:28:17.671] - relayed: [n=1] FALSE
[09:28:17.671] - queued futures: [n=1] FALSE
[09:28:17.671]  - until=1
[09:28:17.672]  - relaying element #1
[09:28:17.672] - relayed: [n=1] TRUE
[09:28:17.672] - queued futures: [n=1] TRUE
[09:28:17.672] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.672]  length: 0 (resolved future 1)
[09:28:17.672] Relaying remaining futures
[09:28:17.672] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.672] - nx: 1
[09:28:17.672] - relay: TRUE
[09:28:17.672] - stdout: TRUE
[09:28:17.672] - signal: TRUE
[09:28:17.673] - resignal: FALSE
[09:28:17.673] - force: TRUE
[09:28:17.673] - relayed: [n=1] TRUE
[09:28:17.673] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.673] - relayed: [n=1] TRUE
[09:28:17.673] - queued futures: [n=1] TRUE
[09:28:17.673] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.673] resolve() on list ... DONE
[09:28:17.673]  - Number of value chunks collected: 1
[09:28:17.673] Resolving 1 futures (chunks) ... DONE
[09:28:17.673] Reducing values from 1 chunks ...
[09:28:17.674]  - Number of values collected after concatenation: 2
[09:28:17.674]  - Number of values expected: 2
[09:28:17.674] Reducing values from 1 chunks ... DONE
[09:28:17.674] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[09:28:17.674] getGlobalsAndPackagesXApply() ...
[09:28:17.674]  - future.globals: TRUE
[09:28:17.674] getGlobalsAndPackages() ...
[09:28:17.674] Searching for globals...
[09:28:17.677] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[09:28:17.677] Searching for globals ... DONE
[09:28:17.677] Resolving globals: FALSE
[09:28:17.677] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[09:28:17.678] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[09:28:17.678] - globals: [1] ‘FUN’
[09:28:17.678] 
[09:28:17.678] getGlobalsAndPackages() ... DONE
[09:28:17.678]  - globals found/used: [n=1] ‘FUN’
[09:28:17.678]  - needed namespaces: [n=0] 
[09:28:17.678] Finding globals ... DONE
[09:28:17.678]  - use_args: TRUE
[09:28:17.678]  - Getting '...' globals ...
[09:28:17.679] resolve() on list ...
[09:28:17.679]  recursive: 0
[09:28:17.680]  length: 1
[09:28:17.680]  elements: ‘...’
[09:28:17.680]  length: 0 (resolved future 1)
[09:28:17.680] resolve() on list ... DONE
[09:28:17.680]    - '...' content: [n=0] 
[09:28:17.680] List of 1
[09:28:17.680]  $ ...: list()
[09:28:17.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.680]  - attr(*, "where")=List of 1
[09:28:17.680]   ..$ ...:<environment: 0x559ba44da2d8> 
[09:28:17.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.680]  - attr(*, "resolved")= logi TRUE
[09:28:17.680]  - attr(*, "total_size")= num NA
[09:28:17.682]  - Getting '...' globals ... DONE
[09:28:17.683] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.683] List of 2
[09:28:17.683]  $ ...future.FUN:function (x)  
[09:28:17.683]  $ ...          : list()
[09:28:17.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.683]  - attr(*, "where")=List of 2
[09:28:17.683]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.683]   ..$ ...          :<environment: 0x559ba44da2d8> 
[09:28:17.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.683]  - attr(*, "resolved")= logi FALSE
[09:28:17.683]  - attr(*, "total_size")= num 9888
[09:28:17.685] Packages to be attached in all futures: [n=0] 
[09:28:17.685] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.685] future_lapply() ...
[09:28:17.687] Number of chunks: 1
[09:28:17.687] getGlobalsAndPackagesXApply() ...
[09:28:17.687]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.687]  - use_args: TRUE
[09:28:17.687] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.687] List of 2
[09:28:17.687]  $ ...          : list()
[09:28:17.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.687]  $ ...future.FUN:function (x)  
[09:28:17.687]  - attr(*, "where")=List of 2
[09:28:17.687]   ..$ ...          :<environment: 0x559ba44da2d8> 
[09:28:17.687]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:17.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.687]  - attr(*, "resolved")= logi FALSE
[09:28:17.687]  - attr(*, "total_size")= num NA
[09:28:17.690] Packages to be attached in all futures: [n=0] 
[09:28:17.690] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.690] Number of futures (= number of chunks): 1
[09:28:17.690] Launching 1 futures (chunks) ...
[09:28:17.690] Chunk #1 of 1 ...
[09:28:17.690]  - seeds: <none>
[09:28:17.690]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.690] getGlobalsAndPackages() ...
[09:28:17.690] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.691] Resolving globals: FALSE
[09:28:17.691] Tweak future expression to call with '...' arguments ...
[09:28:17.691] {
[09:28:17.691]     do.call(function(...) {
[09:28:17.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.691]             on.exit(options(oopts), add = TRUE)
[09:28:17.691]         }
[09:28:17.691]         {
[09:28:17.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.691]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.691]             })
[09:28:17.691]         }
[09:28:17.691]     }, args = future.call.arguments)
[09:28:17.691] }
[09:28:17.691] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.691] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.691] 
[09:28:17.691] getGlobalsAndPackages() ... DONE
[09:28:17.692] run() for ‘Future’ ...
[09:28:17.692] - state: ‘created’
[09:28:17.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.692] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.692]   - Field: ‘label’
[09:28:17.692]   - Field: ‘local’
[09:28:17.693]   - Field: ‘owner’
[09:28:17.693]   - Field: ‘envir’
[09:28:17.693]   - Field: ‘packages’
[09:28:17.693]   - Field: ‘gc’
[09:28:17.693]   - Field: ‘conditions’
[09:28:17.693]   - Field: ‘expr’
[09:28:17.693]   - Field: ‘uuid’
[09:28:17.693]   - Field: ‘seed’
[09:28:17.693]   - Field: ‘version’
[09:28:17.693]   - Field: ‘result’
[09:28:17.693]   - Field: ‘asynchronous’
[09:28:17.693]   - Field: ‘calls’
[09:28:17.694]   - Field: ‘globals’
[09:28:17.694]   - Field: ‘stdout’
[09:28:17.694]   - Field: ‘earlySignal’
[09:28:17.694]   - Field: ‘lazy’
[09:28:17.694]   - Field: ‘state’
[09:28:17.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.694] - Launch lazy future ...
[09:28:17.694] Packages needed by the future expression (n = 0): <none>
[09:28:17.694] Packages needed by future strategies (n = 0): <none>
[09:28:17.695] {
[09:28:17.695]     {
[09:28:17.695]         {
[09:28:17.695]             ...future.startTime <- base::Sys.time()
[09:28:17.695]             {
[09:28:17.695]                 {
[09:28:17.695]                   {
[09:28:17.695]                     base::local({
[09:28:17.695]                       has_future <- base::requireNamespace("future", 
[09:28:17.695]                         quietly = TRUE)
[09:28:17.695]                       if (has_future) {
[09:28:17.695]                         ns <- base::getNamespace("future")
[09:28:17.695]                         version <- ns[[".package"]][["version"]]
[09:28:17.695]                         if (is.null(version)) 
[09:28:17.695]                           version <- utils::packageVersion("future")
[09:28:17.695]                       }
[09:28:17.695]                       else {
[09:28:17.695]                         version <- NULL
[09:28:17.695]                       }
[09:28:17.695]                       if (!has_future || version < "1.8.0") {
[09:28:17.695]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.695]                           "", base::R.version$version.string), 
[09:28:17.695]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.695]                             "release", "version")], collapse = " "), 
[09:28:17.695]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.695]                           info)
[09:28:17.695]                         info <- base::paste(info, collapse = "; ")
[09:28:17.695]                         if (!has_future) {
[09:28:17.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.695]                             info)
[09:28:17.695]                         }
[09:28:17.695]                         else {
[09:28:17.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.695]                             info, version)
[09:28:17.695]                         }
[09:28:17.695]                         base::stop(msg)
[09:28:17.695]                       }
[09:28:17.695]                     })
[09:28:17.695]                   }
[09:28:17.695]                   ...future.strategy.old <- future::plan("list")
[09:28:17.695]                   options(future.plan = NULL)
[09:28:17.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.695]                 }
[09:28:17.695]                 ...future.workdir <- getwd()
[09:28:17.695]             }
[09:28:17.695]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.695]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.695]         }
[09:28:17.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.695]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.695]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.695]             base::names(...future.oldOptions))
[09:28:17.695]     }
[09:28:17.695]     if (FALSE) {
[09:28:17.695]     }
[09:28:17.695]     else {
[09:28:17.695]         if (TRUE) {
[09:28:17.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.695]                 open = "w")
[09:28:17.695]         }
[09:28:17.695]         else {
[09:28:17.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.695]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.695]         }
[09:28:17.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.695]             base::sink(type = "output", split = FALSE)
[09:28:17.695]             base::close(...future.stdout)
[09:28:17.695]         }, add = TRUE)
[09:28:17.695]     }
[09:28:17.695]     ...future.frame <- base::sys.nframe()
[09:28:17.695]     ...future.conditions <- base::list()
[09:28:17.695]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.695]     if (FALSE) {
[09:28:17.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.695]     }
[09:28:17.695]     ...future.result <- base::tryCatch({
[09:28:17.695]         base::withCallingHandlers({
[09:28:17.695]             ...future.value <- base::withVisible(base::local({
[09:28:17.695]                 do.call(function(...) {
[09:28:17.695]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.695]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.695]                     ...future.globals.maxSize)) {
[09:28:17.695]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.695]                     on.exit(options(oopts), add = TRUE)
[09:28:17.695]                   }
[09:28:17.695]                   {
[09:28:17.695]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.695]                       FUN = function(jj) {
[09:28:17.695]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.695]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.695]                       })
[09:28:17.695]                   }
[09:28:17.695]                 }, args = future.call.arguments)
[09:28:17.695]             }))
[09:28:17.695]             future::FutureResult(value = ...future.value$value, 
[09:28:17.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.695]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.695]                     ...future.globalenv.names))
[09:28:17.695]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.695]         }, condition = base::local({
[09:28:17.695]             c <- base::c
[09:28:17.695]             inherits <- base::inherits
[09:28:17.695]             invokeRestart <- base::invokeRestart
[09:28:17.695]             length <- base::length
[09:28:17.695]             list <- base::list
[09:28:17.695]             seq.int <- base::seq.int
[09:28:17.695]             signalCondition <- base::signalCondition
[09:28:17.695]             sys.calls <- base::sys.calls
[09:28:17.695]             `[[` <- base::`[[`
[09:28:17.695]             `+` <- base::`+`
[09:28:17.695]             `<<-` <- base::`<<-`
[09:28:17.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.695]                   3L)]
[09:28:17.695]             }
[09:28:17.695]             function(cond) {
[09:28:17.695]                 is_error <- inherits(cond, "error")
[09:28:17.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.695]                   NULL)
[09:28:17.695]                 if (is_error) {
[09:28:17.695]                   sessionInformation <- function() {
[09:28:17.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.695]                       search = base::search(), system = base::Sys.info())
[09:28:17.695]                   }
[09:28:17.695]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.695]                     cond$call), session = sessionInformation(), 
[09:28:17.695]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.695]                   signalCondition(cond)
[09:28:17.695]                 }
[09:28:17.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.695]                 "immediateCondition"))) {
[09:28:17.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.695]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.695]                   if (TRUE && !signal) {
[09:28:17.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.695]                     {
[09:28:17.695]                       inherits <- base::inherits
[09:28:17.695]                       invokeRestart <- base::invokeRestart
[09:28:17.695]                       is.null <- base::is.null
[09:28:17.695]                       muffled <- FALSE
[09:28:17.695]                       if (inherits(cond, "message")) {
[09:28:17.695]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.695]                         if (muffled) 
[09:28:17.695]                           invokeRestart("muffleMessage")
[09:28:17.695]                       }
[09:28:17.695]                       else if (inherits(cond, "warning")) {
[09:28:17.695]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.695]                         if (muffled) 
[09:28:17.695]                           invokeRestart("muffleWarning")
[09:28:17.695]                       }
[09:28:17.695]                       else if (inherits(cond, "condition")) {
[09:28:17.695]                         if (!is.null(pattern)) {
[09:28:17.695]                           computeRestarts <- base::computeRestarts
[09:28:17.695]                           grepl <- base::grepl
[09:28:17.695]                           restarts <- computeRestarts(cond)
[09:28:17.695]                           for (restart in restarts) {
[09:28:17.695]                             name <- restart$name
[09:28:17.695]                             if (is.null(name)) 
[09:28:17.695]                               next
[09:28:17.695]                             if (!grepl(pattern, name)) 
[09:28:17.695]                               next
[09:28:17.695]                             invokeRestart(restart)
[09:28:17.695]                             muffled <- TRUE
[09:28:17.695]                             break
[09:28:17.695]                           }
[09:28:17.695]                         }
[09:28:17.695]                       }
[09:28:17.695]                       invisible(muffled)
[09:28:17.695]                     }
[09:28:17.695]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.695]                   }
[09:28:17.695]                 }
[09:28:17.695]                 else {
[09:28:17.695]                   if (TRUE) {
[09:28:17.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.695]                     {
[09:28:17.695]                       inherits <- base::inherits
[09:28:17.695]                       invokeRestart <- base::invokeRestart
[09:28:17.695]                       is.null <- base::is.null
[09:28:17.695]                       muffled <- FALSE
[09:28:17.695]                       if (inherits(cond, "message")) {
[09:28:17.695]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.695]                         if (muffled) 
[09:28:17.695]                           invokeRestart("muffleMessage")
[09:28:17.695]                       }
[09:28:17.695]                       else if (inherits(cond, "warning")) {
[09:28:17.695]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.695]                         if (muffled) 
[09:28:17.695]                           invokeRestart("muffleWarning")
[09:28:17.695]                       }
[09:28:17.695]                       else if (inherits(cond, "condition")) {
[09:28:17.695]                         if (!is.null(pattern)) {
[09:28:17.695]                           computeRestarts <- base::computeRestarts
[09:28:17.695]                           grepl <- base::grepl
[09:28:17.695]                           restarts <- computeRestarts(cond)
[09:28:17.695]                           for (restart in restarts) {
[09:28:17.695]                             name <- restart$name
[09:28:17.695]                             if (is.null(name)) 
[09:28:17.695]                               next
[09:28:17.695]                             if (!grepl(pattern, name)) 
[09:28:17.695]                               next
[09:28:17.695]                             invokeRestart(restart)
[09:28:17.695]                             muffled <- TRUE
[09:28:17.695]                             break
[09:28:17.695]                           }
[09:28:17.695]                         }
[09:28:17.695]                       }
[09:28:17.695]                       invisible(muffled)
[09:28:17.695]                     }
[09:28:17.695]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.695]                   }
[09:28:17.695]                 }
[09:28:17.695]             }
[09:28:17.695]         }))
[09:28:17.695]     }, error = function(ex) {
[09:28:17.695]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.695]                 ...future.rng), started = ...future.startTime, 
[09:28:17.695]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.695]             version = "1.8"), class = "FutureResult")
[09:28:17.695]     }, finally = {
[09:28:17.695]         if (!identical(...future.workdir, getwd())) 
[09:28:17.695]             setwd(...future.workdir)
[09:28:17.695]         {
[09:28:17.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.695]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.695]             }
[09:28:17.695]             base::options(...future.oldOptions)
[09:28:17.695]             if (.Platform$OS.type == "windows") {
[09:28:17.695]                 old_names <- names(...future.oldEnvVars)
[09:28:17.695]                 envs <- base::Sys.getenv()
[09:28:17.695]                 names <- names(envs)
[09:28:17.695]                 common <- intersect(names, old_names)
[09:28:17.695]                 added <- setdiff(names, old_names)
[09:28:17.695]                 removed <- setdiff(old_names, names)
[09:28:17.695]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.695]                   envs[common]]
[09:28:17.695]                 NAMES <- toupper(changed)
[09:28:17.695]                 args <- list()
[09:28:17.695]                 for (kk in seq_along(NAMES)) {
[09:28:17.695]                   name <- changed[[kk]]
[09:28:17.695]                   NAME <- NAMES[[kk]]
[09:28:17.695]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.695]                     next
[09:28:17.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.695]                 }
[09:28:17.695]                 NAMES <- toupper(added)
[09:28:17.695]                 for (kk in seq_along(NAMES)) {
[09:28:17.695]                   name <- added[[kk]]
[09:28:17.695]                   NAME <- NAMES[[kk]]
[09:28:17.695]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.695]                     next
[09:28:17.695]                   args[[name]] <- ""
[09:28:17.695]                 }
[09:28:17.695]                 NAMES <- toupper(removed)
[09:28:17.695]                 for (kk in seq_along(NAMES)) {
[09:28:17.695]                   name <- removed[[kk]]
[09:28:17.695]                   NAME <- NAMES[[kk]]
[09:28:17.695]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.695]                     next
[09:28:17.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.695]                 }
[09:28:17.695]                 if (length(args) > 0) 
[09:28:17.695]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.695]             }
[09:28:17.695]             else {
[09:28:17.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.695]             }
[09:28:17.695]             {
[09:28:17.695]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.695]                   0L) {
[09:28:17.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.695]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.695]                   base::options(opts)
[09:28:17.695]                 }
[09:28:17.695]                 {
[09:28:17.695]                   {
[09:28:17.695]                     NULL
[09:28:17.695]                     RNGkind("Mersenne-Twister")
[09:28:17.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:17.695]                       inherits = FALSE)
[09:28:17.695]                   }
[09:28:17.695]                   options(future.plan = NULL)
[09:28:17.695]                   if (is.na(NA_character_)) 
[09:28:17.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.695]                     .init = FALSE)
[09:28:17.695]                 }
[09:28:17.695]             }
[09:28:17.695]         }
[09:28:17.695]     })
[09:28:17.695]     if (TRUE) {
[09:28:17.695]         base::sink(type = "output", split = FALSE)
[09:28:17.695]         if (TRUE) {
[09:28:17.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.695]         }
[09:28:17.695]         else {
[09:28:17.695]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.695]         }
[09:28:17.695]         base::close(...future.stdout)
[09:28:17.695]         ...future.stdout <- NULL
[09:28:17.695]     }
[09:28:17.695]     ...future.result$conditions <- ...future.conditions
[09:28:17.695]     ...future.result$finished <- base::Sys.time()
[09:28:17.695]     ...future.result
[09:28:17.695] }
[09:28:17.696] assign_globals() ...
[09:28:17.696] List of 5
[09:28:17.696]  $ future.call.arguments    : list()
[09:28:17.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.696]  $ ...future.FUN            :function (x)  
[09:28:17.696]  $ ...future.elements_ii    :List of 2
[09:28:17.696]   ..$ : int [1:2] 1 3
[09:28:17.696]   ..$ : int [1:2] 2 4
[09:28:17.696]  $ ...future.seeds_ii       : NULL
[09:28:17.696]  $ ...future.globals.maxSize: num Inf
[09:28:17.696]  - attr(*, "resolved")= logi FALSE
[09:28:17.696]  - attr(*, "total_size")= num NA
[09:28:17.696]  - attr(*, "where")=List of 5
[09:28:17.696]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.696]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.696]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.696]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.696]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.696]  - attr(*, "already-done")= logi TRUE
[09:28:17.701] - copied ‘future.call.arguments’ to environment
[09:28:17.701] - reassign environment for ‘...future.FUN’
[09:28:17.702] - copied ‘...future.FUN’ to environment
[09:28:17.702] - copied ‘...future.elements_ii’ to environment
[09:28:17.702] - copied ‘...future.seeds_ii’ to environment
[09:28:17.702] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.702] assign_globals() ... done
[09:28:17.703] plan(): Setting new future strategy stack:
[09:28:17.703] List of future strategies:
[09:28:17.703] 1. sequential:
[09:28:17.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.703]    - tweaked: FALSE
[09:28:17.703]    - call: NULL
[09:28:17.703] plan(): nbrOfWorkers() = 1
[09:28:17.704] plan(): Setting new future strategy stack:
[09:28:17.704] List of future strategies:
[09:28:17.704] 1. sequential:
[09:28:17.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.704]    - tweaked: FALSE
[09:28:17.704]    - call: plan(strategy)
[09:28:17.704] plan(): nbrOfWorkers() = 1
[09:28:17.704] SequentialFuture started (and completed)
[09:28:17.705] - Launch lazy future ... done
[09:28:17.705] run() for ‘SequentialFuture’ ... done
[09:28:17.705] Created future:
[09:28:17.705] SequentialFuture:
[09:28:17.705] Label: ‘future_apply-1’
[09:28:17.705] Expression:
[09:28:17.705] {
[09:28:17.705]     do.call(function(...) {
[09:28:17.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.705]             on.exit(options(oopts), add = TRUE)
[09:28:17.705]         }
[09:28:17.705]         {
[09:28:17.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.705]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.705]             })
[09:28:17.705]         }
[09:28:17.705]     }, args = future.call.arguments)
[09:28:17.705] }
[09:28:17.705] Lazy evaluation: FALSE
[09:28:17.705] Asynchronous evaluation: FALSE
[09:28:17.705] Local evaluation: TRUE
[09:28:17.705] Environment: R_GlobalEnv
[09:28:17.705] Capture standard output: TRUE
[09:28:17.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.705] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.705] Packages: <none>
[09:28:17.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.705] Resolved: TRUE
[09:28:17.705] Value: 400 bytes of class ‘list’
[09:28:17.705] Early signaling: FALSE
[09:28:17.705] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.705] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.706] Chunk #1 of 1 ... DONE
[09:28:17.706] Launching 1 futures (chunks) ... DONE
[09:28:17.706] Resolving 1 futures (chunks) ...
[09:28:17.706] resolve() on list ...
[09:28:17.706]  recursive: 0
[09:28:17.706]  length: 1
[09:28:17.706] 
[09:28:17.706] resolved() for ‘SequentialFuture’ ...
[09:28:17.706] - state: ‘finished’
[09:28:17.707] - run: TRUE
[09:28:17.707] - result: ‘FutureResult’
[09:28:17.707] resolved() for ‘SequentialFuture’ ... done
[09:28:17.707] Future #1
[09:28:17.707] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.707] - nx: 1
[09:28:17.707] - relay: TRUE
[09:28:17.707] - stdout: TRUE
[09:28:17.707] - signal: TRUE
[09:28:17.707] - resignal: FALSE
[09:28:17.707] - force: TRUE
[09:28:17.707] - relayed: [n=1] FALSE
[09:28:17.708] - queued futures: [n=1] FALSE
[09:28:17.708]  - until=1
[09:28:17.708]  - relaying element #1
[09:28:17.708] - relayed: [n=1] TRUE
[09:28:17.708] - queued futures: [n=1] TRUE
[09:28:17.708] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.708]  length: 0 (resolved future 1)
[09:28:17.708] Relaying remaining futures
[09:28:17.708] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.708] - nx: 1
[09:28:17.708] - relay: TRUE
[09:28:17.709] - stdout: TRUE
[09:28:17.709] - signal: TRUE
[09:28:17.709] - resignal: FALSE
[09:28:17.709] - force: TRUE
[09:28:17.709] - relayed: [n=1] TRUE
[09:28:17.709] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.709] - relayed: [n=1] TRUE
[09:28:17.709] - queued futures: [n=1] TRUE
[09:28:17.709] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.709] resolve() on list ... DONE
[09:28:17.709]  - Number of value chunks collected: 1
[09:28:17.710] Resolving 1 futures (chunks) ... DONE
[09:28:17.710] Reducing values from 1 chunks ...
[09:28:17.710]  - Number of values collected after concatenation: 2
[09:28:17.710]  - Number of values expected: 2
[09:28:17.710] Reducing values from 1 chunks ... DONE
[09:28:17.710] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[09:28:17.710] getGlobalsAndPackagesXApply() ...
[09:28:17.710]  - future.globals: TRUE
[09:28:17.710] getGlobalsAndPackages() ...
[09:28:17.710] Searching for globals...
[09:28:17.713] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[09:28:17.713] Searching for globals ... DONE
[09:28:17.713] Resolving globals: FALSE
[09:28:17.714] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[09:28:17.714] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[09:28:17.714] - globals: [1] ‘FUN’
[09:28:17.714] 
[09:28:17.714] getGlobalsAndPackages() ... DONE
[09:28:17.714]  - globals found/used: [n=1] ‘FUN’
[09:28:17.715]  - needed namespaces: [n=0] 
[09:28:17.715] Finding globals ... DONE
[09:28:17.715]  - use_args: TRUE
[09:28:17.715]  - Getting '...' globals ...
[09:28:17.715] resolve() on list ...
[09:28:17.715]  recursive: 0
[09:28:17.715]  length: 1
[09:28:17.715]  elements: ‘...’
[09:28:17.715]  length: 0 (resolved future 1)
[09:28:17.715] resolve() on list ... DONE
[09:28:17.716]    - '...' content: [n=0] 
[09:28:17.716] List of 1
[09:28:17.716]  $ ...: list()
[09:28:17.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.716]  - attr(*, "where")=List of 1
[09:28:17.716]   ..$ ...:<environment: 0x559ba2f1adc8> 
[09:28:17.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.716]  - attr(*, "resolved")= logi TRUE
[09:28:17.716]  - attr(*, "total_size")= num NA
[09:28:17.718]  - Getting '...' globals ... DONE
[09:28:17.718] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.718] List of 2
[09:28:17.718]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:17.718]  $ ...          : list()
[09:28:17.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.718]  - attr(*, "where")=List of 2
[09:28:17.718]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.718]   ..$ ...          :<environment: 0x559ba2f1adc8> 
[09:28:17.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.718]  - attr(*, "resolved")= logi FALSE
[09:28:17.718]  - attr(*, "total_size")= num 36296
[09:28:17.721] Packages to be attached in all futures: [n=0] 
[09:28:17.721] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.721] future_lapply() ...
[09:28:17.723] Generating random seeds ...
[09:28:17.723] Generating random seed streams for 2 elements ...
[09:28:17.724] Generating random seed streams for 2 elements ... DONE
[09:28:17.724] Generating random seeds ... DONE
[09:28:17.724] Will set RNG state on exit: 10407, -220919686, 1264129182, 790875009, -1441996935, -1320631515, 888419002
[09:28:17.724] Number of chunks: 1
[09:28:17.724] getGlobalsAndPackagesXApply() ...
[09:28:17.724]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.724]  - use_args: TRUE
[09:28:17.725] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.725] List of 2
[09:28:17.725]  $ ...          : list()
[09:28:17.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.725]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:17.725]  - attr(*, "where")=List of 2
[09:28:17.725]   ..$ ...          :<environment: 0x559ba2f1adc8> 
[09:28:17.725]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.725]  - attr(*, "resolved")= logi FALSE
[09:28:17.725]  - attr(*, "total_size")= num NA
[09:28:17.728] Packages to be attached in all futures: [n=0] 
[09:28:17.728] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.728] Number of futures (= number of chunks): 1
[09:28:17.728] Launching 1 futures (chunks) ...
[09:28:17.728] Chunk #1 of 1 ...
[09:28:17.728]  - seeds: [2] <seeds>
[09:28:17.728]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.728] getGlobalsAndPackages() ...
[09:28:17.728] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.729] Resolving globals: FALSE
[09:28:17.729] Tweak future expression to call with '...' arguments ...
[09:28:17.729] {
[09:28:17.729]     do.call(function(...) {
[09:28:17.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.729]             on.exit(options(oopts), add = TRUE)
[09:28:17.729]         }
[09:28:17.729]         {
[09:28:17.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.729]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:17.729]                   envir = globalenv(), inherits = FALSE)
[09:28:17.729]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.729]             })
[09:28:17.729]         }
[09:28:17.729]     }, args = future.call.arguments)
[09:28:17.729] }
[09:28:17.729] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.729] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.729] 
[09:28:17.730] getGlobalsAndPackages() ... DONE
[09:28:17.730] run() for ‘Future’ ...
[09:28:17.730] - state: ‘created’
[09:28:17.730] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:17.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:17.730]   - Field: ‘label’
[09:28:17.731]   - Field: ‘local’
[09:28:17.731]   - Field: ‘owner’
[09:28:17.731]   - Field: ‘envir’
[09:28:17.731]   - Field: ‘packages’
[09:28:17.731]   - Field: ‘gc’
[09:28:17.731]   - Field: ‘conditions’
[09:28:17.731]   - Field: ‘expr’
[09:28:17.731]   - Field: ‘uuid’
[09:28:17.731]   - Field: ‘seed’
[09:28:17.731]   - Field: ‘version’
[09:28:17.731]   - Field: ‘result’
[09:28:17.731]   - Field: ‘asynchronous’
[09:28:17.732]   - Field: ‘calls’
[09:28:17.732]   - Field: ‘globals’
[09:28:17.732]   - Field: ‘stdout’
[09:28:17.732]   - Field: ‘earlySignal’
[09:28:17.732]   - Field: ‘lazy’
[09:28:17.732]   - Field: ‘state’
[09:28:17.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:17.732] - Launch lazy future ...
[09:28:17.732] Packages needed by the future expression (n = 0): <none>
[09:28:17.732] Packages needed by future strategies (n = 0): <none>
[09:28:17.733] {
[09:28:17.733]     {
[09:28:17.733]         {
[09:28:17.733]             ...future.startTime <- base::Sys.time()
[09:28:17.733]             {
[09:28:17.733]                 {
[09:28:17.733]                   {
[09:28:17.733]                     base::local({
[09:28:17.733]                       has_future <- base::requireNamespace("future", 
[09:28:17.733]                         quietly = TRUE)
[09:28:17.733]                       if (has_future) {
[09:28:17.733]                         ns <- base::getNamespace("future")
[09:28:17.733]                         version <- ns[[".package"]][["version"]]
[09:28:17.733]                         if (is.null(version)) 
[09:28:17.733]                           version <- utils::packageVersion("future")
[09:28:17.733]                       }
[09:28:17.733]                       else {
[09:28:17.733]                         version <- NULL
[09:28:17.733]                       }
[09:28:17.733]                       if (!has_future || version < "1.8.0") {
[09:28:17.733]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.733]                           "", base::R.version$version.string), 
[09:28:17.733]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:17.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.733]                             "release", "version")], collapse = " "), 
[09:28:17.733]                           hostname = base::Sys.info()[["nodename"]])
[09:28:17.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.733]                           info)
[09:28:17.733]                         info <- base::paste(info, collapse = "; ")
[09:28:17.733]                         if (!has_future) {
[09:28:17.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.733]                             info)
[09:28:17.733]                         }
[09:28:17.733]                         else {
[09:28:17.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.733]                             info, version)
[09:28:17.733]                         }
[09:28:17.733]                         base::stop(msg)
[09:28:17.733]                       }
[09:28:17.733]                     })
[09:28:17.733]                   }
[09:28:17.733]                   ...future.strategy.old <- future::plan("list")
[09:28:17.733]                   options(future.plan = NULL)
[09:28:17.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.733]                 }
[09:28:17.733]                 ...future.workdir <- getwd()
[09:28:17.733]             }
[09:28:17.733]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.733]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.733]         }
[09:28:17.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.733]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.733]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.733]             base::names(...future.oldOptions))
[09:28:17.733]     }
[09:28:17.733]     if (FALSE) {
[09:28:17.733]     }
[09:28:17.733]     else {
[09:28:17.733]         if (TRUE) {
[09:28:17.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.733]                 open = "w")
[09:28:17.733]         }
[09:28:17.733]         else {
[09:28:17.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.733]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.733]         }
[09:28:17.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.733]             base::sink(type = "output", split = FALSE)
[09:28:17.733]             base::close(...future.stdout)
[09:28:17.733]         }, add = TRUE)
[09:28:17.733]     }
[09:28:17.733]     ...future.frame <- base::sys.nframe()
[09:28:17.733]     ...future.conditions <- base::list()
[09:28:17.733]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.733]     if (FALSE) {
[09:28:17.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.733]     }
[09:28:17.733]     ...future.result <- base::tryCatch({
[09:28:17.733]         base::withCallingHandlers({
[09:28:17.733]             ...future.value <- base::withVisible(base::local({
[09:28:17.733]                 do.call(function(...) {
[09:28:17.733]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.733]                   if (!identical(...future.globals.maxSize.org, 
[09:28:17.733]                     ...future.globals.maxSize)) {
[09:28:17.733]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.733]                     on.exit(options(oopts), add = TRUE)
[09:28:17.733]                   }
[09:28:17.733]                   {
[09:28:17.733]                     lapply(seq_along(...future.elements_ii), 
[09:28:17.733]                       FUN = function(jj) {
[09:28:17.733]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.733]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:17.733]                           envir = globalenv(), inherits = FALSE)
[09:28:17.733]                         ...future.FUN(...future.X_jj, ...)
[09:28:17.733]                       })
[09:28:17.733]                   }
[09:28:17.733]                 }, args = future.call.arguments)
[09:28:17.733]             }))
[09:28:17.733]             future::FutureResult(value = ...future.value$value, 
[09:28:17.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.733]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.733]                     ...future.globalenv.names))
[09:28:17.733]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.733]         }, condition = base::local({
[09:28:17.733]             c <- base::c
[09:28:17.733]             inherits <- base::inherits
[09:28:17.733]             invokeRestart <- base::invokeRestart
[09:28:17.733]             length <- base::length
[09:28:17.733]             list <- base::list
[09:28:17.733]             seq.int <- base::seq.int
[09:28:17.733]             signalCondition <- base::signalCondition
[09:28:17.733]             sys.calls <- base::sys.calls
[09:28:17.733]             `[[` <- base::`[[`
[09:28:17.733]             `+` <- base::`+`
[09:28:17.733]             `<<-` <- base::`<<-`
[09:28:17.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.733]                   3L)]
[09:28:17.733]             }
[09:28:17.733]             function(cond) {
[09:28:17.733]                 is_error <- inherits(cond, "error")
[09:28:17.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.733]                   NULL)
[09:28:17.733]                 if (is_error) {
[09:28:17.733]                   sessionInformation <- function() {
[09:28:17.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.733]                       search = base::search(), system = base::Sys.info())
[09:28:17.733]                   }
[09:28:17.733]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.733]                     cond$call), session = sessionInformation(), 
[09:28:17.733]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.733]                   signalCondition(cond)
[09:28:17.733]                 }
[09:28:17.733]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[09:28:17.733]                   signal <- TRUE && inherits(cond, character(0))
[09:28:17.733]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.733]                   if (TRUE && !signal) {
[09:28:17.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.733]                     {
[09:28:17.733]                       inherits <- base::inherits
[09:28:17.733]                       invokeRestart <- base::invokeRestart
[09:28:17.733]                       is.null <- base::is.null
[09:28:17.733]                       muffled <- FALSE
[09:28:17.733]                       if (inherits(cond, "message")) {
[09:28:17.733]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.733]                         if (muffled) 
[09:28:17.733]                           invokeRestart("muffleMessage")
[09:28:17.733]                       }
[09:28:17.733]                       else if (inherits(cond, "warning")) {
[09:28:17.733]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.733]                         if (muffled) 
[09:28:17.733]                           invokeRestart("muffleWarning")
[09:28:17.733]                       }
[09:28:17.733]                       else if (inherits(cond, "condition")) {
[09:28:17.733]                         if (!is.null(pattern)) {
[09:28:17.733]                           computeRestarts <- base::computeRestarts
[09:28:17.733]                           grepl <- base::grepl
[09:28:17.733]                           restarts <- computeRestarts(cond)
[09:28:17.733]                           for (restart in restarts) {
[09:28:17.733]                             name <- restart$name
[09:28:17.733]                             if (is.null(name)) 
[09:28:17.733]                               next
[09:28:17.733]                             if (!grepl(pattern, name)) 
[09:28:17.733]                               next
[09:28:17.733]                             invokeRestart(restart)
[09:28:17.733]                             muffled <- TRUE
[09:28:17.733]                             break
[09:28:17.733]                           }
[09:28:17.733]                         }
[09:28:17.733]                       }
[09:28:17.733]                       invisible(muffled)
[09:28:17.733]                     }
[09:28:17.733]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.733]                   }
[09:28:17.733]                 }
[09:28:17.733]                 else {
[09:28:17.733]                   if (FALSE) {
[09:28:17.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.733]                     {
[09:28:17.733]                       inherits <- base::inherits
[09:28:17.733]                       invokeRestart <- base::invokeRestart
[09:28:17.733]                       is.null <- base::is.null
[09:28:17.733]                       muffled <- FALSE
[09:28:17.733]                       if (inherits(cond, "message")) {
[09:28:17.733]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.733]                         if (muffled) 
[09:28:17.733]                           invokeRestart("muffleMessage")
[09:28:17.733]                       }
[09:28:17.733]                       else if (inherits(cond, "warning")) {
[09:28:17.733]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.733]                         if (muffled) 
[09:28:17.733]                           invokeRestart("muffleWarning")
[09:28:17.733]                       }
[09:28:17.733]                       else if (inherits(cond, "condition")) {
[09:28:17.733]                         if (!is.null(pattern)) {
[09:28:17.733]                           computeRestarts <- base::computeRestarts
[09:28:17.733]                           grepl <- base::grepl
[09:28:17.733]                           restarts <- computeRestarts(cond)
[09:28:17.733]                           for (restart in restarts) {
[09:28:17.733]                             name <- restart$name
[09:28:17.733]                             if (is.null(name)) 
[09:28:17.733]                               next
[09:28:17.733]                             if (!grepl(pattern, name)) 
[09:28:17.733]                               next
[09:28:17.733]                             invokeRestart(restart)
[09:28:17.733]                             muffled <- TRUE
[09:28:17.733]                             break
[09:28:17.733]                           }
[09:28:17.733]                         }
[09:28:17.733]                       }
[09:28:17.733]                       invisible(muffled)
[09:28:17.733]                     }
[09:28:17.733]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.733]                   }
[09:28:17.733]                 }
[09:28:17.733]             }
[09:28:17.733]         }))
[09:28:17.733]     }, error = function(ex) {
[09:28:17.733]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.733]                 ...future.rng), started = ...future.startTime, 
[09:28:17.733]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.733]             version = "1.8"), class = "FutureResult")
[09:28:17.733]     }, finally = {
[09:28:17.733]         if (!identical(...future.workdir, getwd())) 
[09:28:17.733]             setwd(...future.workdir)
[09:28:17.733]         {
[09:28:17.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.733]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.733]             }
[09:28:17.733]             base::options(...future.oldOptions)
[09:28:17.733]             if (.Platform$OS.type == "windows") {
[09:28:17.733]                 old_names <- names(...future.oldEnvVars)
[09:28:17.733]                 envs <- base::Sys.getenv()
[09:28:17.733]                 names <- names(envs)
[09:28:17.733]                 common <- intersect(names, old_names)
[09:28:17.733]                 added <- setdiff(names, old_names)
[09:28:17.733]                 removed <- setdiff(old_names, names)
[09:28:17.733]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.733]                   envs[common]]
[09:28:17.733]                 NAMES <- toupper(changed)
[09:28:17.733]                 args <- list()
[09:28:17.733]                 for (kk in seq_along(NAMES)) {
[09:28:17.733]                   name <- changed[[kk]]
[09:28:17.733]                   NAME <- NAMES[[kk]]
[09:28:17.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.733]                     next
[09:28:17.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.733]                 }
[09:28:17.733]                 NAMES <- toupper(added)
[09:28:17.733]                 for (kk in seq_along(NAMES)) {
[09:28:17.733]                   name <- added[[kk]]
[09:28:17.733]                   NAME <- NAMES[[kk]]
[09:28:17.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.733]                     next
[09:28:17.733]                   args[[name]] <- ""
[09:28:17.733]                 }
[09:28:17.733]                 NAMES <- toupper(removed)
[09:28:17.733]                 for (kk in seq_along(NAMES)) {
[09:28:17.733]                   name <- removed[[kk]]
[09:28:17.733]                   NAME <- NAMES[[kk]]
[09:28:17.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.733]                     next
[09:28:17.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.733]                 }
[09:28:17.733]                 if (length(args) > 0) 
[09:28:17.733]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.733]             }
[09:28:17.733]             else {
[09:28:17.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.733]             }
[09:28:17.733]             {
[09:28:17.733]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.733]                   0L) {
[09:28:17.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.733]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.733]                   base::options(opts)
[09:28:17.733]                 }
[09:28:17.733]                 {
[09:28:17.733]                   {
[09:28:17.733]                     base::assign(".Random.seed", c(10407L, -220919686L, 
[09:28:17.733]                     1264129182L, 790875009L, -1441996935L, -1320631515L, 
[09:28:17.733]                     888419002L), envir = base::globalenv(), inherits = FALSE)
[09:28:17.733]                     NULL
[09:28:17.733]                   }
[09:28:17.733]                   options(future.plan = NULL)
[09:28:17.733]                   if (is.na(NA_character_)) 
[09:28:17.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.733]                     .init = FALSE)
[09:28:17.733]                 }
[09:28:17.733]             }
[09:28:17.733]         }
[09:28:17.733]     })
[09:28:17.733]     if (TRUE) {
[09:28:17.733]         base::sink(type = "output", split = FALSE)
[09:28:17.733]         if (TRUE) {
[09:28:17.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.733]         }
[09:28:17.733]         else {
[09:28:17.733]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.733]         }
[09:28:17.733]         base::close(...future.stdout)
[09:28:17.733]         ...future.stdout <- NULL
[09:28:17.733]     }
[09:28:17.733]     ...future.result$conditions <- ...future.conditions
[09:28:17.733]     ...future.result$finished <- base::Sys.time()
[09:28:17.733]     ...future.result
[09:28:17.733] }
[09:28:17.734] assign_globals() ...
[09:28:17.734] List of 5
[09:28:17.734]  $ future.call.arguments    : list()
[09:28:17.734]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.734]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[09:28:17.734]  $ ...future.elements_ii    :List of 2
[09:28:17.734]   ..$ : int [1:2] 1 3
[09:28:17.734]   ..$ : int [1:2] 2 4
[09:28:17.734]  $ ...future.seeds_ii       :List of 2
[09:28:17.734]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[09:28:17.734]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[09:28:17.734]  $ ...future.globals.maxSize: num Inf
[09:28:17.734]  - attr(*, "resolved")= logi FALSE
[09:28:17.734]  - attr(*, "total_size")= num NA
[09:28:17.734]  - attr(*, "where")=List of 5
[09:28:17.734]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.734]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.734]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.734]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.734]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.734]  - attr(*, "already-done")= logi TRUE
[09:28:17.740] - copied ‘future.call.arguments’ to environment
[09:28:17.740] - copied ‘...future.FUN’ to environment
[09:28:17.740] - copied ‘...future.elements_ii’ to environment
[09:28:17.740] - copied ‘...future.seeds_ii’ to environment
[09:28:17.740] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.740] assign_globals() ... done
[09:28:17.740] plan(): Setting new future strategy stack:
[09:28:17.740] List of future strategies:
[09:28:17.740] 1. sequential:
[09:28:17.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.740]    - tweaked: FALSE
[09:28:17.740]    - call: NULL
[09:28:17.741] plan(): nbrOfWorkers() = 1
[09:28:17.741] plan(): Setting new future strategy stack:
[09:28:17.741] List of future strategies:
[09:28:17.741] 1. sequential:
[09:28:17.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.741]    - tweaked: FALSE
[09:28:17.741]    - call: plan(strategy)
[09:28:17.742] plan(): nbrOfWorkers() = 1
[09:28:17.742] SequentialFuture started (and completed)
[09:28:17.742] - Launch lazy future ... done
[09:28:17.742] run() for ‘SequentialFuture’ ... done
[09:28:17.742] Created future:
[09:28:17.742] SequentialFuture:
[09:28:17.742] Label: ‘future_apply-1’
[09:28:17.742] Expression:
[09:28:17.742] {
[09:28:17.742]     do.call(function(...) {
[09:28:17.742]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.742]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.742]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.742]             on.exit(options(oopts), add = TRUE)
[09:28:17.742]         }
[09:28:17.742]         {
[09:28:17.742]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.742]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.742]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:17.742]                   envir = globalenv(), inherits = FALSE)
[09:28:17.742]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.742]             })
[09:28:17.742]         }
[09:28:17.742]     }, args = future.call.arguments)
[09:28:17.742] }
[09:28:17.742] Lazy evaluation: FALSE
[09:28:17.742] Asynchronous evaluation: FALSE
[09:28:17.742] Local evaluation: TRUE
[09:28:17.742] Environment: R_GlobalEnv
[09:28:17.742] Capture standard output: TRUE
[09:28:17.742] Capture condition classes: <none>
[09:28:17.742] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.742] Packages: <none>
[09:28:17.742] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:28:17.742] Resolved: TRUE
[09:28:17.742] Value: 112 bytes of class ‘list’
[09:28:17.742] Early signaling: FALSE
[09:28:17.742] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.742] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:17.743] Chunk #1 of 1 ... DONE
[09:28:17.743] Launching 1 futures (chunks) ... DONE
[09:28:17.743] Resolving 1 futures (chunks) ...
[09:28:17.744] resolve() on list ...
[09:28:17.744]  recursive: 0
[09:28:17.744]  length: 1
[09:28:17.744] 
[09:28:17.744] resolved() for ‘SequentialFuture’ ...
[09:28:17.744] - state: ‘finished’
[09:28:17.744] - run: TRUE
[09:28:17.744] - result: ‘FutureResult’
[09:28:17.744] resolved() for ‘SequentialFuture’ ... done
[09:28:17.744] Future #1
[09:28:17.745] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:17.745] - nx: 1
[09:28:17.745] - relay: TRUE
[09:28:17.745] - stdout: TRUE
[09:28:17.745] - signal: TRUE
[09:28:17.745] - resignal: FALSE
[09:28:17.745] - force: TRUE
[09:28:17.745] - relayed: [n=1] FALSE
[09:28:17.745] - queued futures: [n=1] FALSE
[09:28:17.745]  - until=1
[09:28:17.745]  - relaying element #1
[09:28:17.746] - relayed: [n=1] TRUE
[09:28:17.746] - queued futures: [n=1] TRUE
[09:28:17.746] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:17.746]  length: 0 (resolved future 1)
[09:28:17.746] Relaying remaining futures
[09:28:17.746] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.746] - nx: 1
[09:28:17.746] - relay: TRUE
[09:28:17.746] - stdout: TRUE
[09:28:17.746] - signal: TRUE
[09:28:17.746] - resignal: FALSE
[09:28:17.746] - force: TRUE
[09:28:17.747] - relayed: [n=1] TRUE
[09:28:17.747] - queued futures: [n=1] TRUE
 - flush all
[09:28:17.748] - relayed: [n=1] TRUE
[09:28:17.748] - queued futures: [n=1] TRUE
[09:28:17.748] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.748] resolve() on list ... DONE
[09:28:17.748]  - Number of value chunks collected: 1
[09:28:17.748] Resolving 1 futures (chunks) ... DONE
[09:28:17.748] Reducing values from 1 chunks ...
[09:28:17.748]  - Number of values collected after concatenation: 2
[09:28:17.748]  - Number of values expected: 2
[09:28:17.748] Reducing values from 1 chunks ... DONE
[09:28:17.749] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[09:28:17.749] plan(): Setting new future strategy stack:
[09:28:17.749] List of future strategies:
[09:28:17.749] 1. sequential:
[09:28:17.749]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.749]    - tweaked: FALSE
[09:28:17.749]    - call: plan(sequential)
[09:28:17.749] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[09:28:17.750] plan(): Setting new future strategy stack:
[09:28:17.750] List of future strategies:
[09:28:17.750] 1. multicore:
[09:28:17.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:17.750]    - tweaked: FALSE
[09:28:17.750]    - call: plan(strategy)
[09:28:17.753] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[09:28:17.754] getGlobalsAndPackagesXApply() ...
[09:28:17.754]  - future.globals: TRUE
[09:28:17.754] getGlobalsAndPackages() ...
[09:28:17.754] Searching for globals...
[09:28:17.784] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:17.784] Searching for globals ... DONE
[09:28:17.784] Resolving globals: FALSE
[09:28:17.787] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:17.787] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:17.787] - globals: [1] ‘FUN’
[09:28:17.787] 
[09:28:17.787] getGlobalsAndPackages() ... DONE
[09:28:17.787]  - globals found/used: [n=1] ‘FUN’
[09:28:17.787]  - needed namespaces: [n=0] 
[09:28:17.787] Finding globals ... DONE
[09:28:17.788]  - use_args: TRUE
[09:28:17.788]  - Getting '...' globals ...
[09:28:17.788] resolve() on list ...
[09:28:17.788]  recursive: 0
[09:28:17.788]  length: 1
[09:28:17.788]  elements: ‘...’
[09:28:17.788]  length: 0 (resolved future 1)
[09:28:17.788] resolve() on list ... DONE
[09:28:17.788]    - '...' content: [n=0] 
[09:28:17.789] List of 1
[09:28:17.789]  $ ...: list()
[09:28:17.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.789]  - attr(*, "where")=List of 1
[09:28:17.789]   ..$ ...:<environment: 0x559ba240fe60> 
[09:28:17.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.789]  - attr(*, "resolved")= logi TRUE
[09:28:17.789]  - attr(*, "total_size")= num NA
[09:28:17.791]  - Getting '...' globals ... DONE
[09:28:17.791] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.791] List of 2
[09:28:17.791]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.791]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.791]  $ ...          : list()
[09:28:17.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.791]  - attr(*, "where")=List of 2
[09:28:17.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.791]   ..$ ...          :<environment: 0x559ba240fe60> 
[09:28:17.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.791]  - attr(*, "resolved")= logi FALSE
[09:28:17.791]  - attr(*, "total_size")= num 354224
[09:28:17.794] Packages to be attached in all futures: [n=0] 
[09:28:17.794] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.797] future_lapply() ...
[09:28:17.829] Number of chunks: 2
[09:28:17.830] getGlobalsAndPackagesXApply() ...
[09:28:17.830]  - future.globals: <name-value list> with names ‘list()’
[09:28:17.830]  - use_args: TRUE
[09:28:17.830] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:17.830] List of 2
[09:28:17.830]  $ ...          : list()
[09:28:17.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.830]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.830]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.830]  - attr(*, "where")=List of 2
[09:28:17.830]   ..$ ...          :<environment: 0x559ba240fe60> 
[09:28:17.830]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:17.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.830]  - attr(*, "resolved")= logi FALSE
[09:28:17.830]  - attr(*, "total_size")= num NA
[09:28:17.833] Packages to be attached in all futures: [n=0] 
[09:28:17.833] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.833] Number of futures (= number of chunks): 2
[09:28:17.833] Launching 2 futures (chunks) ...
[09:28:17.833] Chunk #1 of 2 ...
[09:28:17.834]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:17.834]  - seeds: <none>
[09:28:17.834]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.834] getGlobalsAndPackages() ...
[09:28:17.834] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.834] Resolving globals: FALSE
[09:28:17.834] Tweak future expression to call with '...' arguments ...
[09:28:17.834] {
[09:28:17.834]     do.call(function(...) {
[09:28:17.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.834]             on.exit(options(oopts), add = TRUE)
[09:28:17.834]         }
[09:28:17.834]         {
[09:28:17.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.834]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.834]             })
[09:28:17.834]         }
[09:28:17.834]     }, args = future.call.arguments)
[09:28:17.834] }
[09:28:17.835] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.835] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.835] 
[09:28:17.835] getGlobalsAndPackages() ... DONE
[09:28:17.835] run() for ‘Future’ ...
[09:28:17.835] - state: ‘created’
[09:28:17.836] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:17.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:17.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:17.839]   - Field: ‘label’
[09:28:17.839]   - Field: ‘local’
[09:28:17.839]   - Field: ‘owner’
[09:28:17.839]   - Field: ‘envir’
[09:28:17.839]   - Field: ‘workers’
[09:28:17.840]   - Field: ‘packages’
[09:28:17.840]   - Field: ‘gc’
[09:28:17.840]   - Field: ‘job’
[09:28:17.840]   - Field: ‘conditions’
[09:28:17.840]   - Field: ‘expr’
[09:28:17.840]   - Field: ‘uuid’
[09:28:17.840]   - Field: ‘seed’
[09:28:17.840]   - Field: ‘version’
[09:28:17.840]   - Field: ‘result’
[09:28:17.840]   - Field: ‘asynchronous’
[09:28:17.840]   - Field: ‘calls’
[09:28:17.841]   - Field: ‘globals’
[09:28:17.841]   - Field: ‘stdout’
[09:28:17.841]   - Field: ‘earlySignal’
[09:28:17.841]   - Field: ‘lazy’
[09:28:17.841]   - Field: ‘state’
[09:28:17.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:17.841] - Launch lazy future ...
[09:28:17.842] Packages needed by the future expression (n = 0): <none>
[09:28:17.842] Packages needed by future strategies (n = 0): <none>
[09:28:17.842] {
[09:28:17.842]     {
[09:28:17.842]         {
[09:28:17.842]             ...future.startTime <- base::Sys.time()
[09:28:17.842]             {
[09:28:17.842]                 {
[09:28:17.842]                   {
[09:28:17.842]                     {
[09:28:17.842]                       base::local({
[09:28:17.842]                         has_future <- base::requireNamespace("future", 
[09:28:17.842]                           quietly = TRUE)
[09:28:17.842]                         if (has_future) {
[09:28:17.842]                           ns <- base::getNamespace("future")
[09:28:17.842]                           version <- ns[[".package"]][["version"]]
[09:28:17.842]                           if (is.null(version)) 
[09:28:17.842]                             version <- utils::packageVersion("future")
[09:28:17.842]                         }
[09:28:17.842]                         else {
[09:28:17.842]                           version <- NULL
[09:28:17.842]                         }
[09:28:17.842]                         if (!has_future || version < "1.8.0") {
[09:28:17.842]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.842]                             "", base::R.version$version.string), 
[09:28:17.842]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:17.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.842]                               "release", "version")], collapse = " "), 
[09:28:17.842]                             hostname = base::Sys.info()[["nodename"]])
[09:28:17.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.842]                             info)
[09:28:17.842]                           info <- base::paste(info, collapse = "; ")
[09:28:17.842]                           if (!has_future) {
[09:28:17.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.842]                               info)
[09:28:17.842]                           }
[09:28:17.842]                           else {
[09:28:17.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.842]                               info, version)
[09:28:17.842]                           }
[09:28:17.842]                           base::stop(msg)
[09:28:17.842]                         }
[09:28:17.842]                       })
[09:28:17.842]                     }
[09:28:17.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:17.842]                     base::options(mc.cores = 1L)
[09:28:17.842]                   }
[09:28:17.842]                   ...future.strategy.old <- future::plan("list")
[09:28:17.842]                   options(future.plan = NULL)
[09:28:17.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.842]                 }
[09:28:17.842]                 ...future.workdir <- getwd()
[09:28:17.842]             }
[09:28:17.842]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.842]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.842]         }
[09:28:17.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.842]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.842]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.842]             base::names(...future.oldOptions))
[09:28:17.842]     }
[09:28:17.842]     if (FALSE) {
[09:28:17.842]     }
[09:28:17.842]     else {
[09:28:17.842]         if (TRUE) {
[09:28:17.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.842]                 open = "w")
[09:28:17.842]         }
[09:28:17.842]         else {
[09:28:17.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.842]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.842]         }
[09:28:17.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.842]             base::sink(type = "output", split = FALSE)
[09:28:17.842]             base::close(...future.stdout)
[09:28:17.842]         }, add = TRUE)
[09:28:17.842]     }
[09:28:17.842]     ...future.frame <- base::sys.nframe()
[09:28:17.842]     ...future.conditions <- base::list()
[09:28:17.842]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.842]     if (FALSE) {
[09:28:17.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.842]     }
[09:28:17.842]     ...future.result <- base::tryCatch({
[09:28:17.842]         base::withCallingHandlers({
[09:28:17.842]             ...future.value <- base::withVisible(base::local({
[09:28:17.842]                 withCallingHandlers({
[09:28:17.842]                   {
[09:28:17.842]                     do.call(function(...) {
[09:28:17.842]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.842]                       if (!identical(...future.globals.maxSize.org, 
[09:28:17.842]                         ...future.globals.maxSize)) {
[09:28:17.842]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.842]                         on.exit(options(oopts), add = TRUE)
[09:28:17.842]                       }
[09:28:17.842]                       {
[09:28:17.842]                         lapply(seq_along(...future.elements_ii), 
[09:28:17.842]                           FUN = function(jj) {
[09:28:17.842]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.842]                             ...future.FUN(...future.X_jj, ...)
[09:28:17.842]                           })
[09:28:17.842]                       }
[09:28:17.842]                     }, args = future.call.arguments)
[09:28:17.842]                   }
[09:28:17.842]                 }, immediateCondition = function(cond) {
[09:28:17.842]                   save_rds <- function (object, pathname, ...) 
[09:28:17.842]                   {
[09:28:17.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:17.842]                     if (file_test("-f", pathname_tmp)) {
[09:28:17.842]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:17.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.842]                         fi_tmp[["mtime"]])
[09:28:17.842]                     }
[09:28:17.842]                     tryCatch({
[09:28:17.842]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:17.842]                     }, error = function(ex) {
[09:28:17.842]                       msg <- conditionMessage(ex)
[09:28:17.842]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:17.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.842]                         fi_tmp[["mtime"]], msg)
[09:28:17.842]                       ex$message <- msg
[09:28:17.842]                       stop(ex)
[09:28:17.842]                     })
[09:28:17.842]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:17.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:17.842]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:17.842]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.842]                       fi <- file.info(pathname)
[09:28:17.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:17.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:17.842]                         fi[["size"]], fi[["mtime"]])
[09:28:17.842]                       stop(msg)
[09:28:17.842]                     }
[09:28:17.842]                     invisible(pathname)
[09:28:17.842]                   }
[09:28:17.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:17.842]                     rootPath = tempdir()) 
[09:28:17.842]                   {
[09:28:17.842]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:17.842]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:17.842]                       tmpdir = path, fileext = ".rds")
[09:28:17.842]                     save_rds(obj, file)
[09:28:17.842]                   }
[09:28:17.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:17.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.842]                   {
[09:28:17.842]                     inherits <- base::inherits
[09:28:17.842]                     invokeRestart <- base::invokeRestart
[09:28:17.842]                     is.null <- base::is.null
[09:28:17.842]                     muffled <- FALSE
[09:28:17.842]                     if (inherits(cond, "message")) {
[09:28:17.842]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:17.842]                       if (muffled) 
[09:28:17.842]                         invokeRestart("muffleMessage")
[09:28:17.842]                     }
[09:28:17.842]                     else if (inherits(cond, "warning")) {
[09:28:17.842]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:17.842]                       if (muffled) 
[09:28:17.842]                         invokeRestart("muffleWarning")
[09:28:17.842]                     }
[09:28:17.842]                     else if (inherits(cond, "condition")) {
[09:28:17.842]                       if (!is.null(pattern)) {
[09:28:17.842]                         computeRestarts <- base::computeRestarts
[09:28:17.842]                         grepl <- base::grepl
[09:28:17.842]                         restarts <- computeRestarts(cond)
[09:28:17.842]                         for (restart in restarts) {
[09:28:17.842]                           name <- restart$name
[09:28:17.842]                           if (is.null(name)) 
[09:28:17.842]                             next
[09:28:17.842]                           if (!grepl(pattern, name)) 
[09:28:17.842]                             next
[09:28:17.842]                           invokeRestart(restart)
[09:28:17.842]                           muffled <- TRUE
[09:28:17.842]                           break
[09:28:17.842]                         }
[09:28:17.842]                       }
[09:28:17.842]                     }
[09:28:17.842]                     invisible(muffled)
[09:28:17.842]                   }
[09:28:17.842]                   muffleCondition(cond)
[09:28:17.842]                 })
[09:28:17.842]             }))
[09:28:17.842]             future::FutureResult(value = ...future.value$value, 
[09:28:17.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.842]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.842]                     ...future.globalenv.names))
[09:28:17.842]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.842]         }, condition = base::local({
[09:28:17.842]             c <- base::c
[09:28:17.842]             inherits <- base::inherits
[09:28:17.842]             invokeRestart <- base::invokeRestart
[09:28:17.842]             length <- base::length
[09:28:17.842]             list <- base::list
[09:28:17.842]             seq.int <- base::seq.int
[09:28:17.842]             signalCondition <- base::signalCondition
[09:28:17.842]             sys.calls <- base::sys.calls
[09:28:17.842]             `[[` <- base::`[[`
[09:28:17.842]             `+` <- base::`+`
[09:28:17.842]             `<<-` <- base::`<<-`
[09:28:17.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.842]                   3L)]
[09:28:17.842]             }
[09:28:17.842]             function(cond) {
[09:28:17.842]                 is_error <- inherits(cond, "error")
[09:28:17.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.842]                   NULL)
[09:28:17.842]                 if (is_error) {
[09:28:17.842]                   sessionInformation <- function() {
[09:28:17.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.842]                       search = base::search(), system = base::Sys.info())
[09:28:17.842]                   }
[09:28:17.842]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.842]                     cond$call), session = sessionInformation(), 
[09:28:17.842]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.842]                   signalCondition(cond)
[09:28:17.842]                 }
[09:28:17.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.842]                 "immediateCondition"))) {
[09:28:17.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.842]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.842]                   if (TRUE && !signal) {
[09:28:17.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.842]                     {
[09:28:17.842]                       inherits <- base::inherits
[09:28:17.842]                       invokeRestart <- base::invokeRestart
[09:28:17.842]                       is.null <- base::is.null
[09:28:17.842]                       muffled <- FALSE
[09:28:17.842]                       if (inherits(cond, "message")) {
[09:28:17.842]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.842]                         if (muffled) 
[09:28:17.842]                           invokeRestart("muffleMessage")
[09:28:17.842]                       }
[09:28:17.842]                       else if (inherits(cond, "warning")) {
[09:28:17.842]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.842]                         if (muffled) 
[09:28:17.842]                           invokeRestart("muffleWarning")
[09:28:17.842]                       }
[09:28:17.842]                       else if (inherits(cond, "condition")) {
[09:28:17.842]                         if (!is.null(pattern)) {
[09:28:17.842]                           computeRestarts <- base::computeRestarts
[09:28:17.842]                           grepl <- base::grepl
[09:28:17.842]                           restarts <- computeRestarts(cond)
[09:28:17.842]                           for (restart in restarts) {
[09:28:17.842]                             name <- restart$name
[09:28:17.842]                             if (is.null(name)) 
[09:28:17.842]                               next
[09:28:17.842]                             if (!grepl(pattern, name)) 
[09:28:17.842]                               next
[09:28:17.842]                             invokeRestart(restart)
[09:28:17.842]                             muffled <- TRUE
[09:28:17.842]                             break
[09:28:17.842]                           }
[09:28:17.842]                         }
[09:28:17.842]                       }
[09:28:17.842]                       invisible(muffled)
[09:28:17.842]                     }
[09:28:17.842]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.842]                   }
[09:28:17.842]                 }
[09:28:17.842]                 else {
[09:28:17.842]                   if (TRUE) {
[09:28:17.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.842]                     {
[09:28:17.842]                       inherits <- base::inherits
[09:28:17.842]                       invokeRestart <- base::invokeRestart
[09:28:17.842]                       is.null <- base::is.null
[09:28:17.842]                       muffled <- FALSE
[09:28:17.842]                       if (inherits(cond, "message")) {
[09:28:17.842]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.842]                         if (muffled) 
[09:28:17.842]                           invokeRestart("muffleMessage")
[09:28:17.842]                       }
[09:28:17.842]                       else if (inherits(cond, "warning")) {
[09:28:17.842]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.842]                         if (muffled) 
[09:28:17.842]                           invokeRestart("muffleWarning")
[09:28:17.842]                       }
[09:28:17.842]                       else if (inherits(cond, "condition")) {
[09:28:17.842]                         if (!is.null(pattern)) {
[09:28:17.842]                           computeRestarts <- base::computeRestarts
[09:28:17.842]                           grepl <- base::grepl
[09:28:17.842]                           restarts <- computeRestarts(cond)
[09:28:17.842]                           for (restart in restarts) {
[09:28:17.842]                             name <- restart$name
[09:28:17.842]                             if (is.null(name)) 
[09:28:17.842]                               next
[09:28:17.842]                             if (!grepl(pattern, name)) 
[09:28:17.842]                               next
[09:28:17.842]                             invokeRestart(restart)
[09:28:17.842]                             muffled <- TRUE
[09:28:17.842]                             break
[09:28:17.842]                           }
[09:28:17.842]                         }
[09:28:17.842]                       }
[09:28:17.842]                       invisible(muffled)
[09:28:17.842]                     }
[09:28:17.842]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.842]                   }
[09:28:17.842]                 }
[09:28:17.842]             }
[09:28:17.842]         }))
[09:28:17.842]     }, error = function(ex) {
[09:28:17.842]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.842]                 ...future.rng), started = ...future.startTime, 
[09:28:17.842]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.842]             version = "1.8"), class = "FutureResult")
[09:28:17.842]     }, finally = {
[09:28:17.842]         if (!identical(...future.workdir, getwd())) 
[09:28:17.842]             setwd(...future.workdir)
[09:28:17.842]         {
[09:28:17.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.842]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.842]             }
[09:28:17.842]             base::options(...future.oldOptions)
[09:28:17.842]             if (.Platform$OS.type == "windows") {
[09:28:17.842]                 old_names <- names(...future.oldEnvVars)
[09:28:17.842]                 envs <- base::Sys.getenv()
[09:28:17.842]                 names <- names(envs)
[09:28:17.842]                 common <- intersect(names, old_names)
[09:28:17.842]                 added <- setdiff(names, old_names)
[09:28:17.842]                 removed <- setdiff(old_names, names)
[09:28:17.842]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.842]                   envs[common]]
[09:28:17.842]                 NAMES <- toupper(changed)
[09:28:17.842]                 args <- list()
[09:28:17.842]                 for (kk in seq_along(NAMES)) {
[09:28:17.842]                   name <- changed[[kk]]
[09:28:17.842]                   NAME <- NAMES[[kk]]
[09:28:17.842]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.842]                     next
[09:28:17.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.842]                 }
[09:28:17.842]                 NAMES <- toupper(added)
[09:28:17.842]                 for (kk in seq_along(NAMES)) {
[09:28:17.842]                   name <- added[[kk]]
[09:28:17.842]                   NAME <- NAMES[[kk]]
[09:28:17.842]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.842]                     next
[09:28:17.842]                   args[[name]] <- ""
[09:28:17.842]                 }
[09:28:17.842]                 NAMES <- toupper(removed)
[09:28:17.842]                 for (kk in seq_along(NAMES)) {
[09:28:17.842]                   name <- removed[[kk]]
[09:28:17.842]                   NAME <- NAMES[[kk]]
[09:28:17.842]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.842]                     next
[09:28:17.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.842]                 }
[09:28:17.842]                 if (length(args) > 0) 
[09:28:17.842]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.842]             }
[09:28:17.842]             else {
[09:28:17.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.842]             }
[09:28:17.842]             {
[09:28:17.842]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.842]                   0L) {
[09:28:17.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.842]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.842]                   base::options(opts)
[09:28:17.842]                 }
[09:28:17.842]                 {
[09:28:17.842]                   {
[09:28:17.842]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:17.842]                     NULL
[09:28:17.842]                   }
[09:28:17.842]                   options(future.plan = NULL)
[09:28:17.842]                   if (is.na(NA_character_)) 
[09:28:17.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.842]                     .init = FALSE)
[09:28:17.842]                 }
[09:28:17.842]             }
[09:28:17.842]         }
[09:28:17.842]     })
[09:28:17.842]     if (TRUE) {
[09:28:17.842]         base::sink(type = "output", split = FALSE)
[09:28:17.842]         if (TRUE) {
[09:28:17.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.842]         }
[09:28:17.842]         else {
[09:28:17.842]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.842]         }
[09:28:17.842]         base::close(...future.stdout)
[09:28:17.842]         ...future.stdout <- NULL
[09:28:17.842]     }
[09:28:17.842]     ...future.result$conditions <- ...future.conditions
[09:28:17.842]     ...future.result$finished <- base::Sys.time()
[09:28:17.842]     ...future.result
[09:28:17.842] }
[09:28:17.845] assign_globals() ...
[09:28:17.845] List of 5
[09:28:17.845]  $ future.call.arguments    : list()
[09:28:17.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.845]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.845]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.845]  $ ...future.elements_ii    :List of 1
[09:28:17.845]   ..$ : num [1:4] 1 3 1 7
[09:28:17.845]  $ ...future.seeds_ii       : NULL
[09:28:17.845]  $ ...future.globals.maxSize: num Inf
[09:28:17.845]  - attr(*, "resolved")= logi FALSE
[09:28:17.845]  - attr(*, "total_size")= num NA
[09:28:17.845]  - attr(*, "where")=List of 5
[09:28:17.845]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.845]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.845]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.845]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.845]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.845]  - attr(*, "already-done")= logi TRUE
[09:28:17.849] - copied ‘future.call.arguments’ to environment
[09:28:17.849] - copied ‘...future.FUN’ to environment
[09:28:17.849] - copied ‘...future.elements_ii’ to environment
[09:28:17.850] - copied ‘...future.seeds_ii’ to environment
[09:28:17.850] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.850] assign_globals() ... done
[09:28:17.850] requestCore(): workers = 2
[09:28:17.853] MulticoreFuture started
[09:28:17.853] - Launch lazy future ... done
[09:28:17.853] plan(): Setting new future strategy stack:
[09:28:17.853] run() for ‘MulticoreFuture’ ... done
[09:28:17.854] Created future:
[09:28:17.854] List of future strategies:
[09:28:17.854] 1. sequential:
[09:28:17.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.854]    - tweaked: FALSE
[09:28:17.854]    - call: NULL
[09:28:17.855] plan(): nbrOfWorkers() = 1
[09:28:17.862] plan(): Setting new future strategy stack:
[09:28:17.863] List of future strategies:
[09:28:17.863] 1. multicore:
[09:28:17.863]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:17.863]    - tweaked: FALSE
[09:28:17.863]    - call: plan(strategy)
[09:28:17.869] plan(): nbrOfWorkers() = 2
[09:28:17.854] MulticoreFuture:
[09:28:17.854] Label: ‘future_apply-1’
[09:28:17.854] Expression:
[09:28:17.854] {
[09:28:17.854]     do.call(function(...) {
[09:28:17.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.854]             on.exit(options(oopts), add = TRUE)
[09:28:17.854]         }
[09:28:17.854]         {
[09:28:17.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.854]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.854]             })
[09:28:17.854]         }
[09:28:17.854]     }, args = future.call.arguments)
[09:28:17.854] }
[09:28:17.854] Lazy evaluation: FALSE
[09:28:17.854] Asynchronous evaluation: TRUE
[09:28:17.854] Local evaluation: TRUE
[09:28:17.854] Environment: R_GlobalEnv
[09:28:17.854] Capture standard output: TRUE
[09:28:17.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.854] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.854] Packages: <none>
[09:28:17.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.854] Resolved: TRUE
[09:28:17.854] Value: <not collected>
[09:28:17.854] Conditions captured: <none>
[09:28:17.854] Early signaling: FALSE
[09:28:17.854] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.854] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:17.870] Chunk #1 of 2 ... DONE
[09:28:17.870] Chunk #2 of 2 ...
[09:28:17.871]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:17.871]  - seeds: <none>
[09:28:17.871]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.871] getGlobalsAndPackages() ...
[09:28:17.872] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.872] Resolving globals: FALSE
[09:28:17.872] Tweak future expression to call with '...' arguments ...
[09:28:17.872] {
[09:28:17.872]     do.call(function(...) {
[09:28:17.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.872]             on.exit(options(oopts), add = TRUE)
[09:28:17.872]         }
[09:28:17.872]         {
[09:28:17.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.872]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.872]             })
[09:28:17.872]         }
[09:28:17.872]     }, args = future.call.arguments)
[09:28:17.872] }
[09:28:17.872] Tweak future expression to call with '...' arguments ... DONE
[09:28:17.873] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:17.873] 
[09:28:17.873] getGlobalsAndPackages() ... DONE
[09:28:17.874] run() for ‘Future’ ...
[09:28:17.874] - state: ‘created’
[09:28:17.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:17.879] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:17.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:17.879]   - Field: ‘label’
[09:28:17.879]   - Field: ‘local’
[09:28:17.879]   - Field: ‘owner’
[09:28:17.879]   - Field: ‘envir’
[09:28:17.879]   - Field: ‘workers’
[09:28:17.880]   - Field: ‘packages’
[09:28:17.880]   - Field: ‘gc’
[09:28:17.880]   - Field: ‘job’
[09:28:17.880]   - Field: ‘conditions’
[09:28:17.880]   - Field: ‘expr’
[09:28:17.880]   - Field: ‘uuid’
[09:28:17.880]   - Field: ‘seed’
[09:28:17.880]   - Field: ‘version’
[09:28:17.881]   - Field: ‘result’
[09:28:17.881]   - Field: ‘asynchronous’
[09:28:17.881]   - Field: ‘calls’
[09:28:17.881]   - Field: ‘globals’
[09:28:17.881]   - Field: ‘stdout’
[09:28:17.881]   - Field: ‘earlySignal’
[09:28:17.881]   - Field: ‘lazy’
[09:28:17.881]   - Field: ‘state’
[09:28:17.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:17.882] - Launch lazy future ...
[09:28:17.882] Packages needed by the future expression (n = 0): <none>
[09:28:17.882] Packages needed by future strategies (n = 0): <none>
[09:28:17.883] {
[09:28:17.883]     {
[09:28:17.883]         {
[09:28:17.883]             ...future.startTime <- base::Sys.time()
[09:28:17.883]             {
[09:28:17.883]                 {
[09:28:17.883]                   {
[09:28:17.883]                     {
[09:28:17.883]                       base::local({
[09:28:17.883]                         has_future <- base::requireNamespace("future", 
[09:28:17.883]                           quietly = TRUE)
[09:28:17.883]                         if (has_future) {
[09:28:17.883]                           ns <- base::getNamespace("future")
[09:28:17.883]                           version <- ns[[".package"]][["version"]]
[09:28:17.883]                           if (is.null(version)) 
[09:28:17.883]                             version <- utils::packageVersion("future")
[09:28:17.883]                         }
[09:28:17.883]                         else {
[09:28:17.883]                           version <- NULL
[09:28:17.883]                         }
[09:28:17.883]                         if (!has_future || version < "1.8.0") {
[09:28:17.883]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:17.883]                             "", base::R.version$version.string), 
[09:28:17.883]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:17.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:17.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:17.883]                               "release", "version")], collapse = " "), 
[09:28:17.883]                             hostname = base::Sys.info()[["nodename"]])
[09:28:17.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:17.883]                             info)
[09:28:17.883]                           info <- base::paste(info, collapse = "; ")
[09:28:17.883]                           if (!has_future) {
[09:28:17.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:17.883]                               info)
[09:28:17.883]                           }
[09:28:17.883]                           else {
[09:28:17.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:17.883]                               info, version)
[09:28:17.883]                           }
[09:28:17.883]                           base::stop(msg)
[09:28:17.883]                         }
[09:28:17.883]                       })
[09:28:17.883]                     }
[09:28:17.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:17.883]                     base::options(mc.cores = 1L)
[09:28:17.883]                   }
[09:28:17.883]                   ...future.strategy.old <- future::plan("list")
[09:28:17.883]                   options(future.plan = NULL)
[09:28:17.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:17.883]                 }
[09:28:17.883]                 ...future.workdir <- getwd()
[09:28:17.883]             }
[09:28:17.883]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:17.883]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:17.883]         }
[09:28:17.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:17.883]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:17.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:17.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:17.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:17.883]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:17.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:17.883]             base::names(...future.oldOptions))
[09:28:17.883]     }
[09:28:17.883]     if (FALSE) {
[09:28:17.883]     }
[09:28:17.883]     else {
[09:28:17.883]         if (TRUE) {
[09:28:17.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:17.883]                 open = "w")
[09:28:17.883]         }
[09:28:17.883]         else {
[09:28:17.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:17.883]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:17.883]         }
[09:28:17.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:17.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:17.883]             base::sink(type = "output", split = FALSE)
[09:28:17.883]             base::close(...future.stdout)
[09:28:17.883]         }, add = TRUE)
[09:28:17.883]     }
[09:28:17.883]     ...future.frame <- base::sys.nframe()
[09:28:17.883]     ...future.conditions <- base::list()
[09:28:17.883]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:17.883]     if (FALSE) {
[09:28:17.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:17.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:17.883]     }
[09:28:17.883]     ...future.result <- base::tryCatch({
[09:28:17.883]         base::withCallingHandlers({
[09:28:17.883]             ...future.value <- base::withVisible(base::local({
[09:28:17.883]                 withCallingHandlers({
[09:28:17.883]                   {
[09:28:17.883]                     do.call(function(...) {
[09:28:17.883]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.883]                       if (!identical(...future.globals.maxSize.org, 
[09:28:17.883]                         ...future.globals.maxSize)) {
[09:28:17.883]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.883]                         on.exit(options(oopts), add = TRUE)
[09:28:17.883]                       }
[09:28:17.883]                       {
[09:28:17.883]                         lapply(seq_along(...future.elements_ii), 
[09:28:17.883]                           FUN = function(jj) {
[09:28:17.883]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.883]                             ...future.FUN(...future.X_jj, ...)
[09:28:17.883]                           })
[09:28:17.883]                       }
[09:28:17.883]                     }, args = future.call.arguments)
[09:28:17.883]                   }
[09:28:17.883]                 }, immediateCondition = function(cond) {
[09:28:17.883]                   save_rds <- function (object, pathname, ...) 
[09:28:17.883]                   {
[09:28:17.883]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:17.883]                     if (file_test("-f", pathname_tmp)) {
[09:28:17.883]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.883]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:17.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.883]                         fi_tmp[["mtime"]])
[09:28:17.883]                     }
[09:28:17.883]                     tryCatch({
[09:28:17.883]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:17.883]                     }, error = function(ex) {
[09:28:17.883]                       msg <- conditionMessage(ex)
[09:28:17.883]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.883]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:17.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.883]                         fi_tmp[["mtime"]], msg)
[09:28:17.883]                       ex$message <- msg
[09:28:17.883]                       stop(ex)
[09:28:17.883]                     })
[09:28:17.883]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:17.883]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:17.883]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:17.883]                       fi_tmp <- file.info(pathname_tmp)
[09:28:17.883]                       fi <- file.info(pathname)
[09:28:17.883]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:17.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:17.883]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:17.883]                         fi[["size"]], fi[["mtime"]])
[09:28:17.883]                       stop(msg)
[09:28:17.883]                     }
[09:28:17.883]                     invisible(pathname)
[09:28:17.883]                   }
[09:28:17.883]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:17.883]                     rootPath = tempdir()) 
[09:28:17.883]                   {
[09:28:17.883]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:17.883]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:17.883]                       tmpdir = path, fileext = ".rds")
[09:28:17.883]                     save_rds(obj, file)
[09:28:17.883]                   }
[09:28:17.883]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:17.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.883]                   {
[09:28:17.883]                     inherits <- base::inherits
[09:28:17.883]                     invokeRestart <- base::invokeRestart
[09:28:17.883]                     is.null <- base::is.null
[09:28:17.883]                     muffled <- FALSE
[09:28:17.883]                     if (inherits(cond, "message")) {
[09:28:17.883]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:17.883]                       if (muffled) 
[09:28:17.883]                         invokeRestart("muffleMessage")
[09:28:17.883]                     }
[09:28:17.883]                     else if (inherits(cond, "warning")) {
[09:28:17.883]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:17.883]                       if (muffled) 
[09:28:17.883]                         invokeRestart("muffleWarning")
[09:28:17.883]                     }
[09:28:17.883]                     else if (inherits(cond, "condition")) {
[09:28:17.883]                       if (!is.null(pattern)) {
[09:28:17.883]                         computeRestarts <- base::computeRestarts
[09:28:17.883]                         grepl <- base::grepl
[09:28:17.883]                         restarts <- computeRestarts(cond)
[09:28:17.883]                         for (restart in restarts) {
[09:28:17.883]                           name <- restart$name
[09:28:17.883]                           if (is.null(name)) 
[09:28:17.883]                             next
[09:28:17.883]                           if (!grepl(pattern, name)) 
[09:28:17.883]                             next
[09:28:17.883]                           invokeRestart(restart)
[09:28:17.883]                           muffled <- TRUE
[09:28:17.883]                           break
[09:28:17.883]                         }
[09:28:17.883]                       }
[09:28:17.883]                     }
[09:28:17.883]                     invisible(muffled)
[09:28:17.883]                   }
[09:28:17.883]                   muffleCondition(cond)
[09:28:17.883]                 })
[09:28:17.883]             }))
[09:28:17.883]             future::FutureResult(value = ...future.value$value, 
[09:28:17.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.883]                   ...future.rng), globalenv = if (FALSE) 
[09:28:17.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:17.883]                     ...future.globalenv.names))
[09:28:17.883]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:17.883]         }, condition = base::local({
[09:28:17.883]             c <- base::c
[09:28:17.883]             inherits <- base::inherits
[09:28:17.883]             invokeRestart <- base::invokeRestart
[09:28:17.883]             length <- base::length
[09:28:17.883]             list <- base::list
[09:28:17.883]             seq.int <- base::seq.int
[09:28:17.883]             signalCondition <- base::signalCondition
[09:28:17.883]             sys.calls <- base::sys.calls
[09:28:17.883]             `[[` <- base::`[[`
[09:28:17.883]             `+` <- base::`+`
[09:28:17.883]             `<<-` <- base::`<<-`
[09:28:17.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:17.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:17.883]                   3L)]
[09:28:17.883]             }
[09:28:17.883]             function(cond) {
[09:28:17.883]                 is_error <- inherits(cond, "error")
[09:28:17.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:17.883]                   NULL)
[09:28:17.883]                 if (is_error) {
[09:28:17.883]                   sessionInformation <- function() {
[09:28:17.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:17.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:17.883]                       search = base::search(), system = base::Sys.info())
[09:28:17.883]                   }
[09:28:17.883]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:17.883]                     cond$call), session = sessionInformation(), 
[09:28:17.883]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:17.883]                   signalCondition(cond)
[09:28:17.883]                 }
[09:28:17.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:17.883]                 "immediateCondition"))) {
[09:28:17.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:17.883]                   ...future.conditions[[length(...future.conditions) + 
[09:28:17.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:17.883]                   if (TRUE && !signal) {
[09:28:17.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.883]                     {
[09:28:17.883]                       inherits <- base::inherits
[09:28:17.883]                       invokeRestart <- base::invokeRestart
[09:28:17.883]                       is.null <- base::is.null
[09:28:17.883]                       muffled <- FALSE
[09:28:17.883]                       if (inherits(cond, "message")) {
[09:28:17.883]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.883]                         if (muffled) 
[09:28:17.883]                           invokeRestart("muffleMessage")
[09:28:17.883]                       }
[09:28:17.883]                       else if (inherits(cond, "warning")) {
[09:28:17.883]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.883]                         if (muffled) 
[09:28:17.883]                           invokeRestart("muffleWarning")
[09:28:17.883]                       }
[09:28:17.883]                       else if (inherits(cond, "condition")) {
[09:28:17.883]                         if (!is.null(pattern)) {
[09:28:17.883]                           computeRestarts <- base::computeRestarts
[09:28:17.883]                           grepl <- base::grepl
[09:28:17.883]                           restarts <- computeRestarts(cond)
[09:28:17.883]                           for (restart in restarts) {
[09:28:17.883]                             name <- restart$name
[09:28:17.883]                             if (is.null(name)) 
[09:28:17.883]                               next
[09:28:17.883]                             if (!grepl(pattern, name)) 
[09:28:17.883]                               next
[09:28:17.883]                             invokeRestart(restart)
[09:28:17.883]                             muffled <- TRUE
[09:28:17.883]                             break
[09:28:17.883]                           }
[09:28:17.883]                         }
[09:28:17.883]                       }
[09:28:17.883]                       invisible(muffled)
[09:28:17.883]                     }
[09:28:17.883]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.883]                   }
[09:28:17.883]                 }
[09:28:17.883]                 else {
[09:28:17.883]                   if (TRUE) {
[09:28:17.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:17.883]                     {
[09:28:17.883]                       inherits <- base::inherits
[09:28:17.883]                       invokeRestart <- base::invokeRestart
[09:28:17.883]                       is.null <- base::is.null
[09:28:17.883]                       muffled <- FALSE
[09:28:17.883]                       if (inherits(cond, "message")) {
[09:28:17.883]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:17.883]                         if (muffled) 
[09:28:17.883]                           invokeRestart("muffleMessage")
[09:28:17.883]                       }
[09:28:17.883]                       else if (inherits(cond, "warning")) {
[09:28:17.883]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:17.883]                         if (muffled) 
[09:28:17.883]                           invokeRestart("muffleWarning")
[09:28:17.883]                       }
[09:28:17.883]                       else if (inherits(cond, "condition")) {
[09:28:17.883]                         if (!is.null(pattern)) {
[09:28:17.883]                           computeRestarts <- base::computeRestarts
[09:28:17.883]                           grepl <- base::grepl
[09:28:17.883]                           restarts <- computeRestarts(cond)
[09:28:17.883]                           for (restart in restarts) {
[09:28:17.883]                             name <- restart$name
[09:28:17.883]                             if (is.null(name)) 
[09:28:17.883]                               next
[09:28:17.883]                             if (!grepl(pattern, name)) 
[09:28:17.883]                               next
[09:28:17.883]                             invokeRestart(restart)
[09:28:17.883]                             muffled <- TRUE
[09:28:17.883]                             break
[09:28:17.883]                           }
[09:28:17.883]                         }
[09:28:17.883]                       }
[09:28:17.883]                       invisible(muffled)
[09:28:17.883]                     }
[09:28:17.883]                     muffleCondition(cond, pattern = "^muffle")
[09:28:17.883]                   }
[09:28:17.883]                 }
[09:28:17.883]             }
[09:28:17.883]         }))
[09:28:17.883]     }, error = function(ex) {
[09:28:17.883]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:17.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:17.883]                 ...future.rng), started = ...future.startTime, 
[09:28:17.883]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:17.883]             version = "1.8"), class = "FutureResult")
[09:28:17.883]     }, finally = {
[09:28:17.883]         if (!identical(...future.workdir, getwd())) 
[09:28:17.883]             setwd(...future.workdir)
[09:28:17.883]         {
[09:28:17.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:17.883]                 ...future.oldOptions$nwarnings <- NULL
[09:28:17.883]             }
[09:28:17.883]             base::options(...future.oldOptions)
[09:28:17.883]             if (.Platform$OS.type == "windows") {
[09:28:17.883]                 old_names <- names(...future.oldEnvVars)
[09:28:17.883]                 envs <- base::Sys.getenv()
[09:28:17.883]                 names <- names(envs)
[09:28:17.883]                 common <- intersect(names, old_names)
[09:28:17.883]                 added <- setdiff(names, old_names)
[09:28:17.883]                 removed <- setdiff(old_names, names)
[09:28:17.883]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:17.883]                   envs[common]]
[09:28:17.883]                 NAMES <- toupper(changed)
[09:28:17.883]                 args <- list()
[09:28:17.883]                 for (kk in seq_along(NAMES)) {
[09:28:17.883]                   name <- changed[[kk]]
[09:28:17.883]                   NAME <- NAMES[[kk]]
[09:28:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.883]                     next
[09:28:17.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.883]                 }
[09:28:17.883]                 NAMES <- toupper(added)
[09:28:17.883]                 for (kk in seq_along(NAMES)) {
[09:28:17.883]                   name <- added[[kk]]
[09:28:17.883]                   NAME <- NAMES[[kk]]
[09:28:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.883]                     next
[09:28:17.883]                   args[[name]] <- ""
[09:28:17.883]                 }
[09:28:17.883]                 NAMES <- toupper(removed)
[09:28:17.883]                 for (kk in seq_along(NAMES)) {
[09:28:17.883]                   name <- removed[[kk]]
[09:28:17.883]                   NAME <- NAMES[[kk]]
[09:28:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:17.883]                     next
[09:28:17.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:17.883]                 }
[09:28:17.883]                 if (length(args) > 0) 
[09:28:17.883]                   base::do.call(base::Sys.setenv, args = args)
[09:28:17.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:17.883]             }
[09:28:17.883]             else {
[09:28:17.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:17.883]             }
[09:28:17.883]             {
[09:28:17.883]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:17.883]                   0L) {
[09:28:17.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:17.883]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:17.883]                   base::options(opts)
[09:28:17.883]                 }
[09:28:17.883]                 {
[09:28:17.883]                   {
[09:28:17.883]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:17.883]                     NULL
[09:28:17.883]                   }
[09:28:17.883]                   options(future.plan = NULL)
[09:28:17.883]                   if (is.na(NA_character_)) 
[09:28:17.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:17.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:17.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:17.883]                     .init = FALSE)
[09:28:17.883]                 }
[09:28:17.883]             }
[09:28:17.883]         }
[09:28:17.883]     })
[09:28:17.883]     if (TRUE) {
[09:28:17.883]         base::sink(type = "output", split = FALSE)
[09:28:17.883]         if (TRUE) {
[09:28:17.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:17.883]         }
[09:28:17.883]         else {
[09:28:17.883]             ...future.result["stdout"] <- base::list(NULL)
[09:28:17.883]         }
[09:28:17.883]         base::close(...future.stdout)
[09:28:17.883]         ...future.stdout <- NULL
[09:28:17.883]     }
[09:28:17.883]     ...future.result$conditions <- ...future.conditions
[09:28:17.883]     ...future.result$finished <- base::Sys.time()
[09:28:17.883]     ...future.result
[09:28:17.883] }
[09:28:17.885] assign_globals() ...
[09:28:17.886] List of 5
[09:28:17.886]  $ future.call.arguments    : list()
[09:28:17.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.886]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.886]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.886]  $ ...future.elements_ii    :List of 1
[09:28:17.886]   ..$ : num [1:4] 2 4 6 8
[09:28:17.886]  $ ...future.seeds_ii       : NULL
[09:28:17.886]  $ ...future.globals.maxSize: num Inf
[09:28:17.886]  - attr(*, "resolved")= logi FALSE
[09:28:17.886]  - attr(*, "total_size")= num NA
[09:28:17.886]  - attr(*, "where")=List of 5
[09:28:17.886]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:17.886]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:17.886]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:17.886]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:17.886]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:17.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.886]  - attr(*, "already-done")= logi TRUE
[09:28:17.892] - copied ‘future.call.arguments’ to environment
[09:28:17.892] - copied ‘...future.FUN’ to environment
[09:28:17.892] - copied ‘...future.elements_ii’ to environment
[09:28:17.893] - copied ‘...future.seeds_ii’ to environment
[09:28:17.893] - copied ‘...future.globals.maxSize’ to environment
[09:28:17.893] assign_globals() ... done
[09:28:17.893] requestCore(): workers = 2
[09:28:17.898] MulticoreFuture started
[09:28:17.898] - Launch lazy future ... done
[09:28:17.899] run() for ‘MulticoreFuture’ ... done
[09:28:17.899] Created future:
[09:28:17.899] plan(): Setting new future strategy stack:
[09:28:17.899] List of future strategies:
[09:28:17.899] 1. sequential:
[09:28:17.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:17.899]    - tweaked: FALSE
[09:28:17.899]    - call: NULL
[09:28:17.900] plan(): nbrOfWorkers() = 1
[09:28:17.903] plan(): Setting new future strategy stack:
[09:28:17.903] List of future strategies:
[09:28:17.903] 1. multicore:
[09:28:17.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:17.903]    - tweaked: FALSE
[09:28:17.903]    - call: plan(strategy)
[09:28:17.908] plan(): nbrOfWorkers() = 2
[09:28:17.899] MulticoreFuture:
[09:28:17.899] Label: ‘future_apply-2’
[09:28:17.899] Expression:
[09:28:17.899] {
[09:28:17.899]     do.call(function(...) {
[09:28:17.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:17.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:17.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:17.899]             on.exit(options(oopts), add = TRUE)
[09:28:17.899]         }
[09:28:17.899]         {
[09:28:17.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:17.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:17.899]                 ...future.FUN(...future.X_jj, ...)
[09:28:17.899]             })
[09:28:17.899]         }
[09:28:17.899]     }, args = future.call.arguments)
[09:28:17.899] }
[09:28:17.899] Lazy evaluation: FALSE
[09:28:17.899] Asynchronous evaluation: TRUE
[09:28:17.899] Local evaluation: TRUE
[09:28:17.899] Environment: R_GlobalEnv
[09:28:17.899] Capture standard output: TRUE
[09:28:17.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:17.899] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:17.899] Packages: <none>
[09:28:17.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:17.899] Resolved: TRUE
[09:28:17.899] Value: <not collected>
[09:28:17.899] Conditions captured: <none>
[09:28:17.899] Early signaling: FALSE
[09:28:17.899] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:17.899] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:17.909] Chunk #2 of 2 ... DONE
[09:28:17.909] Launching 2 futures (chunks) ... DONE
[09:28:17.909] Resolving 2 futures (chunks) ...
[09:28:17.909] resolve() on list ...
[09:28:17.910]  recursive: 0
[09:28:17.910]  length: 2
[09:28:17.910] 
[09:28:17.910] Future #1
[09:28:17.911] result() for MulticoreFuture ...
[09:28:17.912] result() for MulticoreFuture ...
[09:28:17.913] result() for MulticoreFuture ... done
[09:28:17.913] result() for MulticoreFuture ... done
[09:28:17.913] result() for MulticoreFuture ...
[09:28:17.913] result() for MulticoreFuture ... done
[09:28:17.913] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:17.913] - nx: 2
[09:28:17.913] - relay: TRUE
[09:28:17.914] - stdout: TRUE
[09:28:17.914] - signal: TRUE
[09:28:17.914] - resignal: FALSE
[09:28:17.914] - force: TRUE
[09:28:17.914] - relayed: [n=2] FALSE, FALSE
[09:28:17.914] - queued futures: [n=2] FALSE, FALSE
[09:28:17.914]  - until=1
[09:28:17.914]  - relaying element #1
[09:28:17.915] result() for MulticoreFuture ...
[09:28:17.915] result() for MulticoreFuture ... done
[09:28:17.915] result() for MulticoreFuture ...
[09:28:17.915] result() for MulticoreFuture ... done
[09:28:17.915] result() for MulticoreFuture ...
[09:28:17.915] result() for MulticoreFuture ... done
[09:28:17.916] result() for MulticoreFuture ...
[09:28:17.916] result() for MulticoreFuture ... done
[09:28:17.916] - relayed: [n=2] TRUE, FALSE
[09:28:17.916] - queued futures: [n=2] TRUE, FALSE
[09:28:17.916] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:17.916]  length: 1 (resolved future 1)
[09:28:17.917] Future #2
[09:28:17.921] result() for MulticoreFuture ...
[09:28:17.922] result() for MulticoreFuture ...
[09:28:17.922] result() for MulticoreFuture ... done
[09:28:17.922] result() for MulticoreFuture ... done
[09:28:17.923] result() for MulticoreFuture ...
[09:28:17.923] result() for MulticoreFuture ... done
[09:28:17.923] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:17.923] - nx: 2
[09:28:17.923] - relay: TRUE
[09:28:17.924] - stdout: TRUE
[09:28:17.924] - signal: TRUE
[09:28:17.924] - resignal: FALSE
[09:28:17.924] - force: TRUE
[09:28:17.924] - relayed: [n=2] TRUE, FALSE
[09:28:17.924] - queued futures: [n=2] TRUE, FALSE
[09:28:17.924]  - until=2
[09:28:17.924]  - relaying element #2
[09:28:17.925] result() for MulticoreFuture ...
[09:28:17.925] result() for MulticoreFuture ... done
[09:28:17.925] result() for MulticoreFuture ...
[09:28:17.925] result() for MulticoreFuture ... done
[09:28:17.925] result() for MulticoreFuture ...
[09:28:17.925] result() for MulticoreFuture ... done
[09:28:17.925] result() for MulticoreFuture ...
[09:28:17.925] result() for MulticoreFuture ... done
[09:28:17.925] - relayed: [n=2] TRUE, TRUE
[09:28:17.926] - queued futures: [n=2] TRUE, TRUE
[09:28:17.926] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:17.926]  length: 0 (resolved future 2)
[09:28:17.926] Relaying remaining futures
[09:28:17.926] signalConditionsASAP(NULL, pos=0) ...
[09:28:17.926] - nx: 2
[09:28:17.926] - relay: TRUE
[09:28:17.926] - stdout: TRUE
[09:28:17.927] - signal: TRUE
[09:28:17.927] - resignal: FALSE
[09:28:17.927] - force: TRUE
[09:28:17.927] - relayed: [n=2] TRUE, TRUE
[09:28:17.927] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:17.927] - relayed: [n=2] TRUE, TRUE
[09:28:17.927] - queued futures: [n=2] TRUE, TRUE
[09:28:17.927] signalConditionsASAP(NULL, pos=0) ... done
[09:28:17.927] resolve() on list ... DONE
[09:28:17.928] result() for MulticoreFuture ...
[09:28:17.928] result() for MulticoreFuture ... done
[09:28:17.928] result() for MulticoreFuture ...
[09:28:17.928] result() for MulticoreFuture ... done
[09:28:17.928] result() for MulticoreFuture ...
[09:28:17.928] result() for MulticoreFuture ... done
[09:28:17.928] result() for MulticoreFuture ...
[09:28:17.928] result() for MulticoreFuture ... done
[09:28:17.929]  - Number of value chunks collected: 2
[09:28:17.929] Resolving 2 futures (chunks) ... DONE
[09:28:17.929] Reducing values from 2 chunks ...
[09:28:17.929]  - Number of values collected after concatenation: 2
[09:28:17.929]  - Number of values expected: 2
[09:28:17.929] Reducing values from 2 chunks ... DONE
[09:28:17.929] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:17.930] getGlobalsAndPackagesXApply() ...
[09:28:17.930]  - future.globals: TRUE
[09:28:17.930] getGlobalsAndPackages() ...
[09:28:17.930] Searching for globals...
[09:28:17.965] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:17.965] Searching for globals ... DONE
[09:28:17.965] Resolving globals: FALSE
[09:28:17.967] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:17.967] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:17.967] - globals: [1] ‘FUN’
[09:28:17.967] 
[09:28:17.968] getGlobalsAndPackages() ... DONE
[09:28:17.968]  - globals found/used: [n=1] ‘FUN’
[09:28:17.968]  - needed namespaces: [n=0] 
[09:28:17.968] Finding globals ... DONE
[09:28:17.968]  - use_args: TRUE
[09:28:17.968]  - Getting '...' globals ...
[09:28:17.968] resolve() on list ...
[09:28:17.968]  recursive: 0
[09:28:17.969]  length: 1
[09:28:17.969]  elements: ‘...’
[09:28:17.969]  length: 0 (resolved future 1)
[09:28:17.969] resolve() on list ... DONE
[09:28:17.969]    - '...' content: [n=0] 
[09:28:17.969] List of 1
[09:28:17.969]  $ ...: list()
[09:28:17.969]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.969]  - attr(*, "where")=List of 1
[09:28:17.969]   ..$ ...:<environment: 0x559ba1e74108> 
[09:28:17.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.969]  - attr(*, "resolved")= logi TRUE
[09:28:17.969]  - attr(*, "total_size")= num NA
[09:28:17.972]  - Getting '...' globals ... DONE
[09:28:17.972] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:17.972] List of 2
[09:28:17.972]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:17.972]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:17.972]  $ ...          : list()
[09:28:17.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:17.972]  - attr(*, "where")=List of 2
[09:28:17.972]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:17.972]   ..$ ...          :<environment: 0x559ba1e74108> 
[09:28:17.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:17.972]  - attr(*, "resolved")= logi FALSE
[09:28:17.972]  - attr(*, "total_size")= num 354224
[09:28:17.974] Packages to be attached in all futures: [n=0] 
[09:28:17.974] getGlobalsAndPackagesXApply() ... DONE
[09:28:17.978] future_lapply() ...
[09:28:18.013] Number of chunks: 2
[09:28:18.013] getGlobalsAndPackagesXApply() ...
[09:28:18.013]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.013]  - use_args: TRUE
[09:28:18.013] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.013] List of 2
[09:28:18.013]  $ ...          : list()
[09:28:18.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.013]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:18.013]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:18.013]  - attr(*, "where")=List of 2
[09:28:18.013]   ..$ ...          :<environment: 0x559ba1e74108> 
[09:28:18.013]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.013]  - attr(*, "resolved")= logi FALSE
[09:28:18.013]  - attr(*, "total_size")= num NA
[09:28:18.017] Packages to be attached in all futures: [n=0] 
[09:28:18.017] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.017] Number of futures (= number of chunks): 2
[09:28:18.017] Launching 2 futures (chunks) ...
[09:28:18.017] Chunk #1 of 2 ...
[09:28:18.017]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.017]  - seeds: <none>
[09:28:18.017]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.018] getGlobalsAndPackages() ...
[09:28:18.018] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.018] Resolving globals: FALSE
[09:28:18.018] Tweak future expression to call with '...' arguments ...
[09:28:18.018] {
[09:28:18.018]     do.call(function(...) {
[09:28:18.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.018]             on.exit(options(oopts), add = TRUE)
[09:28:18.018]         }
[09:28:18.018]         {
[09:28:18.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.018]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.018]             })
[09:28:18.018]         }
[09:28:18.018]     }, args = future.call.arguments)
[09:28:18.018] }
[09:28:18.018] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.019] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.019] 
[09:28:18.019] getGlobalsAndPackages() ... DONE
[09:28:18.019] run() for ‘Future’ ...
[09:28:18.019] - state: ‘created’
[09:28:18.019] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.023]   - Field: ‘label’
[09:28:18.023]   - Field: ‘local’
[09:28:18.023]   - Field: ‘owner’
[09:28:18.023]   - Field: ‘envir’
[09:28:18.023]   - Field: ‘workers’
[09:28:18.023]   - Field: ‘packages’
[09:28:18.023]   - Field: ‘gc’
[09:28:18.024]   - Field: ‘job’
[09:28:18.024]   - Field: ‘conditions’
[09:28:18.024]   - Field: ‘expr’
[09:28:18.024]   - Field: ‘uuid’
[09:28:18.024]   - Field: ‘seed’
[09:28:18.024]   - Field: ‘version’
[09:28:18.025]   - Field: ‘result’
[09:28:18.025]   - Field: ‘asynchronous’
[09:28:18.025]   - Field: ‘calls’
[09:28:18.025]   - Field: ‘globals’
[09:28:18.026]   - Field: ‘stdout’
[09:28:18.026]   - Field: ‘earlySignal’
[09:28:18.026]   - Field: ‘lazy’
[09:28:18.026]   - Field: ‘state’
[09:28:18.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.026] - Launch lazy future ...
[09:28:18.026] Packages needed by the future expression (n = 0): <none>
[09:28:18.026] Packages needed by future strategies (n = 0): <none>
[09:28:18.027] {
[09:28:18.027]     {
[09:28:18.027]         {
[09:28:18.027]             ...future.startTime <- base::Sys.time()
[09:28:18.027]             {
[09:28:18.027]                 {
[09:28:18.027]                   {
[09:28:18.027]                     {
[09:28:18.027]                       base::local({
[09:28:18.027]                         has_future <- base::requireNamespace("future", 
[09:28:18.027]                           quietly = TRUE)
[09:28:18.027]                         if (has_future) {
[09:28:18.027]                           ns <- base::getNamespace("future")
[09:28:18.027]                           version <- ns[[".package"]][["version"]]
[09:28:18.027]                           if (is.null(version)) 
[09:28:18.027]                             version <- utils::packageVersion("future")
[09:28:18.027]                         }
[09:28:18.027]                         else {
[09:28:18.027]                           version <- NULL
[09:28:18.027]                         }
[09:28:18.027]                         if (!has_future || version < "1.8.0") {
[09:28:18.027]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.027]                             "", base::R.version$version.string), 
[09:28:18.027]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.027]                               "release", "version")], collapse = " "), 
[09:28:18.027]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.027]                             info)
[09:28:18.027]                           info <- base::paste(info, collapse = "; ")
[09:28:18.027]                           if (!has_future) {
[09:28:18.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.027]                               info)
[09:28:18.027]                           }
[09:28:18.027]                           else {
[09:28:18.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.027]                               info, version)
[09:28:18.027]                           }
[09:28:18.027]                           base::stop(msg)
[09:28:18.027]                         }
[09:28:18.027]                       })
[09:28:18.027]                     }
[09:28:18.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.027]                     base::options(mc.cores = 1L)
[09:28:18.027]                   }
[09:28:18.027]                   ...future.strategy.old <- future::plan("list")
[09:28:18.027]                   options(future.plan = NULL)
[09:28:18.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.027]                 }
[09:28:18.027]                 ...future.workdir <- getwd()
[09:28:18.027]             }
[09:28:18.027]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.027]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.027]         }
[09:28:18.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.027]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.027]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.027]             base::names(...future.oldOptions))
[09:28:18.027]     }
[09:28:18.027]     if (FALSE) {
[09:28:18.027]     }
[09:28:18.027]     else {
[09:28:18.027]         if (TRUE) {
[09:28:18.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.027]                 open = "w")
[09:28:18.027]         }
[09:28:18.027]         else {
[09:28:18.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.027]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.027]         }
[09:28:18.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.027]             base::sink(type = "output", split = FALSE)
[09:28:18.027]             base::close(...future.stdout)
[09:28:18.027]         }, add = TRUE)
[09:28:18.027]     }
[09:28:18.027]     ...future.frame <- base::sys.nframe()
[09:28:18.027]     ...future.conditions <- base::list()
[09:28:18.027]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.027]     if (FALSE) {
[09:28:18.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.027]     }
[09:28:18.027]     ...future.result <- base::tryCatch({
[09:28:18.027]         base::withCallingHandlers({
[09:28:18.027]             ...future.value <- base::withVisible(base::local({
[09:28:18.027]                 withCallingHandlers({
[09:28:18.027]                   {
[09:28:18.027]                     do.call(function(...) {
[09:28:18.027]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.027]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.027]                         ...future.globals.maxSize)) {
[09:28:18.027]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.027]                         on.exit(options(oopts), add = TRUE)
[09:28:18.027]                       }
[09:28:18.027]                       {
[09:28:18.027]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.027]                           FUN = function(jj) {
[09:28:18.027]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.027]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.027]                           })
[09:28:18.027]                       }
[09:28:18.027]                     }, args = future.call.arguments)
[09:28:18.027]                   }
[09:28:18.027]                 }, immediateCondition = function(cond) {
[09:28:18.027]                   save_rds <- function (object, pathname, ...) 
[09:28:18.027]                   {
[09:28:18.027]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.027]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.027]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.027]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.027]                         fi_tmp[["mtime"]])
[09:28:18.027]                     }
[09:28:18.027]                     tryCatch({
[09:28:18.027]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.027]                     }, error = function(ex) {
[09:28:18.027]                       msg <- conditionMessage(ex)
[09:28:18.027]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.027]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.027]                         fi_tmp[["mtime"]], msg)
[09:28:18.027]                       ex$message <- msg
[09:28:18.027]                       stop(ex)
[09:28:18.027]                     })
[09:28:18.027]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.027]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.027]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.027]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.027]                       fi <- file.info(pathname)
[09:28:18.027]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.027]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.027]                         fi[["size"]], fi[["mtime"]])
[09:28:18.027]                       stop(msg)
[09:28:18.027]                     }
[09:28:18.027]                     invisible(pathname)
[09:28:18.027]                   }
[09:28:18.027]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.027]                     rootPath = tempdir()) 
[09:28:18.027]                   {
[09:28:18.027]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.027]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.027]                       tmpdir = path, fileext = ".rds")
[09:28:18.027]                     save_rds(obj, file)
[09:28:18.027]                   }
[09:28:18.027]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.027]                   {
[09:28:18.027]                     inherits <- base::inherits
[09:28:18.027]                     invokeRestart <- base::invokeRestart
[09:28:18.027]                     is.null <- base::is.null
[09:28:18.027]                     muffled <- FALSE
[09:28:18.027]                     if (inherits(cond, "message")) {
[09:28:18.027]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.027]                       if (muffled) 
[09:28:18.027]                         invokeRestart("muffleMessage")
[09:28:18.027]                     }
[09:28:18.027]                     else if (inherits(cond, "warning")) {
[09:28:18.027]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.027]                       if (muffled) 
[09:28:18.027]                         invokeRestart("muffleWarning")
[09:28:18.027]                     }
[09:28:18.027]                     else if (inherits(cond, "condition")) {
[09:28:18.027]                       if (!is.null(pattern)) {
[09:28:18.027]                         computeRestarts <- base::computeRestarts
[09:28:18.027]                         grepl <- base::grepl
[09:28:18.027]                         restarts <- computeRestarts(cond)
[09:28:18.027]                         for (restart in restarts) {
[09:28:18.027]                           name <- restart$name
[09:28:18.027]                           if (is.null(name)) 
[09:28:18.027]                             next
[09:28:18.027]                           if (!grepl(pattern, name)) 
[09:28:18.027]                             next
[09:28:18.027]                           invokeRestart(restart)
[09:28:18.027]                           muffled <- TRUE
[09:28:18.027]                           break
[09:28:18.027]                         }
[09:28:18.027]                       }
[09:28:18.027]                     }
[09:28:18.027]                     invisible(muffled)
[09:28:18.027]                   }
[09:28:18.027]                   muffleCondition(cond)
[09:28:18.027]                 })
[09:28:18.027]             }))
[09:28:18.027]             future::FutureResult(value = ...future.value$value, 
[09:28:18.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.027]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.027]                     ...future.globalenv.names))
[09:28:18.027]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.027]         }, condition = base::local({
[09:28:18.027]             c <- base::c
[09:28:18.027]             inherits <- base::inherits
[09:28:18.027]             invokeRestart <- base::invokeRestart
[09:28:18.027]             length <- base::length
[09:28:18.027]             list <- base::list
[09:28:18.027]             seq.int <- base::seq.int
[09:28:18.027]             signalCondition <- base::signalCondition
[09:28:18.027]             sys.calls <- base::sys.calls
[09:28:18.027]             `[[` <- base::`[[`
[09:28:18.027]             `+` <- base::`+`
[09:28:18.027]             `<<-` <- base::`<<-`
[09:28:18.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.027]                   3L)]
[09:28:18.027]             }
[09:28:18.027]             function(cond) {
[09:28:18.027]                 is_error <- inherits(cond, "error")
[09:28:18.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.027]                   NULL)
[09:28:18.027]                 if (is_error) {
[09:28:18.027]                   sessionInformation <- function() {
[09:28:18.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.027]                       search = base::search(), system = base::Sys.info())
[09:28:18.027]                   }
[09:28:18.027]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.027]                     cond$call), session = sessionInformation(), 
[09:28:18.027]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.027]                   signalCondition(cond)
[09:28:18.027]                 }
[09:28:18.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.027]                 "immediateCondition"))) {
[09:28:18.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.027]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.027]                   if (TRUE && !signal) {
[09:28:18.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.027]                     {
[09:28:18.027]                       inherits <- base::inherits
[09:28:18.027]                       invokeRestart <- base::invokeRestart
[09:28:18.027]                       is.null <- base::is.null
[09:28:18.027]                       muffled <- FALSE
[09:28:18.027]                       if (inherits(cond, "message")) {
[09:28:18.027]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.027]                         if (muffled) 
[09:28:18.027]                           invokeRestart("muffleMessage")
[09:28:18.027]                       }
[09:28:18.027]                       else if (inherits(cond, "warning")) {
[09:28:18.027]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.027]                         if (muffled) 
[09:28:18.027]                           invokeRestart("muffleWarning")
[09:28:18.027]                       }
[09:28:18.027]                       else if (inherits(cond, "condition")) {
[09:28:18.027]                         if (!is.null(pattern)) {
[09:28:18.027]                           computeRestarts <- base::computeRestarts
[09:28:18.027]                           grepl <- base::grepl
[09:28:18.027]                           restarts <- computeRestarts(cond)
[09:28:18.027]                           for (restart in restarts) {
[09:28:18.027]                             name <- restart$name
[09:28:18.027]                             if (is.null(name)) 
[09:28:18.027]                               next
[09:28:18.027]                             if (!grepl(pattern, name)) 
[09:28:18.027]                               next
[09:28:18.027]                             invokeRestart(restart)
[09:28:18.027]                             muffled <- TRUE
[09:28:18.027]                             break
[09:28:18.027]                           }
[09:28:18.027]                         }
[09:28:18.027]                       }
[09:28:18.027]                       invisible(muffled)
[09:28:18.027]                     }
[09:28:18.027]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.027]                   }
[09:28:18.027]                 }
[09:28:18.027]                 else {
[09:28:18.027]                   if (TRUE) {
[09:28:18.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.027]                     {
[09:28:18.027]                       inherits <- base::inherits
[09:28:18.027]                       invokeRestart <- base::invokeRestart
[09:28:18.027]                       is.null <- base::is.null
[09:28:18.027]                       muffled <- FALSE
[09:28:18.027]                       if (inherits(cond, "message")) {
[09:28:18.027]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.027]                         if (muffled) 
[09:28:18.027]                           invokeRestart("muffleMessage")
[09:28:18.027]                       }
[09:28:18.027]                       else if (inherits(cond, "warning")) {
[09:28:18.027]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.027]                         if (muffled) 
[09:28:18.027]                           invokeRestart("muffleWarning")
[09:28:18.027]                       }
[09:28:18.027]                       else if (inherits(cond, "condition")) {
[09:28:18.027]                         if (!is.null(pattern)) {
[09:28:18.027]                           computeRestarts <- base::computeRestarts
[09:28:18.027]                           grepl <- base::grepl
[09:28:18.027]                           restarts <- computeRestarts(cond)
[09:28:18.027]                           for (restart in restarts) {
[09:28:18.027]                             name <- restart$name
[09:28:18.027]                             if (is.null(name)) 
[09:28:18.027]                               next
[09:28:18.027]                             if (!grepl(pattern, name)) 
[09:28:18.027]                               next
[09:28:18.027]                             invokeRestart(restart)
[09:28:18.027]                             muffled <- TRUE
[09:28:18.027]                             break
[09:28:18.027]                           }
[09:28:18.027]                         }
[09:28:18.027]                       }
[09:28:18.027]                       invisible(muffled)
[09:28:18.027]                     }
[09:28:18.027]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.027]                   }
[09:28:18.027]                 }
[09:28:18.027]             }
[09:28:18.027]         }))
[09:28:18.027]     }, error = function(ex) {
[09:28:18.027]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.027]                 ...future.rng), started = ...future.startTime, 
[09:28:18.027]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.027]             version = "1.8"), class = "FutureResult")
[09:28:18.027]     }, finally = {
[09:28:18.027]         if (!identical(...future.workdir, getwd())) 
[09:28:18.027]             setwd(...future.workdir)
[09:28:18.027]         {
[09:28:18.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.027]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.027]             }
[09:28:18.027]             base::options(...future.oldOptions)
[09:28:18.027]             if (.Platform$OS.type == "windows") {
[09:28:18.027]                 old_names <- names(...future.oldEnvVars)
[09:28:18.027]                 envs <- base::Sys.getenv()
[09:28:18.027]                 names <- names(envs)
[09:28:18.027]                 common <- intersect(names, old_names)
[09:28:18.027]                 added <- setdiff(names, old_names)
[09:28:18.027]                 removed <- setdiff(old_names, names)
[09:28:18.027]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.027]                   envs[common]]
[09:28:18.027]                 NAMES <- toupper(changed)
[09:28:18.027]                 args <- list()
[09:28:18.027]                 for (kk in seq_along(NAMES)) {
[09:28:18.027]                   name <- changed[[kk]]
[09:28:18.027]                   NAME <- NAMES[[kk]]
[09:28:18.027]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.027]                     next
[09:28:18.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.027]                 }
[09:28:18.027]                 NAMES <- toupper(added)
[09:28:18.027]                 for (kk in seq_along(NAMES)) {
[09:28:18.027]                   name <- added[[kk]]
[09:28:18.027]                   NAME <- NAMES[[kk]]
[09:28:18.027]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.027]                     next
[09:28:18.027]                   args[[name]] <- ""
[09:28:18.027]                 }
[09:28:18.027]                 NAMES <- toupper(removed)
[09:28:18.027]                 for (kk in seq_along(NAMES)) {
[09:28:18.027]                   name <- removed[[kk]]
[09:28:18.027]                   NAME <- NAMES[[kk]]
[09:28:18.027]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.027]                     next
[09:28:18.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.027]                 }
[09:28:18.027]                 if (length(args) > 0) 
[09:28:18.027]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.027]             }
[09:28:18.027]             else {
[09:28:18.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.027]             }
[09:28:18.027]             {
[09:28:18.027]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.027]                   0L) {
[09:28:18.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.027]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.027]                   base::options(opts)
[09:28:18.027]                 }
[09:28:18.027]                 {
[09:28:18.027]                   {
[09:28:18.027]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.027]                     NULL
[09:28:18.027]                   }
[09:28:18.027]                   options(future.plan = NULL)
[09:28:18.027]                   if (is.na(NA_character_)) 
[09:28:18.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.027]                     .init = FALSE)
[09:28:18.027]                 }
[09:28:18.027]             }
[09:28:18.027]         }
[09:28:18.027]     })
[09:28:18.027]     if (TRUE) {
[09:28:18.027]         base::sink(type = "output", split = FALSE)
[09:28:18.027]         if (TRUE) {
[09:28:18.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.027]         }
[09:28:18.027]         else {
[09:28:18.027]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.027]         }
[09:28:18.027]         base::close(...future.stdout)
[09:28:18.027]         ...future.stdout <- NULL
[09:28:18.027]     }
[09:28:18.027]     ...future.result$conditions <- ...future.conditions
[09:28:18.027]     ...future.result$finished <- base::Sys.time()
[09:28:18.027]     ...future.result
[09:28:18.027] }
[09:28:18.029] assign_globals() ...
[09:28:18.029] List of 5
[09:28:18.029]  $ future.call.arguments    : list()
[09:28:18.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.029]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:18.029]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:18.029]  $ ...future.elements_ii    :List of 1
[09:28:18.029]   ..$ : num [1:4] 1 3 1 7
[09:28:18.029]  $ ...future.seeds_ii       : NULL
[09:28:18.029]  $ ...future.globals.maxSize: num Inf
[09:28:18.029]  - attr(*, "resolved")= logi FALSE
[09:28:18.029]  - attr(*, "total_size")= num NA
[09:28:18.029]  - attr(*, "where")=List of 5
[09:28:18.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.029]  - attr(*, "already-done")= logi TRUE
[09:28:18.034] - copied ‘future.call.arguments’ to environment
[09:28:18.034] - copied ‘...future.FUN’ to environment
[09:28:18.034] - copied ‘...future.elements_ii’ to environment
[09:28:18.034] - copied ‘...future.seeds_ii’ to environment
[09:28:18.034] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.034] assign_globals() ... done
[09:28:18.034] requestCore(): workers = 2
[09:28:18.036] MulticoreFuture started
[09:28:18.037] - Launch lazy future ... done
[09:28:18.037] run() for ‘MulticoreFuture’ ... done
[09:28:18.037] Created future:
[09:28:18.037] plan(): Setting new future strategy stack:
[09:28:18.038] List of future strategies:
[09:28:18.038] 1. sequential:
[09:28:18.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.038]    - tweaked: FALSE
[09:28:18.038]    - call: NULL
[09:28:18.038] plan(): nbrOfWorkers() = 1
[09:28:18.041] plan(): Setting new future strategy stack:
[09:28:18.041] List of future strategies:
[09:28:18.041] 1. multicore:
[09:28:18.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.041]    - tweaked: FALSE
[09:28:18.041]    - call: plan(strategy)
[09:28:18.046] plan(): nbrOfWorkers() = 2
[09:28:18.037] MulticoreFuture:
[09:28:18.037] Label: ‘future_apply-1’
[09:28:18.037] Expression:
[09:28:18.037] {
[09:28:18.037]     do.call(function(...) {
[09:28:18.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.037]             on.exit(options(oopts), add = TRUE)
[09:28:18.037]         }
[09:28:18.037]         {
[09:28:18.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.037]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.037]             })
[09:28:18.037]         }
[09:28:18.037]     }, args = future.call.arguments)
[09:28:18.037] }
[09:28:18.037] Lazy evaluation: FALSE
[09:28:18.037] Asynchronous evaluation: TRUE
[09:28:18.037] Local evaluation: TRUE
[09:28:18.037] Environment: R_GlobalEnv
[09:28:18.037] Capture standard output: TRUE
[09:28:18.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.037] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.037] Packages: <none>
[09:28:18.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.037] Resolved: TRUE
[09:28:18.037] Value: <not collected>
[09:28:18.037] Conditions captured: <none>
[09:28:18.037] Early signaling: FALSE
[09:28:18.037] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.037] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.047] Chunk #1 of 2 ... DONE
[09:28:18.047] Chunk #2 of 2 ...
[09:28:18.047]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.048]  - seeds: <none>
[09:28:18.048]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.048] getGlobalsAndPackages() ...
[09:28:18.048] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.048] Resolving globals: FALSE
[09:28:18.048] Tweak future expression to call with '...' arguments ...
[09:28:18.049] {
[09:28:18.049]     do.call(function(...) {
[09:28:18.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.049]             on.exit(options(oopts), add = TRUE)
[09:28:18.049]         }
[09:28:18.049]         {
[09:28:18.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.049]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.049]             })
[09:28:18.049]         }
[09:28:18.049]     }, args = future.call.arguments)
[09:28:18.049] }
[09:28:18.049] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.050] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.050] 
[09:28:18.050] getGlobalsAndPackages() ... DONE
[09:28:18.050] run() for ‘Future’ ...
[09:28:18.051] - state: ‘created’
[09:28:18.051] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.055] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.055]   - Field: ‘label’
[09:28:18.056]   - Field: ‘local’
[09:28:18.056]   - Field: ‘owner’
[09:28:18.056]   - Field: ‘envir’
[09:28:18.056]   - Field: ‘workers’
[09:28:18.056]   - Field: ‘packages’
[09:28:18.056]   - Field: ‘gc’
[09:28:18.057]   - Field: ‘job’
[09:28:18.057]   - Field: ‘conditions’
[09:28:18.057]   - Field: ‘expr’
[09:28:18.057]   - Field: ‘uuid’
[09:28:18.057]   - Field: ‘seed’
[09:28:18.057]   - Field: ‘version’
[09:28:18.057]   - Field: ‘result’
[09:28:18.058]   - Field: ‘asynchronous’
[09:28:18.058]   - Field: ‘calls’
[09:28:18.058]   - Field: ‘globals’
[09:28:18.058]   - Field: ‘stdout’
[09:28:18.058]   - Field: ‘earlySignal’
[09:28:18.058]   - Field: ‘lazy’
[09:28:18.058]   - Field: ‘state’
[09:28:18.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.059] - Launch lazy future ...
[09:28:18.059] Packages needed by the future expression (n = 0): <none>
[09:28:18.059] Packages needed by future strategies (n = 0): <none>
[09:28:18.060] {
[09:28:18.060]     {
[09:28:18.060]         {
[09:28:18.060]             ...future.startTime <- base::Sys.time()
[09:28:18.060]             {
[09:28:18.060]                 {
[09:28:18.060]                   {
[09:28:18.060]                     {
[09:28:18.060]                       base::local({
[09:28:18.060]                         has_future <- base::requireNamespace("future", 
[09:28:18.060]                           quietly = TRUE)
[09:28:18.060]                         if (has_future) {
[09:28:18.060]                           ns <- base::getNamespace("future")
[09:28:18.060]                           version <- ns[[".package"]][["version"]]
[09:28:18.060]                           if (is.null(version)) 
[09:28:18.060]                             version <- utils::packageVersion("future")
[09:28:18.060]                         }
[09:28:18.060]                         else {
[09:28:18.060]                           version <- NULL
[09:28:18.060]                         }
[09:28:18.060]                         if (!has_future || version < "1.8.0") {
[09:28:18.060]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.060]                             "", base::R.version$version.string), 
[09:28:18.060]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.060]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.060]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.060]                               "release", "version")], collapse = " "), 
[09:28:18.060]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.060]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.060]                             info)
[09:28:18.060]                           info <- base::paste(info, collapse = "; ")
[09:28:18.060]                           if (!has_future) {
[09:28:18.060]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.060]                               info)
[09:28:18.060]                           }
[09:28:18.060]                           else {
[09:28:18.060]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.060]                               info, version)
[09:28:18.060]                           }
[09:28:18.060]                           base::stop(msg)
[09:28:18.060]                         }
[09:28:18.060]                       })
[09:28:18.060]                     }
[09:28:18.060]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.060]                     base::options(mc.cores = 1L)
[09:28:18.060]                   }
[09:28:18.060]                   ...future.strategy.old <- future::plan("list")
[09:28:18.060]                   options(future.plan = NULL)
[09:28:18.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.060]                 }
[09:28:18.060]                 ...future.workdir <- getwd()
[09:28:18.060]             }
[09:28:18.060]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.060]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.060]         }
[09:28:18.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.060]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.060]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.060]             base::names(...future.oldOptions))
[09:28:18.060]     }
[09:28:18.060]     if (FALSE) {
[09:28:18.060]     }
[09:28:18.060]     else {
[09:28:18.060]         if (TRUE) {
[09:28:18.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.060]                 open = "w")
[09:28:18.060]         }
[09:28:18.060]         else {
[09:28:18.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.060]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.060]         }
[09:28:18.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.060]             base::sink(type = "output", split = FALSE)
[09:28:18.060]             base::close(...future.stdout)
[09:28:18.060]         }, add = TRUE)
[09:28:18.060]     }
[09:28:18.060]     ...future.frame <- base::sys.nframe()
[09:28:18.060]     ...future.conditions <- base::list()
[09:28:18.060]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.060]     if (FALSE) {
[09:28:18.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.060]     }
[09:28:18.060]     ...future.result <- base::tryCatch({
[09:28:18.060]         base::withCallingHandlers({
[09:28:18.060]             ...future.value <- base::withVisible(base::local({
[09:28:18.060]                 withCallingHandlers({
[09:28:18.060]                   {
[09:28:18.060]                     do.call(function(...) {
[09:28:18.060]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.060]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.060]                         ...future.globals.maxSize)) {
[09:28:18.060]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.060]                         on.exit(options(oopts), add = TRUE)
[09:28:18.060]                       }
[09:28:18.060]                       {
[09:28:18.060]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.060]                           FUN = function(jj) {
[09:28:18.060]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.060]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.060]                           })
[09:28:18.060]                       }
[09:28:18.060]                     }, args = future.call.arguments)
[09:28:18.060]                   }
[09:28:18.060]                 }, immediateCondition = function(cond) {
[09:28:18.060]                   save_rds <- function (object, pathname, ...) 
[09:28:18.060]                   {
[09:28:18.060]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.060]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.060]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.060]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.060]                         fi_tmp[["mtime"]])
[09:28:18.060]                     }
[09:28:18.060]                     tryCatch({
[09:28:18.060]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.060]                     }, error = function(ex) {
[09:28:18.060]                       msg <- conditionMessage(ex)
[09:28:18.060]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.060]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.060]                         fi_tmp[["mtime"]], msg)
[09:28:18.060]                       ex$message <- msg
[09:28:18.060]                       stop(ex)
[09:28:18.060]                     })
[09:28:18.060]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.060]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.060]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.060]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.060]                       fi <- file.info(pathname)
[09:28:18.060]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.060]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.060]                         fi[["size"]], fi[["mtime"]])
[09:28:18.060]                       stop(msg)
[09:28:18.060]                     }
[09:28:18.060]                     invisible(pathname)
[09:28:18.060]                   }
[09:28:18.060]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.060]                     rootPath = tempdir()) 
[09:28:18.060]                   {
[09:28:18.060]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.060]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.060]                       tmpdir = path, fileext = ".rds")
[09:28:18.060]                     save_rds(obj, file)
[09:28:18.060]                   }
[09:28:18.060]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.060]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.060]                   {
[09:28:18.060]                     inherits <- base::inherits
[09:28:18.060]                     invokeRestart <- base::invokeRestart
[09:28:18.060]                     is.null <- base::is.null
[09:28:18.060]                     muffled <- FALSE
[09:28:18.060]                     if (inherits(cond, "message")) {
[09:28:18.060]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.060]                       if (muffled) 
[09:28:18.060]                         invokeRestart("muffleMessage")
[09:28:18.060]                     }
[09:28:18.060]                     else if (inherits(cond, "warning")) {
[09:28:18.060]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.060]                       if (muffled) 
[09:28:18.060]                         invokeRestart("muffleWarning")
[09:28:18.060]                     }
[09:28:18.060]                     else if (inherits(cond, "condition")) {
[09:28:18.060]                       if (!is.null(pattern)) {
[09:28:18.060]                         computeRestarts <- base::computeRestarts
[09:28:18.060]                         grepl <- base::grepl
[09:28:18.060]                         restarts <- computeRestarts(cond)
[09:28:18.060]                         for (restart in restarts) {
[09:28:18.060]                           name <- restart$name
[09:28:18.060]                           if (is.null(name)) 
[09:28:18.060]                             next
[09:28:18.060]                           if (!grepl(pattern, name)) 
[09:28:18.060]                             next
[09:28:18.060]                           invokeRestart(restart)
[09:28:18.060]                           muffled <- TRUE
[09:28:18.060]                           break
[09:28:18.060]                         }
[09:28:18.060]                       }
[09:28:18.060]                     }
[09:28:18.060]                     invisible(muffled)
[09:28:18.060]                   }
[09:28:18.060]                   muffleCondition(cond)
[09:28:18.060]                 })
[09:28:18.060]             }))
[09:28:18.060]             future::FutureResult(value = ...future.value$value, 
[09:28:18.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.060]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.060]                     ...future.globalenv.names))
[09:28:18.060]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.060]         }, condition = base::local({
[09:28:18.060]             c <- base::c
[09:28:18.060]             inherits <- base::inherits
[09:28:18.060]             invokeRestart <- base::invokeRestart
[09:28:18.060]             length <- base::length
[09:28:18.060]             list <- base::list
[09:28:18.060]             seq.int <- base::seq.int
[09:28:18.060]             signalCondition <- base::signalCondition
[09:28:18.060]             sys.calls <- base::sys.calls
[09:28:18.060]             `[[` <- base::`[[`
[09:28:18.060]             `+` <- base::`+`
[09:28:18.060]             `<<-` <- base::`<<-`
[09:28:18.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.060]                   3L)]
[09:28:18.060]             }
[09:28:18.060]             function(cond) {
[09:28:18.060]                 is_error <- inherits(cond, "error")
[09:28:18.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.060]                   NULL)
[09:28:18.060]                 if (is_error) {
[09:28:18.060]                   sessionInformation <- function() {
[09:28:18.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.060]                       search = base::search(), system = base::Sys.info())
[09:28:18.060]                   }
[09:28:18.060]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.060]                     cond$call), session = sessionInformation(), 
[09:28:18.060]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.060]                   signalCondition(cond)
[09:28:18.060]                 }
[09:28:18.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.060]                 "immediateCondition"))) {
[09:28:18.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.060]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.060]                   if (TRUE && !signal) {
[09:28:18.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.060]                     {
[09:28:18.060]                       inherits <- base::inherits
[09:28:18.060]                       invokeRestart <- base::invokeRestart
[09:28:18.060]                       is.null <- base::is.null
[09:28:18.060]                       muffled <- FALSE
[09:28:18.060]                       if (inherits(cond, "message")) {
[09:28:18.060]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.060]                         if (muffled) 
[09:28:18.060]                           invokeRestart("muffleMessage")
[09:28:18.060]                       }
[09:28:18.060]                       else if (inherits(cond, "warning")) {
[09:28:18.060]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.060]                         if (muffled) 
[09:28:18.060]                           invokeRestart("muffleWarning")
[09:28:18.060]                       }
[09:28:18.060]                       else if (inherits(cond, "condition")) {
[09:28:18.060]                         if (!is.null(pattern)) {
[09:28:18.060]                           computeRestarts <- base::computeRestarts
[09:28:18.060]                           grepl <- base::grepl
[09:28:18.060]                           restarts <- computeRestarts(cond)
[09:28:18.060]                           for (restart in restarts) {
[09:28:18.060]                             name <- restart$name
[09:28:18.060]                             if (is.null(name)) 
[09:28:18.060]                               next
[09:28:18.060]                             if (!grepl(pattern, name)) 
[09:28:18.060]                               next
[09:28:18.060]                             invokeRestart(restart)
[09:28:18.060]                             muffled <- TRUE
[09:28:18.060]                             break
[09:28:18.060]                           }
[09:28:18.060]                         }
[09:28:18.060]                       }
[09:28:18.060]                       invisible(muffled)
[09:28:18.060]                     }
[09:28:18.060]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.060]                   }
[09:28:18.060]                 }
[09:28:18.060]                 else {
[09:28:18.060]                   if (TRUE) {
[09:28:18.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.060]                     {
[09:28:18.060]                       inherits <- base::inherits
[09:28:18.060]                       invokeRestart <- base::invokeRestart
[09:28:18.060]                       is.null <- base::is.null
[09:28:18.060]                       muffled <- FALSE
[09:28:18.060]                       if (inherits(cond, "message")) {
[09:28:18.060]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.060]                         if (muffled) 
[09:28:18.060]                           invokeRestart("muffleMessage")
[09:28:18.060]                       }
[09:28:18.060]                       else if (inherits(cond, "warning")) {
[09:28:18.060]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.060]                         if (muffled) 
[09:28:18.060]                           invokeRestart("muffleWarning")
[09:28:18.060]                       }
[09:28:18.060]                       else if (inherits(cond, "condition")) {
[09:28:18.060]                         if (!is.null(pattern)) {
[09:28:18.060]                           computeRestarts <- base::computeRestarts
[09:28:18.060]                           grepl <- base::grepl
[09:28:18.060]                           restarts <- computeRestarts(cond)
[09:28:18.060]                           for (restart in restarts) {
[09:28:18.060]                             name <- restart$name
[09:28:18.060]                             if (is.null(name)) 
[09:28:18.060]                               next
[09:28:18.060]                             if (!grepl(pattern, name)) 
[09:28:18.060]                               next
[09:28:18.060]                             invokeRestart(restart)
[09:28:18.060]                             muffled <- TRUE
[09:28:18.060]                             break
[09:28:18.060]                           }
[09:28:18.060]                         }
[09:28:18.060]                       }
[09:28:18.060]                       invisible(muffled)
[09:28:18.060]                     }
[09:28:18.060]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.060]                   }
[09:28:18.060]                 }
[09:28:18.060]             }
[09:28:18.060]         }))
[09:28:18.060]     }, error = function(ex) {
[09:28:18.060]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.060]                 ...future.rng), started = ...future.startTime, 
[09:28:18.060]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.060]             version = "1.8"), class = "FutureResult")
[09:28:18.060]     }, finally = {
[09:28:18.060]         if (!identical(...future.workdir, getwd())) 
[09:28:18.060]             setwd(...future.workdir)
[09:28:18.060]         {
[09:28:18.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.060]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.060]             }
[09:28:18.060]             base::options(...future.oldOptions)
[09:28:18.060]             if (.Platform$OS.type == "windows") {
[09:28:18.060]                 old_names <- names(...future.oldEnvVars)
[09:28:18.060]                 envs <- base::Sys.getenv()
[09:28:18.060]                 names <- names(envs)
[09:28:18.060]                 common <- intersect(names, old_names)
[09:28:18.060]                 added <- setdiff(names, old_names)
[09:28:18.060]                 removed <- setdiff(old_names, names)
[09:28:18.060]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.060]                   envs[common]]
[09:28:18.060]                 NAMES <- toupper(changed)
[09:28:18.060]                 args <- list()
[09:28:18.060]                 for (kk in seq_along(NAMES)) {
[09:28:18.060]                   name <- changed[[kk]]
[09:28:18.060]                   NAME <- NAMES[[kk]]
[09:28:18.060]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.060]                     next
[09:28:18.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.060]                 }
[09:28:18.060]                 NAMES <- toupper(added)
[09:28:18.060]                 for (kk in seq_along(NAMES)) {
[09:28:18.060]                   name <- added[[kk]]
[09:28:18.060]                   NAME <- NAMES[[kk]]
[09:28:18.060]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.060]                     next
[09:28:18.060]                   args[[name]] <- ""
[09:28:18.060]                 }
[09:28:18.060]                 NAMES <- toupper(removed)
[09:28:18.060]                 for (kk in seq_along(NAMES)) {
[09:28:18.060]                   name <- removed[[kk]]
[09:28:18.060]                   NAME <- NAMES[[kk]]
[09:28:18.060]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.060]                     next
[09:28:18.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.060]                 }
[09:28:18.060]                 if (length(args) > 0) 
[09:28:18.060]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.060]             }
[09:28:18.060]             else {
[09:28:18.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.060]             }
[09:28:18.060]             {
[09:28:18.060]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.060]                   0L) {
[09:28:18.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.060]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.060]                   base::options(opts)
[09:28:18.060]                 }
[09:28:18.060]                 {
[09:28:18.060]                   {
[09:28:18.060]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.060]                     NULL
[09:28:18.060]                   }
[09:28:18.060]                   options(future.plan = NULL)
[09:28:18.060]                   if (is.na(NA_character_)) 
[09:28:18.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.060]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.060]                     .init = FALSE)
[09:28:18.060]                 }
[09:28:18.060]             }
[09:28:18.060]         }
[09:28:18.060]     })
[09:28:18.060]     if (TRUE) {
[09:28:18.060]         base::sink(type = "output", split = FALSE)
[09:28:18.060]         if (TRUE) {
[09:28:18.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.060]         }
[09:28:18.060]         else {
[09:28:18.060]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.060]         }
[09:28:18.060]         base::close(...future.stdout)
[09:28:18.060]         ...future.stdout <- NULL
[09:28:18.060]     }
[09:28:18.060]     ...future.result$conditions <- ...future.conditions
[09:28:18.060]     ...future.result$finished <- base::Sys.time()
[09:28:18.060]     ...future.result
[09:28:18.060] }
[09:28:18.063] assign_globals() ...
[09:28:18.063] List of 5
[09:28:18.063]  $ future.call.arguments    : list()
[09:28:18.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.063]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:18.063]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:18.063]  $ ...future.elements_ii    :List of 1
[09:28:18.063]   ..$ : num [1:4] 2 4 6 8
[09:28:18.063]  $ ...future.seeds_ii       : NULL
[09:28:18.063]  $ ...future.globals.maxSize: num Inf
[09:28:18.063]  - attr(*, "resolved")= logi FALSE
[09:28:18.063]  - attr(*, "total_size")= num NA
[09:28:18.063]  - attr(*, "where")=List of 5
[09:28:18.063]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.063]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.063]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.063]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.063]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.063]  - attr(*, "already-done")= logi TRUE
[09:28:18.073] - copied ‘future.call.arguments’ to environment
[09:28:18.073] - copied ‘...future.FUN’ to environment
[09:28:18.073] - copied ‘...future.elements_ii’ to environment
[09:28:18.074] - copied ‘...future.seeds_ii’ to environment
[09:28:18.074] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.074] assign_globals() ... done
[09:28:18.074] requestCore(): workers = 2
[09:28:18.077] MulticoreFuture started
[09:28:18.077] - Launch lazy future ... done
[09:28:18.078] run() for ‘MulticoreFuture’ ... done
[09:28:18.078] plan(): Setting new future strategy stack:
[09:28:18.079] Created future:
[09:28:18.078] List of future strategies:
[09:28:18.078] 1. sequential:
[09:28:18.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.078]    - tweaked: FALSE
[09:28:18.078]    - call: NULL
[09:28:18.080] plan(): nbrOfWorkers() = 1
[09:28:18.082] plan(): Setting new future strategy stack:
[09:28:18.082] List of future strategies:
[09:28:18.082] 1. multicore:
[09:28:18.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.082]    - tweaked: FALSE
[09:28:18.082]    - call: plan(strategy)
[09:28:18.088] plan(): nbrOfWorkers() = 2
[09:28:18.079] MulticoreFuture:
[09:28:18.079] Label: ‘future_apply-2’
[09:28:18.079] Expression:
[09:28:18.079] {
[09:28:18.079]     do.call(function(...) {
[09:28:18.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.079]             on.exit(options(oopts), add = TRUE)
[09:28:18.079]         }
[09:28:18.079]         {
[09:28:18.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.079]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.079]             })
[09:28:18.079]         }
[09:28:18.079]     }, args = future.call.arguments)
[09:28:18.079] }
[09:28:18.079] Lazy evaluation: FALSE
[09:28:18.079] Asynchronous evaluation: TRUE
[09:28:18.079] Local evaluation: TRUE
[09:28:18.079] Environment: R_GlobalEnv
[09:28:18.079] Capture standard output: TRUE
[09:28:18.079] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.079] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.079] Packages: <none>
[09:28:18.079] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.079] Resolved: TRUE
[09:28:18.079] Value: <not collected>
[09:28:18.079] Conditions captured: <none>
[09:28:18.079] Early signaling: FALSE
[09:28:18.079] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.079] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.089] Chunk #2 of 2 ... DONE
[09:28:18.089] Launching 2 futures (chunks) ... DONE
[09:28:18.089] Resolving 2 futures (chunks) ...
[09:28:18.089] resolve() on list ...
[09:28:18.090]  recursive: 0
[09:28:18.090]  length: 2
[09:28:18.090] 
[09:28:18.090] Future #1
[09:28:18.091] result() for MulticoreFuture ...
[09:28:18.092] result() for MulticoreFuture ...
[09:28:18.092] result() for MulticoreFuture ... done
[09:28:18.092] result() for MulticoreFuture ... done
[09:28:18.092] result() for MulticoreFuture ...
[09:28:18.092] result() for MulticoreFuture ... done
[09:28:18.092] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.093] - nx: 2
[09:28:18.093] - relay: TRUE
[09:28:18.093] - stdout: TRUE
[09:28:18.093] - signal: TRUE
[09:28:18.093] - resignal: FALSE
[09:28:18.093] - force: TRUE
[09:28:18.093] - relayed: [n=2] FALSE, FALSE
[09:28:18.094] - queued futures: [n=2] FALSE, FALSE
[09:28:18.094]  - until=1
[09:28:18.094]  - relaying element #1
[09:28:18.094] result() for MulticoreFuture ...
[09:28:18.094] result() for MulticoreFuture ... done
[09:28:18.094] result() for MulticoreFuture ...
[09:28:18.095] result() for MulticoreFuture ... done
[09:28:18.095] result() for MulticoreFuture ...
[09:28:18.095] result() for MulticoreFuture ... done
[09:28:18.095] result() for MulticoreFuture ...
[09:28:18.095] result() for MulticoreFuture ... done
[09:28:18.095] - relayed: [n=2] TRUE, FALSE
[09:28:18.095] - queued futures: [n=2] TRUE, FALSE
[09:28:18.096] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.096]  length: 1 (resolved future 1)
[09:28:18.096] Future #2
[09:28:18.096] result() for MulticoreFuture ...
[09:28:18.097] result() for MulticoreFuture ...
[09:28:18.097] result() for MulticoreFuture ... done
[09:28:18.097] result() for MulticoreFuture ... done
[09:28:18.097] result() for MulticoreFuture ...
[09:28:18.097] result() for MulticoreFuture ... done
[09:28:18.098] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.098] - nx: 2
[09:28:18.098] - relay: TRUE
[09:28:18.098] - stdout: TRUE
[09:28:18.098] - signal: TRUE
[09:28:18.098] - resignal: FALSE
[09:28:18.098] - force: TRUE
[09:28:18.098] - relayed: [n=2] TRUE, FALSE
[09:28:18.098] - queued futures: [n=2] TRUE, FALSE
[09:28:18.099]  - until=2
[09:28:18.099]  - relaying element #2
[09:28:18.099] result() for MulticoreFuture ...
[09:28:18.099] result() for MulticoreFuture ... done
[09:28:18.099] result() for MulticoreFuture ...
[09:28:18.099] result() for MulticoreFuture ... done
[09:28:18.099] result() for MulticoreFuture ...
[09:28:18.100] result() for MulticoreFuture ... done
[09:28:18.100] result() for MulticoreFuture ...
[09:28:18.100] result() for MulticoreFuture ... done
[09:28:18.100] - relayed: [n=2] TRUE, TRUE
[09:28:18.100] - queued futures: [n=2] TRUE, TRUE
[09:28:18.100] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.100]  length: 0 (resolved future 2)
[09:28:18.100] Relaying remaining futures
[09:28:18.100] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.100] - nx: 2
[09:28:18.101] - relay: TRUE
[09:28:18.101] - stdout: TRUE
[09:28:18.101] - signal: TRUE
[09:28:18.101] - resignal: FALSE
[09:28:18.101] - force: TRUE
[09:28:18.101] - relayed: [n=2] TRUE, TRUE
[09:28:18.101] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.101] - relayed: [n=2] TRUE, TRUE
[09:28:18.101] - queued futures: [n=2] TRUE, TRUE
[09:28:18.102] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.102] resolve() on list ... DONE
[09:28:18.102] result() for MulticoreFuture ...
[09:28:18.102] result() for MulticoreFuture ... done
[09:28:18.102] result() for MulticoreFuture ...
[09:28:18.102] result() for MulticoreFuture ... done
[09:28:18.102] result() for MulticoreFuture ...
[09:28:18.102] result() for MulticoreFuture ... done
[09:28:18.103] result() for MulticoreFuture ...
[09:28:18.103] result() for MulticoreFuture ... done
[09:28:18.103]  - Number of value chunks collected: 2
[09:28:18.103] Resolving 2 futures (chunks) ... DONE
[09:28:18.103] Reducing values from 2 chunks ...
[09:28:18.103]  - Number of values collected after concatenation: 2
[09:28:18.103]  - Number of values expected: 2
[09:28:18.103] Reducing values from 2 chunks ... DONE
[09:28:18.103] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:18.104] getGlobalsAndPackagesXApply() ...
[09:28:18.105]  - future.globals: TRUE
[09:28:18.105] getGlobalsAndPackages() ...
[09:28:18.105] Searching for globals...
[09:28:18.106] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:18.106] Searching for globals ... DONE
[09:28:18.106] Resolving globals: FALSE
[09:28:18.107] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:18.107] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:18.107] - globals: [1] ‘FUN’
[09:28:18.108] - packages: [1] ‘stats’
[09:28:18.108] getGlobalsAndPackages() ... DONE
[09:28:18.108]  - globals found/used: [n=1] ‘FUN’
[09:28:18.108]  - needed namespaces: [n=1] ‘stats’
[09:28:18.108] Finding globals ... DONE
[09:28:18.108]  - use_args: TRUE
[09:28:18.108]  - Getting '...' globals ...
[09:28:18.109] resolve() on list ...
[09:28:18.109]  recursive: 0
[09:28:18.109]  length: 1
[09:28:18.109]  elements: ‘...’
[09:28:18.109]  length: 0 (resolved future 1)
[09:28:18.109] resolve() on list ... DONE
[09:28:18.109]    - '...' content: [n=0] 
[09:28:18.109] List of 1
[09:28:18.109]  $ ...: list()
[09:28:18.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.109]  - attr(*, "where")=List of 1
[09:28:18.109]   ..$ ...:<environment: 0x559ba4175060> 
[09:28:18.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.109]  - attr(*, "resolved")= logi TRUE
[09:28:18.109]  - attr(*, "total_size")= num NA
[09:28:18.112]  - Getting '...' globals ... DONE
[09:28:18.112] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.113] List of 2
[09:28:18.113]  $ ...future.FUN:function (x, ...)  
[09:28:18.113]  $ ...          : list()
[09:28:18.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.113]  - attr(*, "where")=List of 2
[09:28:18.113]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.113]   ..$ ...          :<environment: 0x559ba4175060> 
[09:28:18.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.113]  - attr(*, "resolved")= logi FALSE
[09:28:18.113]  - attr(*, "total_size")= num 1248
[09:28:18.117] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:18.118] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.121] future_lapply() ...
[09:28:18.125] Number of chunks: 2
[09:28:18.125] getGlobalsAndPackagesXApply() ...
[09:28:18.125]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.125]  - use_args: TRUE
[09:28:18.126] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.126] List of 2
[09:28:18.126]  $ ...          : list()
[09:28:18.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.126]  $ ...future.FUN:function (x, ...)  
[09:28:18.126]  - attr(*, "where")=List of 2
[09:28:18.126]   ..$ ...          :<environment: 0x559ba4175060> 
[09:28:18.126]   ..$ ...future.FUN:<environment: namespace:stats> 
[09:28:18.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.126]  - attr(*, "resolved")= logi FALSE
[09:28:18.126]  - attr(*, "total_size")= num NA
[09:28:18.128] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:18.128] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.129] Number of futures (= number of chunks): 2
[09:28:18.129] Launching 2 futures (chunks) ...
[09:28:18.129] Chunk #1 of 2 ...
[09:28:18.129]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.129]  - seeds: <none>
[09:28:18.129]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.129] getGlobalsAndPackages() ...
[09:28:18.129] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.130] Resolving globals: FALSE
[09:28:18.130] Tweak future expression to call with '...' arguments ...
[09:28:18.130] {
[09:28:18.130]     do.call(function(...) {
[09:28:18.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.130]             on.exit(options(oopts), add = TRUE)
[09:28:18.130]         }
[09:28:18.130]         {
[09:28:18.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.130]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.130]             })
[09:28:18.130]         }
[09:28:18.130]     }, args = future.call.arguments)
[09:28:18.130] }
[09:28:18.130] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.130] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.131] - packages: [1] ‘stats’
[09:28:18.131] getGlobalsAndPackages() ... DONE
[09:28:18.131] run() for ‘Future’ ...
[09:28:18.131] - state: ‘created’
[09:28:18.131] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.135] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.135]   - Field: ‘label’
[09:28:18.135]   - Field: ‘local’
[09:28:18.135]   - Field: ‘owner’
[09:28:18.135]   - Field: ‘envir’
[09:28:18.135]   - Field: ‘workers’
[09:28:18.135]   - Field: ‘packages’
[09:28:18.135]   - Field: ‘gc’
[09:28:18.136]   - Field: ‘job’
[09:28:18.136]   - Field: ‘conditions’
[09:28:18.136]   - Field: ‘expr’
[09:28:18.136]   - Field: ‘uuid’
[09:28:18.136]   - Field: ‘seed’
[09:28:18.136]   - Field: ‘version’
[09:28:18.136]   - Field: ‘result’
[09:28:18.136]   - Field: ‘asynchronous’
[09:28:18.136]   - Field: ‘calls’
[09:28:18.136]   - Field: ‘globals’
[09:28:18.136]   - Field: ‘stdout’
[09:28:18.137]   - Field: ‘earlySignal’
[09:28:18.137]   - Field: ‘lazy’
[09:28:18.137]   - Field: ‘state’
[09:28:18.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.137] - Launch lazy future ...
[09:28:18.137] Packages needed by the future expression (n = 1): ‘stats’
[09:28:18.137] Packages needed by future strategies (n = 0): <none>
[09:28:18.138] {
[09:28:18.138]     {
[09:28:18.138]         {
[09:28:18.138]             ...future.startTime <- base::Sys.time()
[09:28:18.138]             {
[09:28:18.138]                 {
[09:28:18.138]                   {
[09:28:18.138]                     {
[09:28:18.138]                       {
[09:28:18.138]                         base::local({
[09:28:18.138]                           has_future <- base::requireNamespace("future", 
[09:28:18.138]                             quietly = TRUE)
[09:28:18.138]                           if (has_future) {
[09:28:18.138]                             ns <- base::getNamespace("future")
[09:28:18.138]                             version <- ns[[".package"]][["version"]]
[09:28:18.138]                             if (is.null(version)) 
[09:28:18.138]                               version <- utils::packageVersion("future")
[09:28:18.138]                           }
[09:28:18.138]                           else {
[09:28:18.138]                             version <- NULL
[09:28:18.138]                           }
[09:28:18.138]                           if (!has_future || version < "1.8.0") {
[09:28:18.138]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.138]                               "", base::R.version$version.string), 
[09:28:18.138]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:18.138]                                 base::R.version$platform, 8 * 
[09:28:18.138]                                   base::.Machine$sizeof.pointer), 
[09:28:18.138]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.138]                                 "release", "version")], collapse = " "), 
[09:28:18.138]                               hostname = base::Sys.info()[["nodename"]])
[09:28:18.138]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.138]                               info)
[09:28:18.138]                             info <- base::paste(info, collapse = "; ")
[09:28:18.138]                             if (!has_future) {
[09:28:18.138]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.138]                                 info)
[09:28:18.138]                             }
[09:28:18.138]                             else {
[09:28:18.138]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.138]                                 info, version)
[09:28:18.138]                             }
[09:28:18.138]                             base::stop(msg)
[09:28:18.138]                           }
[09:28:18.138]                         })
[09:28:18.138]                       }
[09:28:18.138]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.138]                       base::options(mc.cores = 1L)
[09:28:18.138]                     }
[09:28:18.138]                     base::local({
[09:28:18.138]                       for (pkg in "stats") {
[09:28:18.138]                         base::loadNamespace(pkg)
[09:28:18.138]                         base::library(pkg, character.only = TRUE)
[09:28:18.138]                       }
[09:28:18.138]                     })
[09:28:18.138]                   }
[09:28:18.138]                   ...future.strategy.old <- future::plan("list")
[09:28:18.138]                   options(future.plan = NULL)
[09:28:18.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.138]                 }
[09:28:18.138]                 ...future.workdir <- getwd()
[09:28:18.138]             }
[09:28:18.138]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.138]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.138]         }
[09:28:18.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.138]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.138]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.138]             base::names(...future.oldOptions))
[09:28:18.138]     }
[09:28:18.138]     if (FALSE) {
[09:28:18.138]     }
[09:28:18.138]     else {
[09:28:18.138]         if (TRUE) {
[09:28:18.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.138]                 open = "w")
[09:28:18.138]         }
[09:28:18.138]         else {
[09:28:18.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.138]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.138]         }
[09:28:18.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.138]             base::sink(type = "output", split = FALSE)
[09:28:18.138]             base::close(...future.stdout)
[09:28:18.138]         }, add = TRUE)
[09:28:18.138]     }
[09:28:18.138]     ...future.frame <- base::sys.nframe()
[09:28:18.138]     ...future.conditions <- base::list()
[09:28:18.138]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.138]     if (FALSE) {
[09:28:18.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.138]     }
[09:28:18.138]     ...future.result <- base::tryCatch({
[09:28:18.138]         base::withCallingHandlers({
[09:28:18.138]             ...future.value <- base::withVisible(base::local({
[09:28:18.138]                 withCallingHandlers({
[09:28:18.138]                   {
[09:28:18.138]                     do.call(function(...) {
[09:28:18.138]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.138]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.138]                         ...future.globals.maxSize)) {
[09:28:18.138]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.138]                         on.exit(options(oopts), add = TRUE)
[09:28:18.138]                       }
[09:28:18.138]                       {
[09:28:18.138]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.138]                           FUN = function(jj) {
[09:28:18.138]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.138]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.138]                           })
[09:28:18.138]                       }
[09:28:18.138]                     }, args = future.call.arguments)
[09:28:18.138]                   }
[09:28:18.138]                 }, immediateCondition = function(cond) {
[09:28:18.138]                   save_rds <- function (object, pathname, ...) 
[09:28:18.138]                   {
[09:28:18.138]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.138]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.138]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.138]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.138]                         fi_tmp[["mtime"]])
[09:28:18.138]                     }
[09:28:18.138]                     tryCatch({
[09:28:18.138]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.138]                     }, error = function(ex) {
[09:28:18.138]                       msg <- conditionMessage(ex)
[09:28:18.138]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.138]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.138]                         fi_tmp[["mtime"]], msg)
[09:28:18.138]                       ex$message <- msg
[09:28:18.138]                       stop(ex)
[09:28:18.138]                     })
[09:28:18.138]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.138]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.138]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.138]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.138]                       fi <- file.info(pathname)
[09:28:18.138]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.138]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.138]                         fi[["size"]], fi[["mtime"]])
[09:28:18.138]                       stop(msg)
[09:28:18.138]                     }
[09:28:18.138]                     invisible(pathname)
[09:28:18.138]                   }
[09:28:18.138]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.138]                     rootPath = tempdir()) 
[09:28:18.138]                   {
[09:28:18.138]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.138]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.138]                       tmpdir = path, fileext = ".rds")
[09:28:18.138]                     save_rds(obj, file)
[09:28:18.138]                   }
[09:28:18.138]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.138]                   {
[09:28:18.138]                     inherits <- base::inherits
[09:28:18.138]                     invokeRestart <- base::invokeRestart
[09:28:18.138]                     is.null <- base::is.null
[09:28:18.138]                     muffled <- FALSE
[09:28:18.138]                     if (inherits(cond, "message")) {
[09:28:18.138]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.138]                       if (muffled) 
[09:28:18.138]                         invokeRestart("muffleMessage")
[09:28:18.138]                     }
[09:28:18.138]                     else if (inherits(cond, "warning")) {
[09:28:18.138]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.138]                       if (muffled) 
[09:28:18.138]                         invokeRestart("muffleWarning")
[09:28:18.138]                     }
[09:28:18.138]                     else if (inherits(cond, "condition")) {
[09:28:18.138]                       if (!is.null(pattern)) {
[09:28:18.138]                         computeRestarts <- base::computeRestarts
[09:28:18.138]                         grepl <- base::grepl
[09:28:18.138]                         restarts <- computeRestarts(cond)
[09:28:18.138]                         for (restart in restarts) {
[09:28:18.138]                           name <- restart$name
[09:28:18.138]                           if (is.null(name)) 
[09:28:18.138]                             next
[09:28:18.138]                           if (!grepl(pattern, name)) 
[09:28:18.138]                             next
[09:28:18.138]                           invokeRestart(restart)
[09:28:18.138]                           muffled <- TRUE
[09:28:18.138]                           break
[09:28:18.138]                         }
[09:28:18.138]                       }
[09:28:18.138]                     }
[09:28:18.138]                     invisible(muffled)
[09:28:18.138]                   }
[09:28:18.138]                   muffleCondition(cond)
[09:28:18.138]                 })
[09:28:18.138]             }))
[09:28:18.138]             future::FutureResult(value = ...future.value$value, 
[09:28:18.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.138]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.138]                     ...future.globalenv.names))
[09:28:18.138]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.138]         }, condition = base::local({
[09:28:18.138]             c <- base::c
[09:28:18.138]             inherits <- base::inherits
[09:28:18.138]             invokeRestart <- base::invokeRestart
[09:28:18.138]             length <- base::length
[09:28:18.138]             list <- base::list
[09:28:18.138]             seq.int <- base::seq.int
[09:28:18.138]             signalCondition <- base::signalCondition
[09:28:18.138]             sys.calls <- base::sys.calls
[09:28:18.138]             `[[` <- base::`[[`
[09:28:18.138]             `+` <- base::`+`
[09:28:18.138]             `<<-` <- base::`<<-`
[09:28:18.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.138]                   3L)]
[09:28:18.138]             }
[09:28:18.138]             function(cond) {
[09:28:18.138]                 is_error <- inherits(cond, "error")
[09:28:18.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.138]                   NULL)
[09:28:18.138]                 if (is_error) {
[09:28:18.138]                   sessionInformation <- function() {
[09:28:18.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.138]                       search = base::search(), system = base::Sys.info())
[09:28:18.138]                   }
[09:28:18.138]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.138]                     cond$call), session = sessionInformation(), 
[09:28:18.138]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.138]                   signalCondition(cond)
[09:28:18.138]                 }
[09:28:18.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.138]                 "immediateCondition"))) {
[09:28:18.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.138]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.138]                   if (TRUE && !signal) {
[09:28:18.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.138]                     {
[09:28:18.138]                       inherits <- base::inherits
[09:28:18.138]                       invokeRestart <- base::invokeRestart
[09:28:18.138]                       is.null <- base::is.null
[09:28:18.138]                       muffled <- FALSE
[09:28:18.138]                       if (inherits(cond, "message")) {
[09:28:18.138]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.138]                         if (muffled) 
[09:28:18.138]                           invokeRestart("muffleMessage")
[09:28:18.138]                       }
[09:28:18.138]                       else if (inherits(cond, "warning")) {
[09:28:18.138]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.138]                         if (muffled) 
[09:28:18.138]                           invokeRestart("muffleWarning")
[09:28:18.138]                       }
[09:28:18.138]                       else if (inherits(cond, "condition")) {
[09:28:18.138]                         if (!is.null(pattern)) {
[09:28:18.138]                           computeRestarts <- base::computeRestarts
[09:28:18.138]                           grepl <- base::grepl
[09:28:18.138]                           restarts <- computeRestarts(cond)
[09:28:18.138]                           for (restart in restarts) {
[09:28:18.138]                             name <- restart$name
[09:28:18.138]                             if (is.null(name)) 
[09:28:18.138]                               next
[09:28:18.138]                             if (!grepl(pattern, name)) 
[09:28:18.138]                               next
[09:28:18.138]                             invokeRestart(restart)
[09:28:18.138]                             muffled <- TRUE
[09:28:18.138]                             break
[09:28:18.138]                           }
[09:28:18.138]                         }
[09:28:18.138]                       }
[09:28:18.138]                       invisible(muffled)
[09:28:18.138]                     }
[09:28:18.138]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.138]                   }
[09:28:18.138]                 }
[09:28:18.138]                 else {
[09:28:18.138]                   if (TRUE) {
[09:28:18.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.138]                     {
[09:28:18.138]                       inherits <- base::inherits
[09:28:18.138]                       invokeRestart <- base::invokeRestart
[09:28:18.138]                       is.null <- base::is.null
[09:28:18.138]                       muffled <- FALSE
[09:28:18.138]                       if (inherits(cond, "message")) {
[09:28:18.138]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.138]                         if (muffled) 
[09:28:18.138]                           invokeRestart("muffleMessage")
[09:28:18.138]                       }
[09:28:18.138]                       else if (inherits(cond, "warning")) {
[09:28:18.138]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.138]                         if (muffled) 
[09:28:18.138]                           invokeRestart("muffleWarning")
[09:28:18.138]                       }
[09:28:18.138]                       else if (inherits(cond, "condition")) {
[09:28:18.138]                         if (!is.null(pattern)) {
[09:28:18.138]                           computeRestarts <- base::computeRestarts
[09:28:18.138]                           grepl <- base::grepl
[09:28:18.138]                           restarts <- computeRestarts(cond)
[09:28:18.138]                           for (restart in restarts) {
[09:28:18.138]                             name <- restart$name
[09:28:18.138]                             if (is.null(name)) 
[09:28:18.138]                               next
[09:28:18.138]                             if (!grepl(pattern, name)) 
[09:28:18.138]                               next
[09:28:18.138]                             invokeRestart(restart)
[09:28:18.138]                             muffled <- TRUE
[09:28:18.138]                             break
[09:28:18.138]                           }
[09:28:18.138]                         }
[09:28:18.138]                       }
[09:28:18.138]                       invisible(muffled)
[09:28:18.138]                     }
[09:28:18.138]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.138]                   }
[09:28:18.138]                 }
[09:28:18.138]             }
[09:28:18.138]         }))
[09:28:18.138]     }, error = function(ex) {
[09:28:18.138]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.138]                 ...future.rng), started = ...future.startTime, 
[09:28:18.138]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.138]             version = "1.8"), class = "FutureResult")
[09:28:18.138]     }, finally = {
[09:28:18.138]         if (!identical(...future.workdir, getwd())) 
[09:28:18.138]             setwd(...future.workdir)
[09:28:18.138]         {
[09:28:18.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.138]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.138]             }
[09:28:18.138]             base::options(...future.oldOptions)
[09:28:18.138]             if (.Platform$OS.type == "windows") {
[09:28:18.138]                 old_names <- names(...future.oldEnvVars)
[09:28:18.138]                 envs <- base::Sys.getenv()
[09:28:18.138]                 names <- names(envs)
[09:28:18.138]                 common <- intersect(names, old_names)
[09:28:18.138]                 added <- setdiff(names, old_names)
[09:28:18.138]                 removed <- setdiff(old_names, names)
[09:28:18.138]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.138]                   envs[common]]
[09:28:18.138]                 NAMES <- toupper(changed)
[09:28:18.138]                 args <- list()
[09:28:18.138]                 for (kk in seq_along(NAMES)) {
[09:28:18.138]                   name <- changed[[kk]]
[09:28:18.138]                   NAME <- NAMES[[kk]]
[09:28:18.138]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.138]                     next
[09:28:18.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.138]                 }
[09:28:18.138]                 NAMES <- toupper(added)
[09:28:18.138]                 for (kk in seq_along(NAMES)) {
[09:28:18.138]                   name <- added[[kk]]
[09:28:18.138]                   NAME <- NAMES[[kk]]
[09:28:18.138]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.138]                     next
[09:28:18.138]                   args[[name]] <- ""
[09:28:18.138]                 }
[09:28:18.138]                 NAMES <- toupper(removed)
[09:28:18.138]                 for (kk in seq_along(NAMES)) {
[09:28:18.138]                   name <- removed[[kk]]
[09:28:18.138]                   NAME <- NAMES[[kk]]
[09:28:18.138]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.138]                     next
[09:28:18.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.138]                 }
[09:28:18.138]                 if (length(args) > 0) 
[09:28:18.138]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.138]             }
[09:28:18.138]             else {
[09:28:18.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.138]             }
[09:28:18.138]             {
[09:28:18.138]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.138]                   0L) {
[09:28:18.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.138]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.138]                   base::options(opts)
[09:28:18.138]                 }
[09:28:18.138]                 {
[09:28:18.138]                   {
[09:28:18.138]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.138]                     NULL
[09:28:18.138]                   }
[09:28:18.138]                   options(future.plan = NULL)
[09:28:18.138]                   if (is.na(NA_character_)) 
[09:28:18.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.138]                     .init = FALSE)
[09:28:18.138]                 }
[09:28:18.138]             }
[09:28:18.138]         }
[09:28:18.138]     })
[09:28:18.138]     if (TRUE) {
[09:28:18.138]         base::sink(type = "output", split = FALSE)
[09:28:18.138]         if (TRUE) {
[09:28:18.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.138]         }
[09:28:18.138]         else {
[09:28:18.138]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.138]         }
[09:28:18.138]         base::close(...future.stdout)
[09:28:18.138]         ...future.stdout <- NULL
[09:28:18.138]     }
[09:28:18.138]     ...future.result$conditions <- ...future.conditions
[09:28:18.138]     ...future.result$finished <- base::Sys.time()
[09:28:18.138]     ...future.result
[09:28:18.138] }
[09:28:18.140] assign_globals() ...
[09:28:18.140] List of 5
[09:28:18.140]  $ future.call.arguments    : list()
[09:28:18.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.140]  $ ...future.FUN            :function (x, ...)  
[09:28:18.140]  $ ...future.elements_ii    :List of 1
[09:28:18.140]   ..$ : num [1:4] 1 3 1 7
[09:28:18.140]  $ ...future.seeds_ii       : NULL
[09:28:18.140]  $ ...future.globals.maxSize: num Inf
[09:28:18.140]  - attr(*, "resolved")= logi FALSE
[09:28:18.140]  - attr(*, "total_size")= num NA
[09:28:18.140]  - attr(*, "where")=List of 5
[09:28:18.140]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.140]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.140]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.140]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.140]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.140]  - attr(*, "already-done")= logi TRUE
[09:28:18.145] - copied ‘future.call.arguments’ to environment
[09:28:18.145] - copied ‘...future.FUN’ to environment
[09:28:18.145] - copied ‘...future.elements_ii’ to environment
[09:28:18.145] - copied ‘...future.seeds_ii’ to environment
[09:28:18.147] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.147] assign_globals() ... done
[09:28:18.147] requestCore(): workers = 2
[09:28:18.149] MulticoreFuture started
[09:28:18.150] - Launch lazy future ... done
[09:28:18.150] run() for ‘MulticoreFuture’ ... done
[09:28:18.151] Created future:
[09:28:18.151] plan(): Setting new future strategy stack:
[09:28:18.151] List of future strategies:
[09:28:18.151] 1. sequential:
[09:28:18.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.151]    - tweaked: FALSE
[09:28:18.151]    - call: NULL
[09:28:18.153] plan(): nbrOfWorkers() = 1
[09:28:18.156] plan(): Setting new future strategy stack:
[09:28:18.156] List of future strategies:
[09:28:18.156] 1. multicore:
[09:28:18.156]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.156]    - tweaked: FALSE
[09:28:18.156]    - call: plan(strategy)
[09:28:18.161] plan(): nbrOfWorkers() = 2
[09:28:18.151] MulticoreFuture:
[09:28:18.151] Label: ‘future_apply-1’
[09:28:18.151] Expression:
[09:28:18.151] {
[09:28:18.151]     do.call(function(...) {
[09:28:18.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.151]             on.exit(options(oopts), add = TRUE)
[09:28:18.151]         }
[09:28:18.151]         {
[09:28:18.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.151]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.151]             })
[09:28:18.151]         }
[09:28:18.151]     }, args = future.call.arguments)
[09:28:18.151] }
[09:28:18.151] Lazy evaluation: FALSE
[09:28:18.151] Asynchronous evaluation: TRUE
[09:28:18.151] Local evaluation: TRUE
[09:28:18.151] Environment: R_GlobalEnv
[09:28:18.151] Capture standard output: TRUE
[09:28:18.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.151] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.151] Packages: 1 packages (‘stats’)
[09:28:18.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.151] Resolved: TRUE
[09:28:18.151] Value: <not collected>
[09:28:18.151] Conditions captured: <none>
[09:28:18.151] Early signaling: FALSE
[09:28:18.151] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.151] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.162] Chunk #1 of 2 ... DONE
[09:28:18.162] Chunk #2 of 2 ...
[09:28:18.163]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.163]  - seeds: <none>
[09:28:18.163]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.163] getGlobalsAndPackages() ...
[09:28:18.163] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.164] Resolving globals: FALSE
[09:28:18.164] Tweak future expression to call with '...' arguments ...
[09:28:18.164] {
[09:28:18.164]     do.call(function(...) {
[09:28:18.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.164]             on.exit(options(oopts), add = TRUE)
[09:28:18.164]         }
[09:28:18.164]         {
[09:28:18.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.164]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.164]             })
[09:28:18.164]         }
[09:28:18.164]     }, args = future.call.arguments)
[09:28:18.164] }
[09:28:18.165] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.165] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.165] - packages: [1] ‘stats’
[09:28:18.166] getGlobalsAndPackages() ... DONE
[09:28:18.166] run() for ‘Future’ ...
[09:28:18.166] - state: ‘created’
[09:28:18.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.172] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.172]   - Field: ‘label’
[09:28:18.173]   - Field: ‘local’
[09:28:18.173]   - Field: ‘owner’
[09:28:18.173]   - Field: ‘envir’
[09:28:18.173]   - Field: ‘workers’
[09:28:18.173]   - Field: ‘packages’
[09:28:18.174]   - Field: ‘gc’
[09:28:18.174]   - Field: ‘job’
[09:28:18.174]   - Field: ‘conditions’
[09:28:18.174]   - Field: ‘expr’
[09:28:18.174]   - Field: ‘uuid’
[09:28:18.174]   - Field: ‘seed’
[09:28:18.174]   - Field: ‘version’
[09:28:18.175]   - Field: ‘result’
[09:28:18.175]   - Field: ‘asynchronous’
[09:28:18.175]   - Field: ‘calls’
[09:28:18.175]   - Field: ‘globals’
[09:28:18.175]   - Field: ‘stdout’
[09:28:18.175]   - Field: ‘earlySignal’
[09:28:18.175]   - Field: ‘lazy’
[09:28:18.175]   - Field: ‘state’
[09:28:18.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.176] - Launch lazy future ...
[09:28:18.176] Packages needed by the future expression (n = 1): ‘stats’
[09:28:18.176] Packages needed by future strategies (n = 0): <none>
[09:28:18.177] {
[09:28:18.177]     {
[09:28:18.177]         {
[09:28:18.177]             ...future.startTime <- base::Sys.time()
[09:28:18.177]             {
[09:28:18.177]                 {
[09:28:18.177]                   {
[09:28:18.177]                     {
[09:28:18.177]                       {
[09:28:18.177]                         base::local({
[09:28:18.177]                           has_future <- base::requireNamespace("future", 
[09:28:18.177]                             quietly = TRUE)
[09:28:18.177]                           if (has_future) {
[09:28:18.177]                             ns <- base::getNamespace("future")
[09:28:18.177]                             version <- ns[[".package"]][["version"]]
[09:28:18.177]                             if (is.null(version)) 
[09:28:18.177]                               version <- utils::packageVersion("future")
[09:28:18.177]                           }
[09:28:18.177]                           else {
[09:28:18.177]                             version <- NULL
[09:28:18.177]                           }
[09:28:18.177]                           if (!has_future || version < "1.8.0") {
[09:28:18.177]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.177]                               "", base::R.version$version.string), 
[09:28:18.177]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:18.177]                                 base::R.version$platform, 8 * 
[09:28:18.177]                                   base::.Machine$sizeof.pointer), 
[09:28:18.177]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.177]                                 "release", "version")], collapse = " "), 
[09:28:18.177]                               hostname = base::Sys.info()[["nodename"]])
[09:28:18.177]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.177]                               info)
[09:28:18.177]                             info <- base::paste(info, collapse = "; ")
[09:28:18.177]                             if (!has_future) {
[09:28:18.177]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.177]                                 info)
[09:28:18.177]                             }
[09:28:18.177]                             else {
[09:28:18.177]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.177]                                 info, version)
[09:28:18.177]                             }
[09:28:18.177]                             base::stop(msg)
[09:28:18.177]                           }
[09:28:18.177]                         })
[09:28:18.177]                       }
[09:28:18.177]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.177]                       base::options(mc.cores = 1L)
[09:28:18.177]                     }
[09:28:18.177]                     base::local({
[09:28:18.177]                       for (pkg in "stats") {
[09:28:18.177]                         base::loadNamespace(pkg)
[09:28:18.177]                         base::library(pkg, character.only = TRUE)
[09:28:18.177]                       }
[09:28:18.177]                     })
[09:28:18.177]                   }
[09:28:18.177]                   ...future.strategy.old <- future::plan("list")
[09:28:18.177]                   options(future.plan = NULL)
[09:28:18.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.177]                 }
[09:28:18.177]                 ...future.workdir <- getwd()
[09:28:18.177]             }
[09:28:18.177]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.177]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.177]         }
[09:28:18.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.177]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.177]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.177]             base::names(...future.oldOptions))
[09:28:18.177]     }
[09:28:18.177]     if (FALSE) {
[09:28:18.177]     }
[09:28:18.177]     else {
[09:28:18.177]         if (TRUE) {
[09:28:18.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.177]                 open = "w")
[09:28:18.177]         }
[09:28:18.177]         else {
[09:28:18.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.177]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.177]         }
[09:28:18.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.177]             base::sink(type = "output", split = FALSE)
[09:28:18.177]             base::close(...future.stdout)
[09:28:18.177]         }, add = TRUE)
[09:28:18.177]     }
[09:28:18.177]     ...future.frame <- base::sys.nframe()
[09:28:18.177]     ...future.conditions <- base::list()
[09:28:18.177]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.177]     if (FALSE) {
[09:28:18.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.177]     }
[09:28:18.177]     ...future.result <- base::tryCatch({
[09:28:18.177]         base::withCallingHandlers({
[09:28:18.177]             ...future.value <- base::withVisible(base::local({
[09:28:18.177]                 withCallingHandlers({
[09:28:18.177]                   {
[09:28:18.177]                     do.call(function(...) {
[09:28:18.177]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.177]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.177]                         ...future.globals.maxSize)) {
[09:28:18.177]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.177]                         on.exit(options(oopts), add = TRUE)
[09:28:18.177]                       }
[09:28:18.177]                       {
[09:28:18.177]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.177]                           FUN = function(jj) {
[09:28:18.177]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.177]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.177]                           })
[09:28:18.177]                       }
[09:28:18.177]                     }, args = future.call.arguments)
[09:28:18.177]                   }
[09:28:18.177]                 }, immediateCondition = function(cond) {
[09:28:18.177]                   save_rds <- function (object, pathname, ...) 
[09:28:18.177]                   {
[09:28:18.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.177]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.177]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.177]                         fi_tmp[["mtime"]])
[09:28:18.177]                     }
[09:28:18.177]                     tryCatch({
[09:28:18.177]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.177]                     }, error = function(ex) {
[09:28:18.177]                       msg <- conditionMessage(ex)
[09:28:18.177]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.177]                         fi_tmp[["mtime"]], msg)
[09:28:18.177]                       ex$message <- msg
[09:28:18.177]                       stop(ex)
[09:28:18.177]                     })
[09:28:18.177]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.177]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.177]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.177]                       fi <- file.info(pathname)
[09:28:18.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.177]                         fi[["size"]], fi[["mtime"]])
[09:28:18.177]                       stop(msg)
[09:28:18.177]                     }
[09:28:18.177]                     invisible(pathname)
[09:28:18.177]                   }
[09:28:18.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.177]                     rootPath = tempdir()) 
[09:28:18.177]                   {
[09:28:18.177]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.177]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.177]                       tmpdir = path, fileext = ".rds")
[09:28:18.177]                     save_rds(obj, file)
[09:28:18.177]                   }
[09:28:18.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.177]                   {
[09:28:18.177]                     inherits <- base::inherits
[09:28:18.177]                     invokeRestart <- base::invokeRestart
[09:28:18.177]                     is.null <- base::is.null
[09:28:18.177]                     muffled <- FALSE
[09:28:18.177]                     if (inherits(cond, "message")) {
[09:28:18.177]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.177]                       if (muffled) 
[09:28:18.177]                         invokeRestart("muffleMessage")
[09:28:18.177]                     }
[09:28:18.177]                     else if (inherits(cond, "warning")) {
[09:28:18.177]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.177]                       if (muffled) 
[09:28:18.177]                         invokeRestart("muffleWarning")
[09:28:18.177]                     }
[09:28:18.177]                     else if (inherits(cond, "condition")) {
[09:28:18.177]                       if (!is.null(pattern)) {
[09:28:18.177]                         computeRestarts <- base::computeRestarts
[09:28:18.177]                         grepl <- base::grepl
[09:28:18.177]                         restarts <- computeRestarts(cond)
[09:28:18.177]                         for (restart in restarts) {
[09:28:18.177]                           name <- restart$name
[09:28:18.177]                           if (is.null(name)) 
[09:28:18.177]                             next
[09:28:18.177]                           if (!grepl(pattern, name)) 
[09:28:18.177]                             next
[09:28:18.177]                           invokeRestart(restart)
[09:28:18.177]                           muffled <- TRUE
[09:28:18.177]                           break
[09:28:18.177]                         }
[09:28:18.177]                       }
[09:28:18.177]                     }
[09:28:18.177]                     invisible(muffled)
[09:28:18.177]                   }
[09:28:18.177]                   muffleCondition(cond)
[09:28:18.177]                 })
[09:28:18.177]             }))
[09:28:18.177]             future::FutureResult(value = ...future.value$value, 
[09:28:18.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.177]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.177]                     ...future.globalenv.names))
[09:28:18.177]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.177]         }, condition = base::local({
[09:28:18.177]             c <- base::c
[09:28:18.177]             inherits <- base::inherits
[09:28:18.177]             invokeRestart <- base::invokeRestart
[09:28:18.177]             length <- base::length
[09:28:18.177]             list <- base::list
[09:28:18.177]             seq.int <- base::seq.int
[09:28:18.177]             signalCondition <- base::signalCondition
[09:28:18.177]             sys.calls <- base::sys.calls
[09:28:18.177]             `[[` <- base::`[[`
[09:28:18.177]             `+` <- base::`+`
[09:28:18.177]             `<<-` <- base::`<<-`
[09:28:18.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.177]                   3L)]
[09:28:18.177]             }
[09:28:18.177]             function(cond) {
[09:28:18.177]                 is_error <- inherits(cond, "error")
[09:28:18.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.177]                   NULL)
[09:28:18.177]                 if (is_error) {
[09:28:18.177]                   sessionInformation <- function() {
[09:28:18.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.177]                       search = base::search(), system = base::Sys.info())
[09:28:18.177]                   }
[09:28:18.177]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.177]                     cond$call), session = sessionInformation(), 
[09:28:18.177]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.177]                   signalCondition(cond)
[09:28:18.177]                 }
[09:28:18.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.177]                 "immediateCondition"))) {
[09:28:18.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.177]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.177]                   if (TRUE && !signal) {
[09:28:18.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.177]                     {
[09:28:18.177]                       inherits <- base::inherits
[09:28:18.177]                       invokeRestart <- base::invokeRestart
[09:28:18.177]                       is.null <- base::is.null
[09:28:18.177]                       muffled <- FALSE
[09:28:18.177]                       if (inherits(cond, "message")) {
[09:28:18.177]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.177]                         if (muffled) 
[09:28:18.177]                           invokeRestart("muffleMessage")
[09:28:18.177]                       }
[09:28:18.177]                       else if (inherits(cond, "warning")) {
[09:28:18.177]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.177]                         if (muffled) 
[09:28:18.177]                           invokeRestart("muffleWarning")
[09:28:18.177]                       }
[09:28:18.177]                       else if (inherits(cond, "condition")) {
[09:28:18.177]                         if (!is.null(pattern)) {
[09:28:18.177]                           computeRestarts <- base::computeRestarts
[09:28:18.177]                           grepl <- base::grepl
[09:28:18.177]                           restarts <- computeRestarts(cond)
[09:28:18.177]                           for (restart in restarts) {
[09:28:18.177]                             name <- restart$name
[09:28:18.177]                             if (is.null(name)) 
[09:28:18.177]                               next
[09:28:18.177]                             if (!grepl(pattern, name)) 
[09:28:18.177]                               next
[09:28:18.177]                             invokeRestart(restart)
[09:28:18.177]                             muffled <- TRUE
[09:28:18.177]                             break
[09:28:18.177]                           }
[09:28:18.177]                         }
[09:28:18.177]                       }
[09:28:18.177]                       invisible(muffled)
[09:28:18.177]                     }
[09:28:18.177]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.177]                   }
[09:28:18.177]                 }
[09:28:18.177]                 else {
[09:28:18.177]                   if (TRUE) {
[09:28:18.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.177]                     {
[09:28:18.177]                       inherits <- base::inherits
[09:28:18.177]                       invokeRestart <- base::invokeRestart
[09:28:18.177]                       is.null <- base::is.null
[09:28:18.177]                       muffled <- FALSE
[09:28:18.177]                       if (inherits(cond, "message")) {
[09:28:18.177]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.177]                         if (muffled) 
[09:28:18.177]                           invokeRestart("muffleMessage")
[09:28:18.177]                       }
[09:28:18.177]                       else if (inherits(cond, "warning")) {
[09:28:18.177]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.177]                         if (muffled) 
[09:28:18.177]                           invokeRestart("muffleWarning")
[09:28:18.177]                       }
[09:28:18.177]                       else if (inherits(cond, "condition")) {
[09:28:18.177]                         if (!is.null(pattern)) {
[09:28:18.177]                           computeRestarts <- base::computeRestarts
[09:28:18.177]                           grepl <- base::grepl
[09:28:18.177]                           restarts <- computeRestarts(cond)
[09:28:18.177]                           for (restart in restarts) {
[09:28:18.177]                             name <- restart$name
[09:28:18.177]                             if (is.null(name)) 
[09:28:18.177]                               next
[09:28:18.177]                             if (!grepl(pattern, name)) 
[09:28:18.177]                               next
[09:28:18.177]                             invokeRestart(restart)
[09:28:18.177]                             muffled <- TRUE
[09:28:18.177]                             break
[09:28:18.177]                           }
[09:28:18.177]                         }
[09:28:18.177]                       }
[09:28:18.177]                       invisible(muffled)
[09:28:18.177]                     }
[09:28:18.177]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.177]                   }
[09:28:18.177]                 }
[09:28:18.177]             }
[09:28:18.177]         }))
[09:28:18.177]     }, error = function(ex) {
[09:28:18.177]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.177]                 ...future.rng), started = ...future.startTime, 
[09:28:18.177]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.177]             version = "1.8"), class = "FutureResult")
[09:28:18.177]     }, finally = {
[09:28:18.177]         if (!identical(...future.workdir, getwd())) 
[09:28:18.177]             setwd(...future.workdir)
[09:28:18.177]         {
[09:28:18.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.177]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.177]             }
[09:28:18.177]             base::options(...future.oldOptions)
[09:28:18.177]             if (.Platform$OS.type == "windows") {
[09:28:18.177]                 old_names <- names(...future.oldEnvVars)
[09:28:18.177]                 envs <- base::Sys.getenv()
[09:28:18.177]                 names <- names(envs)
[09:28:18.177]                 common <- intersect(names, old_names)
[09:28:18.177]                 added <- setdiff(names, old_names)
[09:28:18.177]                 removed <- setdiff(old_names, names)
[09:28:18.177]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.177]                   envs[common]]
[09:28:18.177]                 NAMES <- toupper(changed)
[09:28:18.177]                 args <- list()
[09:28:18.177]                 for (kk in seq_along(NAMES)) {
[09:28:18.177]                   name <- changed[[kk]]
[09:28:18.177]                   NAME <- NAMES[[kk]]
[09:28:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.177]                     next
[09:28:18.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.177]                 }
[09:28:18.177]                 NAMES <- toupper(added)
[09:28:18.177]                 for (kk in seq_along(NAMES)) {
[09:28:18.177]                   name <- added[[kk]]
[09:28:18.177]                   NAME <- NAMES[[kk]]
[09:28:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.177]                     next
[09:28:18.177]                   args[[name]] <- ""
[09:28:18.177]                 }
[09:28:18.177]                 NAMES <- toupper(removed)
[09:28:18.177]                 for (kk in seq_along(NAMES)) {
[09:28:18.177]                   name <- removed[[kk]]
[09:28:18.177]                   NAME <- NAMES[[kk]]
[09:28:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.177]                     next
[09:28:18.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.177]                 }
[09:28:18.177]                 if (length(args) > 0) 
[09:28:18.177]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.177]             }
[09:28:18.177]             else {
[09:28:18.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.177]             }
[09:28:18.177]             {
[09:28:18.177]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.177]                   0L) {
[09:28:18.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.177]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.177]                   base::options(opts)
[09:28:18.177]                 }
[09:28:18.177]                 {
[09:28:18.177]                   {
[09:28:18.177]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.177]                     NULL
[09:28:18.177]                   }
[09:28:18.177]                   options(future.plan = NULL)
[09:28:18.177]                   if (is.na(NA_character_)) 
[09:28:18.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.177]                     .init = FALSE)
[09:28:18.177]                 }
[09:28:18.177]             }
[09:28:18.177]         }
[09:28:18.177]     })
[09:28:18.177]     if (TRUE) {
[09:28:18.177]         base::sink(type = "output", split = FALSE)
[09:28:18.177]         if (TRUE) {
[09:28:18.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.177]         }
[09:28:18.177]         else {
[09:28:18.177]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.177]         }
[09:28:18.177]         base::close(...future.stdout)
[09:28:18.177]         ...future.stdout <- NULL
[09:28:18.177]     }
[09:28:18.177]     ...future.result$conditions <- ...future.conditions
[09:28:18.177]     ...future.result$finished <- base::Sys.time()
[09:28:18.177]     ...future.result
[09:28:18.177] }
[09:28:18.181] assign_globals() ...
[09:28:18.181] List of 5
[09:28:18.181]  $ future.call.arguments    : list()
[09:28:18.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.181]  $ ...future.FUN            :function (x, ...)  
[09:28:18.181]  $ ...future.elements_ii    :List of 1
[09:28:18.181]   ..$ : num [1:4] 2 4 6 8
[09:28:18.181]  $ ...future.seeds_ii       : NULL
[09:28:18.181]  $ ...future.globals.maxSize: num Inf
[09:28:18.181]  - attr(*, "resolved")= logi FALSE
[09:28:18.181]  - attr(*, "total_size")= num NA
[09:28:18.181]  - attr(*, "where")=List of 5
[09:28:18.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.181]  - attr(*, "already-done")= logi TRUE
[09:28:18.188] - copied ‘future.call.arguments’ to environment
[09:28:18.188] - copied ‘...future.FUN’ to environment
[09:28:18.188] - copied ‘...future.elements_ii’ to environment
[09:28:18.188] - copied ‘...future.seeds_ii’ to environment
[09:28:18.188] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.188] assign_globals() ... done
[09:28:18.189] requestCore(): workers = 2
[09:28:18.191] MulticoreFuture started
[09:28:18.191] - Launch lazy future ... done
[09:28:18.191] run() for ‘MulticoreFuture’ ... done
[09:28:18.192] Created future:
[09:28:18.192] plan(): Setting new future strategy stack:
[09:28:18.193] List of future strategies:
[09:28:18.193] 1. sequential:
[09:28:18.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.193]    - tweaked: FALSE
[09:28:18.193]    - call: NULL
[09:28:18.194] plan(): nbrOfWorkers() = 1
[09:28:18.196] plan(): Setting new future strategy stack:
[09:28:18.196] List of future strategies:
[09:28:18.196] 1. multicore:
[09:28:18.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.196]    - tweaked: FALSE
[09:28:18.196]    - call: plan(strategy)
[09:28:18.202] plan(): nbrOfWorkers() = 2
[09:28:18.192] MulticoreFuture:
[09:28:18.192] Label: ‘future_apply-2’
[09:28:18.192] Expression:
[09:28:18.192] {
[09:28:18.192]     do.call(function(...) {
[09:28:18.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.192]             on.exit(options(oopts), add = TRUE)
[09:28:18.192]         }
[09:28:18.192]         {
[09:28:18.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.192]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.192]             })
[09:28:18.192]         }
[09:28:18.192]     }, args = future.call.arguments)
[09:28:18.192] }
[09:28:18.192] Lazy evaluation: FALSE
[09:28:18.192] Asynchronous evaluation: TRUE
[09:28:18.192] Local evaluation: TRUE
[09:28:18.192] Environment: R_GlobalEnv
[09:28:18.192] Capture standard output: TRUE
[09:28:18.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.192] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.192] Packages: 1 packages (‘stats’)
[09:28:18.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.192] Resolved: TRUE
[09:28:18.192] Value: <not collected>
[09:28:18.192] Conditions captured: <none>
[09:28:18.192] Early signaling: FALSE
[09:28:18.192] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.203] Chunk #2 of 2 ... DONE
[09:28:18.203] Launching 2 futures (chunks) ... DONE
[09:28:18.203] Resolving 2 futures (chunks) ...
[09:28:18.203] resolve() on list ...
[09:28:18.203]  recursive: 0
[09:28:18.204]  length: 2
[09:28:18.204] 
[09:28:18.204] Future #1
[09:28:18.204] result() for MulticoreFuture ...
[09:28:18.205] result() for MulticoreFuture ...
[09:28:18.205] result() for MulticoreFuture ... done
[09:28:18.206] result() for MulticoreFuture ... done
[09:28:18.206] result() for MulticoreFuture ...
[09:28:18.206] result() for MulticoreFuture ... done
[09:28:18.206] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.206] - nx: 2
[09:28:18.206] - relay: TRUE
[09:28:18.206] - stdout: TRUE
[09:28:18.206] - signal: TRUE
[09:28:18.207] - resignal: FALSE
[09:28:18.207] - force: TRUE
[09:28:18.207] - relayed: [n=2] FALSE, FALSE
[09:28:18.207] - queued futures: [n=2] FALSE, FALSE
[09:28:18.207]  - until=1
[09:28:18.207]  - relaying element #1
[09:28:18.207] result() for MulticoreFuture ...
[09:28:18.208] result() for MulticoreFuture ... done
[09:28:18.208] result() for MulticoreFuture ...
[09:28:18.208] result() for MulticoreFuture ... done
[09:28:18.208] result() for MulticoreFuture ...
[09:28:18.208] result() for MulticoreFuture ... done
[09:28:18.208] result() for MulticoreFuture ...
[09:28:18.208] result() for MulticoreFuture ... done
[09:28:18.209] - relayed: [n=2] TRUE, FALSE
[09:28:18.209] - queued futures: [n=2] TRUE, FALSE
[09:28:18.209] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.209]  length: 1 (resolved future 1)
[09:28:18.209] Future #2
[09:28:18.209] result() for MulticoreFuture ...
[09:28:18.210] result() for MulticoreFuture ...
[09:28:18.210] result() for MulticoreFuture ... done
[09:28:18.213] result() for MulticoreFuture ... done
[09:28:18.213] result() for MulticoreFuture ...
[09:28:18.214] result() for MulticoreFuture ... done
[09:28:18.214] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.214] - nx: 2
[09:28:18.214] - relay: TRUE
[09:28:18.214] - stdout: TRUE
[09:28:18.215] - signal: TRUE
[09:28:18.215] - resignal: FALSE
[09:28:18.215] - force: TRUE
[09:28:18.215] - relayed: [n=2] TRUE, FALSE
[09:28:18.215] - queued futures: [n=2] TRUE, FALSE
[09:28:18.215]  - until=2
[09:28:18.216]  - relaying element #2
[09:28:18.216] result() for MulticoreFuture ...
[09:28:18.216] result() for MulticoreFuture ... done
[09:28:18.216] result() for MulticoreFuture ...
[09:28:18.216] result() for MulticoreFuture ... done
[09:28:18.216] result() for MulticoreFuture ...
[09:28:18.216] result() for MulticoreFuture ... done
[09:28:18.217] result() for MulticoreFuture ...
[09:28:18.217] result() for MulticoreFuture ... done
[09:28:18.217] - relayed: [n=2] TRUE, TRUE
[09:28:18.217] - queued futures: [n=2] TRUE, TRUE
[09:28:18.217] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.217]  length: 0 (resolved future 2)
[09:28:18.217] Relaying remaining futures
[09:28:18.217] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.217] - nx: 2
[09:28:18.218] - relay: TRUE
[09:28:18.218] - stdout: TRUE
[09:28:18.218] - signal: TRUE
[09:28:18.218] - resignal: FALSE
[09:28:18.218] - force: TRUE
[09:28:18.218] - relayed: [n=2] TRUE, TRUE
[09:28:18.218] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.218] - relayed: [n=2] TRUE, TRUE
[09:28:18.219] - queued futures: [n=2] TRUE, TRUE
[09:28:18.219] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.219] resolve() on list ... DONE
[09:28:18.219] result() for MulticoreFuture ...
[09:28:18.219] result() for MulticoreFuture ... done
[09:28:18.219] result() for MulticoreFuture ...
[09:28:18.219] result() for MulticoreFuture ... done
[09:28:18.219] result() for MulticoreFuture ...
[09:28:18.220] result() for MulticoreFuture ... done
[09:28:18.220] result() for MulticoreFuture ...
[09:28:18.220] result() for MulticoreFuture ... done
[09:28:18.220]  - Number of value chunks collected: 2
[09:28:18.220] Resolving 2 futures (chunks) ... DONE
[09:28:18.220] Reducing values from 2 chunks ...
[09:28:18.220]  - Number of values collected after concatenation: 2
[09:28:18.220]  - Number of values expected: 2
[09:28:18.220] Reducing values from 2 chunks ... DONE
[09:28:18.221] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[09:28:18.221] getGlobalsAndPackagesXApply() ...
[09:28:18.221]  - future.globals: TRUE
[09:28:18.221] getGlobalsAndPackages() ...
[09:28:18.222] Searching for globals...
[09:28:18.223] - globals found: [1] ‘FUN’
[09:28:18.223] Searching for globals ... DONE
[09:28:18.223] Resolving globals: FALSE
[09:28:18.224] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:18.224] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:18.224] - globals: [1] ‘FUN’
[09:28:18.224] 
[09:28:18.224] getGlobalsAndPackages() ... DONE
[09:28:18.224]  - globals found/used: [n=1] ‘FUN’
[09:28:18.225]  - needed namespaces: [n=0] 
[09:28:18.225] Finding globals ... DONE
[09:28:18.225]  - use_args: TRUE
[09:28:18.225]  - Getting '...' globals ...
[09:28:18.225] resolve() on list ...
[09:28:18.225]  recursive: 0
[09:28:18.225]  length: 1
[09:28:18.226]  elements: ‘...’
[09:28:18.226]  length: 0 (resolved future 1)
[09:28:18.226] resolve() on list ... DONE
[09:28:18.226]    - '...' content: [n=0] 
[09:28:18.226] List of 1
[09:28:18.226]  $ ...: list()
[09:28:18.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.226]  - attr(*, "where")=List of 1
[09:28:18.226]   ..$ ...:<environment: 0x559ba1ebe5e8> 
[09:28:18.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.226]  - attr(*, "resolved")= logi TRUE
[09:28:18.226]  - attr(*, "total_size")= num NA
[09:28:18.229]  - Getting '...' globals ... DONE
[09:28:18.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.229] List of 2
[09:28:18.229]  $ ...future.FUN:function (x)  
[09:28:18.229]  $ ...          : list()
[09:28:18.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.229]  - attr(*, "where")=List of 2
[09:28:18.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.229]   ..$ ...          :<environment: 0x559ba1ebe5e8> 
[09:28:18.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.229]  - attr(*, "resolved")= logi FALSE
[09:28:18.229]  - attr(*, "total_size")= num 848
[09:28:18.232] Packages to be attached in all futures: [n=0] 
[09:28:18.233] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.237] future_lapply() ...
[09:28:18.241] Number of chunks: 2
[09:28:18.241] getGlobalsAndPackagesXApply() ...
[09:28:18.242]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.242]  - use_args: TRUE
[09:28:18.242] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.242] List of 2
[09:28:18.242]  $ ...          : list()
[09:28:18.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.242]  $ ...future.FUN:function (x)  
[09:28:18.242]  - attr(*, "where")=List of 2
[09:28:18.242]   ..$ ...          :<environment: 0x559ba1ebe5e8> 
[09:28:18.242]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.242]  - attr(*, "resolved")= logi FALSE
[09:28:18.242]  - attr(*, "total_size")= num NA
[09:28:18.250] Packages to be attached in all futures: [n=0] 
[09:28:18.250] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.250] Number of futures (= number of chunks): 2
[09:28:18.250] Launching 2 futures (chunks) ...
[09:28:18.250] Chunk #1 of 2 ...
[09:28:18.251]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.251]  - seeds: <none>
[09:28:18.251]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.251] getGlobalsAndPackages() ...
[09:28:18.251] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.251] Resolving globals: FALSE
[09:28:18.251] Tweak future expression to call with '...' arguments ...
[09:28:18.252] {
[09:28:18.252]     do.call(function(...) {
[09:28:18.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.252]             on.exit(options(oopts), add = TRUE)
[09:28:18.252]         }
[09:28:18.252]         {
[09:28:18.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.252]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.252]             })
[09:28:18.252]         }
[09:28:18.252]     }, args = future.call.arguments)
[09:28:18.252] }
[09:28:18.252] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.252] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.252] 
[09:28:18.252] getGlobalsAndPackages() ... DONE
[09:28:18.253] run() for ‘Future’ ...
[09:28:18.253] - state: ‘created’
[09:28:18.253] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.257] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.257]   - Field: ‘label’
[09:28:18.257]   - Field: ‘local’
[09:28:18.257]   - Field: ‘owner’
[09:28:18.257]   - Field: ‘envir’
[09:28:18.257]   - Field: ‘workers’
[09:28:18.257]   - Field: ‘packages’
[09:28:18.257]   - Field: ‘gc’
[09:28:18.257]   - Field: ‘job’
[09:28:18.258]   - Field: ‘conditions’
[09:28:18.258]   - Field: ‘expr’
[09:28:18.258]   - Field: ‘uuid’
[09:28:18.258]   - Field: ‘seed’
[09:28:18.258]   - Field: ‘version’
[09:28:18.258]   - Field: ‘result’
[09:28:18.258]   - Field: ‘asynchronous’
[09:28:18.258]   - Field: ‘calls’
[09:28:18.258]   - Field: ‘globals’
[09:28:18.258]   - Field: ‘stdout’
[09:28:18.258]   - Field: ‘earlySignal’
[09:28:18.258]   - Field: ‘lazy’
[09:28:18.259]   - Field: ‘state’
[09:28:18.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.259] - Launch lazy future ...
[09:28:18.259] Packages needed by the future expression (n = 0): <none>
[09:28:18.259] Packages needed by future strategies (n = 0): <none>
[09:28:18.260] {
[09:28:18.260]     {
[09:28:18.260]         {
[09:28:18.260]             ...future.startTime <- base::Sys.time()
[09:28:18.260]             {
[09:28:18.260]                 {
[09:28:18.260]                   {
[09:28:18.260]                     {
[09:28:18.260]                       base::local({
[09:28:18.260]                         has_future <- base::requireNamespace("future", 
[09:28:18.260]                           quietly = TRUE)
[09:28:18.260]                         if (has_future) {
[09:28:18.260]                           ns <- base::getNamespace("future")
[09:28:18.260]                           version <- ns[[".package"]][["version"]]
[09:28:18.260]                           if (is.null(version)) 
[09:28:18.260]                             version <- utils::packageVersion("future")
[09:28:18.260]                         }
[09:28:18.260]                         else {
[09:28:18.260]                           version <- NULL
[09:28:18.260]                         }
[09:28:18.260]                         if (!has_future || version < "1.8.0") {
[09:28:18.260]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.260]                             "", base::R.version$version.string), 
[09:28:18.260]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.260]                               "release", "version")], collapse = " "), 
[09:28:18.260]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.260]                             info)
[09:28:18.260]                           info <- base::paste(info, collapse = "; ")
[09:28:18.260]                           if (!has_future) {
[09:28:18.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.260]                               info)
[09:28:18.260]                           }
[09:28:18.260]                           else {
[09:28:18.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.260]                               info, version)
[09:28:18.260]                           }
[09:28:18.260]                           base::stop(msg)
[09:28:18.260]                         }
[09:28:18.260]                       })
[09:28:18.260]                     }
[09:28:18.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.260]                     base::options(mc.cores = 1L)
[09:28:18.260]                   }
[09:28:18.260]                   ...future.strategy.old <- future::plan("list")
[09:28:18.260]                   options(future.plan = NULL)
[09:28:18.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.260]                 }
[09:28:18.260]                 ...future.workdir <- getwd()
[09:28:18.260]             }
[09:28:18.260]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.260]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.260]         }
[09:28:18.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.260]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.260]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.260]             base::names(...future.oldOptions))
[09:28:18.260]     }
[09:28:18.260]     if (FALSE) {
[09:28:18.260]     }
[09:28:18.260]     else {
[09:28:18.260]         if (TRUE) {
[09:28:18.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.260]                 open = "w")
[09:28:18.260]         }
[09:28:18.260]         else {
[09:28:18.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.260]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.260]         }
[09:28:18.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.260]             base::sink(type = "output", split = FALSE)
[09:28:18.260]             base::close(...future.stdout)
[09:28:18.260]         }, add = TRUE)
[09:28:18.260]     }
[09:28:18.260]     ...future.frame <- base::sys.nframe()
[09:28:18.260]     ...future.conditions <- base::list()
[09:28:18.260]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.260]     if (FALSE) {
[09:28:18.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.260]     }
[09:28:18.260]     ...future.result <- base::tryCatch({
[09:28:18.260]         base::withCallingHandlers({
[09:28:18.260]             ...future.value <- base::withVisible(base::local({
[09:28:18.260]                 withCallingHandlers({
[09:28:18.260]                   {
[09:28:18.260]                     do.call(function(...) {
[09:28:18.260]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.260]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.260]                         ...future.globals.maxSize)) {
[09:28:18.260]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.260]                         on.exit(options(oopts), add = TRUE)
[09:28:18.260]                       }
[09:28:18.260]                       {
[09:28:18.260]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.260]                           FUN = function(jj) {
[09:28:18.260]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.260]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.260]                           })
[09:28:18.260]                       }
[09:28:18.260]                     }, args = future.call.arguments)
[09:28:18.260]                   }
[09:28:18.260]                 }, immediateCondition = function(cond) {
[09:28:18.260]                   save_rds <- function (object, pathname, ...) 
[09:28:18.260]                   {
[09:28:18.260]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.260]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.260]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.260]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.260]                         fi_tmp[["mtime"]])
[09:28:18.260]                     }
[09:28:18.260]                     tryCatch({
[09:28:18.260]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.260]                     }, error = function(ex) {
[09:28:18.260]                       msg <- conditionMessage(ex)
[09:28:18.260]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.260]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.260]                         fi_tmp[["mtime"]], msg)
[09:28:18.260]                       ex$message <- msg
[09:28:18.260]                       stop(ex)
[09:28:18.260]                     })
[09:28:18.260]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.260]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.260]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.260]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.260]                       fi <- file.info(pathname)
[09:28:18.260]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.260]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.260]                         fi[["size"]], fi[["mtime"]])
[09:28:18.260]                       stop(msg)
[09:28:18.260]                     }
[09:28:18.260]                     invisible(pathname)
[09:28:18.260]                   }
[09:28:18.260]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.260]                     rootPath = tempdir()) 
[09:28:18.260]                   {
[09:28:18.260]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.260]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.260]                       tmpdir = path, fileext = ".rds")
[09:28:18.260]                     save_rds(obj, file)
[09:28:18.260]                   }
[09:28:18.260]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.260]                   {
[09:28:18.260]                     inherits <- base::inherits
[09:28:18.260]                     invokeRestart <- base::invokeRestart
[09:28:18.260]                     is.null <- base::is.null
[09:28:18.260]                     muffled <- FALSE
[09:28:18.260]                     if (inherits(cond, "message")) {
[09:28:18.260]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.260]                       if (muffled) 
[09:28:18.260]                         invokeRestart("muffleMessage")
[09:28:18.260]                     }
[09:28:18.260]                     else if (inherits(cond, "warning")) {
[09:28:18.260]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.260]                       if (muffled) 
[09:28:18.260]                         invokeRestart("muffleWarning")
[09:28:18.260]                     }
[09:28:18.260]                     else if (inherits(cond, "condition")) {
[09:28:18.260]                       if (!is.null(pattern)) {
[09:28:18.260]                         computeRestarts <- base::computeRestarts
[09:28:18.260]                         grepl <- base::grepl
[09:28:18.260]                         restarts <- computeRestarts(cond)
[09:28:18.260]                         for (restart in restarts) {
[09:28:18.260]                           name <- restart$name
[09:28:18.260]                           if (is.null(name)) 
[09:28:18.260]                             next
[09:28:18.260]                           if (!grepl(pattern, name)) 
[09:28:18.260]                             next
[09:28:18.260]                           invokeRestart(restart)
[09:28:18.260]                           muffled <- TRUE
[09:28:18.260]                           break
[09:28:18.260]                         }
[09:28:18.260]                       }
[09:28:18.260]                     }
[09:28:18.260]                     invisible(muffled)
[09:28:18.260]                   }
[09:28:18.260]                   muffleCondition(cond)
[09:28:18.260]                 })
[09:28:18.260]             }))
[09:28:18.260]             future::FutureResult(value = ...future.value$value, 
[09:28:18.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.260]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.260]                     ...future.globalenv.names))
[09:28:18.260]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.260]         }, condition = base::local({
[09:28:18.260]             c <- base::c
[09:28:18.260]             inherits <- base::inherits
[09:28:18.260]             invokeRestart <- base::invokeRestart
[09:28:18.260]             length <- base::length
[09:28:18.260]             list <- base::list
[09:28:18.260]             seq.int <- base::seq.int
[09:28:18.260]             signalCondition <- base::signalCondition
[09:28:18.260]             sys.calls <- base::sys.calls
[09:28:18.260]             `[[` <- base::`[[`
[09:28:18.260]             `+` <- base::`+`
[09:28:18.260]             `<<-` <- base::`<<-`
[09:28:18.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.260]                   3L)]
[09:28:18.260]             }
[09:28:18.260]             function(cond) {
[09:28:18.260]                 is_error <- inherits(cond, "error")
[09:28:18.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.260]                   NULL)
[09:28:18.260]                 if (is_error) {
[09:28:18.260]                   sessionInformation <- function() {
[09:28:18.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.260]                       search = base::search(), system = base::Sys.info())
[09:28:18.260]                   }
[09:28:18.260]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.260]                     cond$call), session = sessionInformation(), 
[09:28:18.260]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.260]                   signalCondition(cond)
[09:28:18.260]                 }
[09:28:18.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.260]                 "immediateCondition"))) {
[09:28:18.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.260]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.260]                   if (TRUE && !signal) {
[09:28:18.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.260]                     {
[09:28:18.260]                       inherits <- base::inherits
[09:28:18.260]                       invokeRestart <- base::invokeRestart
[09:28:18.260]                       is.null <- base::is.null
[09:28:18.260]                       muffled <- FALSE
[09:28:18.260]                       if (inherits(cond, "message")) {
[09:28:18.260]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.260]                         if (muffled) 
[09:28:18.260]                           invokeRestart("muffleMessage")
[09:28:18.260]                       }
[09:28:18.260]                       else if (inherits(cond, "warning")) {
[09:28:18.260]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.260]                         if (muffled) 
[09:28:18.260]                           invokeRestart("muffleWarning")
[09:28:18.260]                       }
[09:28:18.260]                       else if (inherits(cond, "condition")) {
[09:28:18.260]                         if (!is.null(pattern)) {
[09:28:18.260]                           computeRestarts <- base::computeRestarts
[09:28:18.260]                           grepl <- base::grepl
[09:28:18.260]                           restarts <- computeRestarts(cond)
[09:28:18.260]                           for (restart in restarts) {
[09:28:18.260]                             name <- restart$name
[09:28:18.260]                             if (is.null(name)) 
[09:28:18.260]                               next
[09:28:18.260]                             if (!grepl(pattern, name)) 
[09:28:18.260]                               next
[09:28:18.260]                             invokeRestart(restart)
[09:28:18.260]                             muffled <- TRUE
[09:28:18.260]                             break
[09:28:18.260]                           }
[09:28:18.260]                         }
[09:28:18.260]                       }
[09:28:18.260]                       invisible(muffled)
[09:28:18.260]                     }
[09:28:18.260]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.260]                   }
[09:28:18.260]                 }
[09:28:18.260]                 else {
[09:28:18.260]                   if (TRUE) {
[09:28:18.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.260]                     {
[09:28:18.260]                       inherits <- base::inherits
[09:28:18.260]                       invokeRestart <- base::invokeRestart
[09:28:18.260]                       is.null <- base::is.null
[09:28:18.260]                       muffled <- FALSE
[09:28:18.260]                       if (inherits(cond, "message")) {
[09:28:18.260]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.260]                         if (muffled) 
[09:28:18.260]                           invokeRestart("muffleMessage")
[09:28:18.260]                       }
[09:28:18.260]                       else if (inherits(cond, "warning")) {
[09:28:18.260]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.260]                         if (muffled) 
[09:28:18.260]                           invokeRestart("muffleWarning")
[09:28:18.260]                       }
[09:28:18.260]                       else if (inherits(cond, "condition")) {
[09:28:18.260]                         if (!is.null(pattern)) {
[09:28:18.260]                           computeRestarts <- base::computeRestarts
[09:28:18.260]                           grepl <- base::grepl
[09:28:18.260]                           restarts <- computeRestarts(cond)
[09:28:18.260]                           for (restart in restarts) {
[09:28:18.260]                             name <- restart$name
[09:28:18.260]                             if (is.null(name)) 
[09:28:18.260]                               next
[09:28:18.260]                             if (!grepl(pattern, name)) 
[09:28:18.260]                               next
[09:28:18.260]                             invokeRestart(restart)
[09:28:18.260]                             muffled <- TRUE
[09:28:18.260]                             break
[09:28:18.260]                           }
[09:28:18.260]                         }
[09:28:18.260]                       }
[09:28:18.260]                       invisible(muffled)
[09:28:18.260]                     }
[09:28:18.260]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.260]                   }
[09:28:18.260]                 }
[09:28:18.260]             }
[09:28:18.260]         }))
[09:28:18.260]     }, error = function(ex) {
[09:28:18.260]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.260]                 ...future.rng), started = ...future.startTime, 
[09:28:18.260]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.260]             version = "1.8"), class = "FutureResult")
[09:28:18.260]     }, finally = {
[09:28:18.260]         if (!identical(...future.workdir, getwd())) 
[09:28:18.260]             setwd(...future.workdir)
[09:28:18.260]         {
[09:28:18.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.260]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.260]             }
[09:28:18.260]             base::options(...future.oldOptions)
[09:28:18.260]             if (.Platform$OS.type == "windows") {
[09:28:18.260]                 old_names <- names(...future.oldEnvVars)
[09:28:18.260]                 envs <- base::Sys.getenv()
[09:28:18.260]                 names <- names(envs)
[09:28:18.260]                 common <- intersect(names, old_names)
[09:28:18.260]                 added <- setdiff(names, old_names)
[09:28:18.260]                 removed <- setdiff(old_names, names)
[09:28:18.260]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.260]                   envs[common]]
[09:28:18.260]                 NAMES <- toupper(changed)
[09:28:18.260]                 args <- list()
[09:28:18.260]                 for (kk in seq_along(NAMES)) {
[09:28:18.260]                   name <- changed[[kk]]
[09:28:18.260]                   NAME <- NAMES[[kk]]
[09:28:18.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.260]                     next
[09:28:18.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.260]                 }
[09:28:18.260]                 NAMES <- toupper(added)
[09:28:18.260]                 for (kk in seq_along(NAMES)) {
[09:28:18.260]                   name <- added[[kk]]
[09:28:18.260]                   NAME <- NAMES[[kk]]
[09:28:18.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.260]                     next
[09:28:18.260]                   args[[name]] <- ""
[09:28:18.260]                 }
[09:28:18.260]                 NAMES <- toupper(removed)
[09:28:18.260]                 for (kk in seq_along(NAMES)) {
[09:28:18.260]                   name <- removed[[kk]]
[09:28:18.260]                   NAME <- NAMES[[kk]]
[09:28:18.260]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.260]                     next
[09:28:18.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.260]                 }
[09:28:18.260]                 if (length(args) > 0) 
[09:28:18.260]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.260]             }
[09:28:18.260]             else {
[09:28:18.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.260]             }
[09:28:18.260]             {
[09:28:18.260]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.260]                   0L) {
[09:28:18.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.260]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.260]                   base::options(opts)
[09:28:18.260]                 }
[09:28:18.260]                 {
[09:28:18.260]                   {
[09:28:18.260]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.260]                     NULL
[09:28:18.260]                   }
[09:28:18.260]                   options(future.plan = NULL)
[09:28:18.260]                   if (is.na(NA_character_)) 
[09:28:18.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.260]                     .init = FALSE)
[09:28:18.260]                 }
[09:28:18.260]             }
[09:28:18.260]         }
[09:28:18.260]     })
[09:28:18.260]     if (TRUE) {
[09:28:18.260]         base::sink(type = "output", split = FALSE)
[09:28:18.260]         if (TRUE) {
[09:28:18.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.260]         }
[09:28:18.260]         else {
[09:28:18.260]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.260]         }
[09:28:18.260]         base::close(...future.stdout)
[09:28:18.260]         ...future.stdout <- NULL
[09:28:18.260]     }
[09:28:18.260]     ...future.result$conditions <- ...future.conditions
[09:28:18.260]     ...future.result$finished <- base::Sys.time()
[09:28:18.260]     ...future.result
[09:28:18.260] }
[09:28:18.262] assign_globals() ...
[09:28:18.262] List of 5
[09:28:18.262]  $ future.call.arguments    : list()
[09:28:18.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.262]  $ ...future.FUN            :function (x)  
[09:28:18.262]  $ ...future.elements_ii    :List of 1
[09:28:18.262]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:18.262]  $ ...future.seeds_ii       : NULL
[09:28:18.262]  $ ...future.globals.maxSize: num Inf
[09:28:18.262]  - attr(*, "resolved")= logi FALSE
[09:28:18.262]  - attr(*, "total_size")= num NA
[09:28:18.262]  - attr(*, "where")=List of 5
[09:28:18.262]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.262]  - attr(*, "already-done")= logi TRUE
[09:28:18.267] - copied ‘future.call.arguments’ to environment
[09:28:18.267] - copied ‘...future.FUN’ to environment
[09:28:18.267] - copied ‘...future.elements_ii’ to environment
[09:28:18.267] - copied ‘...future.seeds_ii’ to environment
[09:28:18.267] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.267] assign_globals() ... done
[09:28:18.267] requestCore(): workers = 2
[09:28:18.269] MulticoreFuture started
[09:28:18.270] - Launch lazy future ... done
[09:28:18.270] run() for ‘MulticoreFuture’ ... done
[09:28:18.270] Created future:
[09:28:18.270] plan(): Setting new future strategy stack:
[09:28:18.271] List of future strategies:
[09:28:18.271] 1. sequential:
[09:28:18.271]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.271]    - tweaked: FALSE
[09:28:18.271]    - call: NULL
[09:28:18.272] plan(): nbrOfWorkers() = 1
[09:28:18.274] plan(): Setting new future strategy stack:
[09:28:18.274] List of future strategies:
[09:28:18.274] 1. multicore:
[09:28:18.274]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.274]    - tweaked: FALSE
[09:28:18.274]    - call: plan(strategy)
[09:28:18.279] plan(): nbrOfWorkers() = 2
[09:28:18.270] MulticoreFuture:
[09:28:18.270] Label: ‘future_apply-1’
[09:28:18.270] Expression:
[09:28:18.270] {
[09:28:18.270]     do.call(function(...) {
[09:28:18.270]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.270]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.270]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.270]             on.exit(options(oopts), add = TRUE)
[09:28:18.270]         }
[09:28:18.270]         {
[09:28:18.270]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.270]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.270]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.270]             })
[09:28:18.270]         }
[09:28:18.270]     }, args = future.call.arguments)
[09:28:18.270] }
[09:28:18.270] Lazy evaluation: FALSE
[09:28:18.270] Asynchronous evaluation: TRUE
[09:28:18.270] Local evaluation: TRUE
[09:28:18.270] Environment: R_GlobalEnv
[09:28:18.270] Capture standard output: TRUE
[09:28:18.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.270] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.270] Packages: <none>
[09:28:18.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.270] Resolved: TRUE
[09:28:18.270] Value: <not collected>
[09:28:18.270] Conditions captured: <none>
[09:28:18.270] Early signaling: FALSE
[09:28:18.270] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.270] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.280] Chunk #1 of 2 ... DONE
[09:28:18.280] Chunk #2 of 2 ...
[09:28:18.280]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.280]  - seeds: <none>
[09:28:18.281]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.281] getGlobalsAndPackages() ...
[09:28:18.281] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.281] Resolving globals: FALSE
[09:28:18.281] Tweak future expression to call with '...' arguments ...
[09:28:18.281] {
[09:28:18.281]     do.call(function(...) {
[09:28:18.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.281]             on.exit(options(oopts), add = TRUE)
[09:28:18.281]         }
[09:28:18.281]         {
[09:28:18.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.281]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.281]             })
[09:28:18.281]         }
[09:28:18.281]     }, args = future.call.arguments)
[09:28:18.281] }
[09:28:18.282] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.282] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.283] 
[09:28:18.283] getGlobalsAndPackages() ... DONE
[09:28:18.283] run() for ‘Future’ ...
[09:28:18.283] - state: ‘created’
[09:28:18.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.289]   - Field: ‘label’
[09:28:18.289]   - Field: ‘local’
[09:28:18.289]   - Field: ‘owner’
[09:28:18.289]   - Field: ‘envir’
[09:28:18.289]   - Field: ‘workers’
[09:28:18.289]   - Field: ‘packages’
[09:28:18.289]   - Field: ‘gc’
[09:28:18.290]   - Field: ‘job’
[09:28:18.290]   - Field: ‘conditions’
[09:28:18.290]   - Field: ‘expr’
[09:28:18.290]   - Field: ‘uuid’
[09:28:18.290]   - Field: ‘seed’
[09:28:18.290]   - Field: ‘version’
[09:28:18.290]   - Field: ‘result’
[09:28:18.290]   - Field: ‘asynchronous’
[09:28:18.291]   - Field: ‘calls’
[09:28:18.291]   - Field: ‘globals’
[09:28:18.291]   - Field: ‘stdout’
[09:28:18.291]   - Field: ‘earlySignal’
[09:28:18.291]   - Field: ‘lazy’
[09:28:18.291]   - Field: ‘state’
[09:28:18.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.292] - Launch lazy future ...
[09:28:18.292] Packages needed by the future expression (n = 0): <none>
[09:28:18.292] Packages needed by future strategies (n = 0): <none>
[09:28:18.296] {
[09:28:18.296]     {
[09:28:18.296]         {
[09:28:18.296]             ...future.startTime <- base::Sys.time()
[09:28:18.296]             {
[09:28:18.296]                 {
[09:28:18.296]                   {
[09:28:18.296]                     {
[09:28:18.296]                       base::local({
[09:28:18.296]                         has_future <- base::requireNamespace("future", 
[09:28:18.296]                           quietly = TRUE)
[09:28:18.296]                         if (has_future) {
[09:28:18.296]                           ns <- base::getNamespace("future")
[09:28:18.296]                           version <- ns[[".package"]][["version"]]
[09:28:18.296]                           if (is.null(version)) 
[09:28:18.296]                             version <- utils::packageVersion("future")
[09:28:18.296]                         }
[09:28:18.296]                         else {
[09:28:18.296]                           version <- NULL
[09:28:18.296]                         }
[09:28:18.296]                         if (!has_future || version < "1.8.0") {
[09:28:18.296]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.296]                             "", base::R.version$version.string), 
[09:28:18.296]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.296]                               "release", "version")], collapse = " "), 
[09:28:18.296]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.296]                             info)
[09:28:18.296]                           info <- base::paste(info, collapse = "; ")
[09:28:18.296]                           if (!has_future) {
[09:28:18.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.296]                               info)
[09:28:18.296]                           }
[09:28:18.296]                           else {
[09:28:18.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.296]                               info, version)
[09:28:18.296]                           }
[09:28:18.296]                           base::stop(msg)
[09:28:18.296]                         }
[09:28:18.296]                       })
[09:28:18.296]                     }
[09:28:18.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.296]                     base::options(mc.cores = 1L)
[09:28:18.296]                   }
[09:28:18.296]                   ...future.strategy.old <- future::plan("list")
[09:28:18.296]                   options(future.plan = NULL)
[09:28:18.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.296]                 }
[09:28:18.296]                 ...future.workdir <- getwd()
[09:28:18.296]             }
[09:28:18.296]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.296]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.296]         }
[09:28:18.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.296]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.296]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.296]             base::names(...future.oldOptions))
[09:28:18.296]     }
[09:28:18.296]     if (FALSE) {
[09:28:18.296]     }
[09:28:18.296]     else {
[09:28:18.296]         if (TRUE) {
[09:28:18.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.296]                 open = "w")
[09:28:18.296]         }
[09:28:18.296]         else {
[09:28:18.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.296]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.296]         }
[09:28:18.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.296]             base::sink(type = "output", split = FALSE)
[09:28:18.296]             base::close(...future.stdout)
[09:28:18.296]         }, add = TRUE)
[09:28:18.296]     }
[09:28:18.296]     ...future.frame <- base::sys.nframe()
[09:28:18.296]     ...future.conditions <- base::list()
[09:28:18.296]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.296]     if (FALSE) {
[09:28:18.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.296]     }
[09:28:18.296]     ...future.result <- base::tryCatch({
[09:28:18.296]         base::withCallingHandlers({
[09:28:18.296]             ...future.value <- base::withVisible(base::local({
[09:28:18.296]                 withCallingHandlers({
[09:28:18.296]                   {
[09:28:18.296]                     do.call(function(...) {
[09:28:18.296]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.296]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.296]                         ...future.globals.maxSize)) {
[09:28:18.296]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.296]                         on.exit(options(oopts), add = TRUE)
[09:28:18.296]                       }
[09:28:18.296]                       {
[09:28:18.296]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.296]                           FUN = function(jj) {
[09:28:18.296]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.296]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.296]                           })
[09:28:18.296]                       }
[09:28:18.296]                     }, args = future.call.arguments)
[09:28:18.296]                   }
[09:28:18.296]                 }, immediateCondition = function(cond) {
[09:28:18.296]                   save_rds <- function (object, pathname, ...) 
[09:28:18.296]                   {
[09:28:18.296]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.296]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.296]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.296]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.296]                         fi_tmp[["mtime"]])
[09:28:18.296]                     }
[09:28:18.296]                     tryCatch({
[09:28:18.296]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.296]                     }, error = function(ex) {
[09:28:18.296]                       msg <- conditionMessage(ex)
[09:28:18.296]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.296]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.296]                         fi_tmp[["mtime"]], msg)
[09:28:18.296]                       ex$message <- msg
[09:28:18.296]                       stop(ex)
[09:28:18.296]                     })
[09:28:18.296]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.296]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.296]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.296]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.296]                       fi <- file.info(pathname)
[09:28:18.296]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.296]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.296]                         fi[["size"]], fi[["mtime"]])
[09:28:18.296]                       stop(msg)
[09:28:18.296]                     }
[09:28:18.296]                     invisible(pathname)
[09:28:18.296]                   }
[09:28:18.296]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.296]                     rootPath = tempdir()) 
[09:28:18.296]                   {
[09:28:18.296]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.296]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.296]                       tmpdir = path, fileext = ".rds")
[09:28:18.296]                     save_rds(obj, file)
[09:28:18.296]                   }
[09:28:18.296]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.296]                   {
[09:28:18.296]                     inherits <- base::inherits
[09:28:18.296]                     invokeRestart <- base::invokeRestart
[09:28:18.296]                     is.null <- base::is.null
[09:28:18.296]                     muffled <- FALSE
[09:28:18.296]                     if (inherits(cond, "message")) {
[09:28:18.296]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.296]                       if (muffled) 
[09:28:18.296]                         invokeRestart("muffleMessage")
[09:28:18.296]                     }
[09:28:18.296]                     else if (inherits(cond, "warning")) {
[09:28:18.296]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.296]                       if (muffled) 
[09:28:18.296]                         invokeRestart("muffleWarning")
[09:28:18.296]                     }
[09:28:18.296]                     else if (inherits(cond, "condition")) {
[09:28:18.296]                       if (!is.null(pattern)) {
[09:28:18.296]                         computeRestarts <- base::computeRestarts
[09:28:18.296]                         grepl <- base::grepl
[09:28:18.296]                         restarts <- computeRestarts(cond)
[09:28:18.296]                         for (restart in restarts) {
[09:28:18.296]                           name <- restart$name
[09:28:18.296]                           if (is.null(name)) 
[09:28:18.296]                             next
[09:28:18.296]                           if (!grepl(pattern, name)) 
[09:28:18.296]                             next
[09:28:18.296]                           invokeRestart(restart)
[09:28:18.296]                           muffled <- TRUE
[09:28:18.296]                           break
[09:28:18.296]                         }
[09:28:18.296]                       }
[09:28:18.296]                     }
[09:28:18.296]                     invisible(muffled)
[09:28:18.296]                   }
[09:28:18.296]                   muffleCondition(cond)
[09:28:18.296]                 })
[09:28:18.296]             }))
[09:28:18.296]             future::FutureResult(value = ...future.value$value, 
[09:28:18.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.296]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.296]                     ...future.globalenv.names))
[09:28:18.296]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.296]         }, condition = base::local({
[09:28:18.296]             c <- base::c
[09:28:18.296]             inherits <- base::inherits
[09:28:18.296]             invokeRestart <- base::invokeRestart
[09:28:18.296]             length <- base::length
[09:28:18.296]             list <- base::list
[09:28:18.296]             seq.int <- base::seq.int
[09:28:18.296]             signalCondition <- base::signalCondition
[09:28:18.296]             sys.calls <- base::sys.calls
[09:28:18.296]             `[[` <- base::`[[`
[09:28:18.296]             `+` <- base::`+`
[09:28:18.296]             `<<-` <- base::`<<-`
[09:28:18.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.296]                   3L)]
[09:28:18.296]             }
[09:28:18.296]             function(cond) {
[09:28:18.296]                 is_error <- inherits(cond, "error")
[09:28:18.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.296]                   NULL)
[09:28:18.296]                 if (is_error) {
[09:28:18.296]                   sessionInformation <- function() {
[09:28:18.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.296]                       search = base::search(), system = base::Sys.info())
[09:28:18.296]                   }
[09:28:18.296]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.296]                     cond$call), session = sessionInformation(), 
[09:28:18.296]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.296]                   signalCondition(cond)
[09:28:18.296]                 }
[09:28:18.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.296]                 "immediateCondition"))) {
[09:28:18.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.296]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.296]                   if (TRUE && !signal) {
[09:28:18.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.296]                     {
[09:28:18.296]                       inherits <- base::inherits
[09:28:18.296]                       invokeRestart <- base::invokeRestart
[09:28:18.296]                       is.null <- base::is.null
[09:28:18.296]                       muffled <- FALSE
[09:28:18.296]                       if (inherits(cond, "message")) {
[09:28:18.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.296]                         if (muffled) 
[09:28:18.296]                           invokeRestart("muffleMessage")
[09:28:18.296]                       }
[09:28:18.296]                       else if (inherits(cond, "warning")) {
[09:28:18.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.296]                         if (muffled) 
[09:28:18.296]                           invokeRestart("muffleWarning")
[09:28:18.296]                       }
[09:28:18.296]                       else if (inherits(cond, "condition")) {
[09:28:18.296]                         if (!is.null(pattern)) {
[09:28:18.296]                           computeRestarts <- base::computeRestarts
[09:28:18.296]                           grepl <- base::grepl
[09:28:18.296]                           restarts <- computeRestarts(cond)
[09:28:18.296]                           for (restart in restarts) {
[09:28:18.296]                             name <- restart$name
[09:28:18.296]                             if (is.null(name)) 
[09:28:18.296]                               next
[09:28:18.296]                             if (!grepl(pattern, name)) 
[09:28:18.296]                               next
[09:28:18.296]                             invokeRestart(restart)
[09:28:18.296]                             muffled <- TRUE
[09:28:18.296]                             break
[09:28:18.296]                           }
[09:28:18.296]                         }
[09:28:18.296]                       }
[09:28:18.296]                       invisible(muffled)
[09:28:18.296]                     }
[09:28:18.296]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.296]                   }
[09:28:18.296]                 }
[09:28:18.296]                 else {
[09:28:18.296]                   if (TRUE) {
[09:28:18.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.296]                     {
[09:28:18.296]                       inherits <- base::inherits
[09:28:18.296]                       invokeRestart <- base::invokeRestart
[09:28:18.296]                       is.null <- base::is.null
[09:28:18.296]                       muffled <- FALSE
[09:28:18.296]                       if (inherits(cond, "message")) {
[09:28:18.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.296]                         if (muffled) 
[09:28:18.296]                           invokeRestart("muffleMessage")
[09:28:18.296]                       }
[09:28:18.296]                       else if (inherits(cond, "warning")) {
[09:28:18.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.296]                         if (muffled) 
[09:28:18.296]                           invokeRestart("muffleWarning")
[09:28:18.296]                       }
[09:28:18.296]                       else if (inherits(cond, "condition")) {
[09:28:18.296]                         if (!is.null(pattern)) {
[09:28:18.296]                           computeRestarts <- base::computeRestarts
[09:28:18.296]                           grepl <- base::grepl
[09:28:18.296]                           restarts <- computeRestarts(cond)
[09:28:18.296]                           for (restart in restarts) {
[09:28:18.296]                             name <- restart$name
[09:28:18.296]                             if (is.null(name)) 
[09:28:18.296]                               next
[09:28:18.296]                             if (!grepl(pattern, name)) 
[09:28:18.296]                               next
[09:28:18.296]                             invokeRestart(restart)
[09:28:18.296]                             muffled <- TRUE
[09:28:18.296]                             break
[09:28:18.296]                           }
[09:28:18.296]                         }
[09:28:18.296]                       }
[09:28:18.296]                       invisible(muffled)
[09:28:18.296]                     }
[09:28:18.296]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.296]                   }
[09:28:18.296]                 }
[09:28:18.296]             }
[09:28:18.296]         }))
[09:28:18.296]     }, error = function(ex) {
[09:28:18.296]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.296]                 ...future.rng), started = ...future.startTime, 
[09:28:18.296]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.296]             version = "1.8"), class = "FutureResult")
[09:28:18.296]     }, finally = {
[09:28:18.296]         if (!identical(...future.workdir, getwd())) 
[09:28:18.296]             setwd(...future.workdir)
[09:28:18.296]         {
[09:28:18.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.296]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.296]             }
[09:28:18.296]             base::options(...future.oldOptions)
[09:28:18.296]             if (.Platform$OS.type == "windows") {
[09:28:18.296]                 old_names <- names(...future.oldEnvVars)
[09:28:18.296]                 envs <- base::Sys.getenv()
[09:28:18.296]                 names <- names(envs)
[09:28:18.296]                 common <- intersect(names, old_names)
[09:28:18.296]                 added <- setdiff(names, old_names)
[09:28:18.296]                 removed <- setdiff(old_names, names)
[09:28:18.296]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.296]                   envs[common]]
[09:28:18.296]                 NAMES <- toupper(changed)
[09:28:18.296]                 args <- list()
[09:28:18.296]                 for (kk in seq_along(NAMES)) {
[09:28:18.296]                   name <- changed[[kk]]
[09:28:18.296]                   NAME <- NAMES[[kk]]
[09:28:18.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.296]                     next
[09:28:18.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.296]                 }
[09:28:18.296]                 NAMES <- toupper(added)
[09:28:18.296]                 for (kk in seq_along(NAMES)) {
[09:28:18.296]                   name <- added[[kk]]
[09:28:18.296]                   NAME <- NAMES[[kk]]
[09:28:18.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.296]                     next
[09:28:18.296]                   args[[name]] <- ""
[09:28:18.296]                 }
[09:28:18.296]                 NAMES <- toupper(removed)
[09:28:18.296]                 for (kk in seq_along(NAMES)) {
[09:28:18.296]                   name <- removed[[kk]]
[09:28:18.296]                   NAME <- NAMES[[kk]]
[09:28:18.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.296]                     next
[09:28:18.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.296]                 }
[09:28:18.296]                 if (length(args) > 0) 
[09:28:18.296]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.296]             }
[09:28:18.296]             else {
[09:28:18.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.296]             }
[09:28:18.296]             {
[09:28:18.296]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.296]                   0L) {
[09:28:18.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.296]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.296]                   base::options(opts)
[09:28:18.296]                 }
[09:28:18.296]                 {
[09:28:18.296]                   {
[09:28:18.296]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.296]                     NULL
[09:28:18.296]                   }
[09:28:18.296]                   options(future.plan = NULL)
[09:28:18.296]                   if (is.na(NA_character_)) 
[09:28:18.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.296]                     .init = FALSE)
[09:28:18.296]                 }
[09:28:18.296]             }
[09:28:18.296]         }
[09:28:18.296]     })
[09:28:18.296]     if (TRUE) {
[09:28:18.296]         base::sink(type = "output", split = FALSE)
[09:28:18.296]         if (TRUE) {
[09:28:18.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.296]         }
[09:28:18.296]         else {
[09:28:18.296]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.296]         }
[09:28:18.296]         base::close(...future.stdout)
[09:28:18.296]         ...future.stdout <- NULL
[09:28:18.296]     }
[09:28:18.296]     ...future.result$conditions <- ...future.conditions
[09:28:18.296]     ...future.result$finished <- base::Sys.time()
[09:28:18.296]     ...future.result
[09:28:18.296] }
[09:28:18.299] assign_globals() ...
[09:28:18.300] List of 5
[09:28:18.300]  $ future.call.arguments    : list()
[09:28:18.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.300]  $ ...future.FUN            :function (x)  
[09:28:18.300]  $ ...future.elements_ii    :List of 1
[09:28:18.300]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:18.300]  $ ...future.seeds_ii       : NULL
[09:28:18.300]  $ ...future.globals.maxSize: num Inf
[09:28:18.300]  - attr(*, "resolved")= logi FALSE
[09:28:18.300]  - attr(*, "total_size")= num NA
[09:28:18.300]  - attr(*, "where")=List of 5
[09:28:18.300]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.300]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.300]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.300]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.300]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.300]  - attr(*, "already-done")= logi TRUE
[09:28:18.309] - copied ‘future.call.arguments’ to environment
[09:28:18.309] - copied ‘...future.FUN’ to environment
[09:28:18.309] - copied ‘...future.elements_ii’ to environment
[09:28:18.309] - copied ‘...future.seeds_ii’ to environment
[09:28:18.309] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.309] assign_globals() ... done
[09:28:18.310] requestCore(): workers = 2
[09:28:18.312] MulticoreFuture started
[09:28:18.312] - Launch lazy future ... done
[09:28:18.312] run() for ‘MulticoreFuture’ ... done
[09:28:18.312] Created future:
[09:28:18.313] plan(): Setting new future strategy stack:
[09:28:18.313] List of future strategies:
[09:28:18.313] 1. sequential:
[09:28:18.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.313]    - tweaked: FALSE
[09:28:18.313]    - call: NULL
[09:28:18.314] plan(): nbrOfWorkers() = 1
[09:28:18.316] plan(): Setting new future strategy stack:
[09:28:18.316] List of future strategies:
[09:28:18.316] 1. multicore:
[09:28:18.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.316]    - tweaked: FALSE
[09:28:18.316]    - call: plan(strategy)
[09:28:18.321] plan(): nbrOfWorkers() = 2
[09:28:18.313] MulticoreFuture:
[09:28:18.313] Label: ‘future_apply-2’
[09:28:18.313] Expression:
[09:28:18.313] {
[09:28:18.313]     do.call(function(...) {
[09:28:18.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.313]             on.exit(options(oopts), add = TRUE)
[09:28:18.313]         }
[09:28:18.313]         {
[09:28:18.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.313]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.313]             })
[09:28:18.313]         }
[09:28:18.313]     }, args = future.call.arguments)
[09:28:18.313] }
[09:28:18.313] Lazy evaluation: FALSE
[09:28:18.313] Asynchronous evaluation: TRUE
[09:28:18.313] Local evaluation: TRUE
[09:28:18.313] Environment: R_GlobalEnv
[09:28:18.313] Capture standard output: TRUE
[09:28:18.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.313] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.313] Packages: <none>
[09:28:18.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.313] Resolved: TRUE
[09:28:18.313] Value: <not collected>
[09:28:18.313] Conditions captured: <none>
[09:28:18.313] Early signaling: FALSE
[09:28:18.313] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.313] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.323] Chunk #2 of 2 ... DONE
[09:28:18.323] Launching 2 futures (chunks) ... DONE
[09:28:18.323] Resolving 2 futures (chunks) ...
[09:28:18.323] resolve() on list ...
[09:28:18.323]  recursive: 0
[09:28:18.323]  length: 2
[09:28:18.323] 
[09:28:18.324] Future #1
[09:28:18.324] result() for MulticoreFuture ...
[09:28:18.325] result() for MulticoreFuture ...
[09:28:18.325] result() for MulticoreFuture ... done
[09:28:18.325] result() for MulticoreFuture ... done
[09:28:18.325] result() for MulticoreFuture ...
[09:28:18.325] result() for MulticoreFuture ... done
[09:28:18.326] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.326] - nx: 2
[09:28:18.326] - relay: TRUE
[09:28:18.326] - stdout: TRUE
[09:28:18.326] - signal: TRUE
[09:28:18.326] - resignal: FALSE
[09:28:18.326] - force: TRUE
[09:28:18.326] - relayed: [n=2] FALSE, FALSE
[09:28:18.327] - queued futures: [n=2] FALSE, FALSE
[09:28:18.327]  - until=1
[09:28:18.327]  - relaying element #1
[09:28:18.327] result() for MulticoreFuture ...
[09:28:18.327] result() for MulticoreFuture ... done
[09:28:18.327] result() for MulticoreFuture ...
[09:28:18.328] result() for MulticoreFuture ... done
[09:28:18.328] result() for MulticoreFuture ...
[09:28:18.328] result() for MulticoreFuture ... done
[09:28:18.328] result() for MulticoreFuture ...
[09:28:18.328] result() for MulticoreFuture ... done
[09:28:18.328] - relayed: [n=2] TRUE, FALSE
[09:28:18.329] - queued futures: [n=2] TRUE, FALSE
[09:28:18.329] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.329]  length: 1 (resolved future 1)
[09:28:18.329] Future #2
[09:28:18.329] result() for MulticoreFuture ...
[09:28:18.330] result() for MulticoreFuture ...
[09:28:18.330] result() for MulticoreFuture ... done
[09:28:18.330] result() for MulticoreFuture ... done
[09:28:18.331] result() for MulticoreFuture ...
[09:28:18.331] result() for MulticoreFuture ... done
[09:28:18.331] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.331] - nx: 2
[09:28:18.331] - relay: TRUE
[09:28:18.331] - stdout: TRUE
[09:28:18.331] - signal: TRUE
[09:28:18.332] - resignal: FALSE
[09:28:18.332] - force: TRUE
[09:28:18.332] - relayed: [n=2] TRUE, FALSE
[09:28:18.332] - queued futures: [n=2] TRUE, FALSE
[09:28:18.332]  - until=2
[09:28:18.332]  - relaying element #2
[09:28:18.332] result() for MulticoreFuture ...
[09:28:18.332] result() for MulticoreFuture ... done
[09:28:18.333] result() for MulticoreFuture ...
[09:28:18.333] result() for MulticoreFuture ... done
[09:28:18.333] result() for MulticoreFuture ...
[09:28:18.333] result() for MulticoreFuture ... done
[09:28:18.333] result() for MulticoreFuture ...
[09:28:18.333] result() for MulticoreFuture ... done
[09:28:18.333] - relayed: [n=2] TRUE, TRUE
[09:28:18.333] - queued futures: [n=2] TRUE, TRUE
[09:28:18.333] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.334]  length: 0 (resolved future 2)
[09:28:18.334] Relaying remaining futures
[09:28:18.334] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.334] - nx: 2
[09:28:18.334] - relay: TRUE
[09:28:18.334] - stdout: TRUE
[09:28:18.334] - signal: TRUE
[09:28:18.334] - resignal: FALSE
[09:28:18.334] - force: TRUE
[09:28:18.335] - relayed: [n=2] TRUE, TRUE
[09:28:18.335] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.335] - relayed: [n=2] TRUE, TRUE
[09:28:18.335] - queued futures: [n=2] TRUE, TRUE
[09:28:18.335] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.335] resolve() on list ... DONE
[09:28:18.335] result() for MulticoreFuture ...
[09:28:18.335] result() for MulticoreFuture ... done
[09:28:18.335] result() for MulticoreFuture ...
[09:28:18.336] result() for MulticoreFuture ... done
[09:28:18.336] result() for MulticoreFuture ...
[09:28:18.336] result() for MulticoreFuture ... done
[09:28:18.336] result() for MulticoreFuture ...
[09:28:18.336] result() for MulticoreFuture ... done
[09:28:18.336]  - Number of value chunks collected: 2
[09:28:18.336] Resolving 2 futures (chunks) ... DONE
[09:28:18.336] Reducing values from 2 chunks ...
[09:28:18.336]  - Number of values collected after concatenation: 2
[09:28:18.337]  - Number of values expected: 2
[09:28:18.337] Reducing values from 2 chunks ... DONE
[09:28:18.337] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[09:28:18.337] getGlobalsAndPackagesXApply() ...
[09:28:18.337]  - future.globals: TRUE
[09:28:18.337] getGlobalsAndPackages() ...
[09:28:18.338] Searching for globals...
[09:28:18.339] - globals found: [1] ‘FUN’
[09:28:18.339] Searching for globals ... DONE
[09:28:18.339] Resolving globals: FALSE
[09:28:18.339] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:18.340] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:18.340] - globals: [1] ‘FUN’
[09:28:18.340] 
[09:28:18.340] getGlobalsAndPackages() ... DONE
[09:28:18.340]  - globals found/used: [n=1] ‘FUN’
[09:28:18.340]  - needed namespaces: [n=0] 
[09:28:18.341] Finding globals ... DONE
[09:28:18.341]  - use_args: TRUE
[09:28:18.341]  - Getting '...' globals ...
[09:28:18.341] resolve() on list ...
[09:28:18.341]  recursive: 0
[09:28:18.341]  length: 1
[09:28:18.341]  elements: ‘...’
[09:28:18.342]  length: 0 (resolved future 1)
[09:28:18.342] resolve() on list ... DONE
[09:28:18.342]    - '...' content: [n=0] 
[09:28:18.342] List of 1
[09:28:18.342]  $ ...: list()
[09:28:18.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.342]  - attr(*, "where")=List of 1
[09:28:18.342]   ..$ ...:<environment: 0x559ba443d1d0> 
[09:28:18.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.342]  - attr(*, "resolved")= logi TRUE
[09:28:18.342]  - attr(*, "total_size")= num NA
[09:28:18.348]  - Getting '...' globals ... DONE
[09:28:18.348] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.348] List of 2
[09:28:18.348]  $ ...future.FUN:function (x)  
[09:28:18.348]  $ ...          : list()
[09:28:18.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.348]  - attr(*, "where")=List of 2
[09:28:18.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.348]   ..$ ...          :<environment: 0x559ba443d1d0> 
[09:28:18.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.348]  - attr(*, "resolved")= logi FALSE
[09:28:18.348]  - attr(*, "total_size")= num 848
[09:28:18.351] Packages to be attached in all futures: [n=0] 
[09:28:18.352] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.355] future_lapply() ...
[09:28:18.359] Number of chunks: 2
[09:28:18.359] getGlobalsAndPackagesXApply() ...
[09:28:18.359]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.359]  - use_args: TRUE
[09:28:18.359] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.359] List of 2
[09:28:18.359]  $ ...          : list()
[09:28:18.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.359]  $ ...future.FUN:function (x)  
[09:28:18.359]  - attr(*, "where")=List of 2
[09:28:18.359]   ..$ ...          :<environment: 0x559ba443d1d0> 
[09:28:18.359]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.359]  - attr(*, "resolved")= logi FALSE
[09:28:18.359]  - attr(*, "total_size")= num NA
[09:28:18.363] Packages to be attached in all futures: [n=0] 
[09:28:18.363] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.363] Number of futures (= number of chunks): 2
[09:28:18.363] Launching 2 futures (chunks) ...
[09:28:18.363] Chunk #1 of 2 ...
[09:28:18.363]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.363]  - seeds: <none>
[09:28:18.363]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.364] getGlobalsAndPackages() ...
[09:28:18.364] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.364] Resolving globals: FALSE
[09:28:18.364] Tweak future expression to call with '...' arguments ...
[09:28:18.364] {
[09:28:18.364]     do.call(function(...) {
[09:28:18.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.364]             on.exit(options(oopts), add = TRUE)
[09:28:18.364]         }
[09:28:18.364]         {
[09:28:18.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.364]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.364]             })
[09:28:18.364]         }
[09:28:18.364]     }, args = future.call.arguments)
[09:28:18.364] }
[09:28:18.364] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.365] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.365] 
[09:28:18.365] getGlobalsAndPackages() ... DONE
[09:28:18.365] run() for ‘Future’ ...
[09:28:18.365] - state: ‘created’
[09:28:18.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.369]   - Field: ‘label’
[09:28:18.369]   - Field: ‘local’
[09:28:18.369]   - Field: ‘owner’
[09:28:18.369]   - Field: ‘envir’
[09:28:18.369]   - Field: ‘workers’
[09:28:18.370]   - Field: ‘packages’
[09:28:18.370]   - Field: ‘gc’
[09:28:18.370]   - Field: ‘job’
[09:28:18.370]   - Field: ‘conditions’
[09:28:18.370]   - Field: ‘expr’
[09:28:18.370]   - Field: ‘uuid’
[09:28:18.370]   - Field: ‘seed’
[09:28:18.370]   - Field: ‘version’
[09:28:18.370]   - Field: ‘result’
[09:28:18.370]   - Field: ‘asynchronous’
[09:28:18.370]   - Field: ‘calls’
[09:28:18.371]   - Field: ‘globals’
[09:28:18.371]   - Field: ‘stdout’
[09:28:18.371]   - Field: ‘earlySignal’
[09:28:18.371]   - Field: ‘lazy’
[09:28:18.371]   - Field: ‘state’
[09:28:18.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.371] - Launch lazy future ...
[09:28:18.371] Packages needed by the future expression (n = 0): <none>
[09:28:18.371] Packages needed by future strategies (n = 0): <none>
[09:28:18.372] {
[09:28:18.372]     {
[09:28:18.372]         {
[09:28:18.372]             ...future.startTime <- base::Sys.time()
[09:28:18.372]             {
[09:28:18.372]                 {
[09:28:18.372]                   {
[09:28:18.372]                     {
[09:28:18.372]                       base::local({
[09:28:18.372]                         has_future <- base::requireNamespace("future", 
[09:28:18.372]                           quietly = TRUE)
[09:28:18.372]                         if (has_future) {
[09:28:18.372]                           ns <- base::getNamespace("future")
[09:28:18.372]                           version <- ns[[".package"]][["version"]]
[09:28:18.372]                           if (is.null(version)) 
[09:28:18.372]                             version <- utils::packageVersion("future")
[09:28:18.372]                         }
[09:28:18.372]                         else {
[09:28:18.372]                           version <- NULL
[09:28:18.372]                         }
[09:28:18.372]                         if (!has_future || version < "1.8.0") {
[09:28:18.372]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.372]                             "", base::R.version$version.string), 
[09:28:18.372]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.372]                               "release", "version")], collapse = " "), 
[09:28:18.372]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.372]                             info)
[09:28:18.372]                           info <- base::paste(info, collapse = "; ")
[09:28:18.372]                           if (!has_future) {
[09:28:18.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.372]                               info)
[09:28:18.372]                           }
[09:28:18.372]                           else {
[09:28:18.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.372]                               info, version)
[09:28:18.372]                           }
[09:28:18.372]                           base::stop(msg)
[09:28:18.372]                         }
[09:28:18.372]                       })
[09:28:18.372]                     }
[09:28:18.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.372]                     base::options(mc.cores = 1L)
[09:28:18.372]                   }
[09:28:18.372]                   ...future.strategy.old <- future::plan("list")
[09:28:18.372]                   options(future.plan = NULL)
[09:28:18.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.372]                 }
[09:28:18.372]                 ...future.workdir <- getwd()
[09:28:18.372]             }
[09:28:18.372]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.372]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.372]         }
[09:28:18.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.372]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.372]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.372]             base::names(...future.oldOptions))
[09:28:18.372]     }
[09:28:18.372]     if (FALSE) {
[09:28:18.372]     }
[09:28:18.372]     else {
[09:28:18.372]         if (TRUE) {
[09:28:18.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.372]                 open = "w")
[09:28:18.372]         }
[09:28:18.372]         else {
[09:28:18.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.372]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.372]         }
[09:28:18.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.372]             base::sink(type = "output", split = FALSE)
[09:28:18.372]             base::close(...future.stdout)
[09:28:18.372]         }, add = TRUE)
[09:28:18.372]     }
[09:28:18.372]     ...future.frame <- base::sys.nframe()
[09:28:18.372]     ...future.conditions <- base::list()
[09:28:18.372]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.372]     if (FALSE) {
[09:28:18.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.372]     }
[09:28:18.372]     ...future.result <- base::tryCatch({
[09:28:18.372]         base::withCallingHandlers({
[09:28:18.372]             ...future.value <- base::withVisible(base::local({
[09:28:18.372]                 withCallingHandlers({
[09:28:18.372]                   {
[09:28:18.372]                     do.call(function(...) {
[09:28:18.372]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.372]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.372]                         ...future.globals.maxSize)) {
[09:28:18.372]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.372]                         on.exit(options(oopts), add = TRUE)
[09:28:18.372]                       }
[09:28:18.372]                       {
[09:28:18.372]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.372]                           FUN = function(jj) {
[09:28:18.372]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.372]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.372]                           })
[09:28:18.372]                       }
[09:28:18.372]                     }, args = future.call.arguments)
[09:28:18.372]                   }
[09:28:18.372]                 }, immediateCondition = function(cond) {
[09:28:18.372]                   save_rds <- function (object, pathname, ...) 
[09:28:18.372]                   {
[09:28:18.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.372]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.372]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.372]                         fi_tmp[["mtime"]])
[09:28:18.372]                     }
[09:28:18.372]                     tryCatch({
[09:28:18.372]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.372]                     }, error = function(ex) {
[09:28:18.372]                       msg <- conditionMessage(ex)
[09:28:18.372]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.372]                         fi_tmp[["mtime"]], msg)
[09:28:18.372]                       ex$message <- msg
[09:28:18.372]                       stop(ex)
[09:28:18.372]                     })
[09:28:18.372]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.372]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.372]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.372]                       fi <- file.info(pathname)
[09:28:18.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.372]                         fi[["size"]], fi[["mtime"]])
[09:28:18.372]                       stop(msg)
[09:28:18.372]                     }
[09:28:18.372]                     invisible(pathname)
[09:28:18.372]                   }
[09:28:18.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.372]                     rootPath = tempdir()) 
[09:28:18.372]                   {
[09:28:18.372]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.372]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.372]                       tmpdir = path, fileext = ".rds")
[09:28:18.372]                     save_rds(obj, file)
[09:28:18.372]                   }
[09:28:18.372]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.372]                   {
[09:28:18.372]                     inherits <- base::inherits
[09:28:18.372]                     invokeRestart <- base::invokeRestart
[09:28:18.372]                     is.null <- base::is.null
[09:28:18.372]                     muffled <- FALSE
[09:28:18.372]                     if (inherits(cond, "message")) {
[09:28:18.372]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.372]                       if (muffled) 
[09:28:18.372]                         invokeRestart("muffleMessage")
[09:28:18.372]                     }
[09:28:18.372]                     else if (inherits(cond, "warning")) {
[09:28:18.372]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.372]                       if (muffled) 
[09:28:18.372]                         invokeRestart("muffleWarning")
[09:28:18.372]                     }
[09:28:18.372]                     else if (inherits(cond, "condition")) {
[09:28:18.372]                       if (!is.null(pattern)) {
[09:28:18.372]                         computeRestarts <- base::computeRestarts
[09:28:18.372]                         grepl <- base::grepl
[09:28:18.372]                         restarts <- computeRestarts(cond)
[09:28:18.372]                         for (restart in restarts) {
[09:28:18.372]                           name <- restart$name
[09:28:18.372]                           if (is.null(name)) 
[09:28:18.372]                             next
[09:28:18.372]                           if (!grepl(pattern, name)) 
[09:28:18.372]                             next
[09:28:18.372]                           invokeRestart(restart)
[09:28:18.372]                           muffled <- TRUE
[09:28:18.372]                           break
[09:28:18.372]                         }
[09:28:18.372]                       }
[09:28:18.372]                     }
[09:28:18.372]                     invisible(muffled)
[09:28:18.372]                   }
[09:28:18.372]                   muffleCondition(cond)
[09:28:18.372]                 })
[09:28:18.372]             }))
[09:28:18.372]             future::FutureResult(value = ...future.value$value, 
[09:28:18.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.372]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.372]                     ...future.globalenv.names))
[09:28:18.372]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.372]         }, condition = base::local({
[09:28:18.372]             c <- base::c
[09:28:18.372]             inherits <- base::inherits
[09:28:18.372]             invokeRestart <- base::invokeRestart
[09:28:18.372]             length <- base::length
[09:28:18.372]             list <- base::list
[09:28:18.372]             seq.int <- base::seq.int
[09:28:18.372]             signalCondition <- base::signalCondition
[09:28:18.372]             sys.calls <- base::sys.calls
[09:28:18.372]             `[[` <- base::`[[`
[09:28:18.372]             `+` <- base::`+`
[09:28:18.372]             `<<-` <- base::`<<-`
[09:28:18.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.372]                   3L)]
[09:28:18.372]             }
[09:28:18.372]             function(cond) {
[09:28:18.372]                 is_error <- inherits(cond, "error")
[09:28:18.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.372]                   NULL)
[09:28:18.372]                 if (is_error) {
[09:28:18.372]                   sessionInformation <- function() {
[09:28:18.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.372]                       search = base::search(), system = base::Sys.info())
[09:28:18.372]                   }
[09:28:18.372]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.372]                     cond$call), session = sessionInformation(), 
[09:28:18.372]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.372]                   signalCondition(cond)
[09:28:18.372]                 }
[09:28:18.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.372]                 "immediateCondition"))) {
[09:28:18.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.372]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.372]                   if (TRUE && !signal) {
[09:28:18.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.372]                     {
[09:28:18.372]                       inherits <- base::inherits
[09:28:18.372]                       invokeRestart <- base::invokeRestart
[09:28:18.372]                       is.null <- base::is.null
[09:28:18.372]                       muffled <- FALSE
[09:28:18.372]                       if (inherits(cond, "message")) {
[09:28:18.372]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.372]                         if (muffled) 
[09:28:18.372]                           invokeRestart("muffleMessage")
[09:28:18.372]                       }
[09:28:18.372]                       else if (inherits(cond, "warning")) {
[09:28:18.372]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.372]                         if (muffled) 
[09:28:18.372]                           invokeRestart("muffleWarning")
[09:28:18.372]                       }
[09:28:18.372]                       else if (inherits(cond, "condition")) {
[09:28:18.372]                         if (!is.null(pattern)) {
[09:28:18.372]                           computeRestarts <- base::computeRestarts
[09:28:18.372]                           grepl <- base::grepl
[09:28:18.372]                           restarts <- computeRestarts(cond)
[09:28:18.372]                           for (restart in restarts) {
[09:28:18.372]                             name <- restart$name
[09:28:18.372]                             if (is.null(name)) 
[09:28:18.372]                               next
[09:28:18.372]                             if (!grepl(pattern, name)) 
[09:28:18.372]                               next
[09:28:18.372]                             invokeRestart(restart)
[09:28:18.372]                             muffled <- TRUE
[09:28:18.372]                             break
[09:28:18.372]                           }
[09:28:18.372]                         }
[09:28:18.372]                       }
[09:28:18.372]                       invisible(muffled)
[09:28:18.372]                     }
[09:28:18.372]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.372]                   }
[09:28:18.372]                 }
[09:28:18.372]                 else {
[09:28:18.372]                   if (TRUE) {
[09:28:18.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.372]                     {
[09:28:18.372]                       inherits <- base::inherits
[09:28:18.372]                       invokeRestart <- base::invokeRestart
[09:28:18.372]                       is.null <- base::is.null
[09:28:18.372]                       muffled <- FALSE
[09:28:18.372]                       if (inherits(cond, "message")) {
[09:28:18.372]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.372]                         if (muffled) 
[09:28:18.372]                           invokeRestart("muffleMessage")
[09:28:18.372]                       }
[09:28:18.372]                       else if (inherits(cond, "warning")) {
[09:28:18.372]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.372]                         if (muffled) 
[09:28:18.372]                           invokeRestart("muffleWarning")
[09:28:18.372]                       }
[09:28:18.372]                       else if (inherits(cond, "condition")) {
[09:28:18.372]                         if (!is.null(pattern)) {
[09:28:18.372]                           computeRestarts <- base::computeRestarts
[09:28:18.372]                           grepl <- base::grepl
[09:28:18.372]                           restarts <- computeRestarts(cond)
[09:28:18.372]                           for (restart in restarts) {
[09:28:18.372]                             name <- restart$name
[09:28:18.372]                             if (is.null(name)) 
[09:28:18.372]                               next
[09:28:18.372]                             if (!grepl(pattern, name)) 
[09:28:18.372]                               next
[09:28:18.372]                             invokeRestart(restart)
[09:28:18.372]                             muffled <- TRUE
[09:28:18.372]                             break
[09:28:18.372]                           }
[09:28:18.372]                         }
[09:28:18.372]                       }
[09:28:18.372]                       invisible(muffled)
[09:28:18.372]                     }
[09:28:18.372]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.372]                   }
[09:28:18.372]                 }
[09:28:18.372]             }
[09:28:18.372]         }))
[09:28:18.372]     }, error = function(ex) {
[09:28:18.372]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.372]                 ...future.rng), started = ...future.startTime, 
[09:28:18.372]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.372]             version = "1.8"), class = "FutureResult")
[09:28:18.372]     }, finally = {
[09:28:18.372]         if (!identical(...future.workdir, getwd())) 
[09:28:18.372]             setwd(...future.workdir)
[09:28:18.372]         {
[09:28:18.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.372]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.372]             }
[09:28:18.372]             base::options(...future.oldOptions)
[09:28:18.372]             if (.Platform$OS.type == "windows") {
[09:28:18.372]                 old_names <- names(...future.oldEnvVars)
[09:28:18.372]                 envs <- base::Sys.getenv()
[09:28:18.372]                 names <- names(envs)
[09:28:18.372]                 common <- intersect(names, old_names)
[09:28:18.372]                 added <- setdiff(names, old_names)
[09:28:18.372]                 removed <- setdiff(old_names, names)
[09:28:18.372]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.372]                   envs[common]]
[09:28:18.372]                 NAMES <- toupper(changed)
[09:28:18.372]                 args <- list()
[09:28:18.372]                 for (kk in seq_along(NAMES)) {
[09:28:18.372]                   name <- changed[[kk]]
[09:28:18.372]                   NAME <- NAMES[[kk]]
[09:28:18.372]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.372]                     next
[09:28:18.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.372]                 }
[09:28:18.372]                 NAMES <- toupper(added)
[09:28:18.372]                 for (kk in seq_along(NAMES)) {
[09:28:18.372]                   name <- added[[kk]]
[09:28:18.372]                   NAME <- NAMES[[kk]]
[09:28:18.372]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.372]                     next
[09:28:18.372]                   args[[name]] <- ""
[09:28:18.372]                 }
[09:28:18.372]                 NAMES <- toupper(removed)
[09:28:18.372]                 for (kk in seq_along(NAMES)) {
[09:28:18.372]                   name <- removed[[kk]]
[09:28:18.372]                   NAME <- NAMES[[kk]]
[09:28:18.372]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.372]                     next
[09:28:18.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.372]                 }
[09:28:18.372]                 if (length(args) > 0) 
[09:28:18.372]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.372]             }
[09:28:18.372]             else {
[09:28:18.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.372]             }
[09:28:18.372]             {
[09:28:18.372]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.372]                   0L) {
[09:28:18.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.372]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.372]                   base::options(opts)
[09:28:18.372]                 }
[09:28:18.372]                 {
[09:28:18.372]                   {
[09:28:18.372]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.372]                     NULL
[09:28:18.372]                   }
[09:28:18.372]                   options(future.plan = NULL)
[09:28:18.372]                   if (is.na(NA_character_)) 
[09:28:18.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.372]                     .init = FALSE)
[09:28:18.372]                 }
[09:28:18.372]             }
[09:28:18.372]         }
[09:28:18.372]     })
[09:28:18.372]     if (TRUE) {
[09:28:18.372]         base::sink(type = "output", split = FALSE)
[09:28:18.372]         if (TRUE) {
[09:28:18.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.372]         }
[09:28:18.372]         else {
[09:28:18.372]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.372]         }
[09:28:18.372]         base::close(...future.stdout)
[09:28:18.372]         ...future.stdout <- NULL
[09:28:18.372]     }
[09:28:18.372]     ...future.result$conditions <- ...future.conditions
[09:28:18.372]     ...future.result$finished <- base::Sys.time()
[09:28:18.372]     ...future.result
[09:28:18.372] }
[09:28:18.374] assign_globals() ...
[09:28:18.374] List of 5
[09:28:18.374]  $ future.call.arguments    : list()
[09:28:18.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.374]  $ ...future.FUN            :function (x)  
[09:28:18.374]  $ ...future.elements_ii    :List of 3
[09:28:18.374]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:18.374]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:18.374]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:18.374]  $ ...future.seeds_ii       : NULL
[09:28:18.374]  $ ...future.globals.maxSize: num Inf
[09:28:18.374]  - attr(*, "resolved")= logi FALSE
[09:28:18.374]  - attr(*, "total_size")= num NA
[09:28:18.374]  - attr(*, "where")=List of 5
[09:28:18.374]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.374]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.374]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.374]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.374]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.374]  - attr(*, "already-done")= logi TRUE
[09:28:18.381] - copied ‘future.call.arguments’ to environment
[09:28:18.382] - copied ‘...future.FUN’ to environment
[09:28:18.382] - copied ‘...future.elements_ii’ to environment
[09:28:18.382] - copied ‘...future.seeds_ii’ to environment
[09:28:18.382] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.382] assign_globals() ... done
[09:28:18.382] requestCore(): workers = 2
[09:28:18.384] MulticoreFuture started
[09:28:18.384] - Launch lazy future ... done
[09:28:18.385] run() for ‘MulticoreFuture’ ... done
[09:28:18.385] Created future:
[09:28:18.385] plan(): Setting new future strategy stack:
[09:28:18.386] List of future strategies:
[09:28:18.386] 1. sequential:
[09:28:18.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.386]    - tweaked: FALSE
[09:28:18.386]    - call: NULL
[09:28:18.387] plan(): nbrOfWorkers() = 1
[09:28:18.389] plan(): Setting new future strategy stack:
[09:28:18.389] List of future strategies:
[09:28:18.389] 1. multicore:
[09:28:18.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.389]    - tweaked: FALSE
[09:28:18.389]    - call: plan(strategy)
[09:28:18.394] plan(): nbrOfWorkers() = 2
[09:28:18.385] MulticoreFuture:
[09:28:18.385] Label: ‘future_apply-1’
[09:28:18.385] Expression:
[09:28:18.385] {
[09:28:18.385]     do.call(function(...) {
[09:28:18.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.385]             on.exit(options(oopts), add = TRUE)
[09:28:18.385]         }
[09:28:18.385]         {
[09:28:18.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.385]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.385]             })
[09:28:18.385]         }
[09:28:18.385]     }, args = future.call.arguments)
[09:28:18.385] }
[09:28:18.385] Lazy evaluation: FALSE
[09:28:18.385] Asynchronous evaluation: TRUE
[09:28:18.385] Local evaluation: TRUE
[09:28:18.385] Environment: R_GlobalEnv
[09:28:18.385] Capture standard output: TRUE
[09:28:18.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.385] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.385] Packages: <none>
[09:28:18.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.385] Resolved: TRUE
[09:28:18.385] Value: <not collected>
[09:28:18.385] Conditions captured: <none>
[09:28:18.385] Early signaling: FALSE
[09:28:18.385] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.385] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.395] Chunk #1 of 2 ... DONE
[09:28:18.395] Chunk #2 of 2 ...
[09:28:18.396]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.396]  - seeds: <none>
[09:28:18.396]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.396] getGlobalsAndPackages() ...
[09:28:18.396] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.396] Resolving globals: FALSE
[09:28:18.397] Tweak future expression to call with '...' arguments ...
[09:28:18.397] {
[09:28:18.397]     do.call(function(...) {
[09:28:18.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.397]             on.exit(options(oopts), add = TRUE)
[09:28:18.397]         }
[09:28:18.397]         {
[09:28:18.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.397]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.397]             })
[09:28:18.397]         }
[09:28:18.397]     }, args = future.call.arguments)
[09:28:18.397] }
[09:28:18.397] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.398] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.398] 
[09:28:18.398] getGlobalsAndPackages() ... DONE
[09:28:18.399] run() for ‘Future’ ...
[09:28:18.399] - state: ‘created’
[09:28:18.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.403] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.404]   - Field: ‘label’
[09:28:18.404]   - Field: ‘local’
[09:28:18.404]   - Field: ‘owner’
[09:28:18.404]   - Field: ‘envir’
[09:28:18.404]   - Field: ‘workers’
[09:28:18.404]   - Field: ‘packages’
[09:28:18.405]   - Field: ‘gc’
[09:28:18.405]   - Field: ‘job’
[09:28:18.405]   - Field: ‘conditions’
[09:28:18.405]   - Field: ‘expr’
[09:28:18.405]   - Field: ‘uuid’
[09:28:18.405]   - Field: ‘seed’
[09:28:18.405]   - Field: ‘version’
[09:28:18.406]   - Field: ‘result’
[09:28:18.406]   - Field: ‘asynchronous’
[09:28:18.406]   - Field: ‘calls’
[09:28:18.406]   - Field: ‘globals’
[09:28:18.406]   - Field: ‘stdout’
[09:28:18.406]   - Field: ‘earlySignal’
[09:28:18.406]   - Field: ‘lazy’
[09:28:18.407]   - Field: ‘state’
[09:28:18.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.407] - Launch lazy future ...
[09:28:18.407] Packages needed by the future expression (n = 0): <none>
[09:28:18.408] Packages needed by future strategies (n = 0): <none>
[09:28:18.408] {
[09:28:18.408]     {
[09:28:18.408]         {
[09:28:18.408]             ...future.startTime <- base::Sys.time()
[09:28:18.408]             {
[09:28:18.408]                 {
[09:28:18.408]                   {
[09:28:18.408]                     {
[09:28:18.408]                       base::local({
[09:28:18.408]                         has_future <- base::requireNamespace("future", 
[09:28:18.408]                           quietly = TRUE)
[09:28:18.408]                         if (has_future) {
[09:28:18.408]                           ns <- base::getNamespace("future")
[09:28:18.408]                           version <- ns[[".package"]][["version"]]
[09:28:18.408]                           if (is.null(version)) 
[09:28:18.408]                             version <- utils::packageVersion("future")
[09:28:18.408]                         }
[09:28:18.408]                         else {
[09:28:18.408]                           version <- NULL
[09:28:18.408]                         }
[09:28:18.408]                         if (!has_future || version < "1.8.0") {
[09:28:18.408]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.408]                             "", base::R.version$version.string), 
[09:28:18.408]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.408]                               "release", "version")], collapse = " "), 
[09:28:18.408]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.408]                             info)
[09:28:18.408]                           info <- base::paste(info, collapse = "; ")
[09:28:18.408]                           if (!has_future) {
[09:28:18.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.408]                               info)
[09:28:18.408]                           }
[09:28:18.408]                           else {
[09:28:18.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.408]                               info, version)
[09:28:18.408]                           }
[09:28:18.408]                           base::stop(msg)
[09:28:18.408]                         }
[09:28:18.408]                       })
[09:28:18.408]                     }
[09:28:18.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.408]                     base::options(mc.cores = 1L)
[09:28:18.408]                   }
[09:28:18.408]                   ...future.strategy.old <- future::plan("list")
[09:28:18.408]                   options(future.plan = NULL)
[09:28:18.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.408]                 }
[09:28:18.408]                 ...future.workdir <- getwd()
[09:28:18.408]             }
[09:28:18.408]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.408]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.408]         }
[09:28:18.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.408]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.408]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.408]             base::names(...future.oldOptions))
[09:28:18.408]     }
[09:28:18.408]     if (FALSE) {
[09:28:18.408]     }
[09:28:18.408]     else {
[09:28:18.408]         if (TRUE) {
[09:28:18.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.408]                 open = "w")
[09:28:18.408]         }
[09:28:18.408]         else {
[09:28:18.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.408]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.408]         }
[09:28:18.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.408]             base::sink(type = "output", split = FALSE)
[09:28:18.408]             base::close(...future.stdout)
[09:28:18.408]         }, add = TRUE)
[09:28:18.408]     }
[09:28:18.408]     ...future.frame <- base::sys.nframe()
[09:28:18.408]     ...future.conditions <- base::list()
[09:28:18.408]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.408]     if (FALSE) {
[09:28:18.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.408]     }
[09:28:18.408]     ...future.result <- base::tryCatch({
[09:28:18.408]         base::withCallingHandlers({
[09:28:18.408]             ...future.value <- base::withVisible(base::local({
[09:28:18.408]                 withCallingHandlers({
[09:28:18.408]                   {
[09:28:18.408]                     do.call(function(...) {
[09:28:18.408]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.408]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.408]                         ...future.globals.maxSize)) {
[09:28:18.408]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.408]                         on.exit(options(oopts), add = TRUE)
[09:28:18.408]                       }
[09:28:18.408]                       {
[09:28:18.408]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.408]                           FUN = function(jj) {
[09:28:18.408]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.408]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.408]                           })
[09:28:18.408]                       }
[09:28:18.408]                     }, args = future.call.arguments)
[09:28:18.408]                   }
[09:28:18.408]                 }, immediateCondition = function(cond) {
[09:28:18.408]                   save_rds <- function (object, pathname, ...) 
[09:28:18.408]                   {
[09:28:18.408]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.408]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.408]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.408]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.408]                         fi_tmp[["mtime"]])
[09:28:18.408]                     }
[09:28:18.408]                     tryCatch({
[09:28:18.408]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.408]                     }, error = function(ex) {
[09:28:18.408]                       msg <- conditionMessage(ex)
[09:28:18.408]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.408]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.408]                         fi_tmp[["mtime"]], msg)
[09:28:18.408]                       ex$message <- msg
[09:28:18.408]                       stop(ex)
[09:28:18.408]                     })
[09:28:18.408]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.408]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.408]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.408]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.408]                       fi <- file.info(pathname)
[09:28:18.408]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.408]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.408]                         fi[["size"]], fi[["mtime"]])
[09:28:18.408]                       stop(msg)
[09:28:18.408]                     }
[09:28:18.408]                     invisible(pathname)
[09:28:18.408]                   }
[09:28:18.408]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.408]                     rootPath = tempdir()) 
[09:28:18.408]                   {
[09:28:18.408]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.408]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.408]                       tmpdir = path, fileext = ".rds")
[09:28:18.408]                     save_rds(obj, file)
[09:28:18.408]                   }
[09:28:18.408]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.408]                   {
[09:28:18.408]                     inherits <- base::inherits
[09:28:18.408]                     invokeRestart <- base::invokeRestart
[09:28:18.408]                     is.null <- base::is.null
[09:28:18.408]                     muffled <- FALSE
[09:28:18.408]                     if (inherits(cond, "message")) {
[09:28:18.408]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.408]                       if (muffled) 
[09:28:18.408]                         invokeRestart("muffleMessage")
[09:28:18.408]                     }
[09:28:18.408]                     else if (inherits(cond, "warning")) {
[09:28:18.408]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.408]                       if (muffled) 
[09:28:18.408]                         invokeRestart("muffleWarning")
[09:28:18.408]                     }
[09:28:18.408]                     else if (inherits(cond, "condition")) {
[09:28:18.408]                       if (!is.null(pattern)) {
[09:28:18.408]                         computeRestarts <- base::computeRestarts
[09:28:18.408]                         grepl <- base::grepl
[09:28:18.408]                         restarts <- computeRestarts(cond)
[09:28:18.408]                         for (restart in restarts) {
[09:28:18.408]                           name <- restart$name
[09:28:18.408]                           if (is.null(name)) 
[09:28:18.408]                             next
[09:28:18.408]                           if (!grepl(pattern, name)) 
[09:28:18.408]                             next
[09:28:18.408]                           invokeRestart(restart)
[09:28:18.408]                           muffled <- TRUE
[09:28:18.408]                           break
[09:28:18.408]                         }
[09:28:18.408]                       }
[09:28:18.408]                     }
[09:28:18.408]                     invisible(muffled)
[09:28:18.408]                   }
[09:28:18.408]                   muffleCondition(cond)
[09:28:18.408]                 })
[09:28:18.408]             }))
[09:28:18.408]             future::FutureResult(value = ...future.value$value, 
[09:28:18.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.408]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.408]                     ...future.globalenv.names))
[09:28:18.408]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.408]         }, condition = base::local({
[09:28:18.408]             c <- base::c
[09:28:18.408]             inherits <- base::inherits
[09:28:18.408]             invokeRestart <- base::invokeRestart
[09:28:18.408]             length <- base::length
[09:28:18.408]             list <- base::list
[09:28:18.408]             seq.int <- base::seq.int
[09:28:18.408]             signalCondition <- base::signalCondition
[09:28:18.408]             sys.calls <- base::sys.calls
[09:28:18.408]             `[[` <- base::`[[`
[09:28:18.408]             `+` <- base::`+`
[09:28:18.408]             `<<-` <- base::`<<-`
[09:28:18.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.408]                   3L)]
[09:28:18.408]             }
[09:28:18.408]             function(cond) {
[09:28:18.408]                 is_error <- inherits(cond, "error")
[09:28:18.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.408]                   NULL)
[09:28:18.408]                 if (is_error) {
[09:28:18.408]                   sessionInformation <- function() {
[09:28:18.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.408]                       search = base::search(), system = base::Sys.info())
[09:28:18.408]                   }
[09:28:18.408]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.408]                     cond$call), session = sessionInformation(), 
[09:28:18.408]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.408]                   signalCondition(cond)
[09:28:18.408]                 }
[09:28:18.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.408]                 "immediateCondition"))) {
[09:28:18.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.408]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.408]                   if (TRUE && !signal) {
[09:28:18.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.408]                     {
[09:28:18.408]                       inherits <- base::inherits
[09:28:18.408]                       invokeRestart <- base::invokeRestart
[09:28:18.408]                       is.null <- base::is.null
[09:28:18.408]                       muffled <- FALSE
[09:28:18.408]                       if (inherits(cond, "message")) {
[09:28:18.408]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.408]                         if (muffled) 
[09:28:18.408]                           invokeRestart("muffleMessage")
[09:28:18.408]                       }
[09:28:18.408]                       else if (inherits(cond, "warning")) {
[09:28:18.408]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.408]                         if (muffled) 
[09:28:18.408]                           invokeRestart("muffleWarning")
[09:28:18.408]                       }
[09:28:18.408]                       else if (inherits(cond, "condition")) {
[09:28:18.408]                         if (!is.null(pattern)) {
[09:28:18.408]                           computeRestarts <- base::computeRestarts
[09:28:18.408]                           grepl <- base::grepl
[09:28:18.408]                           restarts <- computeRestarts(cond)
[09:28:18.408]                           for (restart in restarts) {
[09:28:18.408]                             name <- restart$name
[09:28:18.408]                             if (is.null(name)) 
[09:28:18.408]                               next
[09:28:18.408]                             if (!grepl(pattern, name)) 
[09:28:18.408]                               next
[09:28:18.408]                             invokeRestart(restart)
[09:28:18.408]                             muffled <- TRUE
[09:28:18.408]                             break
[09:28:18.408]                           }
[09:28:18.408]                         }
[09:28:18.408]                       }
[09:28:18.408]                       invisible(muffled)
[09:28:18.408]                     }
[09:28:18.408]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.408]                   }
[09:28:18.408]                 }
[09:28:18.408]                 else {
[09:28:18.408]                   if (TRUE) {
[09:28:18.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.408]                     {
[09:28:18.408]                       inherits <- base::inherits
[09:28:18.408]                       invokeRestart <- base::invokeRestart
[09:28:18.408]                       is.null <- base::is.null
[09:28:18.408]                       muffled <- FALSE
[09:28:18.408]                       if (inherits(cond, "message")) {
[09:28:18.408]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.408]                         if (muffled) 
[09:28:18.408]                           invokeRestart("muffleMessage")
[09:28:18.408]                       }
[09:28:18.408]                       else if (inherits(cond, "warning")) {
[09:28:18.408]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.408]                         if (muffled) 
[09:28:18.408]                           invokeRestart("muffleWarning")
[09:28:18.408]                       }
[09:28:18.408]                       else if (inherits(cond, "condition")) {
[09:28:18.408]                         if (!is.null(pattern)) {
[09:28:18.408]                           computeRestarts <- base::computeRestarts
[09:28:18.408]                           grepl <- base::grepl
[09:28:18.408]                           restarts <- computeRestarts(cond)
[09:28:18.408]                           for (restart in restarts) {
[09:28:18.408]                             name <- restart$name
[09:28:18.408]                             if (is.null(name)) 
[09:28:18.408]                               next
[09:28:18.408]                             if (!grepl(pattern, name)) 
[09:28:18.408]                               next
[09:28:18.408]                             invokeRestart(restart)
[09:28:18.408]                             muffled <- TRUE
[09:28:18.408]                             break
[09:28:18.408]                           }
[09:28:18.408]                         }
[09:28:18.408]                       }
[09:28:18.408]                       invisible(muffled)
[09:28:18.408]                     }
[09:28:18.408]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.408]                   }
[09:28:18.408]                 }
[09:28:18.408]             }
[09:28:18.408]         }))
[09:28:18.408]     }, error = function(ex) {
[09:28:18.408]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.408]                 ...future.rng), started = ...future.startTime, 
[09:28:18.408]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.408]             version = "1.8"), class = "FutureResult")
[09:28:18.408]     }, finally = {
[09:28:18.408]         if (!identical(...future.workdir, getwd())) 
[09:28:18.408]             setwd(...future.workdir)
[09:28:18.408]         {
[09:28:18.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.408]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.408]             }
[09:28:18.408]             base::options(...future.oldOptions)
[09:28:18.408]             if (.Platform$OS.type == "windows") {
[09:28:18.408]                 old_names <- names(...future.oldEnvVars)
[09:28:18.408]                 envs <- base::Sys.getenv()
[09:28:18.408]                 names <- names(envs)
[09:28:18.408]                 common <- intersect(names, old_names)
[09:28:18.408]                 added <- setdiff(names, old_names)
[09:28:18.408]                 removed <- setdiff(old_names, names)
[09:28:18.408]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.408]                   envs[common]]
[09:28:18.408]                 NAMES <- toupper(changed)
[09:28:18.408]                 args <- list()
[09:28:18.408]                 for (kk in seq_along(NAMES)) {
[09:28:18.408]                   name <- changed[[kk]]
[09:28:18.408]                   NAME <- NAMES[[kk]]
[09:28:18.408]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.408]                     next
[09:28:18.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.408]                 }
[09:28:18.408]                 NAMES <- toupper(added)
[09:28:18.408]                 for (kk in seq_along(NAMES)) {
[09:28:18.408]                   name <- added[[kk]]
[09:28:18.408]                   NAME <- NAMES[[kk]]
[09:28:18.408]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.408]                     next
[09:28:18.408]                   args[[name]] <- ""
[09:28:18.408]                 }
[09:28:18.408]                 NAMES <- toupper(removed)
[09:28:18.408]                 for (kk in seq_along(NAMES)) {
[09:28:18.408]                   name <- removed[[kk]]
[09:28:18.408]                   NAME <- NAMES[[kk]]
[09:28:18.408]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.408]                     next
[09:28:18.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.408]                 }
[09:28:18.408]                 if (length(args) > 0) 
[09:28:18.408]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.408]             }
[09:28:18.408]             else {
[09:28:18.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.408]             }
[09:28:18.408]             {
[09:28:18.408]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.408]                   0L) {
[09:28:18.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.408]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.408]                   base::options(opts)
[09:28:18.408]                 }
[09:28:18.408]                 {
[09:28:18.408]                   {
[09:28:18.408]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.408]                     NULL
[09:28:18.408]                   }
[09:28:18.408]                   options(future.plan = NULL)
[09:28:18.408]                   if (is.na(NA_character_)) 
[09:28:18.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.408]                     .init = FALSE)
[09:28:18.408]                 }
[09:28:18.408]             }
[09:28:18.408]         }
[09:28:18.408]     })
[09:28:18.408]     if (TRUE) {
[09:28:18.408]         base::sink(type = "output", split = FALSE)
[09:28:18.408]         if (TRUE) {
[09:28:18.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.408]         }
[09:28:18.408]         else {
[09:28:18.408]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.408]         }
[09:28:18.408]         base::close(...future.stdout)
[09:28:18.408]         ...future.stdout <- NULL
[09:28:18.408]     }
[09:28:18.408]     ...future.result$conditions <- ...future.conditions
[09:28:18.408]     ...future.result$finished <- base::Sys.time()
[09:28:18.408]     ...future.result
[09:28:18.408] }
[09:28:18.412] assign_globals() ...
[09:28:18.412] List of 5
[09:28:18.412]  $ future.call.arguments    : list()
[09:28:18.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.412]  $ ...future.FUN            :function (x)  
[09:28:18.412]  $ ...future.elements_ii    :List of 3
[09:28:18.412]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:18.412]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[09:28:18.412]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[09:28:18.412]  $ ...future.seeds_ii       : NULL
[09:28:18.412]  $ ...future.globals.maxSize: num Inf
[09:28:18.412]  - attr(*, "resolved")= logi FALSE
[09:28:18.412]  - attr(*, "total_size")= num NA
[09:28:18.412]  - attr(*, "where")=List of 5
[09:28:18.412]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.412]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.412]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.412]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.412]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.412]  - attr(*, "already-done")= logi TRUE
[09:28:18.420] - copied ‘future.call.arguments’ to environment
[09:28:18.420] - copied ‘...future.FUN’ to environment
[09:28:18.420] - copied ‘...future.elements_ii’ to environment
[09:28:18.420] - copied ‘...future.seeds_ii’ to environment
[09:28:18.421] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.421] assign_globals() ... done
[09:28:18.421] requestCore(): workers = 2
[09:28:18.423] MulticoreFuture started
[09:28:18.423] - Launch lazy future ... done
[09:28:18.423] run() for ‘MulticoreFuture’ ... done
[09:28:18.424] Created future:
[09:28:18.424] plan(): Setting new future strategy stack:
[09:28:18.424] List of future strategies:
[09:28:18.424] 1. sequential:
[09:28:18.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.424]    - tweaked: FALSE
[09:28:18.424]    - call: NULL
[09:28:18.425] plan(): nbrOfWorkers() = 1
[09:28:18.427] plan(): Setting new future strategy stack:
[09:28:18.427] List of future strategies:
[09:28:18.427] 1. multicore:
[09:28:18.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.427]    - tweaked: FALSE
[09:28:18.427]    - call: plan(strategy)
[09:28:18.424] MulticoreFuture:
[09:28:18.424] Label: ‘future_apply-2’
[09:28:18.424] Expression:
[09:28:18.424] {
[09:28:18.424]     do.call(function(...) {
[09:28:18.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.424]             on.exit(options(oopts), add = TRUE)
[09:28:18.424]         }
[09:28:18.424]         {
[09:28:18.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.424]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.424]             })
[09:28:18.424]         }
[09:28:18.424]     }, args = future.call.arguments)
[09:28:18.424] }
[09:28:18.424] Lazy evaluation: FALSE
[09:28:18.424] Asynchronous evaluation: TRUE
[09:28:18.424] Local evaluation: TRUE
[09:28:18.424] Environment: R_GlobalEnv
[09:28:18.424] Capture standard output: TRUE
[09:28:18.424] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.424] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.424] Packages: <none>
[09:28:18.424] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.424] Resolved: FALSE
[09:28:18.424] Value: <not collected>
[09:28:18.424] Conditions captured: <none>
[09:28:18.424] Early signaling: FALSE
[09:28:18.424] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.424] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.438] Chunk #2 of 2 ... DONE
[09:28:18.437] plan(): nbrOfWorkers() = 2
[09:28:18.438] Launching 2 futures (chunks) ... DONE
[09:28:18.438] Resolving 2 futures (chunks) ...
[09:28:18.438] resolve() on list ...
[09:28:18.438]  recursive: 0
[09:28:18.439]  length: 2
[09:28:18.439] 
[09:28:18.439] Future #1
[09:28:18.439] result() for MulticoreFuture ...
[09:28:18.443] result() for MulticoreFuture ...
[09:28:18.443] result() for MulticoreFuture ... done
[09:28:18.444] result() for MulticoreFuture ... done
[09:28:18.444] result() for MulticoreFuture ...
[09:28:18.445] result() for MulticoreFuture ... done
[09:28:18.445] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.445] - nx: 2
[09:28:18.446] - relay: TRUE
[09:28:18.446] - stdout: TRUE
[09:28:18.446] - signal: TRUE
[09:28:18.447] - resignal: FALSE
[09:28:18.447] - force: TRUE
[09:28:18.447] - relayed: [n=2] FALSE, FALSE
[09:28:18.447] - queued futures: [n=2] FALSE, FALSE
[09:28:18.448]  - until=1
[09:28:18.448]  - relaying element #1
[09:28:18.448] result() for MulticoreFuture ...
[09:28:18.449] result() for MulticoreFuture ... done
[09:28:18.449] result() for MulticoreFuture ...
[09:28:18.449] result() for MulticoreFuture ... done
[09:28:18.449] result() for MulticoreFuture ...
[09:28:18.450] result() for MulticoreFuture ... done
[09:28:18.450] result() for MulticoreFuture ...
[09:28:18.450] result() for MulticoreFuture ... done
[09:28:18.450] - relayed: [n=2] TRUE, FALSE
[09:28:18.450] - queued futures: [n=2] TRUE, FALSE
[09:28:18.451] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.451]  length: 1 (resolved future 1)
[09:28:18.451] Future #2
[09:28:18.451] result() for MulticoreFuture ...
[09:28:18.452] result() for MulticoreFuture ...
[09:28:18.452] result() for MulticoreFuture ... done
[09:28:18.452] result() for MulticoreFuture ... done
[09:28:18.453] result() for MulticoreFuture ...
[09:28:18.453] result() for MulticoreFuture ... done
[09:28:18.453] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.453] - nx: 2
[09:28:18.454] - relay: TRUE
[09:28:18.454] - stdout: TRUE
[09:28:18.454] - signal: TRUE
[09:28:18.454] - resignal: FALSE
[09:28:18.454] - force: TRUE
[09:28:18.454] - relayed: [n=2] TRUE, FALSE
[09:28:18.454] - queued futures: [n=2] TRUE, FALSE
[09:28:18.455]  - until=2
[09:28:18.455]  - relaying element #2
[09:28:18.455] result() for MulticoreFuture ...
[09:28:18.455] result() for MulticoreFuture ... done
[09:28:18.455] result() for MulticoreFuture ...
[09:28:18.455] result() for MulticoreFuture ... done
[09:28:18.455] result() for MulticoreFuture ...
[09:28:18.456] result() for MulticoreFuture ... done
[09:28:18.456] result() for MulticoreFuture ...
[09:28:18.456] result() for MulticoreFuture ... done
[09:28:18.456] - relayed: [n=2] TRUE, TRUE
[09:28:18.456] - queued futures: [n=2] TRUE, TRUE
[09:28:18.456] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.456]  length: 0 (resolved future 2)
[09:28:18.456] Relaying remaining futures
[09:28:18.456] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.457] - nx: 2
[09:28:18.457] - relay: TRUE
[09:28:18.457] - stdout: TRUE
[09:28:18.457] - signal: TRUE
[09:28:18.457] - resignal: FALSE
[09:28:18.457] - force: TRUE
[09:28:18.457] - relayed: [n=2] TRUE, TRUE
[09:28:18.457] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.457] - relayed: [n=2] TRUE, TRUE
[09:28:18.457] - queued futures: [n=2] TRUE, TRUE
[09:28:18.458] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.458] resolve() on list ... DONE
[09:28:18.458] result() for MulticoreFuture ...
[09:28:18.458] result() for MulticoreFuture ... done
[09:28:18.458] result() for MulticoreFuture ...
[09:28:18.458] result() for MulticoreFuture ... done
[09:28:18.458] result() for MulticoreFuture ...
[09:28:18.458] result() for MulticoreFuture ... done
[09:28:18.458] result() for MulticoreFuture ...
[09:28:18.458] result() for MulticoreFuture ... done
[09:28:18.459]  - Number of value chunks collected: 2
[09:28:18.459] Resolving 2 futures (chunks) ... DONE
[09:28:18.459] Reducing values from 2 chunks ...
[09:28:18.459]  - Number of values collected after concatenation: 6
[09:28:18.459]  - Number of values expected: 6
[09:28:18.459] Reducing values from 2 chunks ... DONE
[09:28:18.459] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[09:28:18.460] getGlobalsAndPackagesXApply() ...
[09:28:18.460]  - future.globals: TRUE
[09:28:18.460] getGlobalsAndPackages() ...
[09:28:18.460] Searching for globals...
[09:28:18.462] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[09:28:18.462] Searching for globals ... DONE
[09:28:18.462] Resolving globals: FALSE
[09:28:18.462] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[09:28:18.463] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[09:28:18.463] - globals: [1] ‘FUN’
[09:28:18.463] 
[09:28:18.463] getGlobalsAndPackages() ... DONE
[09:28:18.463]  - globals found/used: [n=1] ‘FUN’
[09:28:18.463]  - needed namespaces: [n=0] 
[09:28:18.463] Finding globals ... DONE
[09:28:18.463]  - use_args: TRUE
[09:28:18.464]  - Getting '...' globals ...
[09:28:18.464] resolve() on list ...
[09:28:18.464]  recursive: 0
[09:28:18.464]  length: 1
[09:28:18.464]  elements: ‘...’
[09:28:18.464]  length: 0 (resolved future 1)
[09:28:18.464] resolve() on list ... DONE
[09:28:18.465]    - '...' content: [n=0] 
[09:28:18.465] List of 1
[09:28:18.465]  $ ...: list()
[09:28:18.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.465]  - attr(*, "where")=List of 1
[09:28:18.465]   ..$ ...:<environment: 0x559ba2f10178> 
[09:28:18.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.465]  - attr(*, "resolved")= logi TRUE
[09:28:18.465]  - attr(*, "total_size")= num NA
[09:28:18.468]  - Getting '...' globals ... DONE
[09:28:18.468] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.468] List of 2
[09:28:18.468]  $ ...future.FUN:function (x)  
[09:28:18.468]  $ ...          : list()
[09:28:18.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.468]  - attr(*, "where")=List of 2
[09:28:18.468]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.468]   ..$ ...          :<environment: 0x559ba2f10178> 
[09:28:18.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.468]  - attr(*, "resolved")= logi FALSE
[09:28:18.468]  - attr(*, "total_size")= num 1768
[09:28:18.471] Packages to be attached in all futures: [n=0] 
[09:28:18.471] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.474] future_lapply() ...
[09:28:18.480] Number of chunks: 2
[09:28:18.480] getGlobalsAndPackagesXApply() ...
[09:28:18.480]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.480]  - use_args: TRUE
[09:28:18.480] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.480] List of 2
[09:28:18.480]  $ ...          : list()
[09:28:18.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.480]  $ ...future.FUN:function (x)  
[09:28:18.480]  - attr(*, "where")=List of 2
[09:28:18.480]   ..$ ...          :<environment: 0x559ba2f10178> 
[09:28:18.480]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:18.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.480]  - attr(*, "resolved")= logi FALSE
[09:28:18.480]  - attr(*, "total_size")= num NA
[09:28:18.483] Packages to be attached in all futures: [n=0] 
[09:28:18.483] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.483] Number of futures (= number of chunks): 2
[09:28:18.483] Launching 2 futures (chunks) ...
[09:28:18.484] Chunk #1 of 2 ...
[09:28:18.484]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.484]  - seeds: <none>
[09:28:18.484]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.484] getGlobalsAndPackages() ...
[09:28:18.484] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.484] Resolving globals: FALSE
[09:28:18.484] Tweak future expression to call with '...' arguments ...
[09:28:18.485] {
[09:28:18.485]     do.call(function(...) {
[09:28:18.485]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.485]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.485]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.485]             on.exit(options(oopts), add = TRUE)
[09:28:18.485]         }
[09:28:18.485]         {
[09:28:18.485]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.485]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.485]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.485]             })
[09:28:18.485]         }
[09:28:18.485]     }, args = future.call.arguments)
[09:28:18.485] }
[09:28:18.485] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.485] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.485] 
[09:28:18.485] getGlobalsAndPackages() ... DONE
[09:28:18.486] run() for ‘Future’ ...
[09:28:18.486] - state: ‘created’
[09:28:18.486] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.489] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.490]   - Field: ‘label’
[09:28:18.490]   - Field: ‘local’
[09:28:18.490]   - Field: ‘owner’
[09:28:18.490]   - Field: ‘envir’
[09:28:18.490]   - Field: ‘workers’
[09:28:18.490]   - Field: ‘packages’
[09:28:18.490]   - Field: ‘gc’
[09:28:18.490]   - Field: ‘job’
[09:28:18.490]   - Field: ‘conditions’
[09:28:18.490]   - Field: ‘expr’
[09:28:18.490]   - Field: ‘uuid’
[09:28:18.491]   - Field: ‘seed’
[09:28:18.491]   - Field: ‘version’
[09:28:18.491]   - Field: ‘result’
[09:28:18.491]   - Field: ‘asynchronous’
[09:28:18.491]   - Field: ‘calls’
[09:28:18.491]   - Field: ‘globals’
[09:28:18.491]   - Field: ‘stdout’
[09:28:18.491]   - Field: ‘earlySignal’
[09:28:18.491]   - Field: ‘lazy’
[09:28:18.491]   - Field: ‘state’
[09:28:18.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.491] - Launch lazy future ...
[09:28:18.492] Packages needed by the future expression (n = 0): <none>
[09:28:18.492] Packages needed by future strategies (n = 0): <none>
[09:28:18.492] {
[09:28:18.492]     {
[09:28:18.492]         {
[09:28:18.492]             ...future.startTime <- base::Sys.time()
[09:28:18.492]             {
[09:28:18.492]                 {
[09:28:18.492]                   {
[09:28:18.492]                     {
[09:28:18.492]                       base::local({
[09:28:18.492]                         has_future <- base::requireNamespace("future", 
[09:28:18.492]                           quietly = TRUE)
[09:28:18.492]                         if (has_future) {
[09:28:18.492]                           ns <- base::getNamespace("future")
[09:28:18.492]                           version <- ns[[".package"]][["version"]]
[09:28:18.492]                           if (is.null(version)) 
[09:28:18.492]                             version <- utils::packageVersion("future")
[09:28:18.492]                         }
[09:28:18.492]                         else {
[09:28:18.492]                           version <- NULL
[09:28:18.492]                         }
[09:28:18.492]                         if (!has_future || version < "1.8.0") {
[09:28:18.492]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.492]                             "", base::R.version$version.string), 
[09:28:18.492]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.492]                               "release", "version")], collapse = " "), 
[09:28:18.492]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.492]                             info)
[09:28:18.492]                           info <- base::paste(info, collapse = "; ")
[09:28:18.492]                           if (!has_future) {
[09:28:18.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.492]                               info)
[09:28:18.492]                           }
[09:28:18.492]                           else {
[09:28:18.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.492]                               info, version)
[09:28:18.492]                           }
[09:28:18.492]                           base::stop(msg)
[09:28:18.492]                         }
[09:28:18.492]                       })
[09:28:18.492]                     }
[09:28:18.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.492]                     base::options(mc.cores = 1L)
[09:28:18.492]                   }
[09:28:18.492]                   ...future.strategy.old <- future::plan("list")
[09:28:18.492]                   options(future.plan = NULL)
[09:28:18.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.492]                 }
[09:28:18.492]                 ...future.workdir <- getwd()
[09:28:18.492]             }
[09:28:18.492]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.492]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.492]         }
[09:28:18.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.492]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.492]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.492]             base::names(...future.oldOptions))
[09:28:18.492]     }
[09:28:18.492]     if (FALSE) {
[09:28:18.492]     }
[09:28:18.492]     else {
[09:28:18.492]         if (TRUE) {
[09:28:18.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.492]                 open = "w")
[09:28:18.492]         }
[09:28:18.492]         else {
[09:28:18.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.492]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.492]         }
[09:28:18.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.492]             base::sink(type = "output", split = FALSE)
[09:28:18.492]             base::close(...future.stdout)
[09:28:18.492]         }, add = TRUE)
[09:28:18.492]     }
[09:28:18.492]     ...future.frame <- base::sys.nframe()
[09:28:18.492]     ...future.conditions <- base::list()
[09:28:18.492]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.492]     if (FALSE) {
[09:28:18.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.492]     }
[09:28:18.492]     ...future.result <- base::tryCatch({
[09:28:18.492]         base::withCallingHandlers({
[09:28:18.492]             ...future.value <- base::withVisible(base::local({
[09:28:18.492]                 withCallingHandlers({
[09:28:18.492]                   {
[09:28:18.492]                     do.call(function(...) {
[09:28:18.492]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.492]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.492]                         ...future.globals.maxSize)) {
[09:28:18.492]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.492]                         on.exit(options(oopts), add = TRUE)
[09:28:18.492]                       }
[09:28:18.492]                       {
[09:28:18.492]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.492]                           FUN = function(jj) {
[09:28:18.492]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.492]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.492]                           })
[09:28:18.492]                       }
[09:28:18.492]                     }, args = future.call.arguments)
[09:28:18.492]                   }
[09:28:18.492]                 }, immediateCondition = function(cond) {
[09:28:18.492]                   save_rds <- function (object, pathname, ...) 
[09:28:18.492]                   {
[09:28:18.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.492]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.492]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.492]                         fi_tmp[["mtime"]])
[09:28:18.492]                     }
[09:28:18.492]                     tryCatch({
[09:28:18.492]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.492]                     }, error = function(ex) {
[09:28:18.492]                       msg <- conditionMessage(ex)
[09:28:18.492]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.492]                         fi_tmp[["mtime"]], msg)
[09:28:18.492]                       ex$message <- msg
[09:28:18.492]                       stop(ex)
[09:28:18.492]                     })
[09:28:18.492]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.492]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.492]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.492]                       fi <- file.info(pathname)
[09:28:18.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.492]                         fi[["size"]], fi[["mtime"]])
[09:28:18.492]                       stop(msg)
[09:28:18.492]                     }
[09:28:18.492]                     invisible(pathname)
[09:28:18.492]                   }
[09:28:18.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.492]                     rootPath = tempdir()) 
[09:28:18.492]                   {
[09:28:18.492]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.492]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.492]                       tmpdir = path, fileext = ".rds")
[09:28:18.492]                     save_rds(obj, file)
[09:28:18.492]                   }
[09:28:18.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.492]                   {
[09:28:18.492]                     inherits <- base::inherits
[09:28:18.492]                     invokeRestart <- base::invokeRestart
[09:28:18.492]                     is.null <- base::is.null
[09:28:18.492]                     muffled <- FALSE
[09:28:18.492]                     if (inherits(cond, "message")) {
[09:28:18.492]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.492]                       if (muffled) 
[09:28:18.492]                         invokeRestart("muffleMessage")
[09:28:18.492]                     }
[09:28:18.492]                     else if (inherits(cond, "warning")) {
[09:28:18.492]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.492]                       if (muffled) 
[09:28:18.492]                         invokeRestart("muffleWarning")
[09:28:18.492]                     }
[09:28:18.492]                     else if (inherits(cond, "condition")) {
[09:28:18.492]                       if (!is.null(pattern)) {
[09:28:18.492]                         computeRestarts <- base::computeRestarts
[09:28:18.492]                         grepl <- base::grepl
[09:28:18.492]                         restarts <- computeRestarts(cond)
[09:28:18.492]                         for (restart in restarts) {
[09:28:18.492]                           name <- restart$name
[09:28:18.492]                           if (is.null(name)) 
[09:28:18.492]                             next
[09:28:18.492]                           if (!grepl(pattern, name)) 
[09:28:18.492]                             next
[09:28:18.492]                           invokeRestart(restart)
[09:28:18.492]                           muffled <- TRUE
[09:28:18.492]                           break
[09:28:18.492]                         }
[09:28:18.492]                       }
[09:28:18.492]                     }
[09:28:18.492]                     invisible(muffled)
[09:28:18.492]                   }
[09:28:18.492]                   muffleCondition(cond)
[09:28:18.492]                 })
[09:28:18.492]             }))
[09:28:18.492]             future::FutureResult(value = ...future.value$value, 
[09:28:18.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.492]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.492]                     ...future.globalenv.names))
[09:28:18.492]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.492]         }, condition = base::local({
[09:28:18.492]             c <- base::c
[09:28:18.492]             inherits <- base::inherits
[09:28:18.492]             invokeRestart <- base::invokeRestart
[09:28:18.492]             length <- base::length
[09:28:18.492]             list <- base::list
[09:28:18.492]             seq.int <- base::seq.int
[09:28:18.492]             signalCondition <- base::signalCondition
[09:28:18.492]             sys.calls <- base::sys.calls
[09:28:18.492]             `[[` <- base::`[[`
[09:28:18.492]             `+` <- base::`+`
[09:28:18.492]             `<<-` <- base::`<<-`
[09:28:18.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.492]                   3L)]
[09:28:18.492]             }
[09:28:18.492]             function(cond) {
[09:28:18.492]                 is_error <- inherits(cond, "error")
[09:28:18.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.492]                   NULL)
[09:28:18.492]                 if (is_error) {
[09:28:18.492]                   sessionInformation <- function() {
[09:28:18.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.492]                       search = base::search(), system = base::Sys.info())
[09:28:18.492]                   }
[09:28:18.492]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.492]                     cond$call), session = sessionInformation(), 
[09:28:18.492]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.492]                   signalCondition(cond)
[09:28:18.492]                 }
[09:28:18.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.492]                 "immediateCondition"))) {
[09:28:18.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.492]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.492]                   if (TRUE && !signal) {
[09:28:18.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.492]                     {
[09:28:18.492]                       inherits <- base::inherits
[09:28:18.492]                       invokeRestart <- base::invokeRestart
[09:28:18.492]                       is.null <- base::is.null
[09:28:18.492]                       muffled <- FALSE
[09:28:18.492]                       if (inherits(cond, "message")) {
[09:28:18.492]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.492]                         if (muffled) 
[09:28:18.492]                           invokeRestart("muffleMessage")
[09:28:18.492]                       }
[09:28:18.492]                       else if (inherits(cond, "warning")) {
[09:28:18.492]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.492]                         if (muffled) 
[09:28:18.492]                           invokeRestart("muffleWarning")
[09:28:18.492]                       }
[09:28:18.492]                       else if (inherits(cond, "condition")) {
[09:28:18.492]                         if (!is.null(pattern)) {
[09:28:18.492]                           computeRestarts <- base::computeRestarts
[09:28:18.492]                           grepl <- base::grepl
[09:28:18.492]                           restarts <- computeRestarts(cond)
[09:28:18.492]                           for (restart in restarts) {
[09:28:18.492]                             name <- restart$name
[09:28:18.492]                             if (is.null(name)) 
[09:28:18.492]                               next
[09:28:18.492]                             if (!grepl(pattern, name)) 
[09:28:18.492]                               next
[09:28:18.492]                             invokeRestart(restart)
[09:28:18.492]                             muffled <- TRUE
[09:28:18.492]                             break
[09:28:18.492]                           }
[09:28:18.492]                         }
[09:28:18.492]                       }
[09:28:18.492]                       invisible(muffled)
[09:28:18.492]                     }
[09:28:18.492]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.492]                   }
[09:28:18.492]                 }
[09:28:18.492]                 else {
[09:28:18.492]                   if (TRUE) {
[09:28:18.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.492]                     {
[09:28:18.492]                       inherits <- base::inherits
[09:28:18.492]                       invokeRestart <- base::invokeRestart
[09:28:18.492]                       is.null <- base::is.null
[09:28:18.492]                       muffled <- FALSE
[09:28:18.492]                       if (inherits(cond, "message")) {
[09:28:18.492]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.492]                         if (muffled) 
[09:28:18.492]                           invokeRestart("muffleMessage")
[09:28:18.492]                       }
[09:28:18.492]                       else if (inherits(cond, "warning")) {
[09:28:18.492]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.492]                         if (muffled) 
[09:28:18.492]                           invokeRestart("muffleWarning")
[09:28:18.492]                       }
[09:28:18.492]                       else if (inherits(cond, "condition")) {
[09:28:18.492]                         if (!is.null(pattern)) {
[09:28:18.492]                           computeRestarts <- base::computeRestarts
[09:28:18.492]                           grepl <- base::grepl
[09:28:18.492]                           restarts <- computeRestarts(cond)
[09:28:18.492]                           for (restart in restarts) {
[09:28:18.492]                             name <- restart$name
[09:28:18.492]                             if (is.null(name)) 
[09:28:18.492]                               next
[09:28:18.492]                             if (!grepl(pattern, name)) 
[09:28:18.492]                               next
[09:28:18.492]                             invokeRestart(restart)
[09:28:18.492]                             muffled <- TRUE
[09:28:18.492]                             break
[09:28:18.492]                           }
[09:28:18.492]                         }
[09:28:18.492]                       }
[09:28:18.492]                       invisible(muffled)
[09:28:18.492]                     }
[09:28:18.492]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.492]                   }
[09:28:18.492]                 }
[09:28:18.492]             }
[09:28:18.492]         }))
[09:28:18.492]     }, error = function(ex) {
[09:28:18.492]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.492]                 ...future.rng), started = ...future.startTime, 
[09:28:18.492]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.492]             version = "1.8"), class = "FutureResult")
[09:28:18.492]     }, finally = {
[09:28:18.492]         if (!identical(...future.workdir, getwd())) 
[09:28:18.492]             setwd(...future.workdir)
[09:28:18.492]         {
[09:28:18.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.492]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.492]             }
[09:28:18.492]             base::options(...future.oldOptions)
[09:28:18.492]             if (.Platform$OS.type == "windows") {
[09:28:18.492]                 old_names <- names(...future.oldEnvVars)
[09:28:18.492]                 envs <- base::Sys.getenv()
[09:28:18.492]                 names <- names(envs)
[09:28:18.492]                 common <- intersect(names, old_names)
[09:28:18.492]                 added <- setdiff(names, old_names)
[09:28:18.492]                 removed <- setdiff(old_names, names)
[09:28:18.492]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.492]                   envs[common]]
[09:28:18.492]                 NAMES <- toupper(changed)
[09:28:18.492]                 args <- list()
[09:28:18.492]                 for (kk in seq_along(NAMES)) {
[09:28:18.492]                   name <- changed[[kk]]
[09:28:18.492]                   NAME <- NAMES[[kk]]
[09:28:18.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.492]                     next
[09:28:18.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.492]                 }
[09:28:18.492]                 NAMES <- toupper(added)
[09:28:18.492]                 for (kk in seq_along(NAMES)) {
[09:28:18.492]                   name <- added[[kk]]
[09:28:18.492]                   NAME <- NAMES[[kk]]
[09:28:18.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.492]                     next
[09:28:18.492]                   args[[name]] <- ""
[09:28:18.492]                 }
[09:28:18.492]                 NAMES <- toupper(removed)
[09:28:18.492]                 for (kk in seq_along(NAMES)) {
[09:28:18.492]                   name <- removed[[kk]]
[09:28:18.492]                   NAME <- NAMES[[kk]]
[09:28:18.492]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.492]                     next
[09:28:18.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.492]                 }
[09:28:18.492]                 if (length(args) > 0) 
[09:28:18.492]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.492]             }
[09:28:18.492]             else {
[09:28:18.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.492]             }
[09:28:18.492]             {
[09:28:18.492]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.492]                   0L) {
[09:28:18.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.492]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.492]                   base::options(opts)
[09:28:18.492]                 }
[09:28:18.492]                 {
[09:28:18.492]                   {
[09:28:18.492]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.492]                     NULL
[09:28:18.492]                   }
[09:28:18.492]                   options(future.plan = NULL)
[09:28:18.492]                   if (is.na(NA_character_)) 
[09:28:18.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.492]                     .init = FALSE)
[09:28:18.492]                 }
[09:28:18.492]             }
[09:28:18.492]         }
[09:28:18.492]     })
[09:28:18.492]     if (TRUE) {
[09:28:18.492]         base::sink(type = "output", split = FALSE)
[09:28:18.492]         if (TRUE) {
[09:28:18.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.492]         }
[09:28:18.492]         else {
[09:28:18.492]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.492]         }
[09:28:18.492]         base::close(...future.stdout)
[09:28:18.492]         ...future.stdout <- NULL
[09:28:18.492]     }
[09:28:18.492]     ...future.result$conditions <- ...future.conditions
[09:28:18.492]     ...future.result$finished <- base::Sys.time()
[09:28:18.492]     ...future.result
[09:28:18.492] }
[09:28:18.495] assign_globals() ...
[09:28:18.495] List of 5
[09:28:18.495]  $ future.call.arguments    : list()
[09:28:18.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.495]  $ ...future.FUN            :function (x)  
[09:28:18.495]  $ ...future.elements_ii    :List of 3
[09:28:18.495]   ..$ : int [1:4] 1 7 13 19
[09:28:18.495]   ..$ : int [1:4] 2 8 14 20
[09:28:18.495]   ..$ : int [1:4] 3 9 15 21
[09:28:18.495]  $ ...future.seeds_ii       : NULL
[09:28:18.495]  $ ...future.globals.maxSize: num Inf
[09:28:18.495]  - attr(*, "resolved")= logi FALSE
[09:28:18.495]  - attr(*, "total_size")= num NA
[09:28:18.495]  - attr(*, "where")=List of 5
[09:28:18.495]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.495]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.495]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.495]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.495]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.495]  - attr(*, "already-done")= logi TRUE
[09:28:18.500] - copied ‘future.call.arguments’ to environment
[09:28:18.500] - reassign environment for ‘...future.FUN’
[09:28:18.500] - copied ‘...future.FUN’ to environment
[09:28:18.500] - copied ‘...future.elements_ii’ to environment
[09:28:18.500] - copied ‘...future.seeds_ii’ to environment
[09:28:18.500] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.500] assign_globals() ... done
[09:28:18.501] requestCore(): workers = 2
[09:28:18.502] MulticoreFuture started
[09:28:18.503] - Launch lazy future ... done
[09:28:18.503] run() for ‘MulticoreFuture’ ... done
[09:28:18.503] Created future:
[09:28:18.504] plan(): Setting new future strategy stack:
[09:28:18.504] List of future strategies:
[09:28:18.504] 1. sequential:
[09:28:18.504]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.504]    - tweaked: FALSE
[09:28:18.504]    - call: NULL
[09:28:18.505] plan(): nbrOfWorkers() = 1
[09:28:18.507] plan(): Setting new future strategy stack:
[09:28:18.507] List of future strategies:
[09:28:18.507] 1. multicore:
[09:28:18.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.507]    - tweaked: FALSE
[09:28:18.507]    - call: plan(strategy)
[09:28:18.512] plan(): nbrOfWorkers() = 2
[09:28:18.503] MulticoreFuture:
[09:28:18.503] Label: ‘future_apply-1’
[09:28:18.503] Expression:
[09:28:18.503] {
[09:28:18.503]     do.call(function(...) {
[09:28:18.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.503]             on.exit(options(oopts), add = TRUE)
[09:28:18.503]         }
[09:28:18.503]         {
[09:28:18.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.503]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.503]             })
[09:28:18.503]         }
[09:28:18.503]     }, args = future.call.arguments)
[09:28:18.503] }
[09:28:18.503] Lazy evaluation: FALSE
[09:28:18.503] Asynchronous evaluation: TRUE
[09:28:18.503] Local evaluation: TRUE
[09:28:18.503] Environment: R_GlobalEnv
[09:28:18.503] Capture standard output: TRUE
[09:28:18.503] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.503] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.503] Packages: <none>
[09:28:18.503] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.503] Resolved: TRUE
[09:28:18.503] Value: <not collected>
[09:28:18.503] Conditions captured: <none>
[09:28:18.503] Early signaling: FALSE
[09:28:18.503] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.503] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.513] Chunk #1 of 2 ... DONE
[09:28:18.513] Chunk #2 of 2 ...
[09:28:18.513]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.513]  - seeds: <none>
[09:28:18.513]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.514] getGlobalsAndPackages() ...
[09:28:18.514] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.514] Resolving globals: FALSE
[09:28:18.514] Tweak future expression to call with '...' arguments ...
[09:28:18.514] {
[09:28:18.514]     do.call(function(...) {
[09:28:18.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.514]             on.exit(options(oopts), add = TRUE)
[09:28:18.514]         }
[09:28:18.514]         {
[09:28:18.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.514]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.514]             })
[09:28:18.514]         }
[09:28:18.514]     }, args = future.call.arguments)
[09:28:18.514] }
[09:28:18.515] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.515] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.515] 
[09:28:18.519] getGlobalsAndPackages() ... DONE
[09:28:18.520] run() for ‘Future’ ...
[09:28:18.520] - state: ‘created’
[09:28:18.521] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.528]   - Field: ‘label’
[09:28:18.528]   - Field: ‘local’
[09:28:18.528]   - Field: ‘owner’
[09:28:18.528]   - Field: ‘envir’
[09:28:18.529]   - Field: ‘workers’
[09:28:18.529]   - Field: ‘packages’
[09:28:18.529]   - Field: ‘gc’
[09:28:18.529]   - Field: ‘job’
[09:28:18.529]   - Field: ‘conditions’
[09:28:18.530]   - Field: ‘expr’
[09:28:18.530]   - Field: ‘uuid’
[09:28:18.530]   - Field: ‘seed’
[09:28:18.530]   - Field: ‘version’
[09:28:18.530]   - Field: ‘result’
[09:28:18.530]   - Field: ‘asynchronous’
[09:28:18.530]   - Field: ‘calls’
[09:28:18.530]   - Field: ‘globals’
[09:28:18.531]   - Field: ‘stdout’
[09:28:18.531]   - Field: ‘earlySignal’
[09:28:18.531]   - Field: ‘lazy’
[09:28:18.531]   - Field: ‘state’
[09:28:18.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.532] - Launch lazy future ...
[09:28:18.532] Packages needed by the future expression (n = 0): <none>
[09:28:18.532] Packages needed by future strategies (n = 0): <none>
[09:28:18.533] {
[09:28:18.533]     {
[09:28:18.533]         {
[09:28:18.533]             ...future.startTime <- base::Sys.time()
[09:28:18.533]             {
[09:28:18.533]                 {
[09:28:18.533]                   {
[09:28:18.533]                     {
[09:28:18.533]                       base::local({
[09:28:18.533]                         has_future <- base::requireNamespace("future", 
[09:28:18.533]                           quietly = TRUE)
[09:28:18.533]                         if (has_future) {
[09:28:18.533]                           ns <- base::getNamespace("future")
[09:28:18.533]                           version <- ns[[".package"]][["version"]]
[09:28:18.533]                           if (is.null(version)) 
[09:28:18.533]                             version <- utils::packageVersion("future")
[09:28:18.533]                         }
[09:28:18.533]                         else {
[09:28:18.533]                           version <- NULL
[09:28:18.533]                         }
[09:28:18.533]                         if (!has_future || version < "1.8.0") {
[09:28:18.533]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.533]                             "", base::R.version$version.string), 
[09:28:18.533]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.533]                               "release", "version")], collapse = " "), 
[09:28:18.533]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.533]                             info)
[09:28:18.533]                           info <- base::paste(info, collapse = "; ")
[09:28:18.533]                           if (!has_future) {
[09:28:18.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.533]                               info)
[09:28:18.533]                           }
[09:28:18.533]                           else {
[09:28:18.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.533]                               info, version)
[09:28:18.533]                           }
[09:28:18.533]                           base::stop(msg)
[09:28:18.533]                         }
[09:28:18.533]                       })
[09:28:18.533]                     }
[09:28:18.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.533]                     base::options(mc.cores = 1L)
[09:28:18.533]                   }
[09:28:18.533]                   ...future.strategy.old <- future::plan("list")
[09:28:18.533]                   options(future.plan = NULL)
[09:28:18.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.533]                 }
[09:28:18.533]                 ...future.workdir <- getwd()
[09:28:18.533]             }
[09:28:18.533]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.533]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.533]         }
[09:28:18.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.533]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.533]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.533]             base::names(...future.oldOptions))
[09:28:18.533]     }
[09:28:18.533]     if (FALSE) {
[09:28:18.533]     }
[09:28:18.533]     else {
[09:28:18.533]         if (TRUE) {
[09:28:18.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.533]                 open = "w")
[09:28:18.533]         }
[09:28:18.533]         else {
[09:28:18.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.533]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.533]         }
[09:28:18.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.533]             base::sink(type = "output", split = FALSE)
[09:28:18.533]             base::close(...future.stdout)
[09:28:18.533]         }, add = TRUE)
[09:28:18.533]     }
[09:28:18.533]     ...future.frame <- base::sys.nframe()
[09:28:18.533]     ...future.conditions <- base::list()
[09:28:18.533]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.533]     if (FALSE) {
[09:28:18.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.533]     }
[09:28:18.533]     ...future.result <- base::tryCatch({
[09:28:18.533]         base::withCallingHandlers({
[09:28:18.533]             ...future.value <- base::withVisible(base::local({
[09:28:18.533]                 withCallingHandlers({
[09:28:18.533]                   {
[09:28:18.533]                     do.call(function(...) {
[09:28:18.533]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.533]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.533]                         ...future.globals.maxSize)) {
[09:28:18.533]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.533]                         on.exit(options(oopts), add = TRUE)
[09:28:18.533]                       }
[09:28:18.533]                       {
[09:28:18.533]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.533]                           FUN = function(jj) {
[09:28:18.533]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.533]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.533]                           })
[09:28:18.533]                       }
[09:28:18.533]                     }, args = future.call.arguments)
[09:28:18.533]                   }
[09:28:18.533]                 }, immediateCondition = function(cond) {
[09:28:18.533]                   save_rds <- function (object, pathname, ...) 
[09:28:18.533]                   {
[09:28:18.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.533]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.533]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.533]                         fi_tmp[["mtime"]])
[09:28:18.533]                     }
[09:28:18.533]                     tryCatch({
[09:28:18.533]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.533]                     }, error = function(ex) {
[09:28:18.533]                       msg <- conditionMessage(ex)
[09:28:18.533]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.533]                         fi_tmp[["mtime"]], msg)
[09:28:18.533]                       ex$message <- msg
[09:28:18.533]                       stop(ex)
[09:28:18.533]                     })
[09:28:18.533]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.533]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.533]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.533]                       fi <- file.info(pathname)
[09:28:18.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.533]                         fi[["size"]], fi[["mtime"]])
[09:28:18.533]                       stop(msg)
[09:28:18.533]                     }
[09:28:18.533]                     invisible(pathname)
[09:28:18.533]                   }
[09:28:18.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.533]                     rootPath = tempdir()) 
[09:28:18.533]                   {
[09:28:18.533]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.533]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.533]                       tmpdir = path, fileext = ".rds")
[09:28:18.533]                     save_rds(obj, file)
[09:28:18.533]                   }
[09:28:18.533]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.533]                   {
[09:28:18.533]                     inherits <- base::inherits
[09:28:18.533]                     invokeRestart <- base::invokeRestart
[09:28:18.533]                     is.null <- base::is.null
[09:28:18.533]                     muffled <- FALSE
[09:28:18.533]                     if (inherits(cond, "message")) {
[09:28:18.533]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.533]                       if (muffled) 
[09:28:18.533]                         invokeRestart("muffleMessage")
[09:28:18.533]                     }
[09:28:18.533]                     else if (inherits(cond, "warning")) {
[09:28:18.533]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.533]                       if (muffled) 
[09:28:18.533]                         invokeRestart("muffleWarning")
[09:28:18.533]                     }
[09:28:18.533]                     else if (inherits(cond, "condition")) {
[09:28:18.533]                       if (!is.null(pattern)) {
[09:28:18.533]                         computeRestarts <- base::computeRestarts
[09:28:18.533]                         grepl <- base::grepl
[09:28:18.533]                         restarts <- computeRestarts(cond)
[09:28:18.533]                         for (restart in restarts) {
[09:28:18.533]                           name <- restart$name
[09:28:18.533]                           if (is.null(name)) 
[09:28:18.533]                             next
[09:28:18.533]                           if (!grepl(pattern, name)) 
[09:28:18.533]                             next
[09:28:18.533]                           invokeRestart(restart)
[09:28:18.533]                           muffled <- TRUE
[09:28:18.533]                           break
[09:28:18.533]                         }
[09:28:18.533]                       }
[09:28:18.533]                     }
[09:28:18.533]                     invisible(muffled)
[09:28:18.533]                   }
[09:28:18.533]                   muffleCondition(cond)
[09:28:18.533]                 })
[09:28:18.533]             }))
[09:28:18.533]             future::FutureResult(value = ...future.value$value, 
[09:28:18.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.533]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.533]                     ...future.globalenv.names))
[09:28:18.533]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.533]         }, condition = base::local({
[09:28:18.533]             c <- base::c
[09:28:18.533]             inherits <- base::inherits
[09:28:18.533]             invokeRestart <- base::invokeRestart
[09:28:18.533]             length <- base::length
[09:28:18.533]             list <- base::list
[09:28:18.533]             seq.int <- base::seq.int
[09:28:18.533]             signalCondition <- base::signalCondition
[09:28:18.533]             sys.calls <- base::sys.calls
[09:28:18.533]             `[[` <- base::`[[`
[09:28:18.533]             `+` <- base::`+`
[09:28:18.533]             `<<-` <- base::`<<-`
[09:28:18.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.533]                   3L)]
[09:28:18.533]             }
[09:28:18.533]             function(cond) {
[09:28:18.533]                 is_error <- inherits(cond, "error")
[09:28:18.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.533]                   NULL)
[09:28:18.533]                 if (is_error) {
[09:28:18.533]                   sessionInformation <- function() {
[09:28:18.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.533]                       search = base::search(), system = base::Sys.info())
[09:28:18.533]                   }
[09:28:18.533]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.533]                     cond$call), session = sessionInformation(), 
[09:28:18.533]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.533]                   signalCondition(cond)
[09:28:18.533]                 }
[09:28:18.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.533]                 "immediateCondition"))) {
[09:28:18.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.533]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.533]                   if (TRUE && !signal) {
[09:28:18.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.533]                     {
[09:28:18.533]                       inherits <- base::inherits
[09:28:18.533]                       invokeRestart <- base::invokeRestart
[09:28:18.533]                       is.null <- base::is.null
[09:28:18.533]                       muffled <- FALSE
[09:28:18.533]                       if (inherits(cond, "message")) {
[09:28:18.533]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.533]                         if (muffled) 
[09:28:18.533]                           invokeRestart("muffleMessage")
[09:28:18.533]                       }
[09:28:18.533]                       else if (inherits(cond, "warning")) {
[09:28:18.533]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.533]                         if (muffled) 
[09:28:18.533]                           invokeRestart("muffleWarning")
[09:28:18.533]                       }
[09:28:18.533]                       else if (inherits(cond, "condition")) {
[09:28:18.533]                         if (!is.null(pattern)) {
[09:28:18.533]                           computeRestarts <- base::computeRestarts
[09:28:18.533]                           grepl <- base::grepl
[09:28:18.533]                           restarts <- computeRestarts(cond)
[09:28:18.533]                           for (restart in restarts) {
[09:28:18.533]                             name <- restart$name
[09:28:18.533]                             if (is.null(name)) 
[09:28:18.533]                               next
[09:28:18.533]                             if (!grepl(pattern, name)) 
[09:28:18.533]                               next
[09:28:18.533]                             invokeRestart(restart)
[09:28:18.533]                             muffled <- TRUE
[09:28:18.533]                             break
[09:28:18.533]                           }
[09:28:18.533]                         }
[09:28:18.533]                       }
[09:28:18.533]                       invisible(muffled)
[09:28:18.533]                     }
[09:28:18.533]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.533]                   }
[09:28:18.533]                 }
[09:28:18.533]                 else {
[09:28:18.533]                   if (TRUE) {
[09:28:18.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.533]                     {
[09:28:18.533]                       inherits <- base::inherits
[09:28:18.533]                       invokeRestart <- base::invokeRestart
[09:28:18.533]                       is.null <- base::is.null
[09:28:18.533]                       muffled <- FALSE
[09:28:18.533]                       if (inherits(cond, "message")) {
[09:28:18.533]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.533]                         if (muffled) 
[09:28:18.533]                           invokeRestart("muffleMessage")
[09:28:18.533]                       }
[09:28:18.533]                       else if (inherits(cond, "warning")) {
[09:28:18.533]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.533]                         if (muffled) 
[09:28:18.533]                           invokeRestart("muffleWarning")
[09:28:18.533]                       }
[09:28:18.533]                       else if (inherits(cond, "condition")) {
[09:28:18.533]                         if (!is.null(pattern)) {
[09:28:18.533]                           computeRestarts <- base::computeRestarts
[09:28:18.533]                           grepl <- base::grepl
[09:28:18.533]                           restarts <- computeRestarts(cond)
[09:28:18.533]                           for (restart in restarts) {
[09:28:18.533]                             name <- restart$name
[09:28:18.533]                             if (is.null(name)) 
[09:28:18.533]                               next
[09:28:18.533]                             if (!grepl(pattern, name)) 
[09:28:18.533]                               next
[09:28:18.533]                             invokeRestart(restart)
[09:28:18.533]                             muffled <- TRUE
[09:28:18.533]                             break
[09:28:18.533]                           }
[09:28:18.533]                         }
[09:28:18.533]                       }
[09:28:18.533]                       invisible(muffled)
[09:28:18.533]                     }
[09:28:18.533]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.533]                   }
[09:28:18.533]                 }
[09:28:18.533]             }
[09:28:18.533]         }))
[09:28:18.533]     }, error = function(ex) {
[09:28:18.533]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.533]                 ...future.rng), started = ...future.startTime, 
[09:28:18.533]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.533]             version = "1.8"), class = "FutureResult")
[09:28:18.533]     }, finally = {
[09:28:18.533]         if (!identical(...future.workdir, getwd())) 
[09:28:18.533]             setwd(...future.workdir)
[09:28:18.533]         {
[09:28:18.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.533]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.533]             }
[09:28:18.533]             base::options(...future.oldOptions)
[09:28:18.533]             if (.Platform$OS.type == "windows") {
[09:28:18.533]                 old_names <- names(...future.oldEnvVars)
[09:28:18.533]                 envs <- base::Sys.getenv()
[09:28:18.533]                 names <- names(envs)
[09:28:18.533]                 common <- intersect(names, old_names)
[09:28:18.533]                 added <- setdiff(names, old_names)
[09:28:18.533]                 removed <- setdiff(old_names, names)
[09:28:18.533]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.533]                   envs[common]]
[09:28:18.533]                 NAMES <- toupper(changed)
[09:28:18.533]                 args <- list()
[09:28:18.533]                 for (kk in seq_along(NAMES)) {
[09:28:18.533]                   name <- changed[[kk]]
[09:28:18.533]                   NAME <- NAMES[[kk]]
[09:28:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.533]                     next
[09:28:18.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.533]                 }
[09:28:18.533]                 NAMES <- toupper(added)
[09:28:18.533]                 for (kk in seq_along(NAMES)) {
[09:28:18.533]                   name <- added[[kk]]
[09:28:18.533]                   NAME <- NAMES[[kk]]
[09:28:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.533]                     next
[09:28:18.533]                   args[[name]] <- ""
[09:28:18.533]                 }
[09:28:18.533]                 NAMES <- toupper(removed)
[09:28:18.533]                 for (kk in seq_along(NAMES)) {
[09:28:18.533]                   name <- removed[[kk]]
[09:28:18.533]                   NAME <- NAMES[[kk]]
[09:28:18.533]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.533]                     next
[09:28:18.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.533]                 }
[09:28:18.533]                 if (length(args) > 0) 
[09:28:18.533]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.533]             }
[09:28:18.533]             else {
[09:28:18.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.533]             }
[09:28:18.533]             {
[09:28:18.533]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.533]                   0L) {
[09:28:18.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.533]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.533]                   base::options(opts)
[09:28:18.533]                 }
[09:28:18.533]                 {
[09:28:18.533]                   {
[09:28:18.533]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.533]                     NULL
[09:28:18.533]                   }
[09:28:18.533]                   options(future.plan = NULL)
[09:28:18.533]                   if (is.na(NA_character_)) 
[09:28:18.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.533]                     .init = FALSE)
[09:28:18.533]                 }
[09:28:18.533]             }
[09:28:18.533]         }
[09:28:18.533]     })
[09:28:18.533]     if (TRUE) {
[09:28:18.533]         base::sink(type = "output", split = FALSE)
[09:28:18.533]         if (TRUE) {
[09:28:18.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.533]         }
[09:28:18.533]         else {
[09:28:18.533]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.533]         }
[09:28:18.533]         base::close(...future.stdout)
[09:28:18.533]         ...future.stdout <- NULL
[09:28:18.533]     }
[09:28:18.533]     ...future.result$conditions <- ...future.conditions
[09:28:18.533]     ...future.result$finished <- base::Sys.time()
[09:28:18.533]     ...future.result
[09:28:18.533] }
[09:28:18.536] assign_globals() ...
[09:28:18.536] List of 5
[09:28:18.536]  $ future.call.arguments    : list()
[09:28:18.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.536]  $ ...future.FUN            :function (x)  
[09:28:18.536]  $ ...future.elements_ii    :List of 3
[09:28:18.536]   ..$ : int [1:4] 4 10 16 22
[09:28:18.536]   ..$ : int [1:4] 5 11 17 23
[09:28:18.536]   ..$ : int [1:4] 6 12 18 24
[09:28:18.536]  $ ...future.seeds_ii       : NULL
[09:28:18.536]  $ ...future.globals.maxSize: num Inf
[09:28:18.536]  - attr(*, "resolved")= logi FALSE
[09:28:18.536]  - attr(*, "total_size")= num NA
[09:28:18.536]  - attr(*, "where")=List of 5
[09:28:18.536]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.536]  - attr(*, "already-done")= logi TRUE
[09:28:18.543] - copied ‘future.call.arguments’ to environment
[09:28:18.543] - reassign environment for ‘...future.FUN’
[09:28:18.543] - copied ‘...future.FUN’ to environment
[09:28:18.543] - copied ‘...future.elements_ii’ to environment
[09:28:18.543] - copied ‘...future.seeds_ii’ to environment
[09:28:18.543] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.543] assign_globals() ... done
[09:28:18.544] requestCore(): workers = 2
[09:28:18.546] MulticoreFuture started
[09:28:18.546] - Launch lazy future ... done
[09:28:18.546] run() for ‘MulticoreFuture’ ... done
[09:28:18.546] Created future:
[09:28:18.547] plan(): Setting new future strategy stack:
[09:28:18.547] List of future strategies:
[09:28:18.547] 1. sequential:
[09:28:18.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.547]    - tweaked: FALSE
[09:28:18.547]    - call: NULL
[09:28:18.548] plan(): nbrOfWorkers() = 1
[09:28:18.550] plan(): Setting new future strategy stack:
[09:28:18.550] List of future strategies:
[09:28:18.550] 1. multicore:
[09:28:18.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.550]    - tweaked: FALSE
[09:28:18.550]    - call: plan(strategy)
[09:28:18.555] plan(): nbrOfWorkers() = 2
[09:28:18.547] MulticoreFuture:
[09:28:18.547] Label: ‘future_apply-2’
[09:28:18.547] Expression:
[09:28:18.547] {
[09:28:18.547]     do.call(function(...) {
[09:28:18.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.547]             on.exit(options(oopts), add = TRUE)
[09:28:18.547]         }
[09:28:18.547]         {
[09:28:18.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.547]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.547]             })
[09:28:18.547]         }
[09:28:18.547]     }, args = future.call.arguments)
[09:28:18.547] }
[09:28:18.547] Lazy evaluation: FALSE
[09:28:18.547] Asynchronous evaluation: TRUE
[09:28:18.547] Local evaluation: TRUE
[09:28:18.547] Environment: R_GlobalEnv
[09:28:18.547] Capture standard output: TRUE
[09:28:18.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.547] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.547] Packages: <none>
[09:28:18.547] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.547] Resolved: TRUE
[09:28:18.547] Value: <not collected>
[09:28:18.547] Conditions captured: <none>
[09:28:18.547] Early signaling: FALSE
[09:28:18.547] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.547] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.556] Chunk #2 of 2 ... DONE
[09:28:18.556] Launching 2 futures (chunks) ... DONE
[09:28:18.556] Resolving 2 futures (chunks) ...
[09:28:18.557] resolve() on list ...
[09:28:18.557]  recursive: 0
[09:28:18.557]  length: 2
[09:28:18.557] 
[09:28:18.557] Future #1
[09:28:18.557] result() for MulticoreFuture ...
[09:28:18.558] result() for MulticoreFuture ...
[09:28:18.559] result() for MulticoreFuture ... done
[09:28:18.559] result() for MulticoreFuture ... done
[09:28:18.559] result() for MulticoreFuture ...
[09:28:18.559] result() for MulticoreFuture ... done
[09:28:18.559] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.559] - nx: 2
[09:28:18.559] - relay: TRUE
[09:28:18.560] - stdout: TRUE
[09:28:18.560] - signal: TRUE
[09:28:18.560] - resignal: FALSE
[09:28:18.560] - force: TRUE
[09:28:18.560] - relayed: [n=2] FALSE, FALSE
[09:28:18.560] - queued futures: [n=2] FALSE, FALSE
[09:28:18.560]  - until=1
[09:28:18.561]  - relaying element #1
[09:28:18.561] result() for MulticoreFuture ...
[09:28:18.561] result() for MulticoreFuture ... done
[09:28:18.561] result() for MulticoreFuture ...
[09:28:18.561] result() for MulticoreFuture ... done
[09:28:18.561] result() for MulticoreFuture ...
[09:28:18.561] result() for MulticoreFuture ... done
[09:28:18.562] result() for MulticoreFuture ...
[09:28:18.562] result() for MulticoreFuture ... done
[09:28:18.562] - relayed: [n=2] TRUE, FALSE
[09:28:18.562] - queued futures: [n=2] TRUE, FALSE
[09:28:18.562] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.562]  length: 1 (resolved future 1)
[09:28:18.563] Future #2
[09:28:18.563] result() for MulticoreFuture ...
[09:28:18.563] result() for MulticoreFuture ...
[09:28:18.564] result() for MulticoreFuture ... done
[09:28:18.564] result() for MulticoreFuture ... done
[09:28:18.564] result() for MulticoreFuture ...
[09:28:18.564] result() for MulticoreFuture ... done
[09:28:18.564] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.564] - nx: 2
[09:28:18.564] - relay: TRUE
[09:28:18.565] - stdout: TRUE
[09:28:18.565] - signal: TRUE
[09:28:18.565] - resignal: FALSE
[09:28:18.565] - force: TRUE
[09:28:18.565] - relayed: [n=2] TRUE, FALSE
[09:28:18.565] - queued futures: [n=2] TRUE, FALSE
[09:28:18.565]  - until=2
[09:28:18.565]  - relaying element #2
[09:28:18.565] result() for MulticoreFuture ...
[09:28:18.566] result() for MulticoreFuture ... done
[09:28:18.566] result() for MulticoreFuture ...
[09:28:18.566] result() for MulticoreFuture ... done
[09:28:18.566] result() for MulticoreFuture ...
[09:28:18.566] result() for MulticoreFuture ... done
[09:28:18.566] result() for MulticoreFuture ...
[09:28:18.566] result() for MulticoreFuture ... done
[09:28:18.566] - relayed: [n=2] TRUE, TRUE
[09:28:18.567] - queued futures: [n=2] TRUE, TRUE
[09:28:18.567] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.567]  length: 0 (resolved future 2)
[09:28:18.567] Relaying remaining futures
[09:28:18.567] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.567] - nx: 2
[09:28:18.567] - relay: TRUE
[09:28:18.567] - stdout: TRUE
[09:28:18.567] - signal: TRUE
[09:28:18.567] - resignal: FALSE
[09:28:18.570] - force: TRUE
[09:28:18.570] - relayed: [n=2] TRUE, TRUE
[09:28:18.570] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.571] - relayed: [n=2] TRUE, TRUE
[09:28:18.571] - queued futures: [n=2] TRUE, TRUE
[09:28:18.571] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.571] resolve() on list ... DONE
[09:28:18.571] result() for MulticoreFuture ...
[09:28:18.571] result() for MulticoreFuture ... done
[09:28:18.572] result() for MulticoreFuture ...
[09:28:18.572] result() for MulticoreFuture ... done
[09:28:18.572] result() for MulticoreFuture ...
[09:28:18.572] result() for MulticoreFuture ... done
[09:28:18.572] result() for MulticoreFuture ...
[09:28:18.573] result() for MulticoreFuture ... done
[09:28:18.573]  - Number of value chunks collected: 2
[09:28:18.573] Resolving 2 futures (chunks) ... DONE
[09:28:18.573] Reducing values from 2 chunks ...
[09:28:18.573]  - Number of values collected after concatenation: 6
[09:28:18.573]  - Number of values expected: 6
[09:28:18.574] Reducing values from 2 chunks ... DONE
[09:28:18.574] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[09:28:18.574] getGlobalsAndPackagesXApply() ...
[09:28:18.574]  - future.globals: TRUE
[09:28:18.574] getGlobalsAndPackages() ...
[09:28:18.575] Searching for globals...
[09:28:18.576] - globals found: [1] ‘FUN’
[09:28:18.576] Searching for globals ... DONE
[09:28:18.576] Resolving globals: FALSE
[09:28:18.577] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:18.577] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:18.577] - globals: [1] ‘FUN’
[09:28:18.577] 
[09:28:18.577] getGlobalsAndPackages() ... DONE
[09:28:18.577]  - globals found/used: [n=1] ‘FUN’
[09:28:18.578]  - needed namespaces: [n=0] 
[09:28:18.578] Finding globals ... DONE
[09:28:18.578]  - use_args: TRUE
[09:28:18.578]  - Getting '...' globals ...
[09:28:18.578] resolve() on list ...
[09:28:18.578]  recursive: 0
[09:28:18.578]  length: 1
[09:28:18.579]  elements: ‘...’
[09:28:18.579]  length: 0 (resolved future 1)
[09:28:18.579] resolve() on list ... DONE
[09:28:18.579]    - '...' content: [n=0] 
[09:28:18.579] List of 1
[09:28:18.579]  $ ...: list()
[09:28:18.579]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.579]  - attr(*, "where")=List of 1
[09:28:18.579]   ..$ ...:<environment: 0x559ba46bbcc8> 
[09:28:18.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.579]  - attr(*, "resolved")= logi TRUE
[09:28:18.579]  - attr(*, "total_size")= num NA
[09:28:18.582]  - Getting '...' globals ... DONE
[09:28:18.582] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.582] List of 2
[09:28:18.582]  $ ...future.FUN:function (x)  
[09:28:18.582]  $ ...          : list()
[09:28:18.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.582]  - attr(*, "where")=List of 2
[09:28:18.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.582]   ..$ ...          :<environment: 0x559ba46bbcc8> 
[09:28:18.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.582]  - attr(*, "resolved")= logi FALSE
[09:28:18.582]  - attr(*, "total_size")= num 848
[09:28:18.585] Packages to be attached in all futures: [n=0] 
[09:28:18.585] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.589] future_lapply() ...
[09:28:18.593] Number of chunks: 2
[09:28:18.593] getGlobalsAndPackagesXApply() ...
[09:28:18.593]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.593]  - use_args: TRUE
[09:28:18.593] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.593] List of 2
[09:28:18.593]  $ ...          : list()
[09:28:18.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.593]  $ ...future.FUN:function (x)  
[09:28:18.593]  - attr(*, "where")=List of 2
[09:28:18.593]   ..$ ...          :<environment: 0x559ba46bbcc8> 
[09:28:18.593]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.593]  - attr(*, "resolved")= logi FALSE
[09:28:18.593]  - attr(*, "total_size")= num NA
[09:28:18.596] Packages to be attached in all futures: [n=0] 
[09:28:18.597] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.597] Number of futures (= number of chunks): 2
[09:28:18.597] Launching 2 futures (chunks) ...
[09:28:18.597] Chunk #1 of 2 ...
[09:28:18.597]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.597]  - seeds: <none>
[09:28:18.597]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.597] getGlobalsAndPackages() ...
[09:28:18.598] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.598] Resolving globals: FALSE
[09:28:18.598] Tweak future expression to call with '...' arguments ...
[09:28:18.598] {
[09:28:18.598]     do.call(function(...) {
[09:28:18.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.598]             on.exit(options(oopts), add = TRUE)
[09:28:18.598]         }
[09:28:18.598]         {
[09:28:18.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.598]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.598]             })
[09:28:18.598]         }
[09:28:18.598]     }, args = future.call.arguments)
[09:28:18.598] }
[09:28:18.598] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.599] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.599] 
[09:28:18.599] getGlobalsAndPackages() ... DONE
[09:28:18.599] run() for ‘Future’ ...
[09:28:18.599] - state: ‘created’
[09:28:18.599] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.605]   - Field: ‘label’
[09:28:18.605]   - Field: ‘local’
[09:28:18.605]   - Field: ‘owner’
[09:28:18.605]   - Field: ‘envir’
[09:28:18.605]   - Field: ‘workers’
[09:28:18.605]   - Field: ‘packages’
[09:28:18.605]   - Field: ‘gc’
[09:28:18.605]   - Field: ‘job’
[09:28:18.605]   - Field: ‘conditions’
[09:28:18.606]   - Field: ‘expr’
[09:28:18.606]   - Field: ‘uuid’
[09:28:18.606]   - Field: ‘seed’
[09:28:18.606]   - Field: ‘version’
[09:28:18.606]   - Field: ‘result’
[09:28:18.606]   - Field: ‘asynchronous’
[09:28:18.606]   - Field: ‘calls’
[09:28:18.606]   - Field: ‘globals’
[09:28:18.606]   - Field: ‘stdout’
[09:28:18.606]   - Field: ‘earlySignal’
[09:28:18.607]   - Field: ‘lazy’
[09:28:18.607]   - Field: ‘state’
[09:28:18.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.607] - Launch lazy future ...
[09:28:18.607] Packages needed by the future expression (n = 0): <none>
[09:28:18.607] Packages needed by future strategies (n = 0): <none>
[09:28:18.608] {
[09:28:18.608]     {
[09:28:18.608]         {
[09:28:18.608]             ...future.startTime <- base::Sys.time()
[09:28:18.608]             {
[09:28:18.608]                 {
[09:28:18.608]                   {
[09:28:18.608]                     {
[09:28:18.608]                       base::local({
[09:28:18.608]                         has_future <- base::requireNamespace("future", 
[09:28:18.608]                           quietly = TRUE)
[09:28:18.608]                         if (has_future) {
[09:28:18.608]                           ns <- base::getNamespace("future")
[09:28:18.608]                           version <- ns[[".package"]][["version"]]
[09:28:18.608]                           if (is.null(version)) 
[09:28:18.608]                             version <- utils::packageVersion("future")
[09:28:18.608]                         }
[09:28:18.608]                         else {
[09:28:18.608]                           version <- NULL
[09:28:18.608]                         }
[09:28:18.608]                         if (!has_future || version < "1.8.0") {
[09:28:18.608]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.608]                             "", base::R.version$version.string), 
[09:28:18.608]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.608]                               "release", "version")], collapse = " "), 
[09:28:18.608]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.608]                             info)
[09:28:18.608]                           info <- base::paste(info, collapse = "; ")
[09:28:18.608]                           if (!has_future) {
[09:28:18.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.608]                               info)
[09:28:18.608]                           }
[09:28:18.608]                           else {
[09:28:18.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.608]                               info, version)
[09:28:18.608]                           }
[09:28:18.608]                           base::stop(msg)
[09:28:18.608]                         }
[09:28:18.608]                       })
[09:28:18.608]                     }
[09:28:18.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.608]                     base::options(mc.cores = 1L)
[09:28:18.608]                   }
[09:28:18.608]                   ...future.strategy.old <- future::plan("list")
[09:28:18.608]                   options(future.plan = NULL)
[09:28:18.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.608]                 }
[09:28:18.608]                 ...future.workdir <- getwd()
[09:28:18.608]             }
[09:28:18.608]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.608]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.608]         }
[09:28:18.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.608]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.608]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.608]             base::names(...future.oldOptions))
[09:28:18.608]     }
[09:28:18.608]     if (FALSE) {
[09:28:18.608]     }
[09:28:18.608]     else {
[09:28:18.608]         if (TRUE) {
[09:28:18.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.608]                 open = "w")
[09:28:18.608]         }
[09:28:18.608]         else {
[09:28:18.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.608]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.608]         }
[09:28:18.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.608]             base::sink(type = "output", split = FALSE)
[09:28:18.608]             base::close(...future.stdout)
[09:28:18.608]         }, add = TRUE)
[09:28:18.608]     }
[09:28:18.608]     ...future.frame <- base::sys.nframe()
[09:28:18.608]     ...future.conditions <- base::list()
[09:28:18.608]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.608]     if (FALSE) {
[09:28:18.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.608]     }
[09:28:18.608]     ...future.result <- base::tryCatch({
[09:28:18.608]         base::withCallingHandlers({
[09:28:18.608]             ...future.value <- base::withVisible(base::local({
[09:28:18.608]                 withCallingHandlers({
[09:28:18.608]                   {
[09:28:18.608]                     do.call(function(...) {
[09:28:18.608]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.608]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.608]                         ...future.globals.maxSize)) {
[09:28:18.608]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.608]                         on.exit(options(oopts), add = TRUE)
[09:28:18.608]                       }
[09:28:18.608]                       {
[09:28:18.608]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.608]                           FUN = function(jj) {
[09:28:18.608]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.608]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.608]                           })
[09:28:18.608]                       }
[09:28:18.608]                     }, args = future.call.arguments)
[09:28:18.608]                   }
[09:28:18.608]                 }, immediateCondition = function(cond) {
[09:28:18.608]                   save_rds <- function (object, pathname, ...) 
[09:28:18.608]                   {
[09:28:18.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.608]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.608]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.608]                         fi_tmp[["mtime"]])
[09:28:18.608]                     }
[09:28:18.608]                     tryCatch({
[09:28:18.608]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.608]                     }, error = function(ex) {
[09:28:18.608]                       msg <- conditionMessage(ex)
[09:28:18.608]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.608]                         fi_tmp[["mtime"]], msg)
[09:28:18.608]                       ex$message <- msg
[09:28:18.608]                       stop(ex)
[09:28:18.608]                     })
[09:28:18.608]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.608]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.608]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.608]                       fi <- file.info(pathname)
[09:28:18.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.608]                         fi[["size"]], fi[["mtime"]])
[09:28:18.608]                       stop(msg)
[09:28:18.608]                     }
[09:28:18.608]                     invisible(pathname)
[09:28:18.608]                   }
[09:28:18.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.608]                     rootPath = tempdir()) 
[09:28:18.608]                   {
[09:28:18.608]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.608]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.608]                       tmpdir = path, fileext = ".rds")
[09:28:18.608]                     save_rds(obj, file)
[09:28:18.608]                   }
[09:28:18.608]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.608]                   {
[09:28:18.608]                     inherits <- base::inherits
[09:28:18.608]                     invokeRestart <- base::invokeRestart
[09:28:18.608]                     is.null <- base::is.null
[09:28:18.608]                     muffled <- FALSE
[09:28:18.608]                     if (inherits(cond, "message")) {
[09:28:18.608]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.608]                       if (muffled) 
[09:28:18.608]                         invokeRestart("muffleMessage")
[09:28:18.608]                     }
[09:28:18.608]                     else if (inherits(cond, "warning")) {
[09:28:18.608]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.608]                       if (muffled) 
[09:28:18.608]                         invokeRestart("muffleWarning")
[09:28:18.608]                     }
[09:28:18.608]                     else if (inherits(cond, "condition")) {
[09:28:18.608]                       if (!is.null(pattern)) {
[09:28:18.608]                         computeRestarts <- base::computeRestarts
[09:28:18.608]                         grepl <- base::grepl
[09:28:18.608]                         restarts <- computeRestarts(cond)
[09:28:18.608]                         for (restart in restarts) {
[09:28:18.608]                           name <- restart$name
[09:28:18.608]                           if (is.null(name)) 
[09:28:18.608]                             next
[09:28:18.608]                           if (!grepl(pattern, name)) 
[09:28:18.608]                             next
[09:28:18.608]                           invokeRestart(restart)
[09:28:18.608]                           muffled <- TRUE
[09:28:18.608]                           break
[09:28:18.608]                         }
[09:28:18.608]                       }
[09:28:18.608]                     }
[09:28:18.608]                     invisible(muffled)
[09:28:18.608]                   }
[09:28:18.608]                   muffleCondition(cond)
[09:28:18.608]                 })
[09:28:18.608]             }))
[09:28:18.608]             future::FutureResult(value = ...future.value$value, 
[09:28:18.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.608]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.608]                     ...future.globalenv.names))
[09:28:18.608]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.608]         }, condition = base::local({
[09:28:18.608]             c <- base::c
[09:28:18.608]             inherits <- base::inherits
[09:28:18.608]             invokeRestart <- base::invokeRestart
[09:28:18.608]             length <- base::length
[09:28:18.608]             list <- base::list
[09:28:18.608]             seq.int <- base::seq.int
[09:28:18.608]             signalCondition <- base::signalCondition
[09:28:18.608]             sys.calls <- base::sys.calls
[09:28:18.608]             `[[` <- base::`[[`
[09:28:18.608]             `+` <- base::`+`
[09:28:18.608]             `<<-` <- base::`<<-`
[09:28:18.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.608]                   3L)]
[09:28:18.608]             }
[09:28:18.608]             function(cond) {
[09:28:18.608]                 is_error <- inherits(cond, "error")
[09:28:18.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.608]                   NULL)
[09:28:18.608]                 if (is_error) {
[09:28:18.608]                   sessionInformation <- function() {
[09:28:18.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.608]                       search = base::search(), system = base::Sys.info())
[09:28:18.608]                   }
[09:28:18.608]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.608]                     cond$call), session = sessionInformation(), 
[09:28:18.608]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.608]                   signalCondition(cond)
[09:28:18.608]                 }
[09:28:18.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.608]                 "immediateCondition"))) {
[09:28:18.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.608]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.608]                   if (TRUE && !signal) {
[09:28:18.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.608]                     {
[09:28:18.608]                       inherits <- base::inherits
[09:28:18.608]                       invokeRestart <- base::invokeRestart
[09:28:18.608]                       is.null <- base::is.null
[09:28:18.608]                       muffled <- FALSE
[09:28:18.608]                       if (inherits(cond, "message")) {
[09:28:18.608]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.608]                         if (muffled) 
[09:28:18.608]                           invokeRestart("muffleMessage")
[09:28:18.608]                       }
[09:28:18.608]                       else if (inherits(cond, "warning")) {
[09:28:18.608]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.608]                         if (muffled) 
[09:28:18.608]                           invokeRestart("muffleWarning")
[09:28:18.608]                       }
[09:28:18.608]                       else if (inherits(cond, "condition")) {
[09:28:18.608]                         if (!is.null(pattern)) {
[09:28:18.608]                           computeRestarts <- base::computeRestarts
[09:28:18.608]                           grepl <- base::grepl
[09:28:18.608]                           restarts <- computeRestarts(cond)
[09:28:18.608]                           for (restart in restarts) {
[09:28:18.608]                             name <- restart$name
[09:28:18.608]                             if (is.null(name)) 
[09:28:18.608]                               next
[09:28:18.608]                             if (!grepl(pattern, name)) 
[09:28:18.608]                               next
[09:28:18.608]                             invokeRestart(restart)
[09:28:18.608]                             muffled <- TRUE
[09:28:18.608]                             break
[09:28:18.608]                           }
[09:28:18.608]                         }
[09:28:18.608]                       }
[09:28:18.608]                       invisible(muffled)
[09:28:18.608]                     }
[09:28:18.608]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.608]                   }
[09:28:18.608]                 }
[09:28:18.608]                 else {
[09:28:18.608]                   if (TRUE) {
[09:28:18.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.608]                     {
[09:28:18.608]                       inherits <- base::inherits
[09:28:18.608]                       invokeRestart <- base::invokeRestart
[09:28:18.608]                       is.null <- base::is.null
[09:28:18.608]                       muffled <- FALSE
[09:28:18.608]                       if (inherits(cond, "message")) {
[09:28:18.608]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.608]                         if (muffled) 
[09:28:18.608]                           invokeRestart("muffleMessage")
[09:28:18.608]                       }
[09:28:18.608]                       else if (inherits(cond, "warning")) {
[09:28:18.608]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.608]                         if (muffled) 
[09:28:18.608]                           invokeRestart("muffleWarning")
[09:28:18.608]                       }
[09:28:18.608]                       else if (inherits(cond, "condition")) {
[09:28:18.608]                         if (!is.null(pattern)) {
[09:28:18.608]                           computeRestarts <- base::computeRestarts
[09:28:18.608]                           grepl <- base::grepl
[09:28:18.608]                           restarts <- computeRestarts(cond)
[09:28:18.608]                           for (restart in restarts) {
[09:28:18.608]                             name <- restart$name
[09:28:18.608]                             if (is.null(name)) 
[09:28:18.608]                               next
[09:28:18.608]                             if (!grepl(pattern, name)) 
[09:28:18.608]                               next
[09:28:18.608]                             invokeRestart(restart)
[09:28:18.608]                             muffled <- TRUE
[09:28:18.608]                             break
[09:28:18.608]                           }
[09:28:18.608]                         }
[09:28:18.608]                       }
[09:28:18.608]                       invisible(muffled)
[09:28:18.608]                     }
[09:28:18.608]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.608]                   }
[09:28:18.608]                 }
[09:28:18.608]             }
[09:28:18.608]         }))
[09:28:18.608]     }, error = function(ex) {
[09:28:18.608]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.608]                 ...future.rng), started = ...future.startTime, 
[09:28:18.608]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.608]             version = "1.8"), class = "FutureResult")
[09:28:18.608]     }, finally = {
[09:28:18.608]         if (!identical(...future.workdir, getwd())) 
[09:28:18.608]             setwd(...future.workdir)
[09:28:18.608]         {
[09:28:18.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.608]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.608]             }
[09:28:18.608]             base::options(...future.oldOptions)
[09:28:18.608]             if (.Platform$OS.type == "windows") {
[09:28:18.608]                 old_names <- names(...future.oldEnvVars)
[09:28:18.608]                 envs <- base::Sys.getenv()
[09:28:18.608]                 names <- names(envs)
[09:28:18.608]                 common <- intersect(names, old_names)
[09:28:18.608]                 added <- setdiff(names, old_names)
[09:28:18.608]                 removed <- setdiff(old_names, names)
[09:28:18.608]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.608]                   envs[common]]
[09:28:18.608]                 NAMES <- toupper(changed)
[09:28:18.608]                 args <- list()
[09:28:18.608]                 for (kk in seq_along(NAMES)) {
[09:28:18.608]                   name <- changed[[kk]]
[09:28:18.608]                   NAME <- NAMES[[kk]]
[09:28:18.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.608]                     next
[09:28:18.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.608]                 }
[09:28:18.608]                 NAMES <- toupper(added)
[09:28:18.608]                 for (kk in seq_along(NAMES)) {
[09:28:18.608]                   name <- added[[kk]]
[09:28:18.608]                   NAME <- NAMES[[kk]]
[09:28:18.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.608]                     next
[09:28:18.608]                   args[[name]] <- ""
[09:28:18.608]                 }
[09:28:18.608]                 NAMES <- toupper(removed)
[09:28:18.608]                 for (kk in seq_along(NAMES)) {
[09:28:18.608]                   name <- removed[[kk]]
[09:28:18.608]                   NAME <- NAMES[[kk]]
[09:28:18.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.608]                     next
[09:28:18.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.608]                 }
[09:28:18.608]                 if (length(args) > 0) 
[09:28:18.608]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.608]             }
[09:28:18.608]             else {
[09:28:18.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.608]             }
[09:28:18.608]             {
[09:28:18.608]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.608]                   0L) {
[09:28:18.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.608]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.608]                   base::options(opts)
[09:28:18.608]                 }
[09:28:18.608]                 {
[09:28:18.608]                   {
[09:28:18.608]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.608]                     NULL
[09:28:18.608]                   }
[09:28:18.608]                   options(future.plan = NULL)
[09:28:18.608]                   if (is.na(NA_character_)) 
[09:28:18.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.608]                     .init = FALSE)
[09:28:18.608]                 }
[09:28:18.608]             }
[09:28:18.608]         }
[09:28:18.608]     })
[09:28:18.608]     if (TRUE) {
[09:28:18.608]         base::sink(type = "output", split = FALSE)
[09:28:18.608]         if (TRUE) {
[09:28:18.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.608]         }
[09:28:18.608]         else {
[09:28:18.608]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.608]         }
[09:28:18.608]         base::close(...future.stdout)
[09:28:18.608]         ...future.stdout <- NULL
[09:28:18.608]     }
[09:28:18.608]     ...future.result$conditions <- ...future.conditions
[09:28:18.608]     ...future.result$finished <- base::Sys.time()
[09:28:18.608]     ...future.result
[09:28:18.608] }
[09:28:18.610] assign_globals() ...
[09:28:18.610] List of 5
[09:28:18.610]  $ future.call.arguments    : list()
[09:28:18.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.610]  $ ...future.FUN            :function (x)  
[09:28:18.610]  $ ...future.elements_ii    :List of 1
[09:28:18.610]   ..$ : int 1
[09:28:18.610]  $ ...future.seeds_ii       : NULL
[09:28:18.610]  $ ...future.globals.maxSize: num Inf
[09:28:18.610]  - attr(*, "resolved")= logi FALSE
[09:28:18.610]  - attr(*, "total_size")= num NA
[09:28:18.610]  - attr(*, "where")=List of 5
[09:28:18.610]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.610]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.610]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.610]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.610]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.610]  - attr(*, "already-done")= logi TRUE
[09:28:18.614] - copied ‘future.call.arguments’ to environment
[09:28:18.615] - copied ‘...future.FUN’ to environment
[09:28:18.615] - copied ‘...future.elements_ii’ to environment
[09:28:18.615] - copied ‘...future.seeds_ii’ to environment
[09:28:18.615] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.615] assign_globals() ... done
[09:28:18.615] requestCore(): workers = 2
[09:28:18.617] MulticoreFuture started
[09:28:18.617] - Launch lazy future ... done
[09:28:18.618] run() for ‘MulticoreFuture’ ... done
[09:28:18.618] Created future:
[09:28:18.618] plan(): Setting new future strategy stack:
[09:28:18.618] List of future strategies:
[09:28:18.618] 1. sequential:
[09:28:18.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.618]    - tweaked: FALSE
[09:28:18.618]    - call: NULL
[09:28:18.619] plan(): nbrOfWorkers() = 1
[09:28:18.621] plan(): Setting new future strategy stack:
[09:28:18.621] List of future strategies:
[09:28:18.621] 1. multicore:
[09:28:18.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.621]    - tweaked: FALSE
[09:28:18.621]    - call: plan(strategy)
[09:28:18.626] plan(): nbrOfWorkers() = 2
[09:28:18.618] MulticoreFuture:
[09:28:18.618] Label: ‘future_apply-1’
[09:28:18.618] Expression:
[09:28:18.618] {
[09:28:18.618]     do.call(function(...) {
[09:28:18.618]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.618]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.618]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.618]             on.exit(options(oopts), add = TRUE)
[09:28:18.618]         }
[09:28:18.618]         {
[09:28:18.618]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.618]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.618]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.618]             })
[09:28:18.618]         }
[09:28:18.618]     }, args = future.call.arguments)
[09:28:18.618] }
[09:28:18.618] Lazy evaluation: FALSE
[09:28:18.618] Asynchronous evaluation: TRUE
[09:28:18.618] Local evaluation: TRUE
[09:28:18.618] Environment: R_GlobalEnv
[09:28:18.618] Capture standard output: TRUE
[09:28:18.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.618] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.618] Packages: <none>
[09:28:18.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.618] Resolved: TRUE
[09:28:18.618] Value: <not collected>
[09:28:18.618] Conditions captured: <none>
[09:28:18.618] Early signaling: FALSE
[09:28:18.618] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.618] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.627] Chunk #1 of 2 ... DONE
[09:28:18.627] Chunk #2 of 2 ...
[09:28:18.628]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.628]  - seeds: <none>
[09:28:18.628]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.628] getGlobalsAndPackages() ...
[09:28:18.628] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.629] Resolving globals: FALSE
[09:28:18.629] Tweak future expression to call with '...' arguments ...
[09:28:18.629] {
[09:28:18.629]     do.call(function(...) {
[09:28:18.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.629]             on.exit(options(oopts), add = TRUE)
[09:28:18.629]         }
[09:28:18.629]         {
[09:28:18.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.629]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.629]             })
[09:28:18.629]         }
[09:28:18.629]     }, args = future.call.arguments)
[09:28:18.629] }
[09:28:18.629] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.630] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.630] 
[09:28:18.630] getGlobalsAndPackages() ... DONE
[09:28:18.631] run() for ‘Future’ ...
[09:28:18.631] - state: ‘created’
[09:28:18.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.636]   - Field: ‘label’
[09:28:18.636]   - Field: ‘local’
[09:28:18.636]   - Field: ‘owner’
[09:28:18.636]   - Field: ‘envir’
[09:28:18.637]   - Field: ‘workers’
[09:28:18.637]   - Field: ‘packages’
[09:28:18.637]   - Field: ‘gc’
[09:28:18.637]   - Field: ‘job’
[09:28:18.637]   - Field: ‘conditions’
[09:28:18.637]   - Field: ‘expr’
[09:28:18.637]   - Field: ‘uuid’
[09:28:18.638]   - Field: ‘seed’
[09:28:18.638]   - Field: ‘version’
[09:28:18.638]   - Field: ‘result’
[09:28:18.638]   - Field: ‘asynchronous’
[09:28:18.638]   - Field: ‘calls’
[09:28:18.638]   - Field: ‘globals’
[09:28:18.638]   - Field: ‘stdout’
[09:28:18.639]   - Field: ‘earlySignal’
[09:28:18.639]   - Field: ‘lazy’
[09:28:18.639]   - Field: ‘state’
[09:28:18.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.639] - Launch lazy future ...
[09:28:18.639] Packages needed by the future expression (n = 0): <none>
[09:28:18.640] Packages needed by future strategies (n = 0): <none>
[09:28:18.640] {
[09:28:18.640]     {
[09:28:18.640]         {
[09:28:18.640]             ...future.startTime <- base::Sys.time()
[09:28:18.640]             {
[09:28:18.640]                 {
[09:28:18.640]                   {
[09:28:18.640]                     {
[09:28:18.640]                       base::local({
[09:28:18.640]                         has_future <- base::requireNamespace("future", 
[09:28:18.640]                           quietly = TRUE)
[09:28:18.640]                         if (has_future) {
[09:28:18.640]                           ns <- base::getNamespace("future")
[09:28:18.640]                           version <- ns[[".package"]][["version"]]
[09:28:18.640]                           if (is.null(version)) 
[09:28:18.640]                             version <- utils::packageVersion("future")
[09:28:18.640]                         }
[09:28:18.640]                         else {
[09:28:18.640]                           version <- NULL
[09:28:18.640]                         }
[09:28:18.640]                         if (!has_future || version < "1.8.0") {
[09:28:18.640]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.640]                             "", base::R.version$version.string), 
[09:28:18.640]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.640]                               "release", "version")], collapse = " "), 
[09:28:18.640]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.640]                             info)
[09:28:18.640]                           info <- base::paste(info, collapse = "; ")
[09:28:18.640]                           if (!has_future) {
[09:28:18.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.640]                               info)
[09:28:18.640]                           }
[09:28:18.640]                           else {
[09:28:18.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.640]                               info, version)
[09:28:18.640]                           }
[09:28:18.640]                           base::stop(msg)
[09:28:18.640]                         }
[09:28:18.640]                       })
[09:28:18.640]                     }
[09:28:18.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.640]                     base::options(mc.cores = 1L)
[09:28:18.640]                   }
[09:28:18.640]                   ...future.strategy.old <- future::plan("list")
[09:28:18.640]                   options(future.plan = NULL)
[09:28:18.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.640]                 }
[09:28:18.640]                 ...future.workdir <- getwd()
[09:28:18.640]             }
[09:28:18.640]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.640]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.640]         }
[09:28:18.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.640]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.640]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.640]             base::names(...future.oldOptions))
[09:28:18.640]     }
[09:28:18.640]     if (FALSE) {
[09:28:18.640]     }
[09:28:18.640]     else {
[09:28:18.640]         if (TRUE) {
[09:28:18.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.640]                 open = "w")
[09:28:18.640]         }
[09:28:18.640]         else {
[09:28:18.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.640]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.640]         }
[09:28:18.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.640]             base::sink(type = "output", split = FALSE)
[09:28:18.640]             base::close(...future.stdout)
[09:28:18.640]         }, add = TRUE)
[09:28:18.640]     }
[09:28:18.640]     ...future.frame <- base::sys.nframe()
[09:28:18.640]     ...future.conditions <- base::list()
[09:28:18.640]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.640]     if (FALSE) {
[09:28:18.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.640]     }
[09:28:18.640]     ...future.result <- base::tryCatch({
[09:28:18.640]         base::withCallingHandlers({
[09:28:18.640]             ...future.value <- base::withVisible(base::local({
[09:28:18.640]                 withCallingHandlers({
[09:28:18.640]                   {
[09:28:18.640]                     do.call(function(...) {
[09:28:18.640]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.640]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.640]                         ...future.globals.maxSize)) {
[09:28:18.640]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.640]                         on.exit(options(oopts), add = TRUE)
[09:28:18.640]                       }
[09:28:18.640]                       {
[09:28:18.640]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.640]                           FUN = function(jj) {
[09:28:18.640]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.640]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.640]                           })
[09:28:18.640]                       }
[09:28:18.640]                     }, args = future.call.arguments)
[09:28:18.640]                   }
[09:28:18.640]                 }, immediateCondition = function(cond) {
[09:28:18.640]                   save_rds <- function (object, pathname, ...) 
[09:28:18.640]                   {
[09:28:18.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.640]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.640]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.640]                         fi_tmp[["mtime"]])
[09:28:18.640]                     }
[09:28:18.640]                     tryCatch({
[09:28:18.640]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.640]                     }, error = function(ex) {
[09:28:18.640]                       msg <- conditionMessage(ex)
[09:28:18.640]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.640]                         fi_tmp[["mtime"]], msg)
[09:28:18.640]                       ex$message <- msg
[09:28:18.640]                       stop(ex)
[09:28:18.640]                     })
[09:28:18.640]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.640]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.640]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.640]                       fi <- file.info(pathname)
[09:28:18.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.640]                         fi[["size"]], fi[["mtime"]])
[09:28:18.640]                       stop(msg)
[09:28:18.640]                     }
[09:28:18.640]                     invisible(pathname)
[09:28:18.640]                   }
[09:28:18.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.640]                     rootPath = tempdir()) 
[09:28:18.640]                   {
[09:28:18.640]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.640]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.640]                       tmpdir = path, fileext = ".rds")
[09:28:18.640]                     save_rds(obj, file)
[09:28:18.640]                   }
[09:28:18.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.640]                   {
[09:28:18.640]                     inherits <- base::inherits
[09:28:18.640]                     invokeRestart <- base::invokeRestart
[09:28:18.640]                     is.null <- base::is.null
[09:28:18.640]                     muffled <- FALSE
[09:28:18.640]                     if (inherits(cond, "message")) {
[09:28:18.640]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.640]                       if (muffled) 
[09:28:18.640]                         invokeRestart("muffleMessage")
[09:28:18.640]                     }
[09:28:18.640]                     else if (inherits(cond, "warning")) {
[09:28:18.640]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.640]                       if (muffled) 
[09:28:18.640]                         invokeRestart("muffleWarning")
[09:28:18.640]                     }
[09:28:18.640]                     else if (inherits(cond, "condition")) {
[09:28:18.640]                       if (!is.null(pattern)) {
[09:28:18.640]                         computeRestarts <- base::computeRestarts
[09:28:18.640]                         grepl <- base::grepl
[09:28:18.640]                         restarts <- computeRestarts(cond)
[09:28:18.640]                         for (restart in restarts) {
[09:28:18.640]                           name <- restart$name
[09:28:18.640]                           if (is.null(name)) 
[09:28:18.640]                             next
[09:28:18.640]                           if (!grepl(pattern, name)) 
[09:28:18.640]                             next
[09:28:18.640]                           invokeRestart(restart)
[09:28:18.640]                           muffled <- TRUE
[09:28:18.640]                           break
[09:28:18.640]                         }
[09:28:18.640]                       }
[09:28:18.640]                     }
[09:28:18.640]                     invisible(muffled)
[09:28:18.640]                   }
[09:28:18.640]                   muffleCondition(cond)
[09:28:18.640]                 })
[09:28:18.640]             }))
[09:28:18.640]             future::FutureResult(value = ...future.value$value, 
[09:28:18.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.640]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.640]                     ...future.globalenv.names))
[09:28:18.640]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.640]         }, condition = base::local({
[09:28:18.640]             c <- base::c
[09:28:18.640]             inherits <- base::inherits
[09:28:18.640]             invokeRestart <- base::invokeRestart
[09:28:18.640]             length <- base::length
[09:28:18.640]             list <- base::list
[09:28:18.640]             seq.int <- base::seq.int
[09:28:18.640]             signalCondition <- base::signalCondition
[09:28:18.640]             sys.calls <- base::sys.calls
[09:28:18.640]             `[[` <- base::`[[`
[09:28:18.640]             `+` <- base::`+`
[09:28:18.640]             `<<-` <- base::`<<-`
[09:28:18.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.640]                   3L)]
[09:28:18.640]             }
[09:28:18.640]             function(cond) {
[09:28:18.640]                 is_error <- inherits(cond, "error")
[09:28:18.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.640]                   NULL)
[09:28:18.640]                 if (is_error) {
[09:28:18.640]                   sessionInformation <- function() {
[09:28:18.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.640]                       search = base::search(), system = base::Sys.info())
[09:28:18.640]                   }
[09:28:18.640]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.640]                     cond$call), session = sessionInformation(), 
[09:28:18.640]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.640]                   signalCondition(cond)
[09:28:18.640]                 }
[09:28:18.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.640]                 "immediateCondition"))) {
[09:28:18.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.640]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.640]                   if (TRUE && !signal) {
[09:28:18.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.640]                     {
[09:28:18.640]                       inherits <- base::inherits
[09:28:18.640]                       invokeRestart <- base::invokeRestart
[09:28:18.640]                       is.null <- base::is.null
[09:28:18.640]                       muffled <- FALSE
[09:28:18.640]                       if (inherits(cond, "message")) {
[09:28:18.640]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.640]                         if (muffled) 
[09:28:18.640]                           invokeRestart("muffleMessage")
[09:28:18.640]                       }
[09:28:18.640]                       else if (inherits(cond, "warning")) {
[09:28:18.640]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.640]                         if (muffled) 
[09:28:18.640]                           invokeRestart("muffleWarning")
[09:28:18.640]                       }
[09:28:18.640]                       else if (inherits(cond, "condition")) {
[09:28:18.640]                         if (!is.null(pattern)) {
[09:28:18.640]                           computeRestarts <- base::computeRestarts
[09:28:18.640]                           grepl <- base::grepl
[09:28:18.640]                           restarts <- computeRestarts(cond)
[09:28:18.640]                           for (restart in restarts) {
[09:28:18.640]                             name <- restart$name
[09:28:18.640]                             if (is.null(name)) 
[09:28:18.640]                               next
[09:28:18.640]                             if (!grepl(pattern, name)) 
[09:28:18.640]                               next
[09:28:18.640]                             invokeRestart(restart)
[09:28:18.640]                             muffled <- TRUE
[09:28:18.640]                             break
[09:28:18.640]                           }
[09:28:18.640]                         }
[09:28:18.640]                       }
[09:28:18.640]                       invisible(muffled)
[09:28:18.640]                     }
[09:28:18.640]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.640]                   }
[09:28:18.640]                 }
[09:28:18.640]                 else {
[09:28:18.640]                   if (TRUE) {
[09:28:18.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.640]                     {
[09:28:18.640]                       inherits <- base::inherits
[09:28:18.640]                       invokeRestart <- base::invokeRestart
[09:28:18.640]                       is.null <- base::is.null
[09:28:18.640]                       muffled <- FALSE
[09:28:18.640]                       if (inherits(cond, "message")) {
[09:28:18.640]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.640]                         if (muffled) 
[09:28:18.640]                           invokeRestart("muffleMessage")
[09:28:18.640]                       }
[09:28:18.640]                       else if (inherits(cond, "warning")) {
[09:28:18.640]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.640]                         if (muffled) 
[09:28:18.640]                           invokeRestart("muffleWarning")
[09:28:18.640]                       }
[09:28:18.640]                       else if (inherits(cond, "condition")) {
[09:28:18.640]                         if (!is.null(pattern)) {
[09:28:18.640]                           computeRestarts <- base::computeRestarts
[09:28:18.640]                           grepl <- base::grepl
[09:28:18.640]                           restarts <- computeRestarts(cond)
[09:28:18.640]                           for (restart in restarts) {
[09:28:18.640]                             name <- restart$name
[09:28:18.640]                             if (is.null(name)) 
[09:28:18.640]                               next
[09:28:18.640]                             if (!grepl(pattern, name)) 
[09:28:18.640]                               next
[09:28:18.640]                             invokeRestart(restart)
[09:28:18.640]                             muffled <- TRUE
[09:28:18.640]                             break
[09:28:18.640]                           }
[09:28:18.640]                         }
[09:28:18.640]                       }
[09:28:18.640]                       invisible(muffled)
[09:28:18.640]                     }
[09:28:18.640]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.640]                   }
[09:28:18.640]                 }
[09:28:18.640]             }
[09:28:18.640]         }))
[09:28:18.640]     }, error = function(ex) {
[09:28:18.640]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.640]                 ...future.rng), started = ...future.startTime, 
[09:28:18.640]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.640]             version = "1.8"), class = "FutureResult")
[09:28:18.640]     }, finally = {
[09:28:18.640]         if (!identical(...future.workdir, getwd())) 
[09:28:18.640]             setwd(...future.workdir)
[09:28:18.640]         {
[09:28:18.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.640]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.640]             }
[09:28:18.640]             base::options(...future.oldOptions)
[09:28:18.640]             if (.Platform$OS.type == "windows") {
[09:28:18.640]                 old_names <- names(...future.oldEnvVars)
[09:28:18.640]                 envs <- base::Sys.getenv()
[09:28:18.640]                 names <- names(envs)
[09:28:18.640]                 common <- intersect(names, old_names)
[09:28:18.640]                 added <- setdiff(names, old_names)
[09:28:18.640]                 removed <- setdiff(old_names, names)
[09:28:18.640]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.640]                   envs[common]]
[09:28:18.640]                 NAMES <- toupper(changed)
[09:28:18.640]                 args <- list()
[09:28:18.640]                 for (kk in seq_along(NAMES)) {
[09:28:18.640]                   name <- changed[[kk]]
[09:28:18.640]                   NAME <- NAMES[[kk]]
[09:28:18.640]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.640]                     next
[09:28:18.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.640]                 }
[09:28:18.640]                 NAMES <- toupper(added)
[09:28:18.640]                 for (kk in seq_along(NAMES)) {
[09:28:18.640]                   name <- added[[kk]]
[09:28:18.640]                   NAME <- NAMES[[kk]]
[09:28:18.640]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.640]                     next
[09:28:18.640]                   args[[name]] <- ""
[09:28:18.640]                 }
[09:28:18.640]                 NAMES <- toupper(removed)
[09:28:18.640]                 for (kk in seq_along(NAMES)) {
[09:28:18.640]                   name <- removed[[kk]]
[09:28:18.640]                   NAME <- NAMES[[kk]]
[09:28:18.640]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.640]                     next
[09:28:18.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.640]                 }
[09:28:18.640]                 if (length(args) > 0) 
[09:28:18.640]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.640]             }
[09:28:18.640]             else {
[09:28:18.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.640]             }
[09:28:18.640]             {
[09:28:18.640]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.640]                   0L) {
[09:28:18.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.640]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.640]                   base::options(opts)
[09:28:18.640]                 }
[09:28:18.640]                 {
[09:28:18.640]                   {
[09:28:18.640]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.640]                     NULL
[09:28:18.640]                   }
[09:28:18.640]                   options(future.plan = NULL)
[09:28:18.640]                   if (is.na(NA_character_)) 
[09:28:18.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.640]                     .init = FALSE)
[09:28:18.640]                 }
[09:28:18.640]             }
[09:28:18.640]         }
[09:28:18.640]     })
[09:28:18.640]     if (TRUE) {
[09:28:18.640]         base::sink(type = "output", split = FALSE)
[09:28:18.640]         if (TRUE) {
[09:28:18.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.640]         }
[09:28:18.640]         else {
[09:28:18.640]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.640]         }
[09:28:18.640]         base::close(...future.stdout)
[09:28:18.640]         ...future.stdout <- NULL
[09:28:18.640]     }
[09:28:18.640]     ...future.result$conditions <- ...future.conditions
[09:28:18.640]     ...future.result$finished <- base::Sys.time()
[09:28:18.640]     ...future.result
[09:28:18.640] }
[09:28:18.644] assign_globals() ...
[09:28:18.644] List of 5
[09:28:18.644]  $ future.call.arguments    : list()
[09:28:18.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.644]  $ ...future.FUN            :function (x)  
[09:28:18.644]  $ ...future.elements_ii    :List of 1
[09:28:18.644]   ..$ : int 2
[09:28:18.644]  $ ...future.seeds_ii       : NULL
[09:28:18.644]  $ ...future.globals.maxSize: num Inf
[09:28:18.644]  - attr(*, "resolved")= logi FALSE
[09:28:18.644]  - attr(*, "total_size")= num NA
[09:28:18.644]  - attr(*, "where")=List of 5
[09:28:18.644]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.644]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.644]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.644]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.644]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.644]  - attr(*, "already-done")= logi TRUE
[09:28:18.656] - copied ‘future.call.arguments’ to environment
[09:28:18.656] - copied ‘...future.FUN’ to environment
[09:28:18.656] - copied ‘...future.elements_ii’ to environment
[09:28:18.657] - copied ‘...future.seeds_ii’ to environment
[09:28:18.657] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.657] assign_globals() ... done
[09:28:18.657] requestCore(): workers = 2
[09:28:18.659] MulticoreFuture started
[09:28:18.659] - Launch lazy future ... done
[09:28:18.660] run() for ‘MulticoreFuture’ ... done
[09:28:18.660] Created future:
[09:28:18.660] plan(): Setting new future strategy stack:
[09:28:18.661] List of future strategies:
[09:28:18.661] 1. sequential:
[09:28:18.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.661]    - tweaked: FALSE
[09:28:18.661]    - call: NULL
[09:28:18.662] plan(): nbrOfWorkers() = 1
[09:28:18.664] plan(): Setting new future strategy stack:
[09:28:18.664] List of future strategies:
[09:28:18.664] 1. multicore:
[09:28:18.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.664]    - tweaked: FALSE
[09:28:18.664]    - call: plan(strategy)
[09:28:18.669] plan(): nbrOfWorkers() = 2
[09:28:18.660] MulticoreFuture:
[09:28:18.660] Label: ‘future_apply-2’
[09:28:18.660] Expression:
[09:28:18.660] {
[09:28:18.660]     do.call(function(...) {
[09:28:18.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.660]             on.exit(options(oopts), add = TRUE)
[09:28:18.660]         }
[09:28:18.660]         {
[09:28:18.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.660]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.660]             })
[09:28:18.660]         }
[09:28:18.660]     }, args = future.call.arguments)
[09:28:18.660] }
[09:28:18.660] Lazy evaluation: FALSE
[09:28:18.660] Asynchronous evaluation: TRUE
[09:28:18.660] Local evaluation: TRUE
[09:28:18.660] Environment: R_GlobalEnv
[09:28:18.660] Capture standard output: TRUE
[09:28:18.660] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.660] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.660] Packages: <none>
[09:28:18.660] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.660] Resolved: TRUE
[09:28:18.660] Value: <not collected>
[09:28:18.660] Conditions captured: <none>
[09:28:18.660] Early signaling: FALSE
[09:28:18.660] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.660] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.670] Chunk #2 of 2 ... DONE
[09:28:18.671] Launching 2 futures (chunks) ... DONE
[09:28:18.671] Resolving 2 futures (chunks) ...
[09:28:18.671] resolve() on list ...
[09:28:18.671]  recursive: 0
[09:28:18.671]  length: 2
[09:28:18.671] 
[09:28:18.672] Future #1
[09:28:18.672] result() for MulticoreFuture ...
[09:28:18.673] result() for MulticoreFuture ...
[09:28:18.673] result() for MulticoreFuture ... done
[09:28:18.673] result() for MulticoreFuture ... done
[09:28:18.673] result() for MulticoreFuture ...
[09:28:18.674] result() for MulticoreFuture ... done
[09:28:18.674] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.674] - nx: 2
[09:28:18.674] - relay: TRUE
[09:28:18.674] - stdout: TRUE
[09:28:18.674] - signal: TRUE
[09:28:18.674] - resignal: FALSE
[09:28:18.675] - force: TRUE
[09:28:18.675] - relayed: [n=2] FALSE, FALSE
[09:28:18.675] - queued futures: [n=2] FALSE, FALSE
[09:28:18.675]  - until=1
[09:28:18.675]  - relaying element #1
[09:28:18.675] result() for MulticoreFuture ...
[09:28:18.675] result() for MulticoreFuture ... done
[09:28:18.676] result() for MulticoreFuture ...
[09:28:18.676] result() for MulticoreFuture ... done
[09:28:18.676] result() for MulticoreFuture ...
[09:28:18.676] result() for MulticoreFuture ... done
[09:28:18.676] result() for MulticoreFuture ...
[09:28:18.676] result() for MulticoreFuture ... done
[09:28:18.676] - relayed: [n=2] TRUE, FALSE
[09:28:18.677] - queued futures: [n=2] TRUE, FALSE
[09:28:18.677] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.677]  length: 1 (resolved future 1)
[09:28:18.677] Future #2
[09:28:18.677] result() for MulticoreFuture ...
[09:28:18.678] result() for MulticoreFuture ...
[09:28:18.678] result() for MulticoreFuture ... done
[09:28:18.678] result() for MulticoreFuture ... done
[09:28:18.678] result() for MulticoreFuture ...
[09:28:18.679] result() for MulticoreFuture ... done
[09:28:18.679] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.679] - nx: 2
[09:28:18.679] - relay: TRUE
[09:28:18.679] - stdout: TRUE
[09:28:18.679] - signal: TRUE
[09:28:18.679] - resignal: FALSE
[09:28:18.679] - force: TRUE
[09:28:18.680] - relayed: [n=2] TRUE, FALSE
[09:28:18.680] - queued futures: [n=2] TRUE, FALSE
[09:28:18.680]  - until=2
[09:28:18.680]  - relaying element #2
[09:28:18.680] result() for MulticoreFuture ...
[09:28:18.680] result() for MulticoreFuture ... done
[09:28:18.680] result() for MulticoreFuture ...
[09:28:18.681] result() for MulticoreFuture ... done
[09:28:18.681] result() for MulticoreFuture ...
[09:28:18.681] result() for MulticoreFuture ... done
[09:28:18.681] result() for MulticoreFuture ...
[09:28:18.681] result() for MulticoreFuture ... done
[09:28:18.681] - relayed: [n=2] TRUE, TRUE
[09:28:18.681] - queued futures: [n=2] TRUE, TRUE
[09:28:18.681] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.682]  length: 0 (resolved future 2)
[09:28:18.682] Relaying remaining futures
[09:28:18.682] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.682] - nx: 2
[09:28:18.682] - relay: TRUE
[09:28:18.682] - stdout: TRUE
[09:28:18.682] - signal: TRUE
[09:28:18.682] - resignal: FALSE
[09:28:18.682] - force: TRUE
[09:28:18.682] - relayed: [n=2] TRUE, TRUE
[09:28:18.683] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.683] - relayed: [n=2] TRUE, TRUE
[09:28:18.683] - queued futures: [n=2] TRUE, TRUE
[09:28:18.683] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.683] resolve() on list ... DONE
[09:28:18.683] result() for MulticoreFuture ...
[09:28:18.683] result() for MulticoreFuture ... done
[09:28:18.683] result() for MulticoreFuture ...
[09:28:18.683] result() for MulticoreFuture ... done
[09:28:18.684] result() for MulticoreFuture ...
[09:28:18.684] result() for MulticoreFuture ... done
[09:28:18.684] result() for MulticoreFuture ...
[09:28:18.684] result() for MulticoreFuture ... done
[09:28:18.684]  - Number of value chunks collected: 2
[09:28:18.684] Resolving 2 futures (chunks) ... DONE
[09:28:18.684] Reducing values from 2 chunks ...
[09:28:18.684]  - Number of values collected after concatenation: 2
[09:28:18.685]  - Number of values expected: 2
[09:28:18.685] Reducing values from 2 chunks ... DONE
[09:28:18.685] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[09:28:18.685] getGlobalsAndPackagesXApply() ...
[09:28:18.685]  - future.globals: TRUE
[09:28:18.685] getGlobalsAndPackages() ...
[09:28:18.685] Searching for globals...
[09:28:18.687] - globals found: [1] ‘FUN’
[09:28:18.687] Searching for globals ... DONE
[09:28:18.687] Resolving globals: FALSE
[09:28:18.687] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:18.688] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:18.688] - globals: [1] ‘FUN’
[09:28:18.688] 
[09:28:18.688] getGlobalsAndPackages() ... DONE
[09:28:18.688]  - globals found/used: [n=1] ‘FUN’
[09:28:18.688]  - needed namespaces: [n=0] 
[09:28:18.688] Finding globals ... DONE
[09:28:18.689]  - use_args: TRUE
[09:28:18.689]  - Getting '...' globals ...
[09:28:18.689] resolve() on list ...
[09:28:18.689]  recursive: 0
[09:28:18.689]  length: 1
[09:28:18.689]  elements: ‘...’
[09:28:18.690]  length: 0 (resolved future 1)
[09:28:18.690] resolve() on list ... DONE
[09:28:18.690]    - '...' content: [n=0] 
[09:28:18.690] List of 1
[09:28:18.690]  $ ...: list()
[09:28:18.690]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.690]  - attr(*, "where")=List of 1
[09:28:18.690]   ..$ ...:<environment: 0x559ba42bb790> 
[09:28:18.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.690]  - attr(*, "resolved")= logi TRUE
[09:28:18.690]  - attr(*, "total_size")= num NA
[09:28:18.695]  - Getting '...' globals ... DONE
[09:28:18.695] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.696] List of 2
[09:28:18.696]  $ ...future.FUN:function (x)  
[09:28:18.696]  $ ...          : list()
[09:28:18.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.696]  - attr(*, "where")=List of 2
[09:28:18.696]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.696]   ..$ ...          :<environment: 0x559ba42bb790> 
[09:28:18.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.696]  - attr(*, "resolved")= logi FALSE
[09:28:18.696]  - attr(*, "total_size")= num 848
[09:28:18.699] Packages to be attached in all futures: [n=0] 
[09:28:18.699] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.702] future_lapply() ...
[09:28:18.706] Number of chunks: 2
[09:28:18.706] getGlobalsAndPackagesXApply() ...
[09:28:18.706]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.706]  - use_args: TRUE
[09:28:18.707] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.707] List of 2
[09:28:18.707]  $ ...          : list()
[09:28:18.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.707]  $ ...future.FUN:function (x)  
[09:28:18.707]  - attr(*, "where")=List of 2
[09:28:18.707]   ..$ ...          :<environment: 0x559ba42bb790> 
[09:28:18.707]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.707]  - attr(*, "resolved")= logi FALSE
[09:28:18.707]  - attr(*, "total_size")= num NA
[09:28:18.710] Packages to be attached in all futures: [n=0] 
[09:28:18.710] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.710] Number of futures (= number of chunks): 2
[09:28:18.710] Launching 2 futures (chunks) ...
[09:28:18.710] Chunk #1 of 2 ...
[09:28:18.711]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.711]  - seeds: <none>
[09:28:18.711]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.711] getGlobalsAndPackages() ...
[09:28:18.711] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.711] Resolving globals: FALSE
[09:28:18.711] Tweak future expression to call with '...' arguments ...
[09:28:18.711] {
[09:28:18.711]     do.call(function(...) {
[09:28:18.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.711]             on.exit(options(oopts), add = TRUE)
[09:28:18.711]         }
[09:28:18.711]         {
[09:28:18.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.711]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.711]             })
[09:28:18.711]         }
[09:28:18.711]     }, args = future.call.arguments)
[09:28:18.711] }
[09:28:18.711] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.712] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.712] 
[09:28:18.712] getGlobalsAndPackages() ... DONE
[09:28:18.712] run() for ‘Future’ ...
[09:28:18.713] - state: ‘created’
[09:28:18.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.716]   - Field: ‘label’
[09:28:18.716]   - Field: ‘local’
[09:28:18.716]   - Field: ‘owner’
[09:28:18.717]   - Field: ‘envir’
[09:28:18.717]   - Field: ‘workers’
[09:28:18.717]   - Field: ‘packages’
[09:28:18.717]   - Field: ‘gc’
[09:28:18.717]   - Field: ‘job’
[09:28:18.717]   - Field: ‘conditions’
[09:28:18.717]   - Field: ‘expr’
[09:28:18.717]   - Field: ‘uuid’
[09:28:18.717]   - Field: ‘seed’
[09:28:18.717]   - Field: ‘version’
[09:28:18.717]   - Field: ‘result’
[09:28:18.718]   - Field: ‘asynchronous’
[09:28:18.718]   - Field: ‘calls’
[09:28:18.718]   - Field: ‘globals’
[09:28:18.718]   - Field: ‘stdout’
[09:28:18.718]   - Field: ‘earlySignal’
[09:28:18.718]   - Field: ‘lazy’
[09:28:18.718]   - Field: ‘state’
[09:28:18.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.718] - Launch lazy future ...
[09:28:18.719] Packages needed by the future expression (n = 0): <none>
[09:28:18.719] Packages needed by future strategies (n = 0): <none>
[09:28:18.719] {
[09:28:18.719]     {
[09:28:18.719]         {
[09:28:18.719]             ...future.startTime <- base::Sys.time()
[09:28:18.719]             {
[09:28:18.719]                 {
[09:28:18.719]                   {
[09:28:18.719]                     {
[09:28:18.719]                       base::local({
[09:28:18.719]                         has_future <- base::requireNamespace("future", 
[09:28:18.719]                           quietly = TRUE)
[09:28:18.719]                         if (has_future) {
[09:28:18.719]                           ns <- base::getNamespace("future")
[09:28:18.719]                           version <- ns[[".package"]][["version"]]
[09:28:18.719]                           if (is.null(version)) 
[09:28:18.719]                             version <- utils::packageVersion("future")
[09:28:18.719]                         }
[09:28:18.719]                         else {
[09:28:18.719]                           version <- NULL
[09:28:18.719]                         }
[09:28:18.719]                         if (!has_future || version < "1.8.0") {
[09:28:18.719]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.719]                             "", base::R.version$version.string), 
[09:28:18.719]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.719]                               "release", "version")], collapse = " "), 
[09:28:18.719]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.719]                             info)
[09:28:18.719]                           info <- base::paste(info, collapse = "; ")
[09:28:18.719]                           if (!has_future) {
[09:28:18.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.719]                               info)
[09:28:18.719]                           }
[09:28:18.719]                           else {
[09:28:18.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.719]                               info, version)
[09:28:18.719]                           }
[09:28:18.719]                           base::stop(msg)
[09:28:18.719]                         }
[09:28:18.719]                       })
[09:28:18.719]                     }
[09:28:18.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.719]                     base::options(mc.cores = 1L)
[09:28:18.719]                   }
[09:28:18.719]                   ...future.strategy.old <- future::plan("list")
[09:28:18.719]                   options(future.plan = NULL)
[09:28:18.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.719]                 }
[09:28:18.719]                 ...future.workdir <- getwd()
[09:28:18.719]             }
[09:28:18.719]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.719]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.719]         }
[09:28:18.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.719]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.719]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.719]             base::names(...future.oldOptions))
[09:28:18.719]     }
[09:28:18.719]     if (FALSE) {
[09:28:18.719]     }
[09:28:18.719]     else {
[09:28:18.719]         if (TRUE) {
[09:28:18.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.719]                 open = "w")
[09:28:18.719]         }
[09:28:18.719]         else {
[09:28:18.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.719]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.719]         }
[09:28:18.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.719]             base::sink(type = "output", split = FALSE)
[09:28:18.719]             base::close(...future.stdout)
[09:28:18.719]         }, add = TRUE)
[09:28:18.719]     }
[09:28:18.719]     ...future.frame <- base::sys.nframe()
[09:28:18.719]     ...future.conditions <- base::list()
[09:28:18.719]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.719]     if (FALSE) {
[09:28:18.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.719]     }
[09:28:18.719]     ...future.result <- base::tryCatch({
[09:28:18.719]         base::withCallingHandlers({
[09:28:18.719]             ...future.value <- base::withVisible(base::local({
[09:28:18.719]                 withCallingHandlers({
[09:28:18.719]                   {
[09:28:18.719]                     do.call(function(...) {
[09:28:18.719]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.719]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.719]                         ...future.globals.maxSize)) {
[09:28:18.719]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.719]                         on.exit(options(oopts), add = TRUE)
[09:28:18.719]                       }
[09:28:18.719]                       {
[09:28:18.719]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.719]                           FUN = function(jj) {
[09:28:18.719]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.719]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.719]                           })
[09:28:18.719]                       }
[09:28:18.719]                     }, args = future.call.arguments)
[09:28:18.719]                   }
[09:28:18.719]                 }, immediateCondition = function(cond) {
[09:28:18.719]                   save_rds <- function (object, pathname, ...) 
[09:28:18.719]                   {
[09:28:18.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.719]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.719]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.719]                         fi_tmp[["mtime"]])
[09:28:18.719]                     }
[09:28:18.719]                     tryCatch({
[09:28:18.719]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.719]                     }, error = function(ex) {
[09:28:18.719]                       msg <- conditionMessage(ex)
[09:28:18.719]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.719]                         fi_tmp[["mtime"]], msg)
[09:28:18.719]                       ex$message <- msg
[09:28:18.719]                       stop(ex)
[09:28:18.719]                     })
[09:28:18.719]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.719]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.719]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.719]                       fi <- file.info(pathname)
[09:28:18.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.719]                         fi[["size"]], fi[["mtime"]])
[09:28:18.719]                       stop(msg)
[09:28:18.719]                     }
[09:28:18.719]                     invisible(pathname)
[09:28:18.719]                   }
[09:28:18.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.719]                     rootPath = tempdir()) 
[09:28:18.719]                   {
[09:28:18.719]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.719]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.719]                       tmpdir = path, fileext = ".rds")
[09:28:18.719]                     save_rds(obj, file)
[09:28:18.719]                   }
[09:28:18.719]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.719]                   {
[09:28:18.719]                     inherits <- base::inherits
[09:28:18.719]                     invokeRestart <- base::invokeRestart
[09:28:18.719]                     is.null <- base::is.null
[09:28:18.719]                     muffled <- FALSE
[09:28:18.719]                     if (inherits(cond, "message")) {
[09:28:18.719]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.719]                       if (muffled) 
[09:28:18.719]                         invokeRestart("muffleMessage")
[09:28:18.719]                     }
[09:28:18.719]                     else if (inherits(cond, "warning")) {
[09:28:18.719]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.719]                       if (muffled) 
[09:28:18.719]                         invokeRestart("muffleWarning")
[09:28:18.719]                     }
[09:28:18.719]                     else if (inherits(cond, "condition")) {
[09:28:18.719]                       if (!is.null(pattern)) {
[09:28:18.719]                         computeRestarts <- base::computeRestarts
[09:28:18.719]                         grepl <- base::grepl
[09:28:18.719]                         restarts <- computeRestarts(cond)
[09:28:18.719]                         for (restart in restarts) {
[09:28:18.719]                           name <- restart$name
[09:28:18.719]                           if (is.null(name)) 
[09:28:18.719]                             next
[09:28:18.719]                           if (!grepl(pattern, name)) 
[09:28:18.719]                             next
[09:28:18.719]                           invokeRestart(restart)
[09:28:18.719]                           muffled <- TRUE
[09:28:18.719]                           break
[09:28:18.719]                         }
[09:28:18.719]                       }
[09:28:18.719]                     }
[09:28:18.719]                     invisible(muffled)
[09:28:18.719]                   }
[09:28:18.719]                   muffleCondition(cond)
[09:28:18.719]                 })
[09:28:18.719]             }))
[09:28:18.719]             future::FutureResult(value = ...future.value$value, 
[09:28:18.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.719]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.719]                     ...future.globalenv.names))
[09:28:18.719]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.719]         }, condition = base::local({
[09:28:18.719]             c <- base::c
[09:28:18.719]             inherits <- base::inherits
[09:28:18.719]             invokeRestart <- base::invokeRestart
[09:28:18.719]             length <- base::length
[09:28:18.719]             list <- base::list
[09:28:18.719]             seq.int <- base::seq.int
[09:28:18.719]             signalCondition <- base::signalCondition
[09:28:18.719]             sys.calls <- base::sys.calls
[09:28:18.719]             `[[` <- base::`[[`
[09:28:18.719]             `+` <- base::`+`
[09:28:18.719]             `<<-` <- base::`<<-`
[09:28:18.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.719]                   3L)]
[09:28:18.719]             }
[09:28:18.719]             function(cond) {
[09:28:18.719]                 is_error <- inherits(cond, "error")
[09:28:18.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.719]                   NULL)
[09:28:18.719]                 if (is_error) {
[09:28:18.719]                   sessionInformation <- function() {
[09:28:18.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.719]                       search = base::search(), system = base::Sys.info())
[09:28:18.719]                   }
[09:28:18.719]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.719]                     cond$call), session = sessionInformation(), 
[09:28:18.719]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.719]                   signalCondition(cond)
[09:28:18.719]                 }
[09:28:18.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.719]                 "immediateCondition"))) {
[09:28:18.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.719]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.719]                   if (TRUE && !signal) {
[09:28:18.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.719]                     {
[09:28:18.719]                       inherits <- base::inherits
[09:28:18.719]                       invokeRestart <- base::invokeRestart
[09:28:18.719]                       is.null <- base::is.null
[09:28:18.719]                       muffled <- FALSE
[09:28:18.719]                       if (inherits(cond, "message")) {
[09:28:18.719]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.719]                         if (muffled) 
[09:28:18.719]                           invokeRestart("muffleMessage")
[09:28:18.719]                       }
[09:28:18.719]                       else if (inherits(cond, "warning")) {
[09:28:18.719]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.719]                         if (muffled) 
[09:28:18.719]                           invokeRestart("muffleWarning")
[09:28:18.719]                       }
[09:28:18.719]                       else if (inherits(cond, "condition")) {
[09:28:18.719]                         if (!is.null(pattern)) {
[09:28:18.719]                           computeRestarts <- base::computeRestarts
[09:28:18.719]                           grepl <- base::grepl
[09:28:18.719]                           restarts <- computeRestarts(cond)
[09:28:18.719]                           for (restart in restarts) {
[09:28:18.719]                             name <- restart$name
[09:28:18.719]                             if (is.null(name)) 
[09:28:18.719]                               next
[09:28:18.719]                             if (!grepl(pattern, name)) 
[09:28:18.719]                               next
[09:28:18.719]                             invokeRestart(restart)
[09:28:18.719]                             muffled <- TRUE
[09:28:18.719]                             break
[09:28:18.719]                           }
[09:28:18.719]                         }
[09:28:18.719]                       }
[09:28:18.719]                       invisible(muffled)
[09:28:18.719]                     }
[09:28:18.719]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.719]                   }
[09:28:18.719]                 }
[09:28:18.719]                 else {
[09:28:18.719]                   if (TRUE) {
[09:28:18.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.719]                     {
[09:28:18.719]                       inherits <- base::inherits
[09:28:18.719]                       invokeRestart <- base::invokeRestart
[09:28:18.719]                       is.null <- base::is.null
[09:28:18.719]                       muffled <- FALSE
[09:28:18.719]                       if (inherits(cond, "message")) {
[09:28:18.719]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.719]                         if (muffled) 
[09:28:18.719]                           invokeRestart("muffleMessage")
[09:28:18.719]                       }
[09:28:18.719]                       else if (inherits(cond, "warning")) {
[09:28:18.719]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.719]                         if (muffled) 
[09:28:18.719]                           invokeRestart("muffleWarning")
[09:28:18.719]                       }
[09:28:18.719]                       else if (inherits(cond, "condition")) {
[09:28:18.719]                         if (!is.null(pattern)) {
[09:28:18.719]                           computeRestarts <- base::computeRestarts
[09:28:18.719]                           grepl <- base::grepl
[09:28:18.719]                           restarts <- computeRestarts(cond)
[09:28:18.719]                           for (restart in restarts) {
[09:28:18.719]                             name <- restart$name
[09:28:18.719]                             if (is.null(name)) 
[09:28:18.719]                               next
[09:28:18.719]                             if (!grepl(pattern, name)) 
[09:28:18.719]                               next
[09:28:18.719]                             invokeRestart(restart)
[09:28:18.719]                             muffled <- TRUE
[09:28:18.719]                             break
[09:28:18.719]                           }
[09:28:18.719]                         }
[09:28:18.719]                       }
[09:28:18.719]                       invisible(muffled)
[09:28:18.719]                     }
[09:28:18.719]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.719]                   }
[09:28:18.719]                 }
[09:28:18.719]             }
[09:28:18.719]         }))
[09:28:18.719]     }, error = function(ex) {
[09:28:18.719]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.719]                 ...future.rng), started = ...future.startTime, 
[09:28:18.719]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.719]             version = "1.8"), class = "FutureResult")
[09:28:18.719]     }, finally = {
[09:28:18.719]         if (!identical(...future.workdir, getwd())) 
[09:28:18.719]             setwd(...future.workdir)
[09:28:18.719]         {
[09:28:18.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.719]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.719]             }
[09:28:18.719]             base::options(...future.oldOptions)
[09:28:18.719]             if (.Platform$OS.type == "windows") {
[09:28:18.719]                 old_names <- names(...future.oldEnvVars)
[09:28:18.719]                 envs <- base::Sys.getenv()
[09:28:18.719]                 names <- names(envs)
[09:28:18.719]                 common <- intersect(names, old_names)
[09:28:18.719]                 added <- setdiff(names, old_names)
[09:28:18.719]                 removed <- setdiff(old_names, names)
[09:28:18.719]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.719]                   envs[common]]
[09:28:18.719]                 NAMES <- toupper(changed)
[09:28:18.719]                 args <- list()
[09:28:18.719]                 for (kk in seq_along(NAMES)) {
[09:28:18.719]                   name <- changed[[kk]]
[09:28:18.719]                   NAME <- NAMES[[kk]]
[09:28:18.719]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.719]                     next
[09:28:18.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.719]                 }
[09:28:18.719]                 NAMES <- toupper(added)
[09:28:18.719]                 for (kk in seq_along(NAMES)) {
[09:28:18.719]                   name <- added[[kk]]
[09:28:18.719]                   NAME <- NAMES[[kk]]
[09:28:18.719]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.719]                     next
[09:28:18.719]                   args[[name]] <- ""
[09:28:18.719]                 }
[09:28:18.719]                 NAMES <- toupper(removed)
[09:28:18.719]                 for (kk in seq_along(NAMES)) {
[09:28:18.719]                   name <- removed[[kk]]
[09:28:18.719]                   NAME <- NAMES[[kk]]
[09:28:18.719]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.719]                     next
[09:28:18.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.719]                 }
[09:28:18.719]                 if (length(args) > 0) 
[09:28:18.719]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.719]             }
[09:28:18.719]             else {
[09:28:18.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.719]             }
[09:28:18.719]             {
[09:28:18.719]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.719]                   0L) {
[09:28:18.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.719]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.719]                   base::options(opts)
[09:28:18.719]                 }
[09:28:18.719]                 {
[09:28:18.719]                   {
[09:28:18.719]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.719]                     NULL
[09:28:18.719]                   }
[09:28:18.719]                   options(future.plan = NULL)
[09:28:18.719]                   if (is.na(NA_character_)) 
[09:28:18.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.719]                     .init = FALSE)
[09:28:18.719]                 }
[09:28:18.719]             }
[09:28:18.719]         }
[09:28:18.719]     })
[09:28:18.719]     if (TRUE) {
[09:28:18.719]         base::sink(type = "output", split = FALSE)
[09:28:18.719]         if (TRUE) {
[09:28:18.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.719]         }
[09:28:18.719]         else {
[09:28:18.719]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.719]         }
[09:28:18.719]         base::close(...future.stdout)
[09:28:18.719]         ...future.stdout <- NULL
[09:28:18.719]     }
[09:28:18.719]     ...future.result$conditions <- ...future.conditions
[09:28:18.719]     ...future.result$finished <- base::Sys.time()
[09:28:18.719]     ...future.result
[09:28:18.719] }
[09:28:18.722] assign_globals() ...
[09:28:18.722] List of 5
[09:28:18.722]  $ future.call.arguments    : list()
[09:28:18.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.722]  $ ...future.FUN            :function (x)  
[09:28:18.722]  $ ...future.elements_ii    :List of 1
[09:28:18.722]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[09:28:18.722]  $ ...future.seeds_ii       : NULL
[09:28:18.722]  $ ...future.globals.maxSize: num Inf
[09:28:18.722]  - attr(*, "resolved")= logi FALSE
[09:28:18.722]  - attr(*, "total_size")= num NA
[09:28:18.722]  - attr(*, "where")=List of 5
[09:28:18.722]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.722]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.722]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.722]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.722]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.722]  - attr(*, "already-done")= logi TRUE
[09:28:18.728] - copied ‘future.call.arguments’ to environment
[09:28:18.728] - copied ‘...future.FUN’ to environment
[09:28:18.728] - copied ‘...future.elements_ii’ to environment
[09:28:18.728] - copied ‘...future.seeds_ii’ to environment
[09:28:18.729] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.729] assign_globals() ... done
[09:28:18.729] requestCore(): workers = 2
[09:28:18.731] MulticoreFuture started
[09:28:18.731] - Launch lazy future ... done
[09:28:18.731] run() for ‘MulticoreFuture’ ... done
[09:28:18.732] Created future:
[09:28:18.732] plan(): Setting new future strategy stack:
[09:28:18.732] List of future strategies:
[09:28:18.732] 1. sequential:
[09:28:18.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.732]    - tweaked: FALSE
[09:28:18.732]    - call: NULL
[09:28:18.733] plan(): nbrOfWorkers() = 1
[09:28:18.736] plan(): Setting new future strategy stack:
[09:28:18.736] List of future strategies:
[09:28:18.736] 1. multicore:
[09:28:18.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.736]    - tweaked: FALSE
[09:28:18.736]    - call: plan(strategy)
[09:28:18.741] plan(): nbrOfWorkers() = 2
[09:28:18.732] MulticoreFuture:
[09:28:18.732] Label: ‘future_apply-1’
[09:28:18.732] Expression:
[09:28:18.732] {
[09:28:18.732]     do.call(function(...) {
[09:28:18.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.732]             on.exit(options(oopts), add = TRUE)
[09:28:18.732]         }
[09:28:18.732]         {
[09:28:18.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.732]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.732]             })
[09:28:18.732]         }
[09:28:18.732]     }, args = future.call.arguments)
[09:28:18.732] }
[09:28:18.732] Lazy evaluation: FALSE
[09:28:18.732] Asynchronous evaluation: TRUE
[09:28:18.732] Local evaluation: TRUE
[09:28:18.732] Environment: R_GlobalEnv
[09:28:18.732] Capture standard output: TRUE
[09:28:18.732] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.732] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.732] Packages: <none>
[09:28:18.732] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.732] Resolved: TRUE
[09:28:18.732] Value: <not collected>
[09:28:18.732] Conditions captured: <none>
[09:28:18.732] Early signaling: FALSE
[09:28:18.732] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.732] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.742] Chunk #1 of 2 ... DONE
[09:28:18.742] Chunk #2 of 2 ...
[09:28:18.742]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.742]  - seeds: <none>
[09:28:18.742]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.743] getGlobalsAndPackages() ...
[09:28:18.743] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.743] Resolving globals: FALSE
[09:28:18.743] Tweak future expression to call with '...' arguments ...
[09:28:18.743] {
[09:28:18.743]     do.call(function(...) {
[09:28:18.743]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.743]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.743]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.743]             on.exit(options(oopts), add = TRUE)
[09:28:18.743]         }
[09:28:18.743]         {
[09:28:18.743]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.743]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.743]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.743]             })
[09:28:18.743]         }
[09:28:18.743]     }, args = future.call.arguments)
[09:28:18.743] }
[09:28:18.744] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.744] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.745] 
[09:28:18.745] getGlobalsAndPackages() ... DONE
[09:28:18.745] run() for ‘Future’ ...
[09:28:18.745] - state: ‘created’
[09:28:18.746] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.750] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.750]   - Field: ‘label’
[09:28:18.751]   - Field: ‘local’
[09:28:18.751]   - Field: ‘owner’
[09:28:18.751]   - Field: ‘envir’
[09:28:18.751]   - Field: ‘workers’
[09:28:18.751]   - Field: ‘packages’
[09:28:18.751]   - Field: ‘gc’
[09:28:18.751]   - Field: ‘job’
[09:28:18.752]   - Field: ‘conditions’
[09:28:18.752]   - Field: ‘expr’
[09:28:18.752]   - Field: ‘uuid’
[09:28:18.752]   - Field: ‘seed’
[09:28:18.752]   - Field: ‘version’
[09:28:18.752]   - Field: ‘result’
[09:28:18.752]   - Field: ‘asynchronous’
[09:28:18.753]   - Field: ‘calls’
[09:28:18.753]   - Field: ‘globals’
[09:28:18.753]   - Field: ‘stdout’
[09:28:18.753]   - Field: ‘earlySignal’
[09:28:18.753]   - Field: ‘lazy’
[09:28:18.753]   - Field: ‘state’
[09:28:18.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.754] - Launch lazy future ...
[09:28:18.754] Packages needed by the future expression (n = 0): <none>
[09:28:18.754] Packages needed by future strategies (n = 0): <none>
[09:28:18.755] {
[09:28:18.755]     {
[09:28:18.755]         {
[09:28:18.755]             ...future.startTime <- base::Sys.time()
[09:28:18.755]             {
[09:28:18.755]                 {
[09:28:18.755]                   {
[09:28:18.755]                     {
[09:28:18.755]                       base::local({
[09:28:18.755]                         has_future <- base::requireNamespace("future", 
[09:28:18.755]                           quietly = TRUE)
[09:28:18.755]                         if (has_future) {
[09:28:18.755]                           ns <- base::getNamespace("future")
[09:28:18.755]                           version <- ns[[".package"]][["version"]]
[09:28:18.755]                           if (is.null(version)) 
[09:28:18.755]                             version <- utils::packageVersion("future")
[09:28:18.755]                         }
[09:28:18.755]                         else {
[09:28:18.755]                           version <- NULL
[09:28:18.755]                         }
[09:28:18.755]                         if (!has_future || version < "1.8.0") {
[09:28:18.755]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.755]                             "", base::R.version$version.string), 
[09:28:18.755]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.755]                               "release", "version")], collapse = " "), 
[09:28:18.755]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.755]                             info)
[09:28:18.755]                           info <- base::paste(info, collapse = "; ")
[09:28:18.755]                           if (!has_future) {
[09:28:18.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.755]                               info)
[09:28:18.755]                           }
[09:28:18.755]                           else {
[09:28:18.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.755]                               info, version)
[09:28:18.755]                           }
[09:28:18.755]                           base::stop(msg)
[09:28:18.755]                         }
[09:28:18.755]                       })
[09:28:18.755]                     }
[09:28:18.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.755]                     base::options(mc.cores = 1L)
[09:28:18.755]                   }
[09:28:18.755]                   ...future.strategy.old <- future::plan("list")
[09:28:18.755]                   options(future.plan = NULL)
[09:28:18.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.755]                 }
[09:28:18.755]                 ...future.workdir <- getwd()
[09:28:18.755]             }
[09:28:18.755]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.755]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.755]         }
[09:28:18.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.755]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.755]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.755]             base::names(...future.oldOptions))
[09:28:18.755]     }
[09:28:18.755]     if (FALSE) {
[09:28:18.755]     }
[09:28:18.755]     else {
[09:28:18.755]         if (TRUE) {
[09:28:18.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.755]                 open = "w")
[09:28:18.755]         }
[09:28:18.755]         else {
[09:28:18.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.755]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.755]         }
[09:28:18.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.755]             base::sink(type = "output", split = FALSE)
[09:28:18.755]             base::close(...future.stdout)
[09:28:18.755]         }, add = TRUE)
[09:28:18.755]     }
[09:28:18.755]     ...future.frame <- base::sys.nframe()
[09:28:18.755]     ...future.conditions <- base::list()
[09:28:18.755]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.755]     if (FALSE) {
[09:28:18.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.755]     }
[09:28:18.755]     ...future.result <- base::tryCatch({
[09:28:18.755]         base::withCallingHandlers({
[09:28:18.755]             ...future.value <- base::withVisible(base::local({
[09:28:18.755]                 withCallingHandlers({
[09:28:18.755]                   {
[09:28:18.755]                     do.call(function(...) {
[09:28:18.755]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.755]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.755]                         ...future.globals.maxSize)) {
[09:28:18.755]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.755]                         on.exit(options(oopts), add = TRUE)
[09:28:18.755]                       }
[09:28:18.755]                       {
[09:28:18.755]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.755]                           FUN = function(jj) {
[09:28:18.755]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.755]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.755]                           })
[09:28:18.755]                       }
[09:28:18.755]                     }, args = future.call.arguments)
[09:28:18.755]                   }
[09:28:18.755]                 }, immediateCondition = function(cond) {
[09:28:18.755]                   save_rds <- function (object, pathname, ...) 
[09:28:18.755]                   {
[09:28:18.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.755]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.755]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.755]                         fi_tmp[["mtime"]])
[09:28:18.755]                     }
[09:28:18.755]                     tryCatch({
[09:28:18.755]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.755]                     }, error = function(ex) {
[09:28:18.755]                       msg <- conditionMessage(ex)
[09:28:18.755]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.755]                         fi_tmp[["mtime"]], msg)
[09:28:18.755]                       ex$message <- msg
[09:28:18.755]                       stop(ex)
[09:28:18.755]                     })
[09:28:18.755]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.755]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.755]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.755]                       fi <- file.info(pathname)
[09:28:18.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.755]                         fi[["size"]], fi[["mtime"]])
[09:28:18.755]                       stop(msg)
[09:28:18.755]                     }
[09:28:18.755]                     invisible(pathname)
[09:28:18.755]                   }
[09:28:18.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.755]                     rootPath = tempdir()) 
[09:28:18.755]                   {
[09:28:18.755]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.755]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.755]                       tmpdir = path, fileext = ".rds")
[09:28:18.755]                     save_rds(obj, file)
[09:28:18.755]                   }
[09:28:18.755]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.755]                   {
[09:28:18.755]                     inherits <- base::inherits
[09:28:18.755]                     invokeRestart <- base::invokeRestart
[09:28:18.755]                     is.null <- base::is.null
[09:28:18.755]                     muffled <- FALSE
[09:28:18.755]                     if (inherits(cond, "message")) {
[09:28:18.755]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.755]                       if (muffled) 
[09:28:18.755]                         invokeRestart("muffleMessage")
[09:28:18.755]                     }
[09:28:18.755]                     else if (inherits(cond, "warning")) {
[09:28:18.755]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.755]                       if (muffled) 
[09:28:18.755]                         invokeRestart("muffleWarning")
[09:28:18.755]                     }
[09:28:18.755]                     else if (inherits(cond, "condition")) {
[09:28:18.755]                       if (!is.null(pattern)) {
[09:28:18.755]                         computeRestarts <- base::computeRestarts
[09:28:18.755]                         grepl <- base::grepl
[09:28:18.755]                         restarts <- computeRestarts(cond)
[09:28:18.755]                         for (restart in restarts) {
[09:28:18.755]                           name <- restart$name
[09:28:18.755]                           if (is.null(name)) 
[09:28:18.755]                             next
[09:28:18.755]                           if (!grepl(pattern, name)) 
[09:28:18.755]                             next
[09:28:18.755]                           invokeRestart(restart)
[09:28:18.755]                           muffled <- TRUE
[09:28:18.755]                           break
[09:28:18.755]                         }
[09:28:18.755]                       }
[09:28:18.755]                     }
[09:28:18.755]                     invisible(muffled)
[09:28:18.755]                   }
[09:28:18.755]                   muffleCondition(cond)
[09:28:18.755]                 })
[09:28:18.755]             }))
[09:28:18.755]             future::FutureResult(value = ...future.value$value, 
[09:28:18.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.755]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.755]                     ...future.globalenv.names))
[09:28:18.755]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.755]         }, condition = base::local({
[09:28:18.755]             c <- base::c
[09:28:18.755]             inherits <- base::inherits
[09:28:18.755]             invokeRestart <- base::invokeRestart
[09:28:18.755]             length <- base::length
[09:28:18.755]             list <- base::list
[09:28:18.755]             seq.int <- base::seq.int
[09:28:18.755]             signalCondition <- base::signalCondition
[09:28:18.755]             sys.calls <- base::sys.calls
[09:28:18.755]             `[[` <- base::`[[`
[09:28:18.755]             `+` <- base::`+`
[09:28:18.755]             `<<-` <- base::`<<-`
[09:28:18.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.755]                   3L)]
[09:28:18.755]             }
[09:28:18.755]             function(cond) {
[09:28:18.755]                 is_error <- inherits(cond, "error")
[09:28:18.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.755]                   NULL)
[09:28:18.755]                 if (is_error) {
[09:28:18.755]                   sessionInformation <- function() {
[09:28:18.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.755]                       search = base::search(), system = base::Sys.info())
[09:28:18.755]                   }
[09:28:18.755]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.755]                     cond$call), session = sessionInformation(), 
[09:28:18.755]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.755]                   signalCondition(cond)
[09:28:18.755]                 }
[09:28:18.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.755]                 "immediateCondition"))) {
[09:28:18.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.755]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.755]                   if (TRUE && !signal) {
[09:28:18.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.755]                     {
[09:28:18.755]                       inherits <- base::inherits
[09:28:18.755]                       invokeRestart <- base::invokeRestart
[09:28:18.755]                       is.null <- base::is.null
[09:28:18.755]                       muffled <- FALSE
[09:28:18.755]                       if (inherits(cond, "message")) {
[09:28:18.755]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.755]                         if (muffled) 
[09:28:18.755]                           invokeRestart("muffleMessage")
[09:28:18.755]                       }
[09:28:18.755]                       else if (inherits(cond, "warning")) {
[09:28:18.755]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.755]                         if (muffled) 
[09:28:18.755]                           invokeRestart("muffleWarning")
[09:28:18.755]                       }
[09:28:18.755]                       else if (inherits(cond, "condition")) {
[09:28:18.755]                         if (!is.null(pattern)) {
[09:28:18.755]                           computeRestarts <- base::computeRestarts
[09:28:18.755]                           grepl <- base::grepl
[09:28:18.755]                           restarts <- computeRestarts(cond)
[09:28:18.755]                           for (restart in restarts) {
[09:28:18.755]                             name <- restart$name
[09:28:18.755]                             if (is.null(name)) 
[09:28:18.755]                               next
[09:28:18.755]                             if (!grepl(pattern, name)) 
[09:28:18.755]                               next
[09:28:18.755]                             invokeRestart(restart)
[09:28:18.755]                             muffled <- TRUE
[09:28:18.755]                             break
[09:28:18.755]                           }
[09:28:18.755]                         }
[09:28:18.755]                       }
[09:28:18.755]                       invisible(muffled)
[09:28:18.755]                     }
[09:28:18.755]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.755]                   }
[09:28:18.755]                 }
[09:28:18.755]                 else {
[09:28:18.755]                   if (TRUE) {
[09:28:18.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.755]                     {
[09:28:18.755]                       inherits <- base::inherits
[09:28:18.755]                       invokeRestart <- base::invokeRestart
[09:28:18.755]                       is.null <- base::is.null
[09:28:18.755]                       muffled <- FALSE
[09:28:18.755]                       if (inherits(cond, "message")) {
[09:28:18.755]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.755]                         if (muffled) 
[09:28:18.755]                           invokeRestart("muffleMessage")
[09:28:18.755]                       }
[09:28:18.755]                       else if (inherits(cond, "warning")) {
[09:28:18.755]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.755]                         if (muffled) 
[09:28:18.755]                           invokeRestart("muffleWarning")
[09:28:18.755]                       }
[09:28:18.755]                       else if (inherits(cond, "condition")) {
[09:28:18.755]                         if (!is.null(pattern)) {
[09:28:18.755]                           computeRestarts <- base::computeRestarts
[09:28:18.755]                           grepl <- base::grepl
[09:28:18.755]                           restarts <- computeRestarts(cond)
[09:28:18.755]                           for (restart in restarts) {
[09:28:18.755]                             name <- restart$name
[09:28:18.755]                             if (is.null(name)) 
[09:28:18.755]                               next
[09:28:18.755]                             if (!grepl(pattern, name)) 
[09:28:18.755]                               next
[09:28:18.755]                             invokeRestart(restart)
[09:28:18.755]                             muffled <- TRUE
[09:28:18.755]                             break
[09:28:18.755]                           }
[09:28:18.755]                         }
[09:28:18.755]                       }
[09:28:18.755]                       invisible(muffled)
[09:28:18.755]                     }
[09:28:18.755]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.755]                   }
[09:28:18.755]                 }
[09:28:18.755]             }
[09:28:18.755]         }))
[09:28:18.755]     }, error = function(ex) {
[09:28:18.755]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.755]                 ...future.rng), started = ...future.startTime, 
[09:28:18.755]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.755]             version = "1.8"), class = "FutureResult")
[09:28:18.755]     }, finally = {
[09:28:18.755]         if (!identical(...future.workdir, getwd())) 
[09:28:18.755]             setwd(...future.workdir)
[09:28:18.755]         {
[09:28:18.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.755]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.755]             }
[09:28:18.755]             base::options(...future.oldOptions)
[09:28:18.755]             if (.Platform$OS.type == "windows") {
[09:28:18.755]                 old_names <- names(...future.oldEnvVars)
[09:28:18.755]                 envs <- base::Sys.getenv()
[09:28:18.755]                 names <- names(envs)
[09:28:18.755]                 common <- intersect(names, old_names)
[09:28:18.755]                 added <- setdiff(names, old_names)
[09:28:18.755]                 removed <- setdiff(old_names, names)
[09:28:18.755]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.755]                   envs[common]]
[09:28:18.755]                 NAMES <- toupper(changed)
[09:28:18.755]                 args <- list()
[09:28:18.755]                 for (kk in seq_along(NAMES)) {
[09:28:18.755]                   name <- changed[[kk]]
[09:28:18.755]                   NAME <- NAMES[[kk]]
[09:28:18.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.755]                     next
[09:28:18.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.755]                 }
[09:28:18.755]                 NAMES <- toupper(added)
[09:28:18.755]                 for (kk in seq_along(NAMES)) {
[09:28:18.755]                   name <- added[[kk]]
[09:28:18.755]                   NAME <- NAMES[[kk]]
[09:28:18.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.755]                     next
[09:28:18.755]                   args[[name]] <- ""
[09:28:18.755]                 }
[09:28:18.755]                 NAMES <- toupper(removed)
[09:28:18.755]                 for (kk in seq_along(NAMES)) {
[09:28:18.755]                   name <- removed[[kk]]
[09:28:18.755]                   NAME <- NAMES[[kk]]
[09:28:18.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.755]                     next
[09:28:18.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.755]                 }
[09:28:18.755]                 if (length(args) > 0) 
[09:28:18.755]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.755]             }
[09:28:18.755]             else {
[09:28:18.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.755]             }
[09:28:18.755]             {
[09:28:18.755]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.755]                   0L) {
[09:28:18.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.755]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.755]                   base::options(opts)
[09:28:18.755]                 }
[09:28:18.755]                 {
[09:28:18.755]                   {
[09:28:18.755]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.755]                     NULL
[09:28:18.755]                   }
[09:28:18.755]                   options(future.plan = NULL)
[09:28:18.755]                   if (is.na(NA_character_)) 
[09:28:18.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.755]                     .init = FALSE)
[09:28:18.755]                 }
[09:28:18.755]             }
[09:28:18.755]         }
[09:28:18.755]     })
[09:28:18.755]     if (TRUE) {
[09:28:18.755]         base::sink(type = "output", split = FALSE)
[09:28:18.755]         if (TRUE) {
[09:28:18.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.755]         }
[09:28:18.755]         else {
[09:28:18.755]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.755]         }
[09:28:18.755]         base::close(...future.stdout)
[09:28:18.755]         ...future.stdout <- NULL
[09:28:18.755]     }
[09:28:18.755]     ...future.result$conditions <- ...future.conditions
[09:28:18.755]     ...future.result$finished <- base::Sys.time()
[09:28:18.755]     ...future.result
[09:28:18.755] }
[09:28:18.758] assign_globals() ...
[09:28:18.759] List of 5
[09:28:18.759]  $ future.call.arguments    : list()
[09:28:18.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.759]  $ ...future.FUN            :function (x)  
[09:28:18.759]  $ ...future.elements_ii    :List of 1
[09:28:18.759]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[09:28:18.759]  $ ...future.seeds_ii       : NULL
[09:28:18.759]  $ ...future.globals.maxSize: num Inf
[09:28:18.759]  - attr(*, "resolved")= logi FALSE
[09:28:18.759]  - attr(*, "total_size")= num NA
[09:28:18.759]  - attr(*, "where")=List of 5
[09:28:18.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.759]  - attr(*, "already-done")= logi TRUE
[09:28:18.766] - copied ‘future.call.arguments’ to environment
[09:28:18.766] - copied ‘...future.FUN’ to environment
[09:28:18.766] - copied ‘...future.elements_ii’ to environment
[09:28:18.767] - copied ‘...future.seeds_ii’ to environment
[09:28:18.767] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.767] assign_globals() ... done
[09:28:18.767] requestCore(): workers = 2
[09:28:18.769] MulticoreFuture started
[09:28:18.769] - Launch lazy future ... done
[09:28:18.770] run() for ‘MulticoreFuture’ ... done
[09:28:18.770] Created future:
[09:28:18.770] plan(): Setting new future strategy stack:
[09:28:18.770] List of future strategies:
[09:28:18.770] 1. sequential:
[09:28:18.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.770]    - tweaked: FALSE
[09:28:18.770]    - call: NULL
[09:28:18.771] plan(): nbrOfWorkers() = 1
[09:28:18.774] plan(): Setting new future strategy stack:
[09:28:18.774] List of future strategies:
[09:28:18.774] 1. multicore:
[09:28:18.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.774]    - tweaked: FALSE
[09:28:18.774]    - call: plan(strategy)
[09:28:18.782] plan(): nbrOfWorkers() = 2
[09:28:18.770] MulticoreFuture:
[09:28:18.770] Label: ‘future_apply-2’
[09:28:18.770] Expression:
[09:28:18.770] {
[09:28:18.770]     do.call(function(...) {
[09:28:18.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.770]             on.exit(options(oopts), add = TRUE)
[09:28:18.770]         }
[09:28:18.770]         {
[09:28:18.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.770]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.770]             })
[09:28:18.770]         }
[09:28:18.770]     }, args = future.call.arguments)
[09:28:18.770] }
[09:28:18.770] Lazy evaluation: FALSE
[09:28:18.770] Asynchronous evaluation: TRUE
[09:28:18.770] Local evaluation: TRUE
[09:28:18.770] Environment: R_GlobalEnv
[09:28:18.770] Capture standard output: TRUE
[09:28:18.770] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.770] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.770] Packages: <none>
[09:28:18.770] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.770] Resolved: FALSE
[09:28:18.770] Value: <not collected>
[09:28:18.770] Conditions captured: <none>
[09:28:18.770] Early signaling: FALSE
[09:28:18.770] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.770] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.783] Chunk #2 of 2 ... DONE
[09:28:18.783] Launching 2 futures (chunks) ... DONE
[09:28:18.783] Resolving 2 futures (chunks) ...
[09:28:18.784] resolve() on list ...
[09:28:18.784]  recursive: 0
[09:28:18.784]  length: 2
[09:28:18.784] 
[09:28:18.784] Future #1
[09:28:18.785] result() for MulticoreFuture ...
[09:28:18.785] result() for MulticoreFuture ...
[09:28:18.786] result() for MulticoreFuture ... done
[09:28:18.788] result() for MulticoreFuture ... done
[09:28:18.788] result() for MulticoreFuture ...
[09:28:18.789] result() for MulticoreFuture ... done
[09:28:18.789] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.790] - nx: 2
[09:28:18.790] - relay: TRUE
[09:28:18.790] - stdout: TRUE
[09:28:18.791] - signal: TRUE
[09:28:18.791] - resignal: FALSE
[09:28:18.791] - force: TRUE
[09:28:18.791] - relayed: [n=2] FALSE, FALSE
[09:28:18.792] - queued futures: [n=2] FALSE, FALSE
[09:28:18.792]  - until=1
[09:28:18.792]  - relaying element #1
[09:28:18.793] result() for MulticoreFuture ...
[09:28:18.793] result() for MulticoreFuture ... done
[09:28:18.793] result() for MulticoreFuture ...
[09:28:18.794] result() for MulticoreFuture ... done
[09:28:18.794] result() for MulticoreFuture ...
[09:28:18.794] result() for MulticoreFuture ... done
[09:28:18.794] result() for MulticoreFuture ...
[09:28:18.795] result() for MulticoreFuture ... done
[09:28:18.795] - relayed: [n=2] TRUE, FALSE
[09:28:18.795] - queued futures: [n=2] TRUE, FALSE
[09:28:18.795] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.795]  length: 1 (resolved future 1)
[09:28:18.796] Future #2
[09:28:18.796] result() for MulticoreFuture ...
[09:28:18.797] result() for MulticoreFuture ...
[09:28:18.797] result() for MulticoreFuture ... done
[09:28:18.797] result() for MulticoreFuture ... done
[09:28:18.797] result() for MulticoreFuture ...
[09:28:18.797] result() for MulticoreFuture ... done
[09:28:18.797] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.798] - nx: 2
[09:28:18.798] - relay: TRUE
[09:28:18.798] - stdout: TRUE
[09:28:18.798] - signal: TRUE
[09:28:18.798] - resignal: FALSE
[09:28:18.798] - force: TRUE
[09:28:18.798] - relayed: [n=2] TRUE, FALSE
[09:28:18.798] - queued futures: [n=2] TRUE, FALSE
[09:28:18.799]  - until=2
[09:28:18.799]  - relaying element #2
[09:28:18.799] result() for MulticoreFuture ...
[09:28:18.799] result() for MulticoreFuture ... done
[09:28:18.799] result() for MulticoreFuture ...
[09:28:18.799] result() for MulticoreFuture ... done
[09:28:18.799] result() for MulticoreFuture ...
[09:28:18.799] result() for MulticoreFuture ... done
[09:28:18.799] result() for MulticoreFuture ...
[09:28:18.800] result() for MulticoreFuture ... done
[09:28:18.800] - relayed: [n=2] TRUE, TRUE
[09:28:18.800] - queued futures: [n=2] TRUE, TRUE
[09:28:18.800] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.800]  length: 0 (resolved future 2)
[09:28:18.800] Relaying remaining futures
[09:28:18.800] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.800] - nx: 2
[09:28:18.800] - relay: TRUE
[09:28:18.801] - stdout: TRUE
[09:28:18.801] - signal: TRUE
[09:28:18.801] - resignal: FALSE
[09:28:18.801] - force: TRUE
[09:28:18.801] - relayed: [n=2] TRUE, TRUE
[09:28:18.801] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.801] - relayed: [n=2] TRUE, TRUE
[09:28:18.801] - queued futures: [n=2] TRUE, TRUE
[09:28:18.801] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.801] resolve() on list ... DONE
[09:28:18.802] result() for MulticoreFuture ...
[09:28:18.802] result() for MulticoreFuture ... done
[09:28:18.802] result() for MulticoreFuture ...
[09:28:18.802] result() for MulticoreFuture ... done
[09:28:18.802] result() for MulticoreFuture ...
[09:28:18.802] result() for MulticoreFuture ... done
[09:28:18.802] result() for MulticoreFuture ...
[09:28:18.802] result() for MulticoreFuture ... done
[09:28:18.802]  - Number of value chunks collected: 2
[09:28:18.802] Resolving 2 futures (chunks) ... DONE
[09:28:18.803] Reducing values from 2 chunks ...
[09:28:18.803]  - Number of values collected after concatenation: 2
[09:28:18.803]  - Number of values expected: 2
[09:28:18.803] Reducing values from 2 chunks ... DONE
[09:28:18.803] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[09:28:18.803] getGlobalsAndPackagesXApply() ...
[09:28:18.804]  - future.globals: TRUE
[09:28:18.804] getGlobalsAndPackages() ...
[09:28:18.804] Searching for globals...
[09:28:18.807] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[09:28:18.807] Searching for globals ... DONE
[09:28:18.807] Resolving globals: FALSE
[09:28:18.807] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[09:28:18.808] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[09:28:18.808] - globals: [1] ‘FUN’
[09:28:18.808] 
[09:28:18.808] getGlobalsAndPackages() ... DONE
[09:28:18.808]  - globals found/used: [n=1] ‘FUN’
[09:28:18.808]  - needed namespaces: [n=0] 
[09:28:18.808] Finding globals ... DONE
[09:28:18.809]  - use_args: TRUE
[09:28:18.809]  - Getting '...' globals ...
[09:28:18.809] resolve() on list ...
[09:28:18.809]  recursive: 0
[09:28:18.809]  length: 1
[09:28:18.809]  elements: ‘...’
[09:28:18.809]  length: 0 (resolved future 1)
[09:28:18.810] resolve() on list ... DONE
[09:28:18.810]    - '...' content: [n=0] 
[09:28:18.810] List of 1
[09:28:18.810]  $ ...: list()
[09:28:18.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.810]  - attr(*, "where")=List of 1
[09:28:18.810]   ..$ ...:<environment: 0x559ba25030c0> 
[09:28:18.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.810]  - attr(*, "resolved")= logi TRUE
[09:28:18.810]  - attr(*, "total_size")= num NA
[09:28:18.812]  - Getting '...' globals ... DONE
[09:28:18.813] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.813] List of 2
[09:28:18.813]  $ ...future.FUN:function (x)  
[09:28:18.813]  $ ...          : list()
[09:28:18.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.813]  - attr(*, "where")=List of 2
[09:28:18.813]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.813]   ..$ ...          :<environment: 0x559ba25030c0> 
[09:28:18.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.813]  - attr(*, "resolved")= logi FALSE
[09:28:18.813]  - attr(*, "total_size")= num 9888
[09:28:18.817] Packages to be attached in all futures: [n=0] 
[09:28:18.817] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.821] future_lapply() ...
[09:28:18.826] Number of chunks: 2
[09:28:18.826] getGlobalsAndPackagesXApply() ...
[09:28:18.826]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.826]  - use_args: TRUE
[09:28:18.826] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.826] List of 2
[09:28:18.826]  $ ...          : list()
[09:28:18.826]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.826]  $ ...future.FUN:function (x)  
[09:28:18.826]  - attr(*, "where")=List of 2
[09:28:18.826]   ..$ ...          :<environment: 0x559ba25030c0> 
[09:28:18.826]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:18.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.826]  - attr(*, "resolved")= logi FALSE
[09:28:18.826]  - attr(*, "total_size")= num NA
[09:28:18.829] Packages to be attached in all futures: [n=0] 
[09:28:18.829] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.829] Number of futures (= number of chunks): 2
[09:28:18.829] Launching 2 futures (chunks) ...
[09:28:18.830] Chunk #1 of 2 ...
[09:28:18.830]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.830]  - seeds: <none>
[09:28:18.830]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.830] getGlobalsAndPackages() ...
[09:28:18.830] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.830] Resolving globals: FALSE
[09:28:18.830] Tweak future expression to call with '...' arguments ...
[09:28:18.830] {
[09:28:18.830]     do.call(function(...) {
[09:28:18.830]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.830]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.830]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.830]             on.exit(options(oopts), add = TRUE)
[09:28:18.830]         }
[09:28:18.830]         {
[09:28:18.830]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.830]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.830]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.830]             })
[09:28:18.830]         }
[09:28:18.830]     }, args = future.call.arguments)
[09:28:18.830] }
[09:28:18.831] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.831] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.831] 
[09:28:18.831] getGlobalsAndPackages() ... DONE
[09:28:18.832] run() for ‘Future’ ...
[09:28:18.832] - state: ‘created’
[09:28:18.832] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.835] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.835]   - Field: ‘label’
[09:28:18.836]   - Field: ‘local’
[09:28:18.836]   - Field: ‘owner’
[09:28:18.836]   - Field: ‘envir’
[09:28:18.836]   - Field: ‘workers’
[09:28:18.836]   - Field: ‘packages’
[09:28:18.836]   - Field: ‘gc’
[09:28:18.836]   - Field: ‘job’
[09:28:18.836]   - Field: ‘conditions’
[09:28:18.836]   - Field: ‘expr’
[09:28:18.836]   - Field: ‘uuid’
[09:28:18.836]   - Field: ‘seed’
[09:28:18.837]   - Field: ‘version’
[09:28:18.837]   - Field: ‘result’
[09:28:18.837]   - Field: ‘asynchronous’
[09:28:18.837]   - Field: ‘calls’
[09:28:18.837]   - Field: ‘globals’
[09:28:18.837]   - Field: ‘stdout’
[09:28:18.837]   - Field: ‘earlySignal’
[09:28:18.837]   - Field: ‘lazy’
[09:28:18.837]   - Field: ‘state’
[09:28:18.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.837] - Launch lazy future ...
[09:28:18.838] Packages needed by the future expression (n = 0): <none>
[09:28:18.838] Packages needed by future strategies (n = 0): <none>
[09:28:18.838] {
[09:28:18.838]     {
[09:28:18.838]         {
[09:28:18.838]             ...future.startTime <- base::Sys.time()
[09:28:18.838]             {
[09:28:18.838]                 {
[09:28:18.838]                   {
[09:28:18.838]                     {
[09:28:18.838]                       base::local({
[09:28:18.838]                         has_future <- base::requireNamespace("future", 
[09:28:18.838]                           quietly = TRUE)
[09:28:18.838]                         if (has_future) {
[09:28:18.838]                           ns <- base::getNamespace("future")
[09:28:18.838]                           version <- ns[[".package"]][["version"]]
[09:28:18.838]                           if (is.null(version)) 
[09:28:18.838]                             version <- utils::packageVersion("future")
[09:28:18.838]                         }
[09:28:18.838]                         else {
[09:28:18.838]                           version <- NULL
[09:28:18.838]                         }
[09:28:18.838]                         if (!has_future || version < "1.8.0") {
[09:28:18.838]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.838]                             "", base::R.version$version.string), 
[09:28:18.838]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.838]                               "release", "version")], collapse = " "), 
[09:28:18.838]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.838]                             info)
[09:28:18.838]                           info <- base::paste(info, collapse = "; ")
[09:28:18.838]                           if (!has_future) {
[09:28:18.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.838]                               info)
[09:28:18.838]                           }
[09:28:18.838]                           else {
[09:28:18.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.838]                               info, version)
[09:28:18.838]                           }
[09:28:18.838]                           base::stop(msg)
[09:28:18.838]                         }
[09:28:18.838]                       })
[09:28:18.838]                     }
[09:28:18.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.838]                     base::options(mc.cores = 1L)
[09:28:18.838]                   }
[09:28:18.838]                   ...future.strategy.old <- future::plan("list")
[09:28:18.838]                   options(future.plan = NULL)
[09:28:18.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.838]                 }
[09:28:18.838]                 ...future.workdir <- getwd()
[09:28:18.838]             }
[09:28:18.838]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.838]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.838]         }
[09:28:18.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.838]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.838]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.838]             base::names(...future.oldOptions))
[09:28:18.838]     }
[09:28:18.838]     if (FALSE) {
[09:28:18.838]     }
[09:28:18.838]     else {
[09:28:18.838]         if (TRUE) {
[09:28:18.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.838]                 open = "w")
[09:28:18.838]         }
[09:28:18.838]         else {
[09:28:18.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.838]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.838]         }
[09:28:18.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.838]             base::sink(type = "output", split = FALSE)
[09:28:18.838]             base::close(...future.stdout)
[09:28:18.838]         }, add = TRUE)
[09:28:18.838]     }
[09:28:18.838]     ...future.frame <- base::sys.nframe()
[09:28:18.838]     ...future.conditions <- base::list()
[09:28:18.838]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.838]     if (FALSE) {
[09:28:18.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.838]     }
[09:28:18.838]     ...future.result <- base::tryCatch({
[09:28:18.838]         base::withCallingHandlers({
[09:28:18.838]             ...future.value <- base::withVisible(base::local({
[09:28:18.838]                 withCallingHandlers({
[09:28:18.838]                   {
[09:28:18.838]                     do.call(function(...) {
[09:28:18.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.838]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.838]                         ...future.globals.maxSize)) {
[09:28:18.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.838]                         on.exit(options(oopts), add = TRUE)
[09:28:18.838]                       }
[09:28:18.838]                       {
[09:28:18.838]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.838]                           FUN = function(jj) {
[09:28:18.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.838]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.838]                           })
[09:28:18.838]                       }
[09:28:18.838]                     }, args = future.call.arguments)
[09:28:18.838]                   }
[09:28:18.838]                 }, immediateCondition = function(cond) {
[09:28:18.838]                   save_rds <- function (object, pathname, ...) 
[09:28:18.838]                   {
[09:28:18.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.838]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.838]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.838]                         fi_tmp[["mtime"]])
[09:28:18.838]                     }
[09:28:18.838]                     tryCatch({
[09:28:18.838]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.838]                     }, error = function(ex) {
[09:28:18.838]                       msg <- conditionMessage(ex)
[09:28:18.838]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.838]                         fi_tmp[["mtime"]], msg)
[09:28:18.838]                       ex$message <- msg
[09:28:18.838]                       stop(ex)
[09:28:18.838]                     })
[09:28:18.838]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.838]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.838]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.838]                       fi <- file.info(pathname)
[09:28:18.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.838]                         fi[["size"]], fi[["mtime"]])
[09:28:18.838]                       stop(msg)
[09:28:18.838]                     }
[09:28:18.838]                     invisible(pathname)
[09:28:18.838]                   }
[09:28:18.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.838]                     rootPath = tempdir()) 
[09:28:18.838]                   {
[09:28:18.838]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.838]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.838]                       tmpdir = path, fileext = ".rds")
[09:28:18.838]                     save_rds(obj, file)
[09:28:18.838]                   }
[09:28:18.838]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.838]                   {
[09:28:18.838]                     inherits <- base::inherits
[09:28:18.838]                     invokeRestart <- base::invokeRestart
[09:28:18.838]                     is.null <- base::is.null
[09:28:18.838]                     muffled <- FALSE
[09:28:18.838]                     if (inherits(cond, "message")) {
[09:28:18.838]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.838]                       if (muffled) 
[09:28:18.838]                         invokeRestart("muffleMessage")
[09:28:18.838]                     }
[09:28:18.838]                     else if (inherits(cond, "warning")) {
[09:28:18.838]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.838]                       if (muffled) 
[09:28:18.838]                         invokeRestart("muffleWarning")
[09:28:18.838]                     }
[09:28:18.838]                     else if (inherits(cond, "condition")) {
[09:28:18.838]                       if (!is.null(pattern)) {
[09:28:18.838]                         computeRestarts <- base::computeRestarts
[09:28:18.838]                         grepl <- base::grepl
[09:28:18.838]                         restarts <- computeRestarts(cond)
[09:28:18.838]                         for (restart in restarts) {
[09:28:18.838]                           name <- restart$name
[09:28:18.838]                           if (is.null(name)) 
[09:28:18.838]                             next
[09:28:18.838]                           if (!grepl(pattern, name)) 
[09:28:18.838]                             next
[09:28:18.838]                           invokeRestart(restart)
[09:28:18.838]                           muffled <- TRUE
[09:28:18.838]                           break
[09:28:18.838]                         }
[09:28:18.838]                       }
[09:28:18.838]                     }
[09:28:18.838]                     invisible(muffled)
[09:28:18.838]                   }
[09:28:18.838]                   muffleCondition(cond)
[09:28:18.838]                 })
[09:28:18.838]             }))
[09:28:18.838]             future::FutureResult(value = ...future.value$value, 
[09:28:18.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.838]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.838]                     ...future.globalenv.names))
[09:28:18.838]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.838]         }, condition = base::local({
[09:28:18.838]             c <- base::c
[09:28:18.838]             inherits <- base::inherits
[09:28:18.838]             invokeRestart <- base::invokeRestart
[09:28:18.838]             length <- base::length
[09:28:18.838]             list <- base::list
[09:28:18.838]             seq.int <- base::seq.int
[09:28:18.838]             signalCondition <- base::signalCondition
[09:28:18.838]             sys.calls <- base::sys.calls
[09:28:18.838]             `[[` <- base::`[[`
[09:28:18.838]             `+` <- base::`+`
[09:28:18.838]             `<<-` <- base::`<<-`
[09:28:18.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.838]                   3L)]
[09:28:18.838]             }
[09:28:18.838]             function(cond) {
[09:28:18.838]                 is_error <- inherits(cond, "error")
[09:28:18.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.838]                   NULL)
[09:28:18.838]                 if (is_error) {
[09:28:18.838]                   sessionInformation <- function() {
[09:28:18.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.838]                       search = base::search(), system = base::Sys.info())
[09:28:18.838]                   }
[09:28:18.838]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.838]                     cond$call), session = sessionInformation(), 
[09:28:18.838]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.838]                   signalCondition(cond)
[09:28:18.838]                 }
[09:28:18.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.838]                 "immediateCondition"))) {
[09:28:18.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.838]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.838]                   if (TRUE && !signal) {
[09:28:18.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.838]                     {
[09:28:18.838]                       inherits <- base::inherits
[09:28:18.838]                       invokeRestart <- base::invokeRestart
[09:28:18.838]                       is.null <- base::is.null
[09:28:18.838]                       muffled <- FALSE
[09:28:18.838]                       if (inherits(cond, "message")) {
[09:28:18.838]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.838]                         if (muffled) 
[09:28:18.838]                           invokeRestart("muffleMessage")
[09:28:18.838]                       }
[09:28:18.838]                       else if (inherits(cond, "warning")) {
[09:28:18.838]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.838]                         if (muffled) 
[09:28:18.838]                           invokeRestart("muffleWarning")
[09:28:18.838]                       }
[09:28:18.838]                       else if (inherits(cond, "condition")) {
[09:28:18.838]                         if (!is.null(pattern)) {
[09:28:18.838]                           computeRestarts <- base::computeRestarts
[09:28:18.838]                           grepl <- base::grepl
[09:28:18.838]                           restarts <- computeRestarts(cond)
[09:28:18.838]                           for (restart in restarts) {
[09:28:18.838]                             name <- restart$name
[09:28:18.838]                             if (is.null(name)) 
[09:28:18.838]                               next
[09:28:18.838]                             if (!grepl(pattern, name)) 
[09:28:18.838]                               next
[09:28:18.838]                             invokeRestart(restart)
[09:28:18.838]                             muffled <- TRUE
[09:28:18.838]                             break
[09:28:18.838]                           }
[09:28:18.838]                         }
[09:28:18.838]                       }
[09:28:18.838]                       invisible(muffled)
[09:28:18.838]                     }
[09:28:18.838]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.838]                   }
[09:28:18.838]                 }
[09:28:18.838]                 else {
[09:28:18.838]                   if (TRUE) {
[09:28:18.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.838]                     {
[09:28:18.838]                       inherits <- base::inherits
[09:28:18.838]                       invokeRestart <- base::invokeRestart
[09:28:18.838]                       is.null <- base::is.null
[09:28:18.838]                       muffled <- FALSE
[09:28:18.838]                       if (inherits(cond, "message")) {
[09:28:18.838]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.838]                         if (muffled) 
[09:28:18.838]                           invokeRestart("muffleMessage")
[09:28:18.838]                       }
[09:28:18.838]                       else if (inherits(cond, "warning")) {
[09:28:18.838]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.838]                         if (muffled) 
[09:28:18.838]                           invokeRestart("muffleWarning")
[09:28:18.838]                       }
[09:28:18.838]                       else if (inherits(cond, "condition")) {
[09:28:18.838]                         if (!is.null(pattern)) {
[09:28:18.838]                           computeRestarts <- base::computeRestarts
[09:28:18.838]                           grepl <- base::grepl
[09:28:18.838]                           restarts <- computeRestarts(cond)
[09:28:18.838]                           for (restart in restarts) {
[09:28:18.838]                             name <- restart$name
[09:28:18.838]                             if (is.null(name)) 
[09:28:18.838]                               next
[09:28:18.838]                             if (!grepl(pattern, name)) 
[09:28:18.838]                               next
[09:28:18.838]                             invokeRestart(restart)
[09:28:18.838]                             muffled <- TRUE
[09:28:18.838]                             break
[09:28:18.838]                           }
[09:28:18.838]                         }
[09:28:18.838]                       }
[09:28:18.838]                       invisible(muffled)
[09:28:18.838]                     }
[09:28:18.838]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.838]                   }
[09:28:18.838]                 }
[09:28:18.838]             }
[09:28:18.838]         }))
[09:28:18.838]     }, error = function(ex) {
[09:28:18.838]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.838]                 ...future.rng), started = ...future.startTime, 
[09:28:18.838]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.838]             version = "1.8"), class = "FutureResult")
[09:28:18.838]     }, finally = {
[09:28:18.838]         if (!identical(...future.workdir, getwd())) 
[09:28:18.838]             setwd(...future.workdir)
[09:28:18.838]         {
[09:28:18.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.838]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.838]             }
[09:28:18.838]             base::options(...future.oldOptions)
[09:28:18.838]             if (.Platform$OS.type == "windows") {
[09:28:18.838]                 old_names <- names(...future.oldEnvVars)
[09:28:18.838]                 envs <- base::Sys.getenv()
[09:28:18.838]                 names <- names(envs)
[09:28:18.838]                 common <- intersect(names, old_names)
[09:28:18.838]                 added <- setdiff(names, old_names)
[09:28:18.838]                 removed <- setdiff(old_names, names)
[09:28:18.838]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.838]                   envs[common]]
[09:28:18.838]                 NAMES <- toupper(changed)
[09:28:18.838]                 args <- list()
[09:28:18.838]                 for (kk in seq_along(NAMES)) {
[09:28:18.838]                   name <- changed[[kk]]
[09:28:18.838]                   NAME <- NAMES[[kk]]
[09:28:18.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.838]                     next
[09:28:18.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.838]                 }
[09:28:18.838]                 NAMES <- toupper(added)
[09:28:18.838]                 for (kk in seq_along(NAMES)) {
[09:28:18.838]                   name <- added[[kk]]
[09:28:18.838]                   NAME <- NAMES[[kk]]
[09:28:18.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.838]                     next
[09:28:18.838]                   args[[name]] <- ""
[09:28:18.838]                 }
[09:28:18.838]                 NAMES <- toupper(removed)
[09:28:18.838]                 for (kk in seq_along(NAMES)) {
[09:28:18.838]                   name <- removed[[kk]]
[09:28:18.838]                   NAME <- NAMES[[kk]]
[09:28:18.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.838]                     next
[09:28:18.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.838]                 }
[09:28:18.838]                 if (length(args) > 0) 
[09:28:18.838]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.838]             }
[09:28:18.838]             else {
[09:28:18.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.838]             }
[09:28:18.838]             {
[09:28:18.838]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.838]                   0L) {
[09:28:18.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.838]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.838]                   base::options(opts)
[09:28:18.838]                 }
[09:28:18.838]                 {
[09:28:18.838]                   {
[09:28:18.838]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.838]                     NULL
[09:28:18.838]                   }
[09:28:18.838]                   options(future.plan = NULL)
[09:28:18.838]                   if (is.na(NA_character_)) 
[09:28:18.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.838]                     .init = FALSE)
[09:28:18.838]                 }
[09:28:18.838]             }
[09:28:18.838]         }
[09:28:18.838]     })
[09:28:18.838]     if (TRUE) {
[09:28:18.838]         base::sink(type = "output", split = FALSE)
[09:28:18.838]         if (TRUE) {
[09:28:18.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.838]         }
[09:28:18.838]         else {
[09:28:18.838]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.838]         }
[09:28:18.838]         base::close(...future.stdout)
[09:28:18.838]         ...future.stdout <- NULL
[09:28:18.838]     }
[09:28:18.838]     ...future.result$conditions <- ...future.conditions
[09:28:18.838]     ...future.result$finished <- base::Sys.time()
[09:28:18.838]     ...future.result
[09:28:18.838] }
[09:28:18.841] assign_globals() ...
[09:28:18.841] List of 5
[09:28:18.841]  $ future.call.arguments    : list()
[09:28:18.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.841]  $ ...future.FUN            :function (x)  
[09:28:18.841]  $ ...future.elements_ii    :List of 1
[09:28:18.841]   ..$ : int [1:2] 1 3
[09:28:18.841]  $ ...future.seeds_ii       : NULL
[09:28:18.841]  $ ...future.globals.maxSize: num Inf
[09:28:18.841]  - attr(*, "resolved")= logi FALSE
[09:28:18.841]  - attr(*, "total_size")= num NA
[09:28:18.841]  - attr(*, "where")=List of 5
[09:28:18.841]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.841]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.841]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.841]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.841]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.841]  - attr(*, "already-done")= logi TRUE
[09:28:18.847] - copied ‘future.call.arguments’ to environment
[09:28:18.847] - reassign environment for ‘...future.FUN’
[09:28:18.847] - copied ‘...future.FUN’ to environment
[09:28:18.847] - copied ‘...future.elements_ii’ to environment
[09:28:18.847] - copied ‘...future.seeds_ii’ to environment
[09:28:18.847] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.847] assign_globals() ... done
[09:28:18.847] requestCore(): workers = 2
[09:28:18.849] MulticoreFuture started
[09:28:18.850] - Launch lazy future ... done
[09:28:18.850] plan(): Setting new future strategy stack:
[09:28:18.850] run() for ‘MulticoreFuture’ ... done
[09:28:18.851] Created future:
[09:28:18.851] List of future strategies:
[09:28:18.851] 1. sequential:
[09:28:18.851]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.851]    - tweaked: FALSE
[09:28:18.851]    - call: NULL
[09:28:18.853] plan(): nbrOfWorkers() = 1
[09:28:18.856] plan(): Setting new future strategy stack:
[09:28:18.856] List of future strategies:
[09:28:18.856] 1. multicore:
[09:28:18.856]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.856]    - tweaked: FALSE
[09:28:18.856]    - call: plan(strategy)
[09:28:18.861] plan(): nbrOfWorkers() = 2
[09:28:18.852] MulticoreFuture:
[09:28:18.852] Label: ‘future_apply-1’
[09:28:18.852] Expression:
[09:28:18.852] {
[09:28:18.852]     do.call(function(...) {
[09:28:18.852]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.852]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.852]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.852]             on.exit(options(oopts), add = TRUE)
[09:28:18.852]         }
[09:28:18.852]         {
[09:28:18.852]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.852]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.852]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.852]             })
[09:28:18.852]         }
[09:28:18.852]     }, args = future.call.arguments)
[09:28:18.852] }
[09:28:18.852] Lazy evaluation: FALSE
[09:28:18.852] Asynchronous evaluation: TRUE
[09:28:18.852] Local evaluation: TRUE
[09:28:18.852] Environment: R_GlobalEnv
[09:28:18.852] Capture standard output: TRUE
[09:28:18.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.852] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.852] Packages: <none>
[09:28:18.852] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.852] Resolved: TRUE
[09:28:18.852] Value: <not collected>
[09:28:18.852] Conditions captured: <none>
[09:28:18.852] Early signaling: FALSE
[09:28:18.852] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.852] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.862] Chunk #1 of 2 ... DONE
[09:28:18.862] Chunk #2 of 2 ...
[09:28:18.863]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.863]  - seeds: <none>
[09:28:18.863]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.863] getGlobalsAndPackages() ...
[09:28:18.863] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.863] Resolving globals: FALSE
[09:28:18.864] Tweak future expression to call with '...' arguments ...
[09:28:18.864] {
[09:28:18.864]     do.call(function(...) {
[09:28:18.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.864]             on.exit(options(oopts), add = TRUE)
[09:28:18.864]         }
[09:28:18.864]         {
[09:28:18.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.864]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.864]             })
[09:28:18.864]         }
[09:28:18.864]     }, args = future.call.arguments)
[09:28:18.864] }
[09:28:18.864] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.865] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.865] 
[09:28:18.865] getGlobalsAndPackages() ... DONE
[09:28:18.866] run() for ‘Future’ ...
[09:28:18.866] - state: ‘created’
[09:28:18.866] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.871] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.871]   - Field: ‘label’
[09:28:18.871]   - Field: ‘local’
[09:28:18.871]   - Field: ‘owner’
[09:28:18.871]   - Field: ‘envir’
[09:28:18.871]   - Field: ‘workers’
[09:28:18.872]   - Field: ‘packages’
[09:28:18.872]   - Field: ‘gc’
[09:28:18.872]   - Field: ‘job’
[09:28:18.872]   - Field: ‘conditions’
[09:28:18.872]   - Field: ‘expr’
[09:28:18.872]   - Field: ‘uuid’
[09:28:18.872]   - Field: ‘seed’
[09:28:18.873]   - Field: ‘version’
[09:28:18.873]   - Field: ‘result’
[09:28:18.873]   - Field: ‘asynchronous’
[09:28:18.873]   - Field: ‘calls’
[09:28:18.873]   - Field: ‘globals’
[09:28:18.873]   - Field: ‘stdout’
[09:28:18.873]   - Field: ‘earlySignal’
[09:28:18.873]   - Field: ‘lazy’
[09:28:18.874]   - Field: ‘state’
[09:28:18.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.874] - Launch lazy future ...
[09:28:18.874] Packages needed by the future expression (n = 0): <none>
[09:28:18.874] Packages needed by future strategies (n = 0): <none>
[09:28:18.875] {
[09:28:18.875]     {
[09:28:18.875]         {
[09:28:18.875]             ...future.startTime <- base::Sys.time()
[09:28:18.875]             {
[09:28:18.875]                 {
[09:28:18.875]                   {
[09:28:18.875]                     {
[09:28:18.875]                       base::local({
[09:28:18.875]                         has_future <- base::requireNamespace("future", 
[09:28:18.875]                           quietly = TRUE)
[09:28:18.875]                         if (has_future) {
[09:28:18.875]                           ns <- base::getNamespace("future")
[09:28:18.875]                           version <- ns[[".package"]][["version"]]
[09:28:18.875]                           if (is.null(version)) 
[09:28:18.875]                             version <- utils::packageVersion("future")
[09:28:18.875]                         }
[09:28:18.875]                         else {
[09:28:18.875]                           version <- NULL
[09:28:18.875]                         }
[09:28:18.875]                         if (!has_future || version < "1.8.0") {
[09:28:18.875]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.875]                             "", base::R.version$version.string), 
[09:28:18.875]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.875]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.875]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.875]                               "release", "version")], collapse = " "), 
[09:28:18.875]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.875]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.875]                             info)
[09:28:18.875]                           info <- base::paste(info, collapse = "; ")
[09:28:18.875]                           if (!has_future) {
[09:28:18.875]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.875]                               info)
[09:28:18.875]                           }
[09:28:18.875]                           else {
[09:28:18.875]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.875]                               info, version)
[09:28:18.875]                           }
[09:28:18.875]                           base::stop(msg)
[09:28:18.875]                         }
[09:28:18.875]                       })
[09:28:18.875]                     }
[09:28:18.875]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.875]                     base::options(mc.cores = 1L)
[09:28:18.875]                   }
[09:28:18.875]                   ...future.strategy.old <- future::plan("list")
[09:28:18.875]                   options(future.plan = NULL)
[09:28:18.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.875]                 }
[09:28:18.875]                 ...future.workdir <- getwd()
[09:28:18.875]             }
[09:28:18.875]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.875]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.875]         }
[09:28:18.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.875]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.875]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.875]             base::names(...future.oldOptions))
[09:28:18.875]     }
[09:28:18.875]     if (FALSE) {
[09:28:18.875]     }
[09:28:18.875]     else {
[09:28:18.875]         if (TRUE) {
[09:28:18.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.875]                 open = "w")
[09:28:18.875]         }
[09:28:18.875]         else {
[09:28:18.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.875]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.875]         }
[09:28:18.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.875]             base::sink(type = "output", split = FALSE)
[09:28:18.875]             base::close(...future.stdout)
[09:28:18.875]         }, add = TRUE)
[09:28:18.875]     }
[09:28:18.875]     ...future.frame <- base::sys.nframe()
[09:28:18.875]     ...future.conditions <- base::list()
[09:28:18.875]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.875]     if (FALSE) {
[09:28:18.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.875]     }
[09:28:18.875]     ...future.result <- base::tryCatch({
[09:28:18.875]         base::withCallingHandlers({
[09:28:18.875]             ...future.value <- base::withVisible(base::local({
[09:28:18.875]                 withCallingHandlers({
[09:28:18.875]                   {
[09:28:18.875]                     do.call(function(...) {
[09:28:18.875]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.875]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.875]                         ...future.globals.maxSize)) {
[09:28:18.875]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.875]                         on.exit(options(oopts), add = TRUE)
[09:28:18.875]                       }
[09:28:18.875]                       {
[09:28:18.875]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.875]                           FUN = function(jj) {
[09:28:18.875]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.875]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.875]                           })
[09:28:18.875]                       }
[09:28:18.875]                     }, args = future.call.arguments)
[09:28:18.875]                   }
[09:28:18.875]                 }, immediateCondition = function(cond) {
[09:28:18.875]                   save_rds <- function (object, pathname, ...) 
[09:28:18.875]                   {
[09:28:18.875]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.875]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.875]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.875]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.875]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.875]                         fi_tmp[["mtime"]])
[09:28:18.875]                     }
[09:28:18.875]                     tryCatch({
[09:28:18.875]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.875]                     }, error = function(ex) {
[09:28:18.875]                       msg <- conditionMessage(ex)
[09:28:18.875]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.875]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.875]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.875]                         fi_tmp[["mtime"]], msg)
[09:28:18.875]                       ex$message <- msg
[09:28:18.875]                       stop(ex)
[09:28:18.875]                     })
[09:28:18.875]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.875]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.875]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.875]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.875]                       fi <- file.info(pathname)
[09:28:18.875]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.875]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.875]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.875]                         fi[["size"]], fi[["mtime"]])
[09:28:18.875]                       stop(msg)
[09:28:18.875]                     }
[09:28:18.875]                     invisible(pathname)
[09:28:18.875]                   }
[09:28:18.875]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.875]                     rootPath = tempdir()) 
[09:28:18.875]                   {
[09:28:18.875]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.875]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.875]                       tmpdir = path, fileext = ".rds")
[09:28:18.875]                     save_rds(obj, file)
[09:28:18.875]                   }
[09:28:18.875]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.875]                   {
[09:28:18.875]                     inherits <- base::inherits
[09:28:18.875]                     invokeRestart <- base::invokeRestart
[09:28:18.875]                     is.null <- base::is.null
[09:28:18.875]                     muffled <- FALSE
[09:28:18.875]                     if (inherits(cond, "message")) {
[09:28:18.875]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.875]                       if (muffled) 
[09:28:18.875]                         invokeRestart("muffleMessage")
[09:28:18.875]                     }
[09:28:18.875]                     else if (inherits(cond, "warning")) {
[09:28:18.875]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.875]                       if (muffled) 
[09:28:18.875]                         invokeRestart("muffleWarning")
[09:28:18.875]                     }
[09:28:18.875]                     else if (inherits(cond, "condition")) {
[09:28:18.875]                       if (!is.null(pattern)) {
[09:28:18.875]                         computeRestarts <- base::computeRestarts
[09:28:18.875]                         grepl <- base::grepl
[09:28:18.875]                         restarts <- computeRestarts(cond)
[09:28:18.875]                         for (restart in restarts) {
[09:28:18.875]                           name <- restart$name
[09:28:18.875]                           if (is.null(name)) 
[09:28:18.875]                             next
[09:28:18.875]                           if (!grepl(pattern, name)) 
[09:28:18.875]                             next
[09:28:18.875]                           invokeRestart(restart)
[09:28:18.875]                           muffled <- TRUE
[09:28:18.875]                           break
[09:28:18.875]                         }
[09:28:18.875]                       }
[09:28:18.875]                     }
[09:28:18.875]                     invisible(muffled)
[09:28:18.875]                   }
[09:28:18.875]                   muffleCondition(cond)
[09:28:18.875]                 })
[09:28:18.875]             }))
[09:28:18.875]             future::FutureResult(value = ...future.value$value, 
[09:28:18.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.875]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.875]                     ...future.globalenv.names))
[09:28:18.875]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.875]         }, condition = base::local({
[09:28:18.875]             c <- base::c
[09:28:18.875]             inherits <- base::inherits
[09:28:18.875]             invokeRestart <- base::invokeRestart
[09:28:18.875]             length <- base::length
[09:28:18.875]             list <- base::list
[09:28:18.875]             seq.int <- base::seq.int
[09:28:18.875]             signalCondition <- base::signalCondition
[09:28:18.875]             sys.calls <- base::sys.calls
[09:28:18.875]             `[[` <- base::`[[`
[09:28:18.875]             `+` <- base::`+`
[09:28:18.875]             `<<-` <- base::`<<-`
[09:28:18.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.875]                   3L)]
[09:28:18.875]             }
[09:28:18.875]             function(cond) {
[09:28:18.875]                 is_error <- inherits(cond, "error")
[09:28:18.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.875]                   NULL)
[09:28:18.875]                 if (is_error) {
[09:28:18.875]                   sessionInformation <- function() {
[09:28:18.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.875]                       search = base::search(), system = base::Sys.info())
[09:28:18.875]                   }
[09:28:18.875]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.875]                     cond$call), session = sessionInformation(), 
[09:28:18.875]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.875]                   signalCondition(cond)
[09:28:18.875]                 }
[09:28:18.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:18.875]                 "immediateCondition"))) {
[09:28:18.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.875]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.875]                   if (TRUE && !signal) {
[09:28:18.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.875]                     {
[09:28:18.875]                       inherits <- base::inherits
[09:28:18.875]                       invokeRestart <- base::invokeRestart
[09:28:18.875]                       is.null <- base::is.null
[09:28:18.875]                       muffled <- FALSE
[09:28:18.875]                       if (inherits(cond, "message")) {
[09:28:18.875]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.875]                         if (muffled) 
[09:28:18.875]                           invokeRestart("muffleMessage")
[09:28:18.875]                       }
[09:28:18.875]                       else if (inherits(cond, "warning")) {
[09:28:18.875]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.875]                         if (muffled) 
[09:28:18.875]                           invokeRestart("muffleWarning")
[09:28:18.875]                       }
[09:28:18.875]                       else if (inherits(cond, "condition")) {
[09:28:18.875]                         if (!is.null(pattern)) {
[09:28:18.875]                           computeRestarts <- base::computeRestarts
[09:28:18.875]                           grepl <- base::grepl
[09:28:18.875]                           restarts <- computeRestarts(cond)
[09:28:18.875]                           for (restart in restarts) {
[09:28:18.875]                             name <- restart$name
[09:28:18.875]                             if (is.null(name)) 
[09:28:18.875]                               next
[09:28:18.875]                             if (!grepl(pattern, name)) 
[09:28:18.875]                               next
[09:28:18.875]                             invokeRestart(restart)
[09:28:18.875]                             muffled <- TRUE
[09:28:18.875]                             break
[09:28:18.875]                           }
[09:28:18.875]                         }
[09:28:18.875]                       }
[09:28:18.875]                       invisible(muffled)
[09:28:18.875]                     }
[09:28:18.875]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.875]                   }
[09:28:18.875]                 }
[09:28:18.875]                 else {
[09:28:18.875]                   if (TRUE) {
[09:28:18.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.875]                     {
[09:28:18.875]                       inherits <- base::inherits
[09:28:18.875]                       invokeRestart <- base::invokeRestart
[09:28:18.875]                       is.null <- base::is.null
[09:28:18.875]                       muffled <- FALSE
[09:28:18.875]                       if (inherits(cond, "message")) {
[09:28:18.875]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.875]                         if (muffled) 
[09:28:18.875]                           invokeRestart("muffleMessage")
[09:28:18.875]                       }
[09:28:18.875]                       else if (inherits(cond, "warning")) {
[09:28:18.875]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.875]                         if (muffled) 
[09:28:18.875]                           invokeRestart("muffleWarning")
[09:28:18.875]                       }
[09:28:18.875]                       else if (inherits(cond, "condition")) {
[09:28:18.875]                         if (!is.null(pattern)) {
[09:28:18.875]                           computeRestarts <- base::computeRestarts
[09:28:18.875]                           grepl <- base::grepl
[09:28:18.875]                           restarts <- computeRestarts(cond)
[09:28:18.875]                           for (restart in restarts) {
[09:28:18.875]                             name <- restart$name
[09:28:18.875]                             if (is.null(name)) 
[09:28:18.875]                               next
[09:28:18.875]                             if (!grepl(pattern, name)) 
[09:28:18.875]                               next
[09:28:18.875]                             invokeRestart(restart)
[09:28:18.875]                             muffled <- TRUE
[09:28:18.875]                             break
[09:28:18.875]                           }
[09:28:18.875]                         }
[09:28:18.875]                       }
[09:28:18.875]                       invisible(muffled)
[09:28:18.875]                     }
[09:28:18.875]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.875]                   }
[09:28:18.875]                 }
[09:28:18.875]             }
[09:28:18.875]         }))
[09:28:18.875]     }, error = function(ex) {
[09:28:18.875]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.875]                 ...future.rng), started = ...future.startTime, 
[09:28:18.875]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.875]             version = "1.8"), class = "FutureResult")
[09:28:18.875]     }, finally = {
[09:28:18.875]         if (!identical(...future.workdir, getwd())) 
[09:28:18.875]             setwd(...future.workdir)
[09:28:18.875]         {
[09:28:18.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.875]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.875]             }
[09:28:18.875]             base::options(...future.oldOptions)
[09:28:18.875]             if (.Platform$OS.type == "windows") {
[09:28:18.875]                 old_names <- names(...future.oldEnvVars)
[09:28:18.875]                 envs <- base::Sys.getenv()
[09:28:18.875]                 names <- names(envs)
[09:28:18.875]                 common <- intersect(names, old_names)
[09:28:18.875]                 added <- setdiff(names, old_names)
[09:28:18.875]                 removed <- setdiff(old_names, names)
[09:28:18.875]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.875]                   envs[common]]
[09:28:18.875]                 NAMES <- toupper(changed)
[09:28:18.875]                 args <- list()
[09:28:18.875]                 for (kk in seq_along(NAMES)) {
[09:28:18.875]                   name <- changed[[kk]]
[09:28:18.875]                   NAME <- NAMES[[kk]]
[09:28:18.875]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.875]                     next
[09:28:18.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.875]                 }
[09:28:18.875]                 NAMES <- toupper(added)
[09:28:18.875]                 for (kk in seq_along(NAMES)) {
[09:28:18.875]                   name <- added[[kk]]
[09:28:18.875]                   NAME <- NAMES[[kk]]
[09:28:18.875]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.875]                     next
[09:28:18.875]                   args[[name]] <- ""
[09:28:18.875]                 }
[09:28:18.875]                 NAMES <- toupper(removed)
[09:28:18.875]                 for (kk in seq_along(NAMES)) {
[09:28:18.875]                   name <- removed[[kk]]
[09:28:18.875]                   NAME <- NAMES[[kk]]
[09:28:18.875]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.875]                     next
[09:28:18.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.875]                 }
[09:28:18.875]                 if (length(args) > 0) 
[09:28:18.875]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.875]             }
[09:28:18.875]             else {
[09:28:18.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.875]             }
[09:28:18.875]             {
[09:28:18.875]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.875]                   0L) {
[09:28:18.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.875]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.875]                   base::options(opts)
[09:28:18.875]                 }
[09:28:18.875]                 {
[09:28:18.875]                   {
[09:28:18.875]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.875]                     NULL
[09:28:18.875]                   }
[09:28:18.875]                   options(future.plan = NULL)
[09:28:18.875]                   if (is.na(NA_character_)) 
[09:28:18.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.875]                     .init = FALSE)
[09:28:18.875]                 }
[09:28:18.875]             }
[09:28:18.875]         }
[09:28:18.875]     })
[09:28:18.875]     if (TRUE) {
[09:28:18.875]         base::sink(type = "output", split = FALSE)
[09:28:18.875]         if (TRUE) {
[09:28:18.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.875]         }
[09:28:18.875]         else {
[09:28:18.875]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.875]         }
[09:28:18.875]         base::close(...future.stdout)
[09:28:18.875]         ...future.stdout <- NULL
[09:28:18.875]     }
[09:28:18.875]     ...future.result$conditions <- ...future.conditions
[09:28:18.875]     ...future.result$finished <- base::Sys.time()
[09:28:18.875]     ...future.result
[09:28:18.875] }
[09:28:18.878] assign_globals() ...
[09:28:18.879] List of 5
[09:28:18.879]  $ future.call.arguments    : list()
[09:28:18.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.879]  $ ...future.FUN            :function (x)  
[09:28:18.879]  $ ...future.elements_ii    :List of 1
[09:28:18.879]   ..$ : int [1:2] 2 4
[09:28:18.879]  $ ...future.seeds_ii       : NULL
[09:28:18.879]  $ ...future.globals.maxSize: num Inf
[09:28:18.879]  - attr(*, "resolved")= logi FALSE
[09:28:18.879]  - attr(*, "total_size")= num NA
[09:28:18.879]  - attr(*, "where")=List of 5
[09:28:18.879]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.879]  - attr(*, "already-done")= logi TRUE
[09:28:18.885] - copied ‘future.call.arguments’ to environment
[09:28:18.885] - reassign environment for ‘...future.FUN’
[09:28:18.886] - copied ‘...future.FUN’ to environment
[09:28:18.886] - copied ‘...future.elements_ii’ to environment
[09:28:18.886] - copied ‘...future.seeds_ii’ to environment
[09:28:18.886] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.886] assign_globals() ... done
[09:28:18.886] requestCore(): workers = 2
[09:28:18.888] MulticoreFuture started
[09:28:18.889] - Launch lazy future ... done
[09:28:18.889] run() for ‘MulticoreFuture’ ... done
[09:28:18.889] Created future:
[09:28:18.889] plan(): Setting new future strategy stack:
[09:28:18.890] List of future strategies:
[09:28:18.890] 1. sequential:
[09:28:18.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.890]    - tweaked: FALSE
[09:28:18.890]    - call: NULL
[09:28:18.891] plan(): nbrOfWorkers() = 1
[09:28:18.893] plan(): Setting new future strategy stack:
[09:28:18.893] List of future strategies:
[09:28:18.893] 1. multicore:
[09:28:18.893]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.893]    - tweaked: FALSE
[09:28:18.893]    - call: plan(strategy)
[09:28:18.898] plan(): nbrOfWorkers() = 2
[09:28:18.889] MulticoreFuture:
[09:28:18.889] Label: ‘future_apply-2’
[09:28:18.889] Expression:
[09:28:18.889] {
[09:28:18.889]     do.call(function(...) {
[09:28:18.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.889]             on.exit(options(oopts), add = TRUE)
[09:28:18.889]         }
[09:28:18.889]         {
[09:28:18.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.889]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.889]             })
[09:28:18.889]         }
[09:28:18.889]     }, args = future.call.arguments)
[09:28:18.889] }
[09:28:18.889] Lazy evaluation: FALSE
[09:28:18.889] Asynchronous evaluation: TRUE
[09:28:18.889] Local evaluation: TRUE
[09:28:18.889] Environment: R_GlobalEnv
[09:28:18.889] Capture standard output: TRUE
[09:28:18.889] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:18.889] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.889] Packages: <none>
[09:28:18.889] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:18.889] Resolved: TRUE
[09:28:18.889] Value: <not collected>
[09:28:18.889] Conditions captured: <none>
[09:28:18.889] Early signaling: FALSE
[09:28:18.889] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.889] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.899] Chunk #2 of 2 ... DONE
[09:28:18.899] Launching 2 futures (chunks) ... DONE
[09:28:18.899] Resolving 2 futures (chunks) ...
[09:28:18.899] resolve() on list ...
[09:28:18.899]  recursive: 0
[09:28:18.899]  length: 2
[09:28:18.899] 
[09:28:18.900] Future #1
[09:28:18.900] result() for MulticoreFuture ...
[09:28:18.901] result() for MulticoreFuture ...
[09:28:18.901] result() for MulticoreFuture ... done
[09:28:18.901] result() for MulticoreFuture ... done
[09:28:18.902] result() for MulticoreFuture ...
[09:28:18.902] result() for MulticoreFuture ... done
[09:28:18.902] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:18.902] - nx: 2
[09:28:18.902] - relay: TRUE
[09:28:18.903] - stdout: TRUE
[09:28:18.903] - signal: TRUE
[09:28:18.903] - resignal: FALSE
[09:28:18.903] - force: TRUE
[09:28:18.903] - relayed: [n=2] FALSE, FALSE
[09:28:18.903] - queued futures: [n=2] FALSE, FALSE
[09:28:18.904]  - until=1
[09:28:18.904]  - relaying element #1
[09:28:18.904] result() for MulticoreFuture ...
[09:28:18.904] result() for MulticoreFuture ... done
[09:28:18.904] result() for MulticoreFuture ...
[09:28:18.908] result() for MulticoreFuture ... done
[09:28:18.909] result() for MulticoreFuture ...
[09:28:18.909] result() for MulticoreFuture ... done
[09:28:18.910] result() for MulticoreFuture ...
[09:28:18.910] result() for MulticoreFuture ... done
[09:28:18.910] - relayed: [n=2] TRUE, FALSE
[09:28:18.910] - queued futures: [n=2] TRUE, FALSE
[09:28:18.911] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:18.911]  length: 1 (resolved future 1)
[09:28:18.912] Future #2
[09:28:18.912] result() for MulticoreFuture ...
[09:28:18.913] result() for MulticoreFuture ...
[09:28:18.913] result() for MulticoreFuture ... done
[09:28:18.914] result() for MulticoreFuture ... done
[09:28:18.914] result() for MulticoreFuture ...
[09:28:18.914] result() for MulticoreFuture ... done
[09:28:18.914] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:18.914] - nx: 2
[09:28:18.915] - relay: TRUE
[09:28:18.915] - stdout: TRUE
[09:28:18.915] - signal: TRUE
[09:28:18.915] - resignal: FALSE
[09:28:18.915] - force: TRUE
[09:28:18.915] - relayed: [n=2] TRUE, FALSE
[09:28:18.915] - queued futures: [n=2] TRUE, FALSE
[09:28:18.916]  - until=2
[09:28:18.916]  - relaying element #2
[09:28:18.916] result() for MulticoreFuture ...
[09:28:18.916] result() for MulticoreFuture ... done
[09:28:18.916] result() for MulticoreFuture ...
[09:28:18.916] result() for MulticoreFuture ... done
[09:28:18.916] result() for MulticoreFuture ...
[09:28:18.916] result() for MulticoreFuture ... done
[09:28:18.916] result() for MulticoreFuture ...
[09:28:18.917] result() for MulticoreFuture ... done
[09:28:18.917] - relayed: [n=2] TRUE, TRUE
[09:28:18.917] - queued futures: [n=2] TRUE, TRUE
[09:28:18.917] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:18.917]  length: 0 (resolved future 2)
[09:28:18.917] Relaying remaining futures
[09:28:18.917] signalConditionsASAP(NULL, pos=0) ...
[09:28:18.917] - nx: 2
[09:28:18.918] - relay: TRUE
[09:28:18.918] - stdout: TRUE
[09:28:18.918] - signal: TRUE
[09:28:18.918] - resignal: FALSE
[09:28:18.918] - force: TRUE
[09:28:18.918] - relayed: [n=2] TRUE, TRUE
[09:28:18.918] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:18.918] - relayed: [n=2] TRUE, TRUE
[09:28:18.918] - queued futures: [n=2] TRUE, TRUE
[09:28:18.919] signalConditionsASAP(NULL, pos=0) ... done
[09:28:18.919] resolve() on list ... DONE
[09:28:18.919] result() for MulticoreFuture ...
[09:28:18.919] result() for MulticoreFuture ... done
[09:28:18.919] result() for MulticoreFuture ...
[09:28:18.919] result() for MulticoreFuture ... done
[09:28:18.919] result() for MulticoreFuture ...
[09:28:18.919] result() for MulticoreFuture ... done
[09:28:18.919] result() for MulticoreFuture ...
[09:28:18.919] result() for MulticoreFuture ... done
[09:28:18.920]  - Number of value chunks collected: 2
[09:28:18.920] Resolving 2 futures (chunks) ... DONE
[09:28:18.920] Reducing values from 2 chunks ...
[09:28:18.920]  - Number of values collected after concatenation: 2
[09:28:18.920]  - Number of values expected: 2
[09:28:18.920] Reducing values from 2 chunks ... DONE
[09:28:18.920] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[09:28:18.921] getGlobalsAndPackagesXApply() ...
[09:28:18.921]  - future.globals: TRUE
[09:28:18.921] getGlobalsAndPackages() ...
[09:28:18.921] Searching for globals...
[09:28:18.924] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[09:28:18.924] Searching for globals ... DONE
[09:28:18.925] Resolving globals: FALSE
[09:28:18.925] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[09:28:18.926] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[09:28:18.926] - globals: [1] ‘FUN’
[09:28:18.926] 
[09:28:18.926] getGlobalsAndPackages() ... DONE
[09:28:18.926]  - globals found/used: [n=1] ‘FUN’
[09:28:18.926]  - needed namespaces: [n=0] 
[09:28:18.926] Finding globals ... DONE
[09:28:18.926]  - use_args: TRUE
[09:28:18.926]  - Getting '...' globals ...
[09:28:18.927] resolve() on list ...
[09:28:18.927]  recursive: 0
[09:28:18.927]  length: 1
[09:28:18.927]  elements: ‘...’
[09:28:18.927]  length: 0 (resolved future 1)
[09:28:18.927] resolve() on list ... DONE
[09:28:18.927]    - '...' content: [n=0] 
[09:28:18.928] List of 1
[09:28:18.928]  $ ...: list()
[09:28:18.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.928]  - attr(*, "where")=List of 1
[09:28:18.928]   ..$ ...:<environment: 0x559ba1e820b8> 
[09:28:18.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.928]  - attr(*, "resolved")= logi TRUE
[09:28:18.928]  - attr(*, "total_size")= num NA
[09:28:18.930]  - Getting '...' globals ... DONE
[09:28:18.930] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:18.931] List of 2
[09:28:18.931]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:18.931]  $ ...          : list()
[09:28:18.931]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.931]  - attr(*, "where")=List of 2
[09:28:18.931]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:18.931]   ..$ ...          :<environment: 0x559ba1e820b8> 
[09:28:18.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.931]  - attr(*, "resolved")= logi FALSE
[09:28:18.931]  - attr(*, "total_size")= num 36296
[09:28:18.933] Packages to be attached in all futures: [n=0] 
[09:28:18.933] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.939] future_lapply() ...
[09:28:18.941] Generating random seeds ...
[09:28:18.941] Generating random seed streams for 2 elements ...
[09:28:18.941] Generating random seed streams for 2 elements ... DONE
[09:28:18.941] Generating random seeds ... DONE
[09:28:18.941] Will set RNG state on exit: 10407, 790875009, 882313998, 749497079, 888419002, -350087459, -932324082
[09:28:18.945] Number of chunks: 2
[09:28:18.945] getGlobalsAndPackagesXApply() ...
[09:28:18.945]  - future.globals: <name-value list> with names ‘list()’
[09:28:18.945]  - use_args: TRUE
[09:28:18.945] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:18.945] List of 2
[09:28:18.945]  $ ...          : list()
[09:28:18.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.945]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:18.945]  - attr(*, "where")=List of 2
[09:28:18.945]   ..$ ...          :<environment: 0x559ba1e820b8> 
[09:28:18.945]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:18.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.945]  - attr(*, "resolved")= logi FALSE
[09:28:18.945]  - attr(*, "total_size")= num NA
[09:28:18.949] Packages to be attached in all futures: [n=0] 
[09:28:18.949] getGlobalsAndPackagesXApply() ... DONE
[09:28:18.949] Number of futures (= number of chunks): 2
[09:28:18.949] Launching 2 futures (chunks) ...
[09:28:18.949] Chunk #1 of 2 ...
[09:28:18.949]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.949]  - seeds: [1] <seeds>
[09:28:18.950]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.950] getGlobalsAndPackages() ...
[09:28:18.950] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.950] Resolving globals: FALSE
[09:28:18.950] Tweak future expression to call with '...' arguments ...
[09:28:18.950] {
[09:28:18.950]     do.call(function(...) {
[09:28:18.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.950]             on.exit(options(oopts), add = TRUE)
[09:28:18.950]         }
[09:28:18.950]         {
[09:28:18.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.950]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:18.950]                   envir = globalenv(), inherits = FALSE)
[09:28:18.950]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.950]             })
[09:28:18.950]         }
[09:28:18.950]     }, args = future.call.arguments)
[09:28:18.950] }
[09:28:18.950] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.951] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.951] 
[09:28:18.951] getGlobalsAndPackages() ... DONE
[09:28:18.951] run() for ‘Future’ ...
[09:28:18.951] - state: ‘created’
[09:28:18.952] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.955] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.955]   - Field: ‘label’
[09:28:18.955]   - Field: ‘local’
[09:28:18.955]   - Field: ‘owner’
[09:28:18.955]   - Field: ‘envir’
[09:28:18.956]   - Field: ‘workers’
[09:28:18.956]   - Field: ‘packages’
[09:28:18.956]   - Field: ‘gc’
[09:28:18.956]   - Field: ‘job’
[09:28:18.956]   - Field: ‘conditions’
[09:28:18.956]   - Field: ‘expr’
[09:28:18.956]   - Field: ‘uuid’
[09:28:18.956]   - Field: ‘seed’
[09:28:18.956]   - Field: ‘version’
[09:28:18.956]   - Field: ‘result’
[09:28:18.956]   - Field: ‘asynchronous’
[09:28:18.957]   - Field: ‘calls’
[09:28:18.957]   - Field: ‘globals’
[09:28:18.957]   - Field: ‘stdout’
[09:28:18.957]   - Field: ‘earlySignal’
[09:28:18.957]   - Field: ‘lazy’
[09:28:18.957]   - Field: ‘state’
[09:28:18.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.957] - Launch lazy future ...
[09:28:18.957] Packages needed by the future expression (n = 0): <none>
[09:28:18.958] Packages needed by future strategies (n = 0): <none>
[09:28:18.958] {
[09:28:18.958]     {
[09:28:18.958]         {
[09:28:18.958]             ...future.startTime <- base::Sys.time()
[09:28:18.958]             {
[09:28:18.958]                 {
[09:28:18.958]                   {
[09:28:18.958]                     {
[09:28:18.958]                       base::local({
[09:28:18.958]                         has_future <- base::requireNamespace("future", 
[09:28:18.958]                           quietly = TRUE)
[09:28:18.958]                         if (has_future) {
[09:28:18.958]                           ns <- base::getNamespace("future")
[09:28:18.958]                           version <- ns[[".package"]][["version"]]
[09:28:18.958]                           if (is.null(version)) 
[09:28:18.958]                             version <- utils::packageVersion("future")
[09:28:18.958]                         }
[09:28:18.958]                         else {
[09:28:18.958]                           version <- NULL
[09:28:18.958]                         }
[09:28:18.958]                         if (!has_future || version < "1.8.0") {
[09:28:18.958]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.958]                             "", base::R.version$version.string), 
[09:28:18.958]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.958]                               "release", "version")], collapse = " "), 
[09:28:18.958]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.958]                             info)
[09:28:18.958]                           info <- base::paste(info, collapse = "; ")
[09:28:18.958]                           if (!has_future) {
[09:28:18.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.958]                               info)
[09:28:18.958]                           }
[09:28:18.958]                           else {
[09:28:18.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.958]                               info, version)
[09:28:18.958]                           }
[09:28:18.958]                           base::stop(msg)
[09:28:18.958]                         }
[09:28:18.958]                       })
[09:28:18.958]                     }
[09:28:18.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.958]                     base::options(mc.cores = 1L)
[09:28:18.958]                   }
[09:28:18.958]                   ...future.strategy.old <- future::plan("list")
[09:28:18.958]                   options(future.plan = NULL)
[09:28:18.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.958]                 }
[09:28:18.958]                 ...future.workdir <- getwd()
[09:28:18.958]             }
[09:28:18.958]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.958]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.958]         }
[09:28:18.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.958]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.958]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.958]             base::names(...future.oldOptions))
[09:28:18.958]     }
[09:28:18.958]     if (FALSE) {
[09:28:18.958]     }
[09:28:18.958]     else {
[09:28:18.958]         if (TRUE) {
[09:28:18.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.958]                 open = "w")
[09:28:18.958]         }
[09:28:18.958]         else {
[09:28:18.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.958]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.958]         }
[09:28:18.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.958]             base::sink(type = "output", split = FALSE)
[09:28:18.958]             base::close(...future.stdout)
[09:28:18.958]         }, add = TRUE)
[09:28:18.958]     }
[09:28:18.958]     ...future.frame <- base::sys.nframe()
[09:28:18.958]     ...future.conditions <- base::list()
[09:28:18.958]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.958]     if (FALSE) {
[09:28:18.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.958]     }
[09:28:18.958]     ...future.result <- base::tryCatch({
[09:28:18.958]         base::withCallingHandlers({
[09:28:18.958]             ...future.value <- base::withVisible(base::local({
[09:28:18.958]                 withCallingHandlers({
[09:28:18.958]                   {
[09:28:18.958]                     do.call(function(...) {
[09:28:18.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.958]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.958]                         ...future.globals.maxSize)) {
[09:28:18.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.958]                         on.exit(options(oopts), add = TRUE)
[09:28:18.958]                       }
[09:28:18.958]                       {
[09:28:18.958]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.958]                           FUN = function(jj) {
[09:28:18.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.958]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:18.958]                               envir = globalenv(), inherits = FALSE)
[09:28:18.958]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.958]                           })
[09:28:18.958]                       }
[09:28:18.958]                     }, args = future.call.arguments)
[09:28:18.958]                   }
[09:28:18.958]                 }, immediateCondition = function(cond) {
[09:28:18.958]                   save_rds <- function (object, pathname, ...) 
[09:28:18.958]                   {
[09:28:18.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.958]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.958]                         fi_tmp[["mtime"]])
[09:28:18.958]                     }
[09:28:18.958]                     tryCatch({
[09:28:18.958]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.958]                     }, error = function(ex) {
[09:28:18.958]                       msg <- conditionMessage(ex)
[09:28:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.958]                         fi_tmp[["mtime"]], msg)
[09:28:18.958]                       ex$message <- msg
[09:28:18.958]                       stop(ex)
[09:28:18.958]                     })
[09:28:18.958]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.958]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.958]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.958]                       fi <- file.info(pathname)
[09:28:18.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.958]                         fi[["size"]], fi[["mtime"]])
[09:28:18.958]                       stop(msg)
[09:28:18.958]                     }
[09:28:18.958]                     invisible(pathname)
[09:28:18.958]                   }
[09:28:18.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.958]                     rootPath = tempdir()) 
[09:28:18.958]                   {
[09:28:18.958]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.958]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.958]                       tmpdir = path, fileext = ".rds")
[09:28:18.958]                     save_rds(obj, file)
[09:28:18.958]                   }
[09:28:18.958]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.958]                   {
[09:28:18.958]                     inherits <- base::inherits
[09:28:18.958]                     invokeRestart <- base::invokeRestart
[09:28:18.958]                     is.null <- base::is.null
[09:28:18.958]                     muffled <- FALSE
[09:28:18.958]                     if (inherits(cond, "message")) {
[09:28:18.958]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.958]                       if (muffled) 
[09:28:18.958]                         invokeRestart("muffleMessage")
[09:28:18.958]                     }
[09:28:18.958]                     else if (inherits(cond, "warning")) {
[09:28:18.958]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.958]                       if (muffled) 
[09:28:18.958]                         invokeRestart("muffleWarning")
[09:28:18.958]                     }
[09:28:18.958]                     else if (inherits(cond, "condition")) {
[09:28:18.958]                       if (!is.null(pattern)) {
[09:28:18.958]                         computeRestarts <- base::computeRestarts
[09:28:18.958]                         grepl <- base::grepl
[09:28:18.958]                         restarts <- computeRestarts(cond)
[09:28:18.958]                         for (restart in restarts) {
[09:28:18.958]                           name <- restart$name
[09:28:18.958]                           if (is.null(name)) 
[09:28:18.958]                             next
[09:28:18.958]                           if (!grepl(pattern, name)) 
[09:28:18.958]                             next
[09:28:18.958]                           invokeRestart(restart)
[09:28:18.958]                           muffled <- TRUE
[09:28:18.958]                           break
[09:28:18.958]                         }
[09:28:18.958]                       }
[09:28:18.958]                     }
[09:28:18.958]                     invisible(muffled)
[09:28:18.958]                   }
[09:28:18.958]                   muffleCondition(cond)
[09:28:18.958]                 })
[09:28:18.958]             }))
[09:28:18.958]             future::FutureResult(value = ...future.value$value, 
[09:28:18.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.958]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.958]                     ...future.globalenv.names))
[09:28:18.958]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.958]         }, condition = base::local({
[09:28:18.958]             c <- base::c
[09:28:18.958]             inherits <- base::inherits
[09:28:18.958]             invokeRestart <- base::invokeRestart
[09:28:18.958]             length <- base::length
[09:28:18.958]             list <- base::list
[09:28:18.958]             seq.int <- base::seq.int
[09:28:18.958]             signalCondition <- base::signalCondition
[09:28:18.958]             sys.calls <- base::sys.calls
[09:28:18.958]             `[[` <- base::`[[`
[09:28:18.958]             `+` <- base::`+`
[09:28:18.958]             `<<-` <- base::`<<-`
[09:28:18.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.958]                   3L)]
[09:28:18.958]             }
[09:28:18.958]             function(cond) {
[09:28:18.958]                 is_error <- inherits(cond, "error")
[09:28:18.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.958]                   NULL)
[09:28:18.958]                 if (is_error) {
[09:28:18.958]                   sessionInformation <- function() {
[09:28:18.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.958]                       search = base::search(), system = base::Sys.info())
[09:28:18.958]                   }
[09:28:18.958]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.958]                     cond$call), session = sessionInformation(), 
[09:28:18.958]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.958]                   signalCondition(cond)
[09:28:18.958]                 }
[09:28:18.958]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[09:28:18.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.958]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.958]                   if (TRUE && !signal) {
[09:28:18.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.958]                     {
[09:28:18.958]                       inherits <- base::inherits
[09:28:18.958]                       invokeRestart <- base::invokeRestart
[09:28:18.958]                       is.null <- base::is.null
[09:28:18.958]                       muffled <- FALSE
[09:28:18.958]                       if (inherits(cond, "message")) {
[09:28:18.958]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.958]                         if (muffled) 
[09:28:18.958]                           invokeRestart("muffleMessage")
[09:28:18.958]                       }
[09:28:18.958]                       else if (inherits(cond, "warning")) {
[09:28:18.958]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.958]                         if (muffled) 
[09:28:18.958]                           invokeRestart("muffleWarning")
[09:28:18.958]                       }
[09:28:18.958]                       else if (inherits(cond, "condition")) {
[09:28:18.958]                         if (!is.null(pattern)) {
[09:28:18.958]                           computeRestarts <- base::computeRestarts
[09:28:18.958]                           grepl <- base::grepl
[09:28:18.958]                           restarts <- computeRestarts(cond)
[09:28:18.958]                           for (restart in restarts) {
[09:28:18.958]                             name <- restart$name
[09:28:18.958]                             if (is.null(name)) 
[09:28:18.958]                               next
[09:28:18.958]                             if (!grepl(pattern, name)) 
[09:28:18.958]                               next
[09:28:18.958]                             invokeRestart(restart)
[09:28:18.958]                             muffled <- TRUE
[09:28:18.958]                             break
[09:28:18.958]                           }
[09:28:18.958]                         }
[09:28:18.958]                       }
[09:28:18.958]                       invisible(muffled)
[09:28:18.958]                     }
[09:28:18.958]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.958]                   }
[09:28:18.958]                 }
[09:28:18.958]                 else {
[09:28:18.958]                   if (TRUE) {
[09:28:18.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.958]                     {
[09:28:18.958]                       inherits <- base::inherits
[09:28:18.958]                       invokeRestart <- base::invokeRestart
[09:28:18.958]                       is.null <- base::is.null
[09:28:18.958]                       muffled <- FALSE
[09:28:18.958]                       if (inherits(cond, "message")) {
[09:28:18.958]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.958]                         if (muffled) 
[09:28:18.958]                           invokeRestart("muffleMessage")
[09:28:18.958]                       }
[09:28:18.958]                       else if (inherits(cond, "warning")) {
[09:28:18.958]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.958]                         if (muffled) 
[09:28:18.958]                           invokeRestart("muffleWarning")
[09:28:18.958]                       }
[09:28:18.958]                       else if (inherits(cond, "condition")) {
[09:28:18.958]                         if (!is.null(pattern)) {
[09:28:18.958]                           computeRestarts <- base::computeRestarts
[09:28:18.958]                           grepl <- base::grepl
[09:28:18.958]                           restarts <- computeRestarts(cond)
[09:28:18.958]                           for (restart in restarts) {
[09:28:18.958]                             name <- restart$name
[09:28:18.958]                             if (is.null(name)) 
[09:28:18.958]                               next
[09:28:18.958]                             if (!grepl(pattern, name)) 
[09:28:18.958]                               next
[09:28:18.958]                             invokeRestart(restart)
[09:28:18.958]                             muffled <- TRUE
[09:28:18.958]                             break
[09:28:18.958]                           }
[09:28:18.958]                         }
[09:28:18.958]                       }
[09:28:18.958]                       invisible(muffled)
[09:28:18.958]                     }
[09:28:18.958]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.958]                   }
[09:28:18.958]                 }
[09:28:18.958]             }
[09:28:18.958]         }))
[09:28:18.958]     }, error = function(ex) {
[09:28:18.958]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.958]                 ...future.rng), started = ...future.startTime, 
[09:28:18.958]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.958]             version = "1.8"), class = "FutureResult")
[09:28:18.958]     }, finally = {
[09:28:18.958]         if (!identical(...future.workdir, getwd())) 
[09:28:18.958]             setwd(...future.workdir)
[09:28:18.958]         {
[09:28:18.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.958]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.958]             }
[09:28:18.958]             base::options(...future.oldOptions)
[09:28:18.958]             if (.Platform$OS.type == "windows") {
[09:28:18.958]                 old_names <- names(...future.oldEnvVars)
[09:28:18.958]                 envs <- base::Sys.getenv()
[09:28:18.958]                 names <- names(envs)
[09:28:18.958]                 common <- intersect(names, old_names)
[09:28:18.958]                 added <- setdiff(names, old_names)
[09:28:18.958]                 removed <- setdiff(old_names, names)
[09:28:18.958]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.958]                   envs[common]]
[09:28:18.958]                 NAMES <- toupper(changed)
[09:28:18.958]                 args <- list()
[09:28:18.958]                 for (kk in seq_along(NAMES)) {
[09:28:18.958]                   name <- changed[[kk]]
[09:28:18.958]                   NAME <- NAMES[[kk]]
[09:28:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.958]                     next
[09:28:18.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.958]                 }
[09:28:18.958]                 NAMES <- toupper(added)
[09:28:18.958]                 for (kk in seq_along(NAMES)) {
[09:28:18.958]                   name <- added[[kk]]
[09:28:18.958]                   NAME <- NAMES[[kk]]
[09:28:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.958]                     next
[09:28:18.958]                   args[[name]] <- ""
[09:28:18.958]                 }
[09:28:18.958]                 NAMES <- toupper(removed)
[09:28:18.958]                 for (kk in seq_along(NAMES)) {
[09:28:18.958]                   name <- removed[[kk]]
[09:28:18.958]                   NAME <- NAMES[[kk]]
[09:28:18.958]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.958]                     next
[09:28:18.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.958]                 }
[09:28:18.958]                 if (length(args) > 0) 
[09:28:18.958]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.958]             }
[09:28:18.958]             else {
[09:28:18.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.958]             }
[09:28:18.958]             {
[09:28:18.958]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.958]                   0L) {
[09:28:18.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.958]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.958]                   base::options(opts)
[09:28:18.958]                 }
[09:28:18.958]                 {
[09:28:18.958]                   {
[09:28:18.958]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.958]                     NULL
[09:28:18.958]                   }
[09:28:18.958]                   options(future.plan = NULL)
[09:28:18.958]                   if (is.na(NA_character_)) 
[09:28:18.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.958]                     .init = FALSE)
[09:28:18.958]                 }
[09:28:18.958]             }
[09:28:18.958]         }
[09:28:18.958]     })
[09:28:18.958]     if (TRUE) {
[09:28:18.958]         base::sink(type = "output", split = FALSE)
[09:28:18.958]         if (TRUE) {
[09:28:18.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.958]         }
[09:28:18.958]         else {
[09:28:18.958]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.958]         }
[09:28:18.958]         base::close(...future.stdout)
[09:28:18.958]         ...future.stdout <- NULL
[09:28:18.958]     }
[09:28:18.958]     ...future.result$conditions <- ...future.conditions
[09:28:18.958]     ...future.result$finished <- base::Sys.time()
[09:28:18.958]     ...future.result
[09:28:18.958] }
[09:28:18.960] assign_globals() ...
[09:28:18.961] List of 5
[09:28:18.961]  $ future.call.arguments    : list()
[09:28:18.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.961]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[09:28:18.961]  $ ...future.elements_ii    :List of 1
[09:28:18.961]   ..$ : int [1:2] 1 3
[09:28:18.961]  $ ...future.seeds_ii       :List of 1
[09:28:18.961]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[09:28:18.961]  $ ...future.globals.maxSize: num Inf
[09:28:18.961]  - attr(*, "resolved")= logi FALSE
[09:28:18.961]  - attr(*, "total_size")= num NA
[09:28:18.961]  - attr(*, "where")=List of 5
[09:28:18.961]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.961]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.961]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.961]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.961]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.961]  - attr(*, "already-done")= logi TRUE
[09:28:18.967] - copied ‘future.call.arguments’ to environment
[09:28:18.967] - copied ‘...future.FUN’ to environment
[09:28:18.967] - copied ‘...future.elements_ii’ to environment
[09:28:18.967] - copied ‘...future.seeds_ii’ to environment
[09:28:18.968] - copied ‘...future.globals.maxSize’ to environment
[09:28:18.968] assign_globals() ... done
[09:28:18.968] requestCore(): workers = 2
[09:28:18.970] MulticoreFuture started
[09:28:18.970] - Launch lazy future ... done
[09:28:18.971] run() for ‘MulticoreFuture’ ... done
[09:28:18.971] Created future:
[09:28:18.971] plan(): Setting new future strategy stack:
[09:28:18.971] List of future strategies:
[09:28:18.971] 1. sequential:
[09:28:18.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:18.971]    - tweaked: FALSE
[09:28:18.971]    - call: NULL
[09:28:18.972] plan(): nbrOfWorkers() = 1
[09:28:18.975] plan(): Setting new future strategy stack:
[09:28:18.975] List of future strategies:
[09:28:18.975] 1. multicore:
[09:28:18.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:18.975]    - tweaked: FALSE
[09:28:18.975]    - call: plan(strategy)
[09:28:18.980] plan(): nbrOfWorkers() = 2
[09:28:18.971] MulticoreFuture:
[09:28:18.971] Label: ‘future_apply-1’
[09:28:18.971] Expression:
[09:28:18.971] {
[09:28:18.971]     do.call(function(...) {
[09:28:18.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.971]             on.exit(options(oopts), add = TRUE)
[09:28:18.971]         }
[09:28:18.971]         {
[09:28:18.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.971]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:18.971]                   envir = globalenv(), inherits = FALSE)
[09:28:18.971]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.971]             })
[09:28:18.971]         }
[09:28:18.971]     }, args = future.call.arguments)
[09:28:18.971] }
[09:28:18.971] Lazy evaluation: FALSE
[09:28:18.971] Asynchronous evaluation: TRUE
[09:28:18.971] Local evaluation: TRUE
[09:28:18.971] Environment: R_GlobalEnv
[09:28:18.971] Capture standard output: TRUE
[09:28:18.971] Capture condition classes: <none>
[09:28:18.971] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:18.971] Packages: <none>
[09:28:18.971] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:28:18.971] Resolved: TRUE
[09:28:18.971] Value: <not collected>
[09:28:18.971] Conditions captured: <none>
[09:28:18.971] Early signaling: FALSE
[09:28:18.971] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:18.971] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.981] Chunk #1 of 2 ... DONE
[09:28:18.981] Chunk #2 of 2 ...
[09:28:18.982]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:18.982]  - seeds: [1] <seeds>
[09:28:18.982]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.982] getGlobalsAndPackages() ...
[09:28:18.982] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.983] Resolving globals: FALSE
[09:28:18.983] Tweak future expression to call with '...' arguments ...
[09:28:18.983] {
[09:28:18.983]     do.call(function(...) {
[09:28:18.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:18.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.983]             on.exit(options(oopts), add = TRUE)
[09:28:18.983]         }
[09:28:18.983]         {
[09:28:18.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:18.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.983]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:18.983]                   envir = globalenv(), inherits = FALSE)
[09:28:18.983]                 ...future.FUN(...future.X_jj, ...)
[09:28:18.983]             })
[09:28:18.983]         }
[09:28:18.983]     }, args = future.call.arguments)
[09:28:18.983] }
[09:28:18.983] Tweak future expression to call with '...' arguments ... DONE
[09:28:18.984] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:18.984] 
[09:28:18.984] getGlobalsAndPackages() ... DONE
[09:28:18.985] run() for ‘Future’ ...
[09:28:18.985] - state: ‘created’
[09:28:18.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:18.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:18.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:18.990]   - Field: ‘label’
[09:28:18.990]   - Field: ‘local’
[09:28:18.990]   - Field: ‘owner’
[09:28:18.991]   - Field: ‘envir’
[09:28:18.991]   - Field: ‘workers’
[09:28:18.991]   - Field: ‘packages’
[09:28:18.991]   - Field: ‘gc’
[09:28:18.991]   - Field: ‘job’
[09:28:18.991]   - Field: ‘conditions’
[09:28:18.991]   - Field: ‘expr’
[09:28:18.992]   - Field: ‘uuid’
[09:28:18.992]   - Field: ‘seed’
[09:28:18.992]   - Field: ‘version’
[09:28:18.992]   - Field: ‘result’
[09:28:18.992]   - Field: ‘asynchronous’
[09:28:18.992]   - Field: ‘calls’
[09:28:18.992]   - Field: ‘globals’
[09:28:18.993]   - Field: ‘stdout’
[09:28:18.993]   - Field: ‘earlySignal’
[09:28:18.993]   - Field: ‘lazy’
[09:28:18.993]   - Field: ‘state’
[09:28:18.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:18.993] - Launch lazy future ...
[09:28:18.994] Packages needed by the future expression (n = 0): <none>
[09:28:18.994] Packages needed by future strategies (n = 0): <none>
[09:28:18.995] {
[09:28:18.995]     {
[09:28:18.995]         {
[09:28:18.995]             ...future.startTime <- base::Sys.time()
[09:28:18.995]             {
[09:28:18.995]                 {
[09:28:18.995]                   {
[09:28:18.995]                     {
[09:28:18.995]                       base::local({
[09:28:18.995]                         has_future <- base::requireNamespace("future", 
[09:28:18.995]                           quietly = TRUE)
[09:28:18.995]                         if (has_future) {
[09:28:18.995]                           ns <- base::getNamespace("future")
[09:28:18.995]                           version <- ns[[".package"]][["version"]]
[09:28:18.995]                           if (is.null(version)) 
[09:28:18.995]                             version <- utils::packageVersion("future")
[09:28:18.995]                         }
[09:28:18.995]                         else {
[09:28:18.995]                           version <- NULL
[09:28:18.995]                         }
[09:28:18.995]                         if (!has_future || version < "1.8.0") {
[09:28:18.995]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:18.995]                             "", base::R.version$version.string), 
[09:28:18.995]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:18.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:18.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:18.995]                               "release", "version")], collapse = " "), 
[09:28:18.995]                             hostname = base::Sys.info()[["nodename"]])
[09:28:18.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:18.995]                             info)
[09:28:18.995]                           info <- base::paste(info, collapse = "; ")
[09:28:18.995]                           if (!has_future) {
[09:28:18.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:18.995]                               info)
[09:28:18.995]                           }
[09:28:18.995]                           else {
[09:28:18.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:18.995]                               info, version)
[09:28:18.995]                           }
[09:28:18.995]                           base::stop(msg)
[09:28:18.995]                         }
[09:28:18.995]                       })
[09:28:18.995]                     }
[09:28:18.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:18.995]                     base::options(mc.cores = 1L)
[09:28:18.995]                   }
[09:28:18.995]                   ...future.strategy.old <- future::plan("list")
[09:28:18.995]                   options(future.plan = NULL)
[09:28:18.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:18.995]                 }
[09:28:18.995]                 ...future.workdir <- getwd()
[09:28:18.995]             }
[09:28:18.995]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:18.995]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:18.995]         }
[09:28:18.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:18.995]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:18.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:18.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:18.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:18.995]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:18.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:18.995]             base::names(...future.oldOptions))
[09:28:18.995]     }
[09:28:18.995]     if (FALSE) {
[09:28:18.995]     }
[09:28:18.995]     else {
[09:28:18.995]         if (TRUE) {
[09:28:18.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:18.995]                 open = "w")
[09:28:18.995]         }
[09:28:18.995]         else {
[09:28:18.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:18.995]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:18.995]         }
[09:28:18.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:18.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:18.995]             base::sink(type = "output", split = FALSE)
[09:28:18.995]             base::close(...future.stdout)
[09:28:18.995]         }, add = TRUE)
[09:28:18.995]     }
[09:28:18.995]     ...future.frame <- base::sys.nframe()
[09:28:18.995]     ...future.conditions <- base::list()
[09:28:18.995]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:18.995]     if (FALSE) {
[09:28:18.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:18.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:18.995]     }
[09:28:18.995]     ...future.result <- base::tryCatch({
[09:28:18.995]         base::withCallingHandlers({
[09:28:18.995]             ...future.value <- base::withVisible(base::local({
[09:28:18.995]                 withCallingHandlers({
[09:28:18.995]                   {
[09:28:18.995]                     do.call(function(...) {
[09:28:18.995]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:18.995]                       if (!identical(...future.globals.maxSize.org, 
[09:28:18.995]                         ...future.globals.maxSize)) {
[09:28:18.995]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:18.995]                         on.exit(options(oopts), add = TRUE)
[09:28:18.995]                       }
[09:28:18.995]                       {
[09:28:18.995]                         lapply(seq_along(...future.elements_ii), 
[09:28:18.995]                           FUN = function(jj) {
[09:28:18.995]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:18.995]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:18.995]                               envir = globalenv(), inherits = FALSE)
[09:28:18.995]                             ...future.FUN(...future.X_jj, ...)
[09:28:18.995]                           })
[09:28:18.995]                       }
[09:28:18.995]                     }, args = future.call.arguments)
[09:28:18.995]                   }
[09:28:18.995]                 }, immediateCondition = function(cond) {
[09:28:18.995]                   save_rds <- function (object, pathname, ...) 
[09:28:18.995]                   {
[09:28:18.995]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:18.995]                     if (file_test("-f", pathname_tmp)) {
[09:28:18.995]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.995]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:18.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.995]                         fi_tmp[["mtime"]])
[09:28:18.995]                     }
[09:28:18.995]                     tryCatch({
[09:28:18.995]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:18.995]                     }, error = function(ex) {
[09:28:18.995]                       msg <- conditionMessage(ex)
[09:28:18.995]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.995]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:18.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.995]                         fi_tmp[["mtime"]], msg)
[09:28:18.995]                       ex$message <- msg
[09:28:18.995]                       stop(ex)
[09:28:18.995]                     })
[09:28:18.995]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:18.995]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:18.995]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:18.995]                       fi_tmp <- file.info(pathname_tmp)
[09:28:18.995]                       fi <- file.info(pathname)
[09:28:18.995]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:18.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:18.995]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:18.995]                         fi[["size"]], fi[["mtime"]])
[09:28:18.995]                       stop(msg)
[09:28:18.995]                     }
[09:28:18.995]                     invisible(pathname)
[09:28:18.995]                   }
[09:28:18.995]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:18.995]                     rootPath = tempdir()) 
[09:28:18.995]                   {
[09:28:18.995]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:18.995]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:18.995]                       tmpdir = path, fileext = ".rds")
[09:28:18.995]                     save_rds(obj, file)
[09:28:18.995]                   }
[09:28:18.995]                   saveImmediateCondition(cond, path = "/tmp/RtmpNHCcDg/.future/immediateConditions")
[09:28:18.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.995]                   {
[09:28:18.995]                     inherits <- base::inherits
[09:28:18.995]                     invokeRestart <- base::invokeRestart
[09:28:18.995]                     is.null <- base::is.null
[09:28:18.995]                     muffled <- FALSE
[09:28:18.995]                     if (inherits(cond, "message")) {
[09:28:18.995]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:18.995]                       if (muffled) 
[09:28:18.995]                         invokeRestart("muffleMessage")
[09:28:18.995]                     }
[09:28:18.995]                     else if (inherits(cond, "warning")) {
[09:28:18.995]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:18.995]                       if (muffled) 
[09:28:18.995]                         invokeRestart("muffleWarning")
[09:28:18.995]                     }
[09:28:18.995]                     else if (inherits(cond, "condition")) {
[09:28:18.995]                       if (!is.null(pattern)) {
[09:28:18.995]                         computeRestarts <- base::computeRestarts
[09:28:18.995]                         grepl <- base::grepl
[09:28:18.995]                         restarts <- computeRestarts(cond)
[09:28:18.995]                         for (restart in restarts) {
[09:28:18.995]                           name <- restart$name
[09:28:18.995]                           if (is.null(name)) 
[09:28:18.995]                             next
[09:28:18.995]                           if (!grepl(pattern, name)) 
[09:28:18.995]                             next
[09:28:18.995]                           invokeRestart(restart)
[09:28:18.995]                           muffled <- TRUE
[09:28:18.995]                           break
[09:28:18.995]                         }
[09:28:18.995]                       }
[09:28:18.995]                     }
[09:28:18.995]                     invisible(muffled)
[09:28:18.995]                   }
[09:28:18.995]                   muffleCondition(cond)
[09:28:18.995]                 })
[09:28:18.995]             }))
[09:28:18.995]             future::FutureResult(value = ...future.value$value, 
[09:28:18.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.995]                   ...future.rng), globalenv = if (FALSE) 
[09:28:18.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:18.995]                     ...future.globalenv.names))
[09:28:18.995]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:18.995]         }, condition = base::local({
[09:28:18.995]             c <- base::c
[09:28:18.995]             inherits <- base::inherits
[09:28:18.995]             invokeRestart <- base::invokeRestart
[09:28:18.995]             length <- base::length
[09:28:18.995]             list <- base::list
[09:28:18.995]             seq.int <- base::seq.int
[09:28:18.995]             signalCondition <- base::signalCondition
[09:28:18.995]             sys.calls <- base::sys.calls
[09:28:18.995]             `[[` <- base::`[[`
[09:28:18.995]             `+` <- base::`+`
[09:28:18.995]             `<<-` <- base::`<<-`
[09:28:18.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:18.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:18.995]                   3L)]
[09:28:18.995]             }
[09:28:18.995]             function(cond) {
[09:28:18.995]                 is_error <- inherits(cond, "error")
[09:28:18.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:18.995]                   NULL)
[09:28:18.995]                 if (is_error) {
[09:28:18.995]                   sessionInformation <- function() {
[09:28:18.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:18.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:18.995]                       search = base::search(), system = base::Sys.info())
[09:28:18.995]                   }
[09:28:18.995]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:18.995]                     cond$call), session = sessionInformation(), 
[09:28:18.995]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:18.995]                   signalCondition(cond)
[09:28:18.995]                 }
[09:28:18.995]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[09:28:18.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:18.995]                   ...future.conditions[[length(...future.conditions) + 
[09:28:18.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:18.995]                   if (TRUE && !signal) {
[09:28:18.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.995]                     {
[09:28:18.995]                       inherits <- base::inherits
[09:28:18.995]                       invokeRestart <- base::invokeRestart
[09:28:18.995]                       is.null <- base::is.null
[09:28:18.995]                       muffled <- FALSE
[09:28:18.995]                       if (inherits(cond, "message")) {
[09:28:18.995]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.995]                         if (muffled) 
[09:28:18.995]                           invokeRestart("muffleMessage")
[09:28:18.995]                       }
[09:28:18.995]                       else if (inherits(cond, "warning")) {
[09:28:18.995]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.995]                         if (muffled) 
[09:28:18.995]                           invokeRestart("muffleWarning")
[09:28:18.995]                       }
[09:28:18.995]                       else if (inherits(cond, "condition")) {
[09:28:18.995]                         if (!is.null(pattern)) {
[09:28:18.995]                           computeRestarts <- base::computeRestarts
[09:28:18.995]                           grepl <- base::grepl
[09:28:18.995]                           restarts <- computeRestarts(cond)
[09:28:18.995]                           for (restart in restarts) {
[09:28:18.995]                             name <- restart$name
[09:28:18.995]                             if (is.null(name)) 
[09:28:18.995]                               next
[09:28:18.995]                             if (!grepl(pattern, name)) 
[09:28:18.995]                               next
[09:28:18.995]                             invokeRestart(restart)
[09:28:18.995]                             muffled <- TRUE
[09:28:18.995]                             break
[09:28:18.995]                           }
[09:28:18.995]                         }
[09:28:18.995]                       }
[09:28:18.995]                       invisible(muffled)
[09:28:18.995]                     }
[09:28:18.995]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.995]                   }
[09:28:18.995]                 }
[09:28:18.995]                 else {
[09:28:18.995]                   if (TRUE) {
[09:28:18.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:18.995]                     {
[09:28:18.995]                       inherits <- base::inherits
[09:28:18.995]                       invokeRestart <- base::invokeRestart
[09:28:18.995]                       is.null <- base::is.null
[09:28:18.995]                       muffled <- FALSE
[09:28:18.995]                       if (inherits(cond, "message")) {
[09:28:18.995]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:18.995]                         if (muffled) 
[09:28:18.995]                           invokeRestart("muffleMessage")
[09:28:18.995]                       }
[09:28:18.995]                       else if (inherits(cond, "warning")) {
[09:28:18.995]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:18.995]                         if (muffled) 
[09:28:18.995]                           invokeRestart("muffleWarning")
[09:28:18.995]                       }
[09:28:18.995]                       else if (inherits(cond, "condition")) {
[09:28:18.995]                         if (!is.null(pattern)) {
[09:28:18.995]                           computeRestarts <- base::computeRestarts
[09:28:18.995]                           grepl <- base::grepl
[09:28:18.995]                           restarts <- computeRestarts(cond)
[09:28:18.995]                           for (restart in restarts) {
[09:28:18.995]                             name <- restart$name
[09:28:18.995]                             if (is.null(name)) 
[09:28:18.995]                               next
[09:28:18.995]                             if (!grepl(pattern, name)) 
[09:28:18.995]                               next
[09:28:18.995]                             invokeRestart(restart)
[09:28:18.995]                             muffled <- TRUE
[09:28:18.995]                             break
[09:28:18.995]                           }
[09:28:18.995]                         }
[09:28:18.995]                       }
[09:28:18.995]                       invisible(muffled)
[09:28:18.995]                     }
[09:28:18.995]                     muffleCondition(cond, pattern = "^muffle")
[09:28:18.995]                   }
[09:28:18.995]                 }
[09:28:18.995]             }
[09:28:18.995]         }))
[09:28:18.995]     }, error = function(ex) {
[09:28:18.995]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:18.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:18.995]                 ...future.rng), started = ...future.startTime, 
[09:28:18.995]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:18.995]             version = "1.8"), class = "FutureResult")
[09:28:18.995]     }, finally = {
[09:28:18.995]         if (!identical(...future.workdir, getwd())) 
[09:28:18.995]             setwd(...future.workdir)
[09:28:18.995]         {
[09:28:18.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:18.995]                 ...future.oldOptions$nwarnings <- NULL
[09:28:18.995]             }
[09:28:18.995]             base::options(...future.oldOptions)
[09:28:18.995]             if (.Platform$OS.type == "windows") {
[09:28:18.995]                 old_names <- names(...future.oldEnvVars)
[09:28:18.995]                 envs <- base::Sys.getenv()
[09:28:18.995]                 names <- names(envs)
[09:28:18.995]                 common <- intersect(names, old_names)
[09:28:18.995]                 added <- setdiff(names, old_names)
[09:28:18.995]                 removed <- setdiff(old_names, names)
[09:28:18.995]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:18.995]                   envs[common]]
[09:28:18.995]                 NAMES <- toupper(changed)
[09:28:18.995]                 args <- list()
[09:28:18.995]                 for (kk in seq_along(NAMES)) {
[09:28:18.995]                   name <- changed[[kk]]
[09:28:18.995]                   NAME <- NAMES[[kk]]
[09:28:18.995]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.995]                     next
[09:28:18.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.995]                 }
[09:28:18.995]                 NAMES <- toupper(added)
[09:28:18.995]                 for (kk in seq_along(NAMES)) {
[09:28:18.995]                   name <- added[[kk]]
[09:28:18.995]                   NAME <- NAMES[[kk]]
[09:28:18.995]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.995]                     next
[09:28:18.995]                   args[[name]] <- ""
[09:28:18.995]                 }
[09:28:18.995]                 NAMES <- toupper(removed)
[09:28:18.995]                 for (kk in seq_along(NAMES)) {
[09:28:18.995]                   name <- removed[[kk]]
[09:28:18.995]                   NAME <- NAMES[[kk]]
[09:28:18.995]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:18.995]                     next
[09:28:18.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:18.995]                 }
[09:28:18.995]                 if (length(args) > 0) 
[09:28:18.995]                   base::do.call(base::Sys.setenv, args = args)
[09:28:18.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:18.995]             }
[09:28:18.995]             else {
[09:28:18.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:18.995]             }
[09:28:18.995]             {
[09:28:18.995]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:18.995]                   0L) {
[09:28:18.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:18.995]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:18.995]                   base::options(opts)
[09:28:18.995]                 }
[09:28:18.995]                 {
[09:28:18.995]                   {
[09:28:18.995]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:18.995]                     NULL
[09:28:18.995]                   }
[09:28:18.995]                   options(future.plan = NULL)
[09:28:18.995]                   if (is.na(NA_character_)) 
[09:28:18.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:18.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:18.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:18.995]                     .init = FALSE)
[09:28:18.995]                 }
[09:28:18.995]             }
[09:28:18.995]         }
[09:28:18.995]     })
[09:28:18.995]     if (TRUE) {
[09:28:18.995]         base::sink(type = "output", split = FALSE)
[09:28:18.995]         if (TRUE) {
[09:28:18.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:18.995]         }
[09:28:18.995]         else {
[09:28:18.995]             ...future.result["stdout"] <- base::list(NULL)
[09:28:18.995]         }
[09:28:18.995]         base::close(...future.stdout)
[09:28:18.995]         ...future.stdout <- NULL
[09:28:18.995]     }
[09:28:18.995]     ...future.result$conditions <- ...future.conditions
[09:28:18.995]     ...future.result$finished <- base::Sys.time()
[09:28:18.995]     ...future.result
[09:28:18.995] }
[09:28:18.998] assign_globals() ...
[09:28:18.998] List of 5
[09:28:18.998]  $ future.call.arguments    : list()
[09:28:18.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:18.998]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[09:28:18.998]  $ ...future.elements_ii    :List of 1
[09:28:18.998]   ..$ : int [1:2] 2 4
[09:28:18.998]  $ ...future.seeds_ii       :List of 1
[09:28:18.998]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[09:28:18.998]  $ ...future.globals.maxSize: num Inf
[09:28:18.998]  - attr(*, "resolved")= logi FALSE
[09:28:18.998]  - attr(*, "total_size")= num NA
[09:28:18.998]  - attr(*, "where")=List of 5
[09:28:18.998]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:18.998]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:18.998]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:18.998]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:18.998]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:18.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:18.998]  - attr(*, "already-done")= logi TRUE
[09:28:19.006] - copied ‘future.call.arguments’ to environment
[09:28:19.006] - copied ‘...future.FUN’ to environment
[09:28:19.006] - copied ‘...future.elements_ii’ to environment
[09:28:19.007] - copied ‘...future.seeds_ii’ to environment
[09:28:19.007] - copied ‘...future.globals.maxSize’ to environment
[09:28:19.007] assign_globals() ... done
[09:28:19.007] requestCore(): workers = 2
[09:28:19.009] MulticoreFuture started
[09:28:19.009] - Launch lazy future ... done
[09:28:19.010] run() for ‘MulticoreFuture’ ... done
[09:28:19.010] Created future:
[09:28:19.010] plan(): Setting new future strategy stack:
[09:28:19.010] List of future strategies:
[09:28:19.010] 1. sequential:
[09:28:19.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:19.010]    - tweaked: FALSE
[09:28:19.010]    - call: NULL
[09:28:19.011] plan(): nbrOfWorkers() = 1
[09:28:19.013] plan(): Setting new future strategy stack:
[09:28:19.014] List of future strategies:
[09:28:19.014] 1. multicore:
[09:28:19.014]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:19.014]    - tweaked: FALSE
[09:28:19.014]    - call: plan(strategy)
[09:28:19.010] MulticoreFuture:
[09:28:19.010] Label: ‘future_apply-2’
[09:28:19.010] Expression:
[09:28:19.010] {
[09:28:19.010]     do.call(function(...) {
[09:28:19.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:19.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.010]             on.exit(options(oopts), add = TRUE)
[09:28:19.010]         }
[09:28:19.010]         {
[09:28:19.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:19.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.010]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:19.010]                   envir = globalenv(), inherits = FALSE)
[09:28:19.010]                 ...future.FUN(...future.X_jj, ...)
[09:28:19.010]             })
[09:28:19.010]         }
[09:28:19.010]     }, args = future.call.arguments)
[09:28:19.010] }
[09:28:19.010] Lazy evaluation: FALSE
[09:28:19.010] Asynchronous evaluation: TRUE
[09:28:19.010] Local evaluation: TRUE
[09:28:19.010] Environment: R_GlobalEnv
[09:28:19.010] Capture standard output: TRUE
[09:28:19.010] Capture condition classes: <none>
[09:28:19.010] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:19.010] Packages: <none>
[09:28:19.010] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:28:19.010] Resolved: FALSE
[09:28:19.010] Value: <not collected>
[09:28:19.010] Conditions captured: <none>
[09:28:19.010] Early signaling: FALSE
[09:28:19.010] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:19.010] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:19.023] Chunk #2 of 2 ... DONE
[09:28:19.023] Launching 2 futures (chunks) ... DONE
[09:28:19.023] Resolving 2 futures (chunks) ...
[09:28:19.024] resolve() on list ...
[09:28:19.024]  recursive: 0
[09:28:19.024] plan(): nbrOfWorkers() = 2
[09:28:19.024]  length: 2
[09:28:19.024] 
[09:28:19.025] Future #1
[09:28:19.025] result() for MulticoreFuture ...
[09:28:19.029] result() for MulticoreFuture ...
[09:28:19.029] result() for MulticoreFuture ... done
[09:28:19.029] result() for MulticoreFuture ... done
[09:28:19.030] result() for MulticoreFuture ...
[09:28:19.030] result() for MulticoreFuture ... done
[09:28:19.030] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:19.031] - nx: 2
[09:28:19.031] - relay: TRUE
[09:28:19.031] - stdout: TRUE
[09:28:19.031] - signal: TRUE
[09:28:19.032] - resignal: FALSE
[09:28:19.032] - force: TRUE
[09:28:19.032] - relayed: [n=2] FALSE, FALSE
[09:28:19.032] - queued futures: [n=2] FALSE, FALSE
[09:28:19.033]  - until=1
[09:28:19.033]  - relaying element #1
[09:28:19.033] result() for MulticoreFuture ...
[09:28:19.034] result() for MulticoreFuture ... done
[09:28:19.034] result() for MulticoreFuture ...
[09:28:19.034] result() for MulticoreFuture ... done
[09:28:19.034] result() for MulticoreFuture ...
[09:28:19.035] result() for MulticoreFuture ... done
[09:28:19.035] result() for MulticoreFuture ...
[09:28:19.035] result() for MulticoreFuture ... done
[09:28:19.035] - relayed: [n=2] TRUE, FALSE
[09:28:19.035] - queued futures: [n=2] TRUE, FALSE
[09:28:19.036] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:19.036]  length: 1 (resolved future 1)
[09:28:19.036] Future #2
[09:28:19.036] result() for MulticoreFuture ...
[09:28:19.037] result() for MulticoreFuture ...
[09:28:19.037] result() for MulticoreFuture ... done
[09:28:19.037] result() for MulticoreFuture ... done
[09:28:19.038] result() for MulticoreFuture ...
[09:28:19.038] result() for MulticoreFuture ... done
[09:28:19.038] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:19.038] - nx: 2
[09:28:19.039] - relay: TRUE
[09:28:19.039] - stdout: TRUE
[09:28:19.039] - signal: TRUE
[09:28:19.039] - resignal: FALSE
[09:28:19.039] - force: TRUE
[09:28:19.039] - relayed: [n=2] TRUE, FALSE
[09:28:19.039] - queued futures: [n=2] TRUE, FALSE
[09:28:19.040]  - until=2
[09:28:19.040]  - relaying element #2
[09:28:19.040] result() for MulticoreFuture ...
[09:28:19.040] result() for MulticoreFuture ... done
[09:28:19.040] result() for MulticoreFuture ...
[09:28:19.040] result() for MulticoreFuture ... done
[09:28:19.041] result() for MulticoreFuture ...
[09:28:19.041] result() for MulticoreFuture ... done
[09:28:19.041] result() for MulticoreFuture ...
[09:28:19.041] result() for MulticoreFuture ... done
[09:28:19.041] - relayed: [n=2] TRUE, TRUE
[09:28:19.041] - queued futures: [n=2] TRUE, TRUE
[09:28:19.041] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:19.041]  length: 0 (resolved future 2)
[09:28:19.041] Relaying remaining futures
[09:28:19.041] signalConditionsASAP(NULL, pos=0) ...
[09:28:19.042] - nx: 2
[09:28:19.042] - relay: TRUE
[09:28:19.042] - stdout: TRUE
[09:28:19.042] - signal: TRUE
[09:28:19.042] - resignal: FALSE
[09:28:19.042] - force: TRUE
[09:28:19.042] - relayed: [n=2] TRUE, TRUE
[09:28:19.042] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:19.042] - relayed: [n=2] TRUE, TRUE
[09:28:19.042] - queued futures: [n=2] TRUE, TRUE
[09:28:19.043] signalConditionsASAP(NULL, pos=0) ... done
[09:28:19.043] resolve() on list ... DONE
[09:28:19.043] result() for MulticoreFuture ...
[09:28:19.043] result() for MulticoreFuture ... done
[09:28:19.043] result() for MulticoreFuture ...
[09:28:19.043] result() for MulticoreFuture ... done
[09:28:19.043] result() for MulticoreFuture ...
[09:28:19.043] result() for MulticoreFuture ... done
[09:28:19.043] result() for MulticoreFuture ...
[09:28:19.043] result() for MulticoreFuture ... done
[09:28:19.044]  - Number of value chunks collected: 2
[09:28:19.044] Resolving 2 futures (chunks) ... DONE
[09:28:19.044] Reducing values from 2 chunks ...
[09:28:19.044]  - Number of values collected after concatenation: 2
[09:28:19.044]  - Number of values expected: 2
[09:28:19.044] Reducing values from 2 chunks ... DONE
[09:28:19.044] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[09:28:19.045] plan(): Setting new future strategy stack:
[09:28:19.045] List of future strategies:
[09:28:19.045] 1. sequential:
[09:28:19.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:19.045]    - tweaked: FALSE
[09:28:19.045]    - call: plan(sequential)
[09:28:19.045] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[09:28:19.046] plan(): Setting new future strategy stack:
[09:28:19.046] List of future strategies:
[09:28:19.046] 1. multisession:
[09:28:19.046]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:19.046]    - tweaked: FALSE
[09:28:19.046]    - call: plan(strategy)
[09:28:19.046] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:28:19.046] multisession:
[09:28:19.046] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:19.046] - tweaked: FALSE
[09:28:19.046] - call: plan(strategy)
[09:28:19.052] getGlobalsAndPackages() ...
[09:28:19.053] Not searching for globals
[09:28:19.053] - globals: [0] <none>
[09:28:19.053] getGlobalsAndPackages() ... DONE
[09:28:19.053] [local output] makeClusterPSOCK() ...
[09:28:19.098] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:28:19.099] [local output] Base port: 11858
[09:28:19.099] [local output] Getting setup options for 2 cluster nodes ...
[09:28:19.099] [local output]  - Node 1 of 2 ...
[09:28:19.100] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:19.101] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNHCcDg/worker.rank=1.parallelly.parent=28368.6ed02df244ab.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpNHCcDg/worker.rank=1.parallelly.parent=28368.6ed02df244ab.pid")'’
[09:28:19.287] - Possible to infer worker's PID: TRUE
[09:28:19.287] [local output] Rscript port: 11858

[09:28:19.288] [local output]  - Node 2 of 2 ...
[09:28:19.288] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:19.289] [local output] Rscript port: 11858

[09:28:19.289] [local output] Getting setup options for 2 cluster nodes ... done
[09:28:19.289] [local output]  - Parallel setup requested for some PSOCK nodes
[09:28:19.290] [local output] Setting up PSOCK nodes in parallel
[09:28:19.290] List of 36
[09:28:19.290]  $ worker          : chr "localhost"
[09:28:19.290]   ..- attr(*, "localhost")= logi TRUE
[09:28:19.290]  $ master          : chr "localhost"
[09:28:19.290]  $ port            : int 11858
[09:28:19.290]  $ connectTimeout  : num 120
[09:28:19.290]  $ timeout         : num 2592000
[09:28:19.290]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:28:19.290]  $ homogeneous     : logi TRUE
[09:28:19.290]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:28:19.290]  $ rscript_envs    : NULL
[09:28:19.290]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:19.290]  $ rscript_startup : NULL
[09:28:19.290]  $ rscript_sh      : chr "sh"
[09:28:19.290]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:19.290]  $ methods         : logi TRUE
[09:28:19.290]  $ socketOptions   : chr "no-delay"
[09:28:19.290]  $ useXDR          : logi FALSE
[09:28:19.290]  $ outfile         : chr "/dev/null"
[09:28:19.290]  $ renice          : int NA
[09:28:19.290]  $ rshcmd          : NULL
[09:28:19.290]  $ user            : chr(0) 
[09:28:19.290]  $ revtunnel       : logi FALSE
[09:28:19.290]  $ rshlogfile      : NULL
[09:28:19.290]  $ rshopts         : chr(0) 
[09:28:19.290]  $ rank            : int 1
[09:28:19.290]  $ manual          : logi FALSE
[09:28:19.290]  $ dryrun          : logi FALSE
[09:28:19.290]  $ quiet           : logi FALSE
[09:28:19.290]  $ setup_strategy  : chr "parallel"
[09:28:19.290]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:19.290]  $ pidfile         : chr "/tmp/RtmpNHCcDg/worker.rank=1.parallelly.parent=28368.6ed02df244ab.pid"
[09:28:19.290]  $ rshcmd_label    : NULL
[09:28:19.290]  $ rsh_call        : NULL
[09:28:19.290]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:19.290]  $ localMachine    : logi TRUE
[09:28:19.290]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:28:19.290]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:28:19.290]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:28:19.290]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:28:19.290]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:28:19.290]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:28:19.290]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:28:19.290]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:28:19.290]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:28:19.290]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:28:19.290]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:28:19.290]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:28:19.290]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:28:19.290]  $ arguments       :List of 28
[09:28:19.290]   ..$ worker          : chr "localhost"
[09:28:19.290]   ..$ master          : NULL
[09:28:19.290]   ..$ port            : int 11858
[09:28:19.290]   ..$ connectTimeout  : num 120
[09:28:19.290]   ..$ timeout         : num 2592000
[09:28:19.290]   ..$ rscript         : NULL
[09:28:19.290]   ..$ homogeneous     : NULL
[09:28:19.290]   ..$ rscript_args    : NULL
[09:28:19.290]   ..$ rscript_envs    : NULL
[09:28:19.290]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:19.290]   ..$ rscript_startup : NULL
[09:28:19.290]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:28:19.290]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:19.290]   ..$ methods         : logi TRUE
[09:28:19.290]   ..$ socketOptions   : chr "no-delay"
[09:28:19.290]   ..$ useXDR          : logi FALSE
[09:28:19.290]   ..$ outfile         : chr "/dev/null"
[09:28:19.290]   ..$ renice          : int NA
[09:28:19.290]   ..$ rshcmd          : NULL
[09:28:19.290]   ..$ user            : NULL
[09:28:19.290]   ..$ revtunnel       : logi NA
[09:28:19.290]   ..$ rshlogfile      : NULL
[09:28:19.290]   ..$ rshopts         : NULL
[09:28:19.290]   ..$ rank            : int 1
[09:28:19.290]   ..$ manual          : logi FALSE
[09:28:19.290]   ..$ dryrun          : logi FALSE
[09:28:19.290]   ..$ quiet           : logi FALSE
[09:28:19.290]   ..$ setup_strategy  : chr "parallel"
[09:28:19.290]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:28:19.306] [local output] System call to launch all workers:
[09:28:19.306] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpNHCcDg/worker.rank=1.parallelly.parent=28368.6ed02df244ab.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11858 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:28:19.306] [local output] Starting PSOCK main server
[09:28:19.312] [local output] Workers launched
[09:28:19.312] [local output] Waiting for workers to connect back
[09:28:19.313]  - [local output] 0 workers out of 2 ready
[09:28:19.591]  - [local output] 0 workers out of 2 ready
[09:28:19.591]  - [local output] 1 workers out of 2 ready
[09:28:19.593]  - [local output] 1 workers out of 2 ready
[09:28:19.594]  - [local output] 2 workers out of 2 ready
[09:28:19.594] [local output] Launching of workers completed
[09:28:19.594] [local output] Collecting session information from workers
[09:28:19.595] [local output]  - Worker #1 of 2
[09:28:19.595] [local output]  - Worker #2 of 2
[09:28:19.595] [local output] makeClusterPSOCK() ... done
[09:28:19.607] Packages needed by the future expression (n = 0): <none>
[09:28:19.607] Packages needed by future strategies (n = 0): <none>
[09:28:19.607] {
[09:28:19.607]     {
[09:28:19.607]         {
[09:28:19.607]             ...future.startTime <- base::Sys.time()
[09:28:19.607]             {
[09:28:19.607]                 {
[09:28:19.607]                   {
[09:28:19.607]                     {
[09:28:19.607]                       base::local({
[09:28:19.607]                         has_future <- base::requireNamespace("future", 
[09:28:19.607]                           quietly = TRUE)
[09:28:19.607]                         if (has_future) {
[09:28:19.607]                           ns <- base::getNamespace("future")
[09:28:19.607]                           version <- ns[[".package"]][["version"]]
[09:28:19.607]                           if (is.null(version)) 
[09:28:19.607]                             version <- utils::packageVersion("future")
[09:28:19.607]                         }
[09:28:19.607]                         else {
[09:28:19.607]                           version <- NULL
[09:28:19.607]                         }
[09:28:19.607]                         if (!has_future || version < "1.8.0") {
[09:28:19.607]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:19.607]                             "", base::R.version$version.string), 
[09:28:19.607]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:19.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:19.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:19.607]                               "release", "version")], collapse = " "), 
[09:28:19.607]                             hostname = base::Sys.info()[["nodename"]])
[09:28:19.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:19.607]                             info)
[09:28:19.607]                           info <- base::paste(info, collapse = "; ")
[09:28:19.607]                           if (!has_future) {
[09:28:19.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:19.607]                               info)
[09:28:19.607]                           }
[09:28:19.607]                           else {
[09:28:19.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:19.607]                               info, version)
[09:28:19.607]                           }
[09:28:19.607]                           base::stop(msg)
[09:28:19.607]                         }
[09:28:19.607]                       })
[09:28:19.607]                     }
[09:28:19.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:19.607]                     base::options(mc.cores = 1L)
[09:28:19.607]                   }
[09:28:19.607]                   ...future.strategy.old <- future::plan("list")
[09:28:19.607]                   options(future.plan = NULL)
[09:28:19.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:19.607]                 }
[09:28:19.607]                 ...future.workdir <- getwd()
[09:28:19.607]             }
[09:28:19.607]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:19.607]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:19.607]         }
[09:28:19.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:19.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:19.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:19.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:19.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:19.607]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:19.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:19.607]             base::names(...future.oldOptions))
[09:28:19.607]     }
[09:28:19.607]     if (FALSE) {
[09:28:19.607]     }
[09:28:19.607]     else {
[09:28:19.607]         if (TRUE) {
[09:28:19.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:19.607]                 open = "w")
[09:28:19.607]         }
[09:28:19.607]         else {
[09:28:19.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:19.607]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:19.607]         }
[09:28:19.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:19.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:19.607]             base::sink(type = "output", split = FALSE)
[09:28:19.607]             base::close(...future.stdout)
[09:28:19.607]         }, add = TRUE)
[09:28:19.607]     }
[09:28:19.607]     ...future.frame <- base::sys.nframe()
[09:28:19.607]     ...future.conditions <- base::list()
[09:28:19.607]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:19.607]     if (FALSE) {
[09:28:19.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:19.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:19.607]     }
[09:28:19.607]     ...future.result <- base::tryCatch({
[09:28:19.607]         base::withCallingHandlers({
[09:28:19.607]             ...future.value <- base::withVisible(base::local({
[09:28:19.607]                 ...future.makeSendCondition <- base::local({
[09:28:19.607]                   sendCondition <- NULL
[09:28:19.607]                   function(frame = 1L) {
[09:28:19.607]                     if (is.function(sendCondition)) 
[09:28:19.607]                       return(sendCondition)
[09:28:19.607]                     ns <- getNamespace("parallel")
[09:28:19.607]                     if (exists("sendData", mode = "function", 
[09:28:19.607]                       envir = ns)) {
[09:28:19.607]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:19.607]                         envir = ns)
[09:28:19.607]                       envir <- sys.frame(frame)
[09:28:19.607]                       master <- NULL
[09:28:19.607]                       while (!identical(envir, .GlobalEnv) && 
[09:28:19.607]                         !identical(envir, emptyenv())) {
[09:28:19.607]                         if (exists("master", mode = "list", envir = envir, 
[09:28:19.607]                           inherits = FALSE)) {
[09:28:19.607]                           master <- get("master", mode = "list", 
[09:28:19.607]                             envir = envir, inherits = FALSE)
[09:28:19.607]                           if (inherits(master, c("SOCKnode", 
[09:28:19.607]                             "SOCK0node"))) {
[09:28:19.607]                             sendCondition <<- function(cond) {
[09:28:19.607]                               data <- list(type = "VALUE", value = cond, 
[09:28:19.607]                                 success = TRUE)
[09:28:19.607]                               parallel_sendData(master, data)
[09:28:19.607]                             }
[09:28:19.607]                             return(sendCondition)
[09:28:19.607]                           }
[09:28:19.607]                         }
[09:28:19.607]                         frame <- frame + 1L
[09:28:19.607]                         envir <- sys.frame(frame)
[09:28:19.607]                       }
[09:28:19.607]                     }
[09:28:19.607]                     sendCondition <<- function(cond) NULL
[09:28:19.607]                   }
[09:28:19.607]                 })
[09:28:19.607]                 withCallingHandlers({
[09:28:19.607]                   NA
[09:28:19.607]                 }, immediateCondition = function(cond) {
[09:28:19.607]                   sendCondition <- ...future.makeSendCondition()
[09:28:19.607]                   sendCondition(cond)
[09:28:19.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.607]                   {
[09:28:19.607]                     inherits <- base::inherits
[09:28:19.607]                     invokeRestart <- base::invokeRestart
[09:28:19.607]                     is.null <- base::is.null
[09:28:19.607]                     muffled <- FALSE
[09:28:19.607]                     if (inherits(cond, "message")) {
[09:28:19.607]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:19.607]                       if (muffled) 
[09:28:19.607]                         invokeRestart("muffleMessage")
[09:28:19.607]                     }
[09:28:19.607]                     else if (inherits(cond, "warning")) {
[09:28:19.607]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:19.607]                       if (muffled) 
[09:28:19.607]                         invokeRestart("muffleWarning")
[09:28:19.607]                     }
[09:28:19.607]                     else if (inherits(cond, "condition")) {
[09:28:19.607]                       if (!is.null(pattern)) {
[09:28:19.607]                         computeRestarts <- base::computeRestarts
[09:28:19.607]                         grepl <- base::grepl
[09:28:19.607]                         restarts <- computeRestarts(cond)
[09:28:19.607]                         for (restart in restarts) {
[09:28:19.607]                           name <- restart$name
[09:28:19.607]                           if (is.null(name)) 
[09:28:19.607]                             next
[09:28:19.607]                           if (!grepl(pattern, name)) 
[09:28:19.607]                             next
[09:28:19.607]                           invokeRestart(restart)
[09:28:19.607]                           muffled <- TRUE
[09:28:19.607]                           break
[09:28:19.607]                         }
[09:28:19.607]                       }
[09:28:19.607]                     }
[09:28:19.607]                     invisible(muffled)
[09:28:19.607]                   }
[09:28:19.607]                   muffleCondition(cond)
[09:28:19.607]                 })
[09:28:19.607]             }))
[09:28:19.607]             future::FutureResult(value = ...future.value$value, 
[09:28:19.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.607]                   ...future.rng), globalenv = if (FALSE) 
[09:28:19.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:19.607]                     ...future.globalenv.names))
[09:28:19.607]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:19.607]         }, condition = base::local({
[09:28:19.607]             c <- base::c
[09:28:19.607]             inherits <- base::inherits
[09:28:19.607]             invokeRestart <- base::invokeRestart
[09:28:19.607]             length <- base::length
[09:28:19.607]             list <- base::list
[09:28:19.607]             seq.int <- base::seq.int
[09:28:19.607]             signalCondition <- base::signalCondition
[09:28:19.607]             sys.calls <- base::sys.calls
[09:28:19.607]             `[[` <- base::`[[`
[09:28:19.607]             `+` <- base::`+`
[09:28:19.607]             `<<-` <- base::`<<-`
[09:28:19.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:19.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:19.607]                   3L)]
[09:28:19.607]             }
[09:28:19.607]             function(cond) {
[09:28:19.607]                 is_error <- inherits(cond, "error")
[09:28:19.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:19.607]                   NULL)
[09:28:19.607]                 if (is_error) {
[09:28:19.607]                   sessionInformation <- function() {
[09:28:19.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:19.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:19.607]                       search = base::search(), system = base::Sys.info())
[09:28:19.607]                   }
[09:28:19.607]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:19.607]                     cond$call), session = sessionInformation(), 
[09:28:19.607]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:19.607]                   signalCondition(cond)
[09:28:19.607]                 }
[09:28:19.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:19.607]                 "immediateCondition"))) {
[09:28:19.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:19.607]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:19.607]                   if (TRUE && !signal) {
[09:28:19.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.607]                     {
[09:28:19.607]                       inherits <- base::inherits
[09:28:19.607]                       invokeRestart <- base::invokeRestart
[09:28:19.607]                       is.null <- base::is.null
[09:28:19.607]                       muffled <- FALSE
[09:28:19.607]                       if (inherits(cond, "message")) {
[09:28:19.607]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.607]                         if (muffled) 
[09:28:19.607]                           invokeRestart("muffleMessage")
[09:28:19.607]                       }
[09:28:19.607]                       else if (inherits(cond, "warning")) {
[09:28:19.607]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.607]                         if (muffled) 
[09:28:19.607]                           invokeRestart("muffleWarning")
[09:28:19.607]                       }
[09:28:19.607]                       else if (inherits(cond, "condition")) {
[09:28:19.607]                         if (!is.null(pattern)) {
[09:28:19.607]                           computeRestarts <- base::computeRestarts
[09:28:19.607]                           grepl <- base::grepl
[09:28:19.607]                           restarts <- computeRestarts(cond)
[09:28:19.607]                           for (restart in restarts) {
[09:28:19.607]                             name <- restart$name
[09:28:19.607]                             if (is.null(name)) 
[09:28:19.607]                               next
[09:28:19.607]                             if (!grepl(pattern, name)) 
[09:28:19.607]                               next
[09:28:19.607]                             invokeRestart(restart)
[09:28:19.607]                             muffled <- TRUE
[09:28:19.607]                             break
[09:28:19.607]                           }
[09:28:19.607]                         }
[09:28:19.607]                       }
[09:28:19.607]                       invisible(muffled)
[09:28:19.607]                     }
[09:28:19.607]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.607]                   }
[09:28:19.607]                 }
[09:28:19.607]                 else {
[09:28:19.607]                   if (TRUE) {
[09:28:19.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.607]                     {
[09:28:19.607]                       inherits <- base::inherits
[09:28:19.607]                       invokeRestart <- base::invokeRestart
[09:28:19.607]                       is.null <- base::is.null
[09:28:19.607]                       muffled <- FALSE
[09:28:19.607]                       if (inherits(cond, "message")) {
[09:28:19.607]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.607]                         if (muffled) 
[09:28:19.607]                           invokeRestart("muffleMessage")
[09:28:19.607]                       }
[09:28:19.607]                       else if (inherits(cond, "warning")) {
[09:28:19.607]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.607]                         if (muffled) 
[09:28:19.607]                           invokeRestart("muffleWarning")
[09:28:19.607]                       }
[09:28:19.607]                       else if (inherits(cond, "condition")) {
[09:28:19.607]                         if (!is.null(pattern)) {
[09:28:19.607]                           computeRestarts <- base::computeRestarts
[09:28:19.607]                           grepl <- base::grepl
[09:28:19.607]                           restarts <- computeRestarts(cond)
[09:28:19.607]                           for (restart in restarts) {
[09:28:19.607]                             name <- restart$name
[09:28:19.607]                             if (is.null(name)) 
[09:28:19.607]                               next
[09:28:19.607]                             if (!grepl(pattern, name)) 
[09:28:19.607]                               next
[09:28:19.607]                             invokeRestart(restart)
[09:28:19.607]                             muffled <- TRUE
[09:28:19.607]                             break
[09:28:19.607]                           }
[09:28:19.607]                         }
[09:28:19.607]                       }
[09:28:19.607]                       invisible(muffled)
[09:28:19.607]                     }
[09:28:19.607]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.607]                   }
[09:28:19.607]                 }
[09:28:19.607]             }
[09:28:19.607]         }))
[09:28:19.607]     }, error = function(ex) {
[09:28:19.607]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:19.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.607]                 ...future.rng), started = ...future.startTime, 
[09:28:19.607]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:19.607]             version = "1.8"), class = "FutureResult")
[09:28:19.607]     }, finally = {
[09:28:19.607]         if (!identical(...future.workdir, getwd())) 
[09:28:19.607]             setwd(...future.workdir)
[09:28:19.607]         {
[09:28:19.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:19.607]                 ...future.oldOptions$nwarnings <- NULL
[09:28:19.607]             }
[09:28:19.607]             base::options(...future.oldOptions)
[09:28:19.607]             if (.Platform$OS.type == "windows") {
[09:28:19.607]                 old_names <- names(...future.oldEnvVars)
[09:28:19.607]                 envs <- base::Sys.getenv()
[09:28:19.607]                 names <- names(envs)
[09:28:19.607]                 common <- intersect(names, old_names)
[09:28:19.607]                 added <- setdiff(names, old_names)
[09:28:19.607]                 removed <- setdiff(old_names, names)
[09:28:19.607]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:19.607]                   envs[common]]
[09:28:19.607]                 NAMES <- toupper(changed)
[09:28:19.607]                 args <- list()
[09:28:19.607]                 for (kk in seq_along(NAMES)) {
[09:28:19.607]                   name <- changed[[kk]]
[09:28:19.607]                   NAME <- NAMES[[kk]]
[09:28:19.607]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.607]                     next
[09:28:19.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.607]                 }
[09:28:19.607]                 NAMES <- toupper(added)
[09:28:19.607]                 for (kk in seq_along(NAMES)) {
[09:28:19.607]                   name <- added[[kk]]
[09:28:19.607]                   NAME <- NAMES[[kk]]
[09:28:19.607]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.607]                     next
[09:28:19.607]                   args[[name]] <- ""
[09:28:19.607]                 }
[09:28:19.607]                 NAMES <- toupper(removed)
[09:28:19.607]                 for (kk in seq_along(NAMES)) {
[09:28:19.607]                   name <- removed[[kk]]
[09:28:19.607]                   NAME <- NAMES[[kk]]
[09:28:19.607]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.607]                     next
[09:28:19.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.607]                 }
[09:28:19.607]                 if (length(args) > 0) 
[09:28:19.607]                   base::do.call(base::Sys.setenv, args = args)
[09:28:19.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:19.607]             }
[09:28:19.607]             else {
[09:28:19.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:19.607]             }
[09:28:19.607]             {
[09:28:19.607]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:19.607]                   0L) {
[09:28:19.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:19.607]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:19.607]                   base::options(opts)
[09:28:19.607]                 }
[09:28:19.607]                 {
[09:28:19.607]                   {
[09:28:19.607]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:19.607]                     NULL
[09:28:19.607]                   }
[09:28:19.607]                   options(future.plan = NULL)
[09:28:19.607]                   if (is.na(NA_character_)) 
[09:28:19.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:19.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:19.607]                     .init = FALSE)
[09:28:19.607]                 }
[09:28:19.607]             }
[09:28:19.607]         }
[09:28:19.607]     })
[09:28:19.607]     if (TRUE) {
[09:28:19.607]         base::sink(type = "output", split = FALSE)
[09:28:19.607]         if (TRUE) {
[09:28:19.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:19.607]         }
[09:28:19.607]         else {
[09:28:19.607]             ...future.result["stdout"] <- base::list(NULL)
[09:28:19.607]         }
[09:28:19.607]         base::close(...future.stdout)
[09:28:19.607]         ...future.stdout <- NULL
[09:28:19.607]     }
[09:28:19.607]     ...future.result$conditions <- ...future.conditions
[09:28:19.607]     ...future.result$finished <- base::Sys.time()
[09:28:19.607]     ...future.result
[09:28:19.607] }
[09:28:19.659] MultisessionFuture started
[09:28:19.659] result() for ClusterFuture ...
[09:28:19.660] receiveMessageFromWorker() for ClusterFuture ...
[09:28:19.660] - Validating connection of MultisessionFuture
[09:28:19.690] - received message: FutureResult
[09:28:19.691] - Received FutureResult
[09:28:19.691] - Erased future from FutureRegistry
[09:28:19.691] result() for ClusterFuture ...
[09:28:19.691] - result already collected: FutureResult
[09:28:19.691] result() for ClusterFuture ... done
[09:28:19.691] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:19.691] result() for ClusterFuture ... done
[09:28:19.692] result() for ClusterFuture ...
[09:28:19.692] - result already collected: FutureResult
[09:28:19.692] result() for ClusterFuture ... done
[09:28:19.692] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:28:19.696] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[09:28:19.696] getGlobalsAndPackagesXApply() ...
[09:28:19.696]  - future.globals: TRUE
[09:28:19.696] getGlobalsAndPackages() ...
[09:28:19.697] Searching for globals...
[09:28:19.737] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:19.737] Searching for globals ... DONE
[09:28:19.738] Resolving globals: FALSE
[09:28:19.741] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:19.742] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:19.742] - globals: [1] ‘FUN’
[09:28:19.742] 
[09:28:19.742] getGlobalsAndPackages() ... DONE
[09:28:19.742]  - globals found/used: [n=1] ‘FUN’
[09:28:19.742]  - needed namespaces: [n=0] 
[09:28:19.742] Finding globals ... DONE
[09:28:19.742]  - use_args: TRUE
[09:28:19.743]  - Getting '...' globals ...
[09:28:19.743] resolve() on list ...
[09:28:19.743]  recursive: 0
[09:28:19.743]  length: 1
[09:28:19.743]  elements: ‘...’
[09:28:19.743]  length: 0 (resolved future 1)
[09:28:19.743] resolve() on list ... DONE
[09:28:19.743]    - '...' content: [n=0] 
[09:28:19.744] List of 1
[09:28:19.744]  $ ...: list()
[09:28:19.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:19.744]  - attr(*, "where")=List of 1
[09:28:19.744]   ..$ ...:<environment: 0x559ba56fc140> 
[09:28:19.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:19.744]  - attr(*, "resolved")= logi TRUE
[09:28:19.744]  - attr(*, "total_size")= num NA
[09:28:19.746]  - Getting '...' globals ... DONE
[09:28:19.746] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:19.746] List of 2
[09:28:19.746]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:19.746]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:19.746]  $ ...          : list()
[09:28:19.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:19.746]  - attr(*, "where")=List of 2
[09:28:19.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:19.746]   ..$ ...          :<environment: 0x559ba56fc140> 
[09:28:19.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:19.746]  - attr(*, "resolved")= logi FALSE
[09:28:19.746]  - attr(*, "total_size")= num 354224
[09:28:19.749] Packages to be attached in all futures: [n=0] 
[09:28:19.749] getGlobalsAndPackagesXApply() ... DONE
[09:28:19.752] future_lapply() ...
[09:28:19.784] Number of chunks: 2
[09:28:19.784] getGlobalsAndPackagesXApply() ...
[09:28:19.784]  - future.globals: <name-value list> with names ‘list()’
[09:28:19.784]  - use_args: TRUE
[09:28:19.785] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:19.785] List of 2
[09:28:19.785]  $ ...          : list()
[09:28:19.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:19.785]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:19.785]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:19.785]  - attr(*, "where")=List of 2
[09:28:19.785]   ..$ ...          :<environment: 0x559ba56fc140> 
[09:28:19.785]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:19.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:19.785]  - attr(*, "resolved")= logi FALSE
[09:28:19.785]  - attr(*, "total_size")= num NA
[09:28:19.788] Packages to be attached in all futures: [n=0] 
[09:28:19.788] getGlobalsAndPackagesXApply() ... DONE
[09:28:19.788] Number of futures (= number of chunks): 2
[09:28:19.788] Launching 2 futures (chunks) ...
[09:28:19.788] Chunk #1 of 2 ...
[09:28:19.789]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:19.789]  - seeds: <none>
[09:28:19.789]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.789] getGlobalsAndPackages() ...
[09:28:19.789] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.789] Resolving globals: FALSE
[09:28:19.789] Tweak future expression to call with '...' arguments ...
[09:28:19.789] {
[09:28:19.789]     do.call(function(...) {
[09:28:19.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:19.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.789]             on.exit(options(oopts), add = TRUE)
[09:28:19.789]         }
[09:28:19.789]         {
[09:28:19.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:19.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.789]                 ...future.FUN(...future.X_jj, ...)
[09:28:19.789]             })
[09:28:19.789]         }
[09:28:19.789]     }, args = future.call.arguments)
[09:28:19.789] }
[09:28:19.790] Tweak future expression to call with '...' arguments ... DONE
[09:28:19.790] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.790] 
[09:28:19.790] getGlobalsAndPackages() ... DONE
[09:28:19.790] run() for ‘Future’ ...
[09:28:19.791] - state: ‘created’
[09:28:19.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:19.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:19.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:19.804]   - Field: ‘node’
[09:28:19.805]   - Field: ‘label’
[09:28:19.805]   - Field: ‘local’
[09:28:19.805]   - Field: ‘owner’
[09:28:19.805]   - Field: ‘envir’
[09:28:19.805]   - Field: ‘workers’
[09:28:19.805]   - Field: ‘packages’
[09:28:19.805]   - Field: ‘gc’
[09:28:19.805]   - Field: ‘conditions’
[09:28:19.805]   - Field: ‘persistent’
[09:28:19.805]   - Field: ‘expr’
[09:28:19.805]   - Field: ‘uuid’
[09:28:19.806]   - Field: ‘seed’
[09:28:19.806]   - Field: ‘version’
[09:28:19.806]   - Field: ‘result’
[09:28:19.806]   - Field: ‘asynchronous’
[09:28:19.806]   - Field: ‘calls’
[09:28:19.806]   - Field: ‘globals’
[09:28:19.806]   - Field: ‘stdout’
[09:28:19.806]   - Field: ‘earlySignal’
[09:28:19.806]   - Field: ‘lazy’
[09:28:19.806]   - Field: ‘state’
[09:28:19.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:19.806] - Launch lazy future ...
[09:28:19.807] Packages needed by the future expression (n = 0): <none>
[09:28:19.807] Packages needed by future strategies (n = 0): <none>
[09:28:19.807] {
[09:28:19.807]     {
[09:28:19.807]         {
[09:28:19.807]             ...future.startTime <- base::Sys.time()
[09:28:19.807]             {
[09:28:19.807]                 {
[09:28:19.807]                   {
[09:28:19.807]                     {
[09:28:19.807]                       base::local({
[09:28:19.807]                         has_future <- base::requireNamespace("future", 
[09:28:19.807]                           quietly = TRUE)
[09:28:19.807]                         if (has_future) {
[09:28:19.807]                           ns <- base::getNamespace("future")
[09:28:19.807]                           version <- ns[[".package"]][["version"]]
[09:28:19.807]                           if (is.null(version)) 
[09:28:19.807]                             version <- utils::packageVersion("future")
[09:28:19.807]                         }
[09:28:19.807]                         else {
[09:28:19.807]                           version <- NULL
[09:28:19.807]                         }
[09:28:19.807]                         if (!has_future || version < "1.8.0") {
[09:28:19.807]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:19.807]                             "", base::R.version$version.string), 
[09:28:19.807]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:19.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:19.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:19.807]                               "release", "version")], collapse = " "), 
[09:28:19.807]                             hostname = base::Sys.info()[["nodename"]])
[09:28:19.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:19.807]                             info)
[09:28:19.807]                           info <- base::paste(info, collapse = "; ")
[09:28:19.807]                           if (!has_future) {
[09:28:19.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:19.807]                               info)
[09:28:19.807]                           }
[09:28:19.807]                           else {
[09:28:19.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:19.807]                               info, version)
[09:28:19.807]                           }
[09:28:19.807]                           base::stop(msg)
[09:28:19.807]                         }
[09:28:19.807]                       })
[09:28:19.807]                     }
[09:28:19.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:19.807]                     base::options(mc.cores = 1L)
[09:28:19.807]                   }
[09:28:19.807]                   ...future.strategy.old <- future::plan("list")
[09:28:19.807]                   options(future.plan = NULL)
[09:28:19.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:19.807]                 }
[09:28:19.807]                 ...future.workdir <- getwd()
[09:28:19.807]             }
[09:28:19.807]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:19.807]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:19.807]         }
[09:28:19.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:19.807]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:19.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:19.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:19.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:19.807]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:19.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:19.807]             base::names(...future.oldOptions))
[09:28:19.807]     }
[09:28:19.807]     if (FALSE) {
[09:28:19.807]     }
[09:28:19.807]     else {
[09:28:19.807]         if (TRUE) {
[09:28:19.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:19.807]                 open = "w")
[09:28:19.807]         }
[09:28:19.807]         else {
[09:28:19.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:19.807]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:19.807]         }
[09:28:19.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:19.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:19.807]             base::sink(type = "output", split = FALSE)
[09:28:19.807]             base::close(...future.stdout)
[09:28:19.807]         }, add = TRUE)
[09:28:19.807]     }
[09:28:19.807]     ...future.frame <- base::sys.nframe()
[09:28:19.807]     ...future.conditions <- base::list()
[09:28:19.807]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:19.807]     if (FALSE) {
[09:28:19.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:19.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:19.807]     }
[09:28:19.807]     ...future.result <- base::tryCatch({
[09:28:19.807]         base::withCallingHandlers({
[09:28:19.807]             ...future.value <- base::withVisible(base::local({
[09:28:19.807]                 ...future.makeSendCondition <- base::local({
[09:28:19.807]                   sendCondition <- NULL
[09:28:19.807]                   function(frame = 1L) {
[09:28:19.807]                     if (is.function(sendCondition)) 
[09:28:19.807]                       return(sendCondition)
[09:28:19.807]                     ns <- getNamespace("parallel")
[09:28:19.807]                     if (exists("sendData", mode = "function", 
[09:28:19.807]                       envir = ns)) {
[09:28:19.807]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:19.807]                         envir = ns)
[09:28:19.807]                       envir <- sys.frame(frame)
[09:28:19.807]                       master <- NULL
[09:28:19.807]                       while (!identical(envir, .GlobalEnv) && 
[09:28:19.807]                         !identical(envir, emptyenv())) {
[09:28:19.807]                         if (exists("master", mode = "list", envir = envir, 
[09:28:19.807]                           inherits = FALSE)) {
[09:28:19.807]                           master <- get("master", mode = "list", 
[09:28:19.807]                             envir = envir, inherits = FALSE)
[09:28:19.807]                           if (inherits(master, c("SOCKnode", 
[09:28:19.807]                             "SOCK0node"))) {
[09:28:19.807]                             sendCondition <<- function(cond) {
[09:28:19.807]                               data <- list(type = "VALUE", value = cond, 
[09:28:19.807]                                 success = TRUE)
[09:28:19.807]                               parallel_sendData(master, data)
[09:28:19.807]                             }
[09:28:19.807]                             return(sendCondition)
[09:28:19.807]                           }
[09:28:19.807]                         }
[09:28:19.807]                         frame <- frame + 1L
[09:28:19.807]                         envir <- sys.frame(frame)
[09:28:19.807]                       }
[09:28:19.807]                     }
[09:28:19.807]                     sendCondition <<- function(cond) NULL
[09:28:19.807]                   }
[09:28:19.807]                 })
[09:28:19.807]                 withCallingHandlers({
[09:28:19.807]                   {
[09:28:19.807]                     do.call(function(...) {
[09:28:19.807]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.807]                       if (!identical(...future.globals.maxSize.org, 
[09:28:19.807]                         ...future.globals.maxSize)) {
[09:28:19.807]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.807]                         on.exit(options(oopts), add = TRUE)
[09:28:19.807]                       }
[09:28:19.807]                       {
[09:28:19.807]                         lapply(seq_along(...future.elements_ii), 
[09:28:19.807]                           FUN = function(jj) {
[09:28:19.807]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.807]                             ...future.FUN(...future.X_jj, ...)
[09:28:19.807]                           })
[09:28:19.807]                       }
[09:28:19.807]                     }, args = future.call.arguments)
[09:28:19.807]                   }
[09:28:19.807]                 }, immediateCondition = function(cond) {
[09:28:19.807]                   sendCondition <- ...future.makeSendCondition()
[09:28:19.807]                   sendCondition(cond)
[09:28:19.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.807]                   {
[09:28:19.807]                     inherits <- base::inherits
[09:28:19.807]                     invokeRestart <- base::invokeRestart
[09:28:19.807]                     is.null <- base::is.null
[09:28:19.807]                     muffled <- FALSE
[09:28:19.807]                     if (inherits(cond, "message")) {
[09:28:19.807]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:19.807]                       if (muffled) 
[09:28:19.807]                         invokeRestart("muffleMessage")
[09:28:19.807]                     }
[09:28:19.807]                     else if (inherits(cond, "warning")) {
[09:28:19.807]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:19.807]                       if (muffled) 
[09:28:19.807]                         invokeRestart("muffleWarning")
[09:28:19.807]                     }
[09:28:19.807]                     else if (inherits(cond, "condition")) {
[09:28:19.807]                       if (!is.null(pattern)) {
[09:28:19.807]                         computeRestarts <- base::computeRestarts
[09:28:19.807]                         grepl <- base::grepl
[09:28:19.807]                         restarts <- computeRestarts(cond)
[09:28:19.807]                         for (restart in restarts) {
[09:28:19.807]                           name <- restart$name
[09:28:19.807]                           if (is.null(name)) 
[09:28:19.807]                             next
[09:28:19.807]                           if (!grepl(pattern, name)) 
[09:28:19.807]                             next
[09:28:19.807]                           invokeRestart(restart)
[09:28:19.807]                           muffled <- TRUE
[09:28:19.807]                           break
[09:28:19.807]                         }
[09:28:19.807]                       }
[09:28:19.807]                     }
[09:28:19.807]                     invisible(muffled)
[09:28:19.807]                   }
[09:28:19.807]                   muffleCondition(cond)
[09:28:19.807]                 })
[09:28:19.807]             }))
[09:28:19.807]             future::FutureResult(value = ...future.value$value, 
[09:28:19.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.807]                   ...future.rng), globalenv = if (FALSE) 
[09:28:19.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:19.807]                     ...future.globalenv.names))
[09:28:19.807]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:19.807]         }, condition = base::local({
[09:28:19.807]             c <- base::c
[09:28:19.807]             inherits <- base::inherits
[09:28:19.807]             invokeRestart <- base::invokeRestart
[09:28:19.807]             length <- base::length
[09:28:19.807]             list <- base::list
[09:28:19.807]             seq.int <- base::seq.int
[09:28:19.807]             signalCondition <- base::signalCondition
[09:28:19.807]             sys.calls <- base::sys.calls
[09:28:19.807]             `[[` <- base::`[[`
[09:28:19.807]             `+` <- base::`+`
[09:28:19.807]             `<<-` <- base::`<<-`
[09:28:19.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:19.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:19.807]                   3L)]
[09:28:19.807]             }
[09:28:19.807]             function(cond) {
[09:28:19.807]                 is_error <- inherits(cond, "error")
[09:28:19.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:19.807]                   NULL)
[09:28:19.807]                 if (is_error) {
[09:28:19.807]                   sessionInformation <- function() {
[09:28:19.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:19.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:19.807]                       search = base::search(), system = base::Sys.info())
[09:28:19.807]                   }
[09:28:19.807]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:19.807]                     cond$call), session = sessionInformation(), 
[09:28:19.807]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:19.807]                   signalCondition(cond)
[09:28:19.807]                 }
[09:28:19.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:19.807]                 "immediateCondition"))) {
[09:28:19.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:19.807]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:19.807]                   if (TRUE && !signal) {
[09:28:19.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.807]                     {
[09:28:19.807]                       inherits <- base::inherits
[09:28:19.807]                       invokeRestart <- base::invokeRestart
[09:28:19.807]                       is.null <- base::is.null
[09:28:19.807]                       muffled <- FALSE
[09:28:19.807]                       if (inherits(cond, "message")) {
[09:28:19.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.807]                         if (muffled) 
[09:28:19.807]                           invokeRestart("muffleMessage")
[09:28:19.807]                       }
[09:28:19.807]                       else if (inherits(cond, "warning")) {
[09:28:19.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.807]                         if (muffled) 
[09:28:19.807]                           invokeRestart("muffleWarning")
[09:28:19.807]                       }
[09:28:19.807]                       else if (inherits(cond, "condition")) {
[09:28:19.807]                         if (!is.null(pattern)) {
[09:28:19.807]                           computeRestarts <- base::computeRestarts
[09:28:19.807]                           grepl <- base::grepl
[09:28:19.807]                           restarts <- computeRestarts(cond)
[09:28:19.807]                           for (restart in restarts) {
[09:28:19.807]                             name <- restart$name
[09:28:19.807]                             if (is.null(name)) 
[09:28:19.807]                               next
[09:28:19.807]                             if (!grepl(pattern, name)) 
[09:28:19.807]                               next
[09:28:19.807]                             invokeRestart(restart)
[09:28:19.807]                             muffled <- TRUE
[09:28:19.807]                             break
[09:28:19.807]                           }
[09:28:19.807]                         }
[09:28:19.807]                       }
[09:28:19.807]                       invisible(muffled)
[09:28:19.807]                     }
[09:28:19.807]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.807]                   }
[09:28:19.807]                 }
[09:28:19.807]                 else {
[09:28:19.807]                   if (TRUE) {
[09:28:19.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.807]                     {
[09:28:19.807]                       inherits <- base::inherits
[09:28:19.807]                       invokeRestart <- base::invokeRestart
[09:28:19.807]                       is.null <- base::is.null
[09:28:19.807]                       muffled <- FALSE
[09:28:19.807]                       if (inherits(cond, "message")) {
[09:28:19.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.807]                         if (muffled) 
[09:28:19.807]                           invokeRestart("muffleMessage")
[09:28:19.807]                       }
[09:28:19.807]                       else if (inherits(cond, "warning")) {
[09:28:19.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.807]                         if (muffled) 
[09:28:19.807]                           invokeRestart("muffleWarning")
[09:28:19.807]                       }
[09:28:19.807]                       else if (inherits(cond, "condition")) {
[09:28:19.807]                         if (!is.null(pattern)) {
[09:28:19.807]                           computeRestarts <- base::computeRestarts
[09:28:19.807]                           grepl <- base::grepl
[09:28:19.807]                           restarts <- computeRestarts(cond)
[09:28:19.807]                           for (restart in restarts) {
[09:28:19.807]                             name <- restart$name
[09:28:19.807]                             if (is.null(name)) 
[09:28:19.807]                               next
[09:28:19.807]                             if (!grepl(pattern, name)) 
[09:28:19.807]                               next
[09:28:19.807]                             invokeRestart(restart)
[09:28:19.807]                             muffled <- TRUE
[09:28:19.807]                             break
[09:28:19.807]                           }
[09:28:19.807]                         }
[09:28:19.807]                       }
[09:28:19.807]                       invisible(muffled)
[09:28:19.807]                     }
[09:28:19.807]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.807]                   }
[09:28:19.807]                 }
[09:28:19.807]             }
[09:28:19.807]         }))
[09:28:19.807]     }, error = function(ex) {
[09:28:19.807]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:19.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.807]                 ...future.rng), started = ...future.startTime, 
[09:28:19.807]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:19.807]             version = "1.8"), class = "FutureResult")
[09:28:19.807]     }, finally = {
[09:28:19.807]         if (!identical(...future.workdir, getwd())) 
[09:28:19.807]             setwd(...future.workdir)
[09:28:19.807]         {
[09:28:19.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:19.807]                 ...future.oldOptions$nwarnings <- NULL
[09:28:19.807]             }
[09:28:19.807]             base::options(...future.oldOptions)
[09:28:19.807]             if (.Platform$OS.type == "windows") {
[09:28:19.807]                 old_names <- names(...future.oldEnvVars)
[09:28:19.807]                 envs <- base::Sys.getenv()
[09:28:19.807]                 names <- names(envs)
[09:28:19.807]                 common <- intersect(names, old_names)
[09:28:19.807]                 added <- setdiff(names, old_names)
[09:28:19.807]                 removed <- setdiff(old_names, names)
[09:28:19.807]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:19.807]                   envs[common]]
[09:28:19.807]                 NAMES <- toupper(changed)
[09:28:19.807]                 args <- list()
[09:28:19.807]                 for (kk in seq_along(NAMES)) {
[09:28:19.807]                   name <- changed[[kk]]
[09:28:19.807]                   NAME <- NAMES[[kk]]
[09:28:19.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.807]                     next
[09:28:19.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.807]                 }
[09:28:19.807]                 NAMES <- toupper(added)
[09:28:19.807]                 for (kk in seq_along(NAMES)) {
[09:28:19.807]                   name <- added[[kk]]
[09:28:19.807]                   NAME <- NAMES[[kk]]
[09:28:19.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.807]                     next
[09:28:19.807]                   args[[name]] <- ""
[09:28:19.807]                 }
[09:28:19.807]                 NAMES <- toupper(removed)
[09:28:19.807]                 for (kk in seq_along(NAMES)) {
[09:28:19.807]                   name <- removed[[kk]]
[09:28:19.807]                   NAME <- NAMES[[kk]]
[09:28:19.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.807]                     next
[09:28:19.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.807]                 }
[09:28:19.807]                 if (length(args) > 0) 
[09:28:19.807]                   base::do.call(base::Sys.setenv, args = args)
[09:28:19.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:19.807]             }
[09:28:19.807]             else {
[09:28:19.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:19.807]             }
[09:28:19.807]             {
[09:28:19.807]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:19.807]                   0L) {
[09:28:19.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:19.807]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:19.807]                   base::options(opts)
[09:28:19.807]                 }
[09:28:19.807]                 {
[09:28:19.807]                   {
[09:28:19.807]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:19.807]                     NULL
[09:28:19.807]                   }
[09:28:19.807]                   options(future.plan = NULL)
[09:28:19.807]                   if (is.na(NA_character_)) 
[09:28:19.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:19.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:19.807]                     .init = FALSE)
[09:28:19.807]                 }
[09:28:19.807]             }
[09:28:19.807]         }
[09:28:19.807]     })
[09:28:19.807]     if (TRUE) {
[09:28:19.807]         base::sink(type = "output", split = FALSE)
[09:28:19.807]         if (TRUE) {
[09:28:19.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:19.807]         }
[09:28:19.807]         else {
[09:28:19.807]             ...future.result["stdout"] <- base::list(NULL)
[09:28:19.807]         }
[09:28:19.807]         base::close(...future.stdout)
[09:28:19.807]         ...future.stdout <- NULL
[09:28:19.807]     }
[09:28:19.807]     ...future.result$conditions <- ...future.conditions
[09:28:19.807]     ...future.result$finished <- base::Sys.time()
[09:28:19.807]     ...future.result
[09:28:19.807] }
[09:28:19.810] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[09:28:19.810] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:19.811] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:19.811] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[09:28:19.852] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[09:28:19.852] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[09:28:19.853] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[09:28:19.853] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:19.853] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:19.853] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:19.854] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:19.854] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[09:28:19.854] MultisessionFuture started
[09:28:19.854] - Launch lazy future ... done
[09:28:19.854] run() for ‘MultisessionFuture’ ... done
[09:28:19.855] Created future:
[09:28:19.855] MultisessionFuture:
[09:28:19.855] Label: ‘future_apply-1’
[09:28:19.855] Expression:
[09:28:19.855] {
[09:28:19.855]     do.call(function(...) {
[09:28:19.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:19.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.855]             on.exit(options(oopts), add = TRUE)
[09:28:19.855]         }
[09:28:19.855]         {
[09:28:19.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:19.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.855]                 ...future.FUN(...future.X_jj, ...)
[09:28:19.855]             })
[09:28:19.855]         }
[09:28:19.855]     }, args = future.call.arguments)
[09:28:19.855] }
[09:28:19.855] Lazy evaluation: FALSE
[09:28:19.855] Asynchronous evaluation: TRUE
[09:28:19.855] Local evaluation: TRUE
[09:28:19.855] Environment: R_GlobalEnv
[09:28:19.855] Capture standard output: TRUE
[09:28:19.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:19.855] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:19.855] Packages: <none>
[09:28:19.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:19.855] Resolved: FALSE
[09:28:19.855] Value: <not collected>
[09:28:19.855] Conditions captured: <none>
[09:28:19.855] Early signaling: FALSE
[09:28:19.855] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:19.855] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:19.866] Chunk #1 of 2 ... DONE
[09:28:19.867] Chunk #2 of 2 ...
[09:28:19.867]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:19.867]  - seeds: <none>
[09:28:19.867]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.867] getGlobalsAndPackages() ...
[09:28:19.867] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.867] Resolving globals: FALSE
[09:28:19.867] Tweak future expression to call with '...' arguments ...
[09:28:19.868] {
[09:28:19.868]     do.call(function(...) {
[09:28:19.868]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.868]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:19.868]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.868]             on.exit(options(oopts), add = TRUE)
[09:28:19.868]         }
[09:28:19.868]         {
[09:28:19.868]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:19.868]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.868]                 ...future.FUN(...future.X_jj, ...)
[09:28:19.868]             })
[09:28:19.868]         }
[09:28:19.868]     }, args = future.call.arguments)
[09:28:19.868] }
[09:28:19.868] Tweak future expression to call with '...' arguments ... DONE
[09:28:19.868] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:19.868] 
[09:28:19.868] getGlobalsAndPackages() ... DONE
[09:28:19.869] run() for ‘Future’ ...
[09:28:19.869] - state: ‘created’
[09:28:19.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:19.882] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:19.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:19.883]   - Field: ‘node’
[09:28:19.883]   - Field: ‘label’
[09:28:19.883]   - Field: ‘local’
[09:28:19.883]   - Field: ‘owner’
[09:28:19.883]   - Field: ‘envir’
[09:28:19.883]   - Field: ‘workers’
[09:28:19.883]   - Field: ‘packages’
[09:28:19.883]   - Field: ‘gc’
[09:28:19.883]   - Field: ‘conditions’
[09:28:19.883]   - Field: ‘persistent’
[09:28:19.883]   - Field: ‘expr’
[09:28:19.884]   - Field: ‘uuid’
[09:28:19.884]   - Field: ‘seed’
[09:28:19.884]   - Field: ‘version’
[09:28:19.884]   - Field: ‘result’
[09:28:19.884]   - Field: ‘asynchronous’
[09:28:19.884]   - Field: ‘calls’
[09:28:19.884]   - Field: ‘globals’
[09:28:19.884]   - Field: ‘stdout’
[09:28:19.884]   - Field: ‘earlySignal’
[09:28:19.884]   - Field: ‘lazy’
[09:28:19.884]   - Field: ‘state’
[09:28:19.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:19.885] - Launch lazy future ...
[09:28:19.885] Packages needed by the future expression (n = 0): <none>
[09:28:19.885] Packages needed by future strategies (n = 0): <none>
[09:28:19.887] {
[09:28:19.887]     {
[09:28:19.887]         {
[09:28:19.887]             ...future.startTime <- base::Sys.time()
[09:28:19.887]             {
[09:28:19.887]                 {
[09:28:19.887]                   {
[09:28:19.887]                     {
[09:28:19.887]                       base::local({
[09:28:19.887]                         has_future <- base::requireNamespace("future", 
[09:28:19.887]                           quietly = TRUE)
[09:28:19.887]                         if (has_future) {
[09:28:19.887]                           ns <- base::getNamespace("future")
[09:28:19.887]                           version <- ns[[".package"]][["version"]]
[09:28:19.887]                           if (is.null(version)) 
[09:28:19.887]                             version <- utils::packageVersion("future")
[09:28:19.887]                         }
[09:28:19.887]                         else {
[09:28:19.887]                           version <- NULL
[09:28:19.887]                         }
[09:28:19.887]                         if (!has_future || version < "1.8.0") {
[09:28:19.887]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:19.887]                             "", base::R.version$version.string), 
[09:28:19.887]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:19.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:19.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:19.887]                               "release", "version")], collapse = " "), 
[09:28:19.887]                             hostname = base::Sys.info()[["nodename"]])
[09:28:19.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:19.887]                             info)
[09:28:19.887]                           info <- base::paste(info, collapse = "; ")
[09:28:19.887]                           if (!has_future) {
[09:28:19.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:19.887]                               info)
[09:28:19.887]                           }
[09:28:19.887]                           else {
[09:28:19.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:19.887]                               info, version)
[09:28:19.887]                           }
[09:28:19.887]                           base::stop(msg)
[09:28:19.887]                         }
[09:28:19.887]                       })
[09:28:19.887]                     }
[09:28:19.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:19.887]                     base::options(mc.cores = 1L)
[09:28:19.887]                   }
[09:28:19.887]                   ...future.strategy.old <- future::plan("list")
[09:28:19.887]                   options(future.plan = NULL)
[09:28:19.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:19.887]                 }
[09:28:19.887]                 ...future.workdir <- getwd()
[09:28:19.887]             }
[09:28:19.887]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:19.887]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:19.887]         }
[09:28:19.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:19.887]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:19.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:19.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:19.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:19.887]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:19.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:19.887]             base::names(...future.oldOptions))
[09:28:19.887]     }
[09:28:19.887]     if (FALSE) {
[09:28:19.887]     }
[09:28:19.887]     else {
[09:28:19.887]         if (TRUE) {
[09:28:19.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:19.887]                 open = "w")
[09:28:19.887]         }
[09:28:19.887]         else {
[09:28:19.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:19.887]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:19.887]         }
[09:28:19.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:19.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:19.887]             base::sink(type = "output", split = FALSE)
[09:28:19.887]             base::close(...future.stdout)
[09:28:19.887]         }, add = TRUE)
[09:28:19.887]     }
[09:28:19.887]     ...future.frame <- base::sys.nframe()
[09:28:19.887]     ...future.conditions <- base::list()
[09:28:19.887]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:19.887]     if (FALSE) {
[09:28:19.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:19.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:19.887]     }
[09:28:19.887]     ...future.result <- base::tryCatch({
[09:28:19.887]         base::withCallingHandlers({
[09:28:19.887]             ...future.value <- base::withVisible(base::local({
[09:28:19.887]                 ...future.makeSendCondition <- base::local({
[09:28:19.887]                   sendCondition <- NULL
[09:28:19.887]                   function(frame = 1L) {
[09:28:19.887]                     if (is.function(sendCondition)) 
[09:28:19.887]                       return(sendCondition)
[09:28:19.887]                     ns <- getNamespace("parallel")
[09:28:19.887]                     if (exists("sendData", mode = "function", 
[09:28:19.887]                       envir = ns)) {
[09:28:19.887]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:19.887]                         envir = ns)
[09:28:19.887]                       envir <- sys.frame(frame)
[09:28:19.887]                       master <- NULL
[09:28:19.887]                       while (!identical(envir, .GlobalEnv) && 
[09:28:19.887]                         !identical(envir, emptyenv())) {
[09:28:19.887]                         if (exists("master", mode = "list", envir = envir, 
[09:28:19.887]                           inherits = FALSE)) {
[09:28:19.887]                           master <- get("master", mode = "list", 
[09:28:19.887]                             envir = envir, inherits = FALSE)
[09:28:19.887]                           if (inherits(master, c("SOCKnode", 
[09:28:19.887]                             "SOCK0node"))) {
[09:28:19.887]                             sendCondition <<- function(cond) {
[09:28:19.887]                               data <- list(type = "VALUE", value = cond, 
[09:28:19.887]                                 success = TRUE)
[09:28:19.887]                               parallel_sendData(master, data)
[09:28:19.887]                             }
[09:28:19.887]                             return(sendCondition)
[09:28:19.887]                           }
[09:28:19.887]                         }
[09:28:19.887]                         frame <- frame + 1L
[09:28:19.887]                         envir <- sys.frame(frame)
[09:28:19.887]                       }
[09:28:19.887]                     }
[09:28:19.887]                     sendCondition <<- function(cond) NULL
[09:28:19.887]                   }
[09:28:19.887]                 })
[09:28:19.887]                 withCallingHandlers({
[09:28:19.887]                   {
[09:28:19.887]                     do.call(function(...) {
[09:28:19.887]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.887]                       if (!identical(...future.globals.maxSize.org, 
[09:28:19.887]                         ...future.globals.maxSize)) {
[09:28:19.887]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.887]                         on.exit(options(oopts), add = TRUE)
[09:28:19.887]                       }
[09:28:19.887]                       {
[09:28:19.887]                         lapply(seq_along(...future.elements_ii), 
[09:28:19.887]                           FUN = function(jj) {
[09:28:19.887]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.887]                             ...future.FUN(...future.X_jj, ...)
[09:28:19.887]                           })
[09:28:19.887]                       }
[09:28:19.887]                     }, args = future.call.arguments)
[09:28:19.887]                   }
[09:28:19.887]                 }, immediateCondition = function(cond) {
[09:28:19.887]                   sendCondition <- ...future.makeSendCondition()
[09:28:19.887]                   sendCondition(cond)
[09:28:19.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.887]                   {
[09:28:19.887]                     inherits <- base::inherits
[09:28:19.887]                     invokeRestart <- base::invokeRestart
[09:28:19.887]                     is.null <- base::is.null
[09:28:19.887]                     muffled <- FALSE
[09:28:19.887]                     if (inherits(cond, "message")) {
[09:28:19.887]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:19.887]                       if (muffled) 
[09:28:19.887]                         invokeRestart("muffleMessage")
[09:28:19.887]                     }
[09:28:19.887]                     else if (inherits(cond, "warning")) {
[09:28:19.887]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:19.887]                       if (muffled) 
[09:28:19.887]                         invokeRestart("muffleWarning")
[09:28:19.887]                     }
[09:28:19.887]                     else if (inherits(cond, "condition")) {
[09:28:19.887]                       if (!is.null(pattern)) {
[09:28:19.887]                         computeRestarts <- base::computeRestarts
[09:28:19.887]                         grepl <- base::grepl
[09:28:19.887]                         restarts <- computeRestarts(cond)
[09:28:19.887]                         for (restart in restarts) {
[09:28:19.887]                           name <- restart$name
[09:28:19.887]                           if (is.null(name)) 
[09:28:19.887]                             next
[09:28:19.887]                           if (!grepl(pattern, name)) 
[09:28:19.887]                             next
[09:28:19.887]                           invokeRestart(restart)
[09:28:19.887]                           muffled <- TRUE
[09:28:19.887]                           break
[09:28:19.887]                         }
[09:28:19.887]                       }
[09:28:19.887]                     }
[09:28:19.887]                     invisible(muffled)
[09:28:19.887]                   }
[09:28:19.887]                   muffleCondition(cond)
[09:28:19.887]                 })
[09:28:19.887]             }))
[09:28:19.887]             future::FutureResult(value = ...future.value$value, 
[09:28:19.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.887]                   ...future.rng), globalenv = if (FALSE) 
[09:28:19.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:19.887]                     ...future.globalenv.names))
[09:28:19.887]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:19.887]         }, condition = base::local({
[09:28:19.887]             c <- base::c
[09:28:19.887]             inherits <- base::inherits
[09:28:19.887]             invokeRestart <- base::invokeRestart
[09:28:19.887]             length <- base::length
[09:28:19.887]             list <- base::list
[09:28:19.887]             seq.int <- base::seq.int
[09:28:19.887]             signalCondition <- base::signalCondition
[09:28:19.887]             sys.calls <- base::sys.calls
[09:28:19.887]             `[[` <- base::`[[`
[09:28:19.887]             `+` <- base::`+`
[09:28:19.887]             `<<-` <- base::`<<-`
[09:28:19.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:19.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:19.887]                   3L)]
[09:28:19.887]             }
[09:28:19.887]             function(cond) {
[09:28:19.887]                 is_error <- inherits(cond, "error")
[09:28:19.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:19.887]                   NULL)
[09:28:19.887]                 if (is_error) {
[09:28:19.887]                   sessionInformation <- function() {
[09:28:19.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:19.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:19.887]                       search = base::search(), system = base::Sys.info())
[09:28:19.887]                   }
[09:28:19.887]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:19.887]                     cond$call), session = sessionInformation(), 
[09:28:19.887]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:19.887]                   signalCondition(cond)
[09:28:19.887]                 }
[09:28:19.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:19.887]                 "immediateCondition"))) {
[09:28:19.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:19.887]                   ...future.conditions[[length(...future.conditions) + 
[09:28:19.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:19.887]                   if (TRUE && !signal) {
[09:28:19.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.887]                     {
[09:28:19.887]                       inherits <- base::inherits
[09:28:19.887]                       invokeRestart <- base::invokeRestart
[09:28:19.887]                       is.null <- base::is.null
[09:28:19.887]                       muffled <- FALSE
[09:28:19.887]                       if (inherits(cond, "message")) {
[09:28:19.887]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.887]                         if (muffled) 
[09:28:19.887]                           invokeRestart("muffleMessage")
[09:28:19.887]                       }
[09:28:19.887]                       else if (inherits(cond, "warning")) {
[09:28:19.887]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.887]                         if (muffled) 
[09:28:19.887]                           invokeRestart("muffleWarning")
[09:28:19.887]                       }
[09:28:19.887]                       else if (inherits(cond, "condition")) {
[09:28:19.887]                         if (!is.null(pattern)) {
[09:28:19.887]                           computeRestarts <- base::computeRestarts
[09:28:19.887]                           grepl <- base::grepl
[09:28:19.887]                           restarts <- computeRestarts(cond)
[09:28:19.887]                           for (restart in restarts) {
[09:28:19.887]                             name <- restart$name
[09:28:19.887]                             if (is.null(name)) 
[09:28:19.887]                               next
[09:28:19.887]                             if (!grepl(pattern, name)) 
[09:28:19.887]                               next
[09:28:19.887]                             invokeRestart(restart)
[09:28:19.887]                             muffled <- TRUE
[09:28:19.887]                             break
[09:28:19.887]                           }
[09:28:19.887]                         }
[09:28:19.887]                       }
[09:28:19.887]                       invisible(muffled)
[09:28:19.887]                     }
[09:28:19.887]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.887]                   }
[09:28:19.887]                 }
[09:28:19.887]                 else {
[09:28:19.887]                   if (TRUE) {
[09:28:19.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:19.887]                     {
[09:28:19.887]                       inherits <- base::inherits
[09:28:19.887]                       invokeRestart <- base::invokeRestart
[09:28:19.887]                       is.null <- base::is.null
[09:28:19.887]                       muffled <- FALSE
[09:28:19.887]                       if (inherits(cond, "message")) {
[09:28:19.887]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:19.887]                         if (muffled) 
[09:28:19.887]                           invokeRestart("muffleMessage")
[09:28:19.887]                       }
[09:28:19.887]                       else if (inherits(cond, "warning")) {
[09:28:19.887]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:19.887]                         if (muffled) 
[09:28:19.887]                           invokeRestart("muffleWarning")
[09:28:19.887]                       }
[09:28:19.887]                       else if (inherits(cond, "condition")) {
[09:28:19.887]                         if (!is.null(pattern)) {
[09:28:19.887]                           computeRestarts <- base::computeRestarts
[09:28:19.887]                           grepl <- base::grepl
[09:28:19.887]                           restarts <- computeRestarts(cond)
[09:28:19.887]                           for (restart in restarts) {
[09:28:19.887]                             name <- restart$name
[09:28:19.887]                             if (is.null(name)) 
[09:28:19.887]                               next
[09:28:19.887]                             if (!grepl(pattern, name)) 
[09:28:19.887]                               next
[09:28:19.887]                             invokeRestart(restart)
[09:28:19.887]                             muffled <- TRUE
[09:28:19.887]                             break
[09:28:19.887]                           }
[09:28:19.887]                         }
[09:28:19.887]                       }
[09:28:19.887]                       invisible(muffled)
[09:28:19.887]                     }
[09:28:19.887]                     muffleCondition(cond, pattern = "^muffle")
[09:28:19.887]                   }
[09:28:19.887]                 }
[09:28:19.887]             }
[09:28:19.887]         }))
[09:28:19.887]     }, error = function(ex) {
[09:28:19.887]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:19.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:19.887]                 ...future.rng), started = ...future.startTime, 
[09:28:19.887]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:19.887]             version = "1.8"), class = "FutureResult")
[09:28:19.887]     }, finally = {
[09:28:19.887]         if (!identical(...future.workdir, getwd())) 
[09:28:19.887]             setwd(...future.workdir)
[09:28:19.887]         {
[09:28:19.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:19.887]                 ...future.oldOptions$nwarnings <- NULL
[09:28:19.887]             }
[09:28:19.887]             base::options(...future.oldOptions)
[09:28:19.887]             if (.Platform$OS.type == "windows") {
[09:28:19.887]                 old_names <- names(...future.oldEnvVars)
[09:28:19.887]                 envs <- base::Sys.getenv()
[09:28:19.887]                 names <- names(envs)
[09:28:19.887]                 common <- intersect(names, old_names)
[09:28:19.887]                 added <- setdiff(names, old_names)
[09:28:19.887]                 removed <- setdiff(old_names, names)
[09:28:19.887]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:19.887]                   envs[common]]
[09:28:19.887]                 NAMES <- toupper(changed)
[09:28:19.887]                 args <- list()
[09:28:19.887]                 for (kk in seq_along(NAMES)) {
[09:28:19.887]                   name <- changed[[kk]]
[09:28:19.887]                   NAME <- NAMES[[kk]]
[09:28:19.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.887]                     next
[09:28:19.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.887]                 }
[09:28:19.887]                 NAMES <- toupper(added)
[09:28:19.887]                 for (kk in seq_along(NAMES)) {
[09:28:19.887]                   name <- added[[kk]]
[09:28:19.887]                   NAME <- NAMES[[kk]]
[09:28:19.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.887]                     next
[09:28:19.887]                   args[[name]] <- ""
[09:28:19.887]                 }
[09:28:19.887]                 NAMES <- toupper(removed)
[09:28:19.887]                 for (kk in seq_along(NAMES)) {
[09:28:19.887]                   name <- removed[[kk]]
[09:28:19.887]                   NAME <- NAMES[[kk]]
[09:28:19.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:19.887]                     next
[09:28:19.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:19.887]                 }
[09:28:19.887]                 if (length(args) > 0) 
[09:28:19.887]                   base::do.call(base::Sys.setenv, args = args)
[09:28:19.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:19.887]             }
[09:28:19.887]             else {
[09:28:19.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:19.887]             }
[09:28:19.887]             {
[09:28:19.887]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:19.887]                   0L) {
[09:28:19.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:19.887]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:19.887]                   base::options(opts)
[09:28:19.887]                 }
[09:28:19.887]                 {
[09:28:19.887]                   {
[09:28:19.887]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:19.887]                     NULL
[09:28:19.887]                   }
[09:28:19.887]                   options(future.plan = NULL)
[09:28:19.887]                   if (is.na(NA_character_)) 
[09:28:19.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:19.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:19.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:19.887]                     .init = FALSE)
[09:28:19.887]                 }
[09:28:19.887]             }
[09:28:19.887]         }
[09:28:19.887]     })
[09:28:19.887]     if (TRUE) {
[09:28:19.887]         base::sink(type = "output", split = FALSE)
[09:28:19.887]         if (TRUE) {
[09:28:19.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:19.887]         }
[09:28:19.887]         else {
[09:28:19.887]             ...future.result["stdout"] <- base::list(NULL)
[09:28:19.887]         }
[09:28:19.887]         base::close(...future.stdout)
[09:28:19.887]         ...future.stdout <- NULL
[09:28:19.887]     }
[09:28:19.887]     ...future.result$conditions <- ...future.conditions
[09:28:19.887]     ...future.result$finished <- base::Sys.time()
[09:28:19.887]     ...future.result
[09:28:19.887] }
[09:28:19.939] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[09:28:19.939] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:19.940] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:19.940] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[09:28:19.984] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[09:28:19.984] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[09:28:19.985] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[09:28:19.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:19.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:19.985] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:19.986] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:19.986] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[09:28:19.986] MultisessionFuture started
[09:28:19.986] - Launch lazy future ... done
[09:28:19.986] run() for ‘MultisessionFuture’ ... done
[09:28:19.986] Created future:
[09:28:19.987] MultisessionFuture:
[09:28:19.987] Label: ‘future_apply-2’
[09:28:19.987] Expression:
[09:28:19.987] {
[09:28:19.987]     do.call(function(...) {
[09:28:19.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:19.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:19.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:19.987]             on.exit(options(oopts), add = TRUE)
[09:28:19.987]         }
[09:28:19.987]         {
[09:28:19.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:19.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:19.987]                 ...future.FUN(...future.X_jj, ...)
[09:28:19.987]             })
[09:28:19.987]         }
[09:28:19.987]     }, args = future.call.arguments)
[09:28:19.987] }
[09:28:19.987] Lazy evaluation: FALSE
[09:28:19.987] Asynchronous evaluation: TRUE
[09:28:19.987] Local evaluation: TRUE
[09:28:19.987] Environment: R_GlobalEnv
[09:28:19.987] Capture standard output: TRUE
[09:28:19.987] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:19.987] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:19.987] Packages: <none>
[09:28:19.987] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:19.987] Resolved: FALSE
[09:28:19.987] Value: <not collected>
[09:28:19.987] Conditions captured: <none>
[09:28:19.987] Early signaling: FALSE
[09:28:19.987] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:19.987] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:19.998] Chunk #2 of 2 ... DONE
[09:28:19.998] Launching 2 futures (chunks) ... DONE
[09:28:19.999] Resolving 2 futures (chunks) ...
[09:28:19.999] resolve() on list ...
[09:28:19.999]  recursive: 0
[09:28:19.999]  length: 2
[09:28:19.999] 
[09:28:20.000] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.000] - Validating connection of MultisessionFuture
[09:28:20.000] - received message: FutureResult
[09:28:20.000] - Received FutureResult
[09:28:20.000] - Erased future from FutureRegistry
[09:28:20.000] result() for ClusterFuture ...
[09:28:20.000] - result already collected: FutureResult
[09:28:20.000] result() for ClusterFuture ... done
[09:28:20.000] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.001] Future #1
[09:28:20.001] result() for ClusterFuture ...
[09:28:20.001] - result already collected: FutureResult
[09:28:20.001] result() for ClusterFuture ... done
[09:28:20.001] result() for ClusterFuture ...
[09:28:20.001] - result already collected: FutureResult
[09:28:20.001] result() for ClusterFuture ... done
[09:28:20.001] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.001] - nx: 2
[09:28:20.001] - relay: TRUE
[09:28:20.002] - stdout: TRUE
[09:28:20.002] - signal: TRUE
[09:28:20.002] - resignal: FALSE
[09:28:20.002] - force: TRUE
[09:28:20.002] - relayed: [n=2] FALSE, FALSE
[09:28:20.002] - queued futures: [n=2] FALSE, FALSE
[09:28:20.002]  - until=1
[09:28:20.002]  - relaying element #1
[09:28:20.002] result() for ClusterFuture ...
[09:28:20.003] - result already collected: FutureResult
[09:28:20.003] result() for ClusterFuture ... done
[09:28:20.003] result() for ClusterFuture ...
[09:28:20.003] - result already collected: FutureResult
[09:28:20.003] result() for ClusterFuture ... done
[09:28:20.003] result() for ClusterFuture ...
[09:28:20.003] - result already collected: FutureResult
[09:28:20.003] result() for ClusterFuture ... done
[09:28:20.004] result() for ClusterFuture ...
[09:28:20.004] - result already collected: FutureResult
[09:28:20.004] result() for ClusterFuture ... done
[09:28:20.004] - relayed: [n=2] TRUE, FALSE
[09:28:20.004] - queued futures: [n=2] TRUE, FALSE
[09:28:20.004] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.004]  length: 1 (resolved future 1)
[09:28:20.067] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.067] - Validating connection of MultisessionFuture
[09:28:20.067] - received message: FutureResult
[09:28:20.067] - Received FutureResult
[09:28:20.067] - Erased future from FutureRegistry
[09:28:20.068] result() for ClusterFuture ...
[09:28:20.068] - result already collected: FutureResult
[09:28:20.068] result() for ClusterFuture ... done
[09:28:20.068] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.068] Future #2
[09:28:20.068] result() for ClusterFuture ...
[09:28:20.068] - result already collected: FutureResult
[09:28:20.068] result() for ClusterFuture ... done
[09:28:20.068] result() for ClusterFuture ...
[09:28:20.068] - result already collected: FutureResult
[09:28:20.068] result() for ClusterFuture ... done
[09:28:20.069] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.069] - nx: 2
[09:28:20.069] - relay: TRUE
[09:28:20.069] - stdout: TRUE
[09:28:20.069] - signal: TRUE
[09:28:20.069] - resignal: FALSE
[09:28:20.069] - force: TRUE
[09:28:20.069] - relayed: [n=2] TRUE, FALSE
[09:28:20.069] - queued futures: [n=2] TRUE, FALSE
[09:28:20.069]  - until=2
[09:28:20.069]  - relaying element #2
[09:28:20.069] result() for ClusterFuture ...
[09:28:20.070] - result already collected: FutureResult
[09:28:20.070] result() for ClusterFuture ... done
[09:28:20.070] result() for ClusterFuture ...
[09:28:20.070] - result already collected: FutureResult
[09:28:20.070] result() for ClusterFuture ... done
[09:28:20.070] result() for ClusterFuture ...
[09:28:20.070] - result already collected: FutureResult
[09:28:20.070] result() for ClusterFuture ... done
[09:28:20.070] result() for ClusterFuture ...
[09:28:20.070] - result already collected: FutureResult
[09:28:20.070] result() for ClusterFuture ... done
[09:28:20.070] - relayed: [n=2] TRUE, TRUE
[09:28:20.071] - queued futures: [n=2] TRUE, TRUE
[09:28:20.071] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.071]  length: 0 (resolved future 2)
[09:28:20.071] Relaying remaining futures
[09:28:20.071] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.071] - nx: 2
[09:28:20.071] - relay: TRUE
[09:28:20.071] - stdout: TRUE
[09:28:20.071] - signal: TRUE
[09:28:20.071] - resignal: FALSE
[09:28:20.071] - force: TRUE
[09:28:20.072] - relayed: [n=2] TRUE, TRUE
[09:28:20.072] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.072] - relayed: [n=2] TRUE, TRUE
[09:28:20.072] - queued futures: [n=2] TRUE, TRUE
[09:28:20.072] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.072] resolve() on list ... DONE
[09:28:20.072] result() for ClusterFuture ...
[09:28:20.072] - result already collected: FutureResult
[09:28:20.072] result() for ClusterFuture ... done
[09:28:20.072] result() for ClusterFuture ...
[09:28:20.072] - result already collected: FutureResult
[09:28:20.073] result() for ClusterFuture ... done
[09:28:20.073] result() for ClusterFuture ...
[09:28:20.073] - result already collected: FutureResult
[09:28:20.073] result() for ClusterFuture ... done
[09:28:20.073] result() for ClusterFuture ...
[09:28:20.073] - result already collected: FutureResult
[09:28:20.073] result() for ClusterFuture ... done
[09:28:20.073]  - Number of value chunks collected: 2
[09:28:20.073] Resolving 2 futures (chunks) ... DONE
[09:28:20.073] Reducing values from 2 chunks ...
[09:28:20.073]  - Number of values collected after concatenation: 2
[09:28:20.074]  - Number of values expected: 2
[09:28:20.074] Reducing values from 2 chunks ... DONE
[09:28:20.074] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:20.074] getGlobalsAndPackagesXApply() ...
[09:28:20.074]  - future.globals: TRUE
[09:28:20.074] getGlobalsAndPackages() ...
[09:28:20.074] Searching for globals...
[09:28:20.105] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[09:28:20.106] Searching for globals ... DONE
[09:28:20.106] Resolving globals: FALSE
[09:28:20.107] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[09:28:20.108] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[09:28:20.108] - globals: [1] ‘FUN’
[09:28:20.108] 
[09:28:20.108] getGlobalsAndPackages() ... DONE
[09:28:20.108]  - globals found/used: [n=1] ‘FUN’
[09:28:20.108]  - needed namespaces: [n=0] 
[09:28:20.108] Finding globals ... DONE
[09:28:20.108]  - use_args: TRUE
[09:28:20.108]  - Getting '...' globals ...
[09:28:20.109] resolve() on list ...
[09:28:20.109]  recursive: 0
[09:28:20.109]  length: 1
[09:28:20.109]  elements: ‘...’
[09:28:20.109]  length: 0 (resolved future 1)
[09:28:20.109] resolve() on list ... DONE
[09:28:20.109]    - '...' content: [n=0] 
[09:28:20.109] List of 1
[09:28:20.109]  $ ...: list()
[09:28:20.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.109]  - attr(*, "where")=List of 1
[09:28:20.109]   ..$ ...:<environment: 0x559ba2b87b30> 
[09:28:20.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.109]  - attr(*, "resolved")= logi TRUE
[09:28:20.109]  - attr(*, "total_size")= num NA
[09:28:20.112]  - Getting '...' globals ... DONE
[09:28:20.112] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.112] List of 2
[09:28:20.112]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:20.112]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:20.112]  $ ...          : list()
[09:28:20.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.112]  - attr(*, "where")=List of 2
[09:28:20.112]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.112]   ..$ ...          :<environment: 0x559ba2b87b30> 
[09:28:20.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.112]  - attr(*, "resolved")= logi FALSE
[09:28:20.112]  - attr(*, "total_size")= num 354224
[09:28:20.115] Packages to be attached in all futures: [n=0] 
[09:28:20.115] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.119] future_lapply() ...
[09:28:20.156] Number of chunks: 2
[09:28:20.156] getGlobalsAndPackagesXApply() ...
[09:28:20.156]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.156]  - use_args: TRUE
[09:28:20.156] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.156] List of 2
[09:28:20.156]  $ ...          : list()
[09:28:20.156]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.156]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[09:28:20.156]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[09:28:20.156]  - attr(*, "where")=List of 2
[09:28:20.156]   ..$ ...          :<environment: 0x559ba2b87b30> 
[09:28:20.156]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:20.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.156]  - attr(*, "resolved")= logi FALSE
[09:28:20.156]  - attr(*, "total_size")= num NA
[09:28:20.160] Packages to be attached in all futures: [n=0] 
[09:28:20.160] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.160] Number of futures (= number of chunks): 2
[09:28:20.160] Launching 2 futures (chunks) ...
[09:28:20.160] Chunk #1 of 2 ...
[09:28:20.160]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.161]  - seeds: <none>
[09:28:20.161]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.161] getGlobalsAndPackages() ...
[09:28:20.161] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.161] Resolving globals: FALSE
[09:28:20.161] Tweak future expression to call with '...' arguments ...
[09:28:20.161] {
[09:28:20.161]     do.call(function(...) {
[09:28:20.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.161]             on.exit(options(oopts), add = TRUE)
[09:28:20.161]         }
[09:28:20.161]         {
[09:28:20.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.161]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.161]             })
[09:28:20.161]         }
[09:28:20.161]     }, args = future.call.arguments)
[09:28:20.161] }
[09:28:20.161] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.162] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.162] 
[09:28:20.162] getGlobalsAndPackages() ... DONE
[09:28:20.162] run() for ‘Future’ ...
[09:28:20.162] - state: ‘created’
[09:28:20.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.176]   - Field: ‘node’
[09:28:20.176]   - Field: ‘label’
[09:28:20.176]   - Field: ‘local’
[09:28:20.177]   - Field: ‘owner’
[09:28:20.177]   - Field: ‘envir’
[09:28:20.177]   - Field: ‘workers’
[09:28:20.177]   - Field: ‘packages’
[09:28:20.177]   - Field: ‘gc’
[09:28:20.177]   - Field: ‘conditions’
[09:28:20.177]   - Field: ‘persistent’
[09:28:20.177]   - Field: ‘expr’
[09:28:20.177]   - Field: ‘uuid’
[09:28:20.177]   - Field: ‘seed’
[09:28:20.177]   - Field: ‘version’
[09:28:20.178]   - Field: ‘result’
[09:28:20.178]   - Field: ‘asynchronous’
[09:28:20.178]   - Field: ‘calls’
[09:28:20.178]   - Field: ‘globals’
[09:28:20.178]   - Field: ‘stdout’
[09:28:20.178]   - Field: ‘earlySignal’
[09:28:20.178]   - Field: ‘lazy’
[09:28:20.178]   - Field: ‘state’
[09:28:20.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.178] - Launch lazy future ...
[09:28:20.179] Packages needed by the future expression (n = 0): <none>
[09:28:20.179] Packages needed by future strategies (n = 0): <none>
[09:28:20.179] {
[09:28:20.179]     {
[09:28:20.179]         {
[09:28:20.179]             ...future.startTime <- base::Sys.time()
[09:28:20.179]             {
[09:28:20.179]                 {
[09:28:20.179]                   {
[09:28:20.179]                     {
[09:28:20.179]                       base::local({
[09:28:20.179]                         has_future <- base::requireNamespace("future", 
[09:28:20.179]                           quietly = TRUE)
[09:28:20.179]                         if (has_future) {
[09:28:20.179]                           ns <- base::getNamespace("future")
[09:28:20.179]                           version <- ns[[".package"]][["version"]]
[09:28:20.179]                           if (is.null(version)) 
[09:28:20.179]                             version <- utils::packageVersion("future")
[09:28:20.179]                         }
[09:28:20.179]                         else {
[09:28:20.179]                           version <- NULL
[09:28:20.179]                         }
[09:28:20.179]                         if (!has_future || version < "1.8.0") {
[09:28:20.179]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.179]                             "", base::R.version$version.string), 
[09:28:20.179]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.179]                               "release", "version")], collapse = " "), 
[09:28:20.179]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.179]                             info)
[09:28:20.179]                           info <- base::paste(info, collapse = "; ")
[09:28:20.179]                           if (!has_future) {
[09:28:20.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.179]                               info)
[09:28:20.179]                           }
[09:28:20.179]                           else {
[09:28:20.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.179]                               info, version)
[09:28:20.179]                           }
[09:28:20.179]                           base::stop(msg)
[09:28:20.179]                         }
[09:28:20.179]                       })
[09:28:20.179]                     }
[09:28:20.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.179]                     base::options(mc.cores = 1L)
[09:28:20.179]                   }
[09:28:20.179]                   ...future.strategy.old <- future::plan("list")
[09:28:20.179]                   options(future.plan = NULL)
[09:28:20.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.179]                 }
[09:28:20.179]                 ...future.workdir <- getwd()
[09:28:20.179]             }
[09:28:20.179]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.179]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.179]         }
[09:28:20.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.179]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.179]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.179]             base::names(...future.oldOptions))
[09:28:20.179]     }
[09:28:20.179]     if (FALSE) {
[09:28:20.179]     }
[09:28:20.179]     else {
[09:28:20.179]         if (TRUE) {
[09:28:20.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.179]                 open = "w")
[09:28:20.179]         }
[09:28:20.179]         else {
[09:28:20.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.179]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.179]         }
[09:28:20.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.179]             base::sink(type = "output", split = FALSE)
[09:28:20.179]             base::close(...future.stdout)
[09:28:20.179]         }, add = TRUE)
[09:28:20.179]     }
[09:28:20.179]     ...future.frame <- base::sys.nframe()
[09:28:20.179]     ...future.conditions <- base::list()
[09:28:20.179]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.179]     if (FALSE) {
[09:28:20.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.179]     }
[09:28:20.179]     ...future.result <- base::tryCatch({
[09:28:20.179]         base::withCallingHandlers({
[09:28:20.179]             ...future.value <- base::withVisible(base::local({
[09:28:20.179]                 ...future.makeSendCondition <- base::local({
[09:28:20.179]                   sendCondition <- NULL
[09:28:20.179]                   function(frame = 1L) {
[09:28:20.179]                     if (is.function(sendCondition)) 
[09:28:20.179]                       return(sendCondition)
[09:28:20.179]                     ns <- getNamespace("parallel")
[09:28:20.179]                     if (exists("sendData", mode = "function", 
[09:28:20.179]                       envir = ns)) {
[09:28:20.179]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.179]                         envir = ns)
[09:28:20.179]                       envir <- sys.frame(frame)
[09:28:20.179]                       master <- NULL
[09:28:20.179]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.179]                         !identical(envir, emptyenv())) {
[09:28:20.179]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.179]                           inherits = FALSE)) {
[09:28:20.179]                           master <- get("master", mode = "list", 
[09:28:20.179]                             envir = envir, inherits = FALSE)
[09:28:20.179]                           if (inherits(master, c("SOCKnode", 
[09:28:20.179]                             "SOCK0node"))) {
[09:28:20.179]                             sendCondition <<- function(cond) {
[09:28:20.179]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.179]                                 success = TRUE)
[09:28:20.179]                               parallel_sendData(master, data)
[09:28:20.179]                             }
[09:28:20.179]                             return(sendCondition)
[09:28:20.179]                           }
[09:28:20.179]                         }
[09:28:20.179]                         frame <- frame + 1L
[09:28:20.179]                         envir <- sys.frame(frame)
[09:28:20.179]                       }
[09:28:20.179]                     }
[09:28:20.179]                     sendCondition <<- function(cond) NULL
[09:28:20.179]                   }
[09:28:20.179]                 })
[09:28:20.179]                 withCallingHandlers({
[09:28:20.179]                   {
[09:28:20.179]                     do.call(function(...) {
[09:28:20.179]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.179]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.179]                         ...future.globals.maxSize)) {
[09:28:20.179]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.179]                         on.exit(options(oopts), add = TRUE)
[09:28:20.179]                       }
[09:28:20.179]                       {
[09:28:20.179]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.179]                           FUN = function(jj) {
[09:28:20.179]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.179]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.179]                           })
[09:28:20.179]                       }
[09:28:20.179]                     }, args = future.call.arguments)
[09:28:20.179]                   }
[09:28:20.179]                 }, immediateCondition = function(cond) {
[09:28:20.179]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.179]                   sendCondition(cond)
[09:28:20.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.179]                   {
[09:28:20.179]                     inherits <- base::inherits
[09:28:20.179]                     invokeRestart <- base::invokeRestart
[09:28:20.179]                     is.null <- base::is.null
[09:28:20.179]                     muffled <- FALSE
[09:28:20.179]                     if (inherits(cond, "message")) {
[09:28:20.179]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.179]                       if (muffled) 
[09:28:20.179]                         invokeRestart("muffleMessage")
[09:28:20.179]                     }
[09:28:20.179]                     else if (inherits(cond, "warning")) {
[09:28:20.179]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.179]                       if (muffled) 
[09:28:20.179]                         invokeRestart("muffleWarning")
[09:28:20.179]                     }
[09:28:20.179]                     else if (inherits(cond, "condition")) {
[09:28:20.179]                       if (!is.null(pattern)) {
[09:28:20.179]                         computeRestarts <- base::computeRestarts
[09:28:20.179]                         grepl <- base::grepl
[09:28:20.179]                         restarts <- computeRestarts(cond)
[09:28:20.179]                         for (restart in restarts) {
[09:28:20.179]                           name <- restart$name
[09:28:20.179]                           if (is.null(name)) 
[09:28:20.179]                             next
[09:28:20.179]                           if (!grepl(pattern, name)) 
[09:28:20.179]                             next
[09:28:20.179]                           invokeRestart(restart)
[09:28:20.179]                           muffled <- TRUE
[09:28:20.179]                           break
[09:28:20.179]                         }
[09:28:20.179]                       }
[09:28:20.179]                     }
[09:28:20.179]                     invisible(muffled)
[09:28:20.179]                   }
[09:28:20.179]                   muffleCondition(cond)
[09:28:20.179]                 })
[09:28:20.179]             }))
[09:28:20.179]             future::FutureResult(value = ...future.value$value, 
[09:28:20.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.179]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.179]                     ...future.globalenv.names))
[09:28:20.179]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.179]         }, condition = base::local({
[09:28:20.179]             c <- base::c
[09:28:20.179]             inherits <- base::inherits
[09:28:20.179]             invokeRestart <- base::invokeRestart
[09:28:20.179]             length <- base::length
[09:28:20.179]             list <- base::list
[09:28:20.179]             seq.int <- base::seq.int
[09:28:20.179]             signalCondition <- base::signalCondition
[09:28:20.179]             sys.calls <- base::sys.calls
[09:28:20.179]             `[[` <- base::`[[`
[09:28:20.179]             `+` <- base::`+`
[09:28:20.179]             `<<-` <- base::`<<-`
[09:28:20.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.179]                   3L)]
[09:28:20.179]             }
[09:28:20.179]             function(cond) {
[09:28:20.179]                 is_error <- inherits(cond, "error")
[09:28:20.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.179]                   NULL)
[09:28:20.179]                 if (is_error) {
[09:28:20.179]                   sessionInformation <- function() {
[09:28:20.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.179]                       search = base::search(), system = base::Sys.info())
[09:28:20.179]                   }
[09:28:20.179]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.179]                     cond$call), session = sessionInformation(), 
[09:28:20.179]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.179]                   signalCondition(cond)
[09:28:20.179]                 }
[09:28:20.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.179]                 "immediateCondition"))) {
[09:28:20.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.179]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.179]                   if (TRUE && !signal) {
[09:28:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.179]                     {
[09:28:20.179]                       inherits <- base::inherits
[09:28:20.179]                       invokeRestart <- base::invokeRestart
[09:28:20.179]                       is.null <- base::is.null
[09:28:20.179]                       muffled <- FALSE
[09:28:20.179]                       if (inherits(cond, "message")) {
[09:28:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.179]                         if (muffled) 
[09:28:20.179]                           invokeRestart("muffleMessage")
[09:28:20.179]                       }
[09:28:20.179]                       else if (inherits(cond, "warning")) {
[09:28:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.179]                         if (muffled) 
[09:28:20.179]                           invokeRestart("muffleWarning")
[09:28:20.179]                       }
[09:28:20.179]                       else if (inherits(cond, "condition")) {
[09:28:20.179]                         if (!is.null(pattern)) {
[09:28:20.179]                           computeRestarts <- base::computeRestarts
[09:28:20.179]                           grepl <- base::grepl
[09:28:20.179]                           restarts <- computeRestarts(cond)
[09:28:20.179]                           for (restart in restarts) {
[09:28:20.179]                             name <- restart$name
[09:28:20.179]                             if (is.null(name)) 
[09:28:20.179]                               next
[09:28:20.179]                             if (!grepl(pattern, name)) 
[09:28:20.179]                               next
[09:28:20.179]                             invokeRestart(restart)
[09:28:20.179]                             muffled <- TRUE
[09:28:20.179]                             break
[09:28:20.179]                           }
[09:28:20.179]                         }
[09:28:20.179]                       }
[09:28:20.179]                       invisible(muffled)
[09:28:20.179]                     }
[09:28:20.179]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.179]                   }
[09:28:20.179]                 }
[09:28:20.179]                 else {
[09:28:20.179]                   if (TRUE) {
[09:28:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.179]                     {
[09:28:20.179]                       inherits <- base::inherits
[09:28:20.179]                       invokeRestart <- base::invokeRestart
[09:28:20.179]                       is.null <- base::is.null
[09:28:20.179]                       muffled <- FALSE
[09:28:20.179]                       if (inherits(cond, "message")) {
[09:28:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.179]                         if (muffled) 
[09:28:20.179]                           invokeRestart("muffleMessage")
[09:28:20.179]                       }
[09:28:20.179]                       else if (inherits(cond, "warning")) {
[09:28:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.179]                         if (muffled) 
[09:28:20.179]                           invokeRestart("muffleWarning")
[09:28:20.179]                       }
[09:28:20.179]                       else if (inherits(cond, "condition")) {
[09:28:20.179]                         if (!is.null(pattern)) {
[09:28:20.179]                           computeRestarts <- base::computeRestarts
[09:28:20.179]                           grepl <- base::grepl
[09:28:20.179]                           restarts <- computeRestarts(cond)
[09:28:20.179]                           for (restart in restarts) {
[09:28:20.179]                             name <- restart$name
[09:28:20.179]                             if (is.null(name)) 
[09:28:20.179]                               next
[09:28:20.179]                             if (!grepl(pattern, name)) 
[09:28:20.179]                               next
[09:28:20.179]                             invokeRestart(restart)
[09:28:20.179]                             muffled <- TRUE
[09:28:20.179]                             break
[09:28:20.179]                           }
[09:28:20.179]                         }
[09:28:20.179]                       }
[09:28:20.179]                       invisible(muffled)
[09:28:20.179]                     }
[09:28:20.179]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.179]                   }
[09:28:20.179]                 }
[09:28:20.179]             }
[09:28:20.179]         }))
[09:28:20.179]     }, error = function(ex) {
[09:28:20.179]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.179]                 ...future.rng), started = ...future.startTime, 
[09:28:20.179]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.179]             version = "1.8"), class = "FutureResult")
[09:28:20.179]     }, finally = {
[09:28:20.179]         if (!identical(...future.workdir, getwd())) 
[09:28:20.179]             setwd(...future.workdir)
[09:28:20.179]         {
[09:28:20.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.179]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.179]             }
[09:28:20.179]             base::options(...future.oldOptions)
[09:28:20.179]             if (.Platform$OS.type == "windows") {
[09:28:20.179]                 old_names <- names(...future.oldEnvVars)
[09:28:20.179]                 envs <- base::Sys.getenv()
[09:28:20.179]                 names <- names(envs)
[09:28:20.179]                 common <- intersect(names, old_names)
[09:28:20.179]                 added <- setdiff(names, old_names)
[09:28:20.179]                 removed <- setdiff(old_names, names)
[09:28:20.179]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.179]                   envs[common]]
[09:28:20.179]                 NAMES <- toupper(changed)
[09:28:20.179]                 args <- list()
[09:28:20.179]                 for (kk in seq_along(NAMES)) {
[09:28:20.179]                   name <- changed[[kk]]
[09:28:20.179]                   NAME <- NAMES[[kk]]
[09:28:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.179]                     next
[09:28:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.179]                 }
[09:28:20.179]                 NAMES <- toupper(added)
[09:28:20.179]                 for (kk in seq_along(NAMES)) {
[09:28:20.179]                   name <- added[[kk]]
[09:28:20.179]                   NAME <- NAMES[[kk]]
[09:28:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.179]                     next
[09:28:20.179]                   args[[name]] <- ""
[09:28:20.179]                 }
[09:28:20.179]                 NAMES <- toupper(removed)
[09:28:20.179]                 for (kk in seq_along(NAMES)) {
[09:28:20.179]                   name <- removed[[kk]]
[09:28:20.179]                   NAME <- NAMES[[kk]]
[09:28:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.179]                     next
[09:28:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.179]                 }
[09:28:20.179]                 if (length(args) > 0) 
[09:28:20.179]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.179]             }
[09:28:20.179]             else {
[09:28:20.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.179]             }
[09:28:20.179]             {
[09:28:20.179]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.179]                   0L) {
[09:28:20.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.179]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.179]                   base::options(opts)
[09:28:20.179]                 }
[09:28:20.179]                 {
[09:28:20.179]                   {
[09:28:20.179]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.179]                     NULL
[09:28:20.179]                   }
[09:28:20.179]                   options(future.plan = NULL)
[09:28:20.179]                   if (is.na(NA_character_)) 
[09:28:20.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.179]                     .init = FALSE)
[09:28:20.179]                 }
[09:28:20.179]             }
[09:28:20.179]         }
[09:28:20.179]     })
[09:28:20.179]     if (TRUE) {
[09:28:20.179]         base::sink(type = "output", split = FALSE)
[09:28:20.179]         if (TRUE) {
[09:28:20.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.179]         }
[09:28:20.179]         else {
[09:28:20.179]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.179]         }
[09:28:20.179]         base::close(...future.stdout)
[09:28:20.179]         ...future.stdout <- NULL
[09:28:20.179]     }
[09:28:20.179]     ...future.result$conditions <- ...future.conditions
[09:28:20.179]     ...future.result$finished <- base::Sys.time()
[09:28:20.179]     ...future.result
[09:28:20.179] }
[09:28:20.182] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[09:28:20.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.183] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.183] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[09:28:20.228] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[09:28:20.228] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[09:28:20.228] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[09:28:20.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.229] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.229] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.230] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[09:28:20.230] MultisessionFuture started
[09:28:20.230] - Launch lazy future ... done
[09:28:20.230] run() for ‘MultisessionFuture’ ... done
[09:28:20.230] Created future:
[09:28:20.230] MultisessionFuture:
[09:28:20.230] Label: ‘future_apply-1’
[09:28:20.230] Expression:
[09:28:20.230] {
[09:28:20.230]     do.call(function(...) {
[09:28:20.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.230]             on.exit(options(oopts), add = TRUE)
[09:28:20.230]         }
[09:28:20.230]         {
[09:28:20.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.230]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.230]             })
[09:28:20.230]         }
[09:28:20.230]     }, args = future.call.arguments)
[09:28:20.230] }
[09:28:20.230] Lazy evaluation: FALSE
[09:28:20.230] Asynchronous evaluation: TRUE
[09:28:20.230] Local evaluation: TRUE
[09:28:20.230] Environment: R_GlobalEnv
[09:28:20.230] Capture standard output: TRUE
[09:28:20.230] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.230] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.230] Packages: <none>
[09:28:20.230] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.230] Resolved: FALSE
[09:28:20.230] Value: <not collected>
[09:28:20.230] Conditions captured: <none>
[09:28:20.230] Early signaling: FALSE
[09:28:20.230] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.230] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.242] Chunk #1 of 2 ... DONE
[09:28:20.242] Chunk #2 of 2 ...
[09:28:20.242]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.242]  - seeds: <none>
[09:28:20.243]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.243] getGlobalsAndPackages() ...
[09:28:20.243] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.243] Resolving globals: FALSE
[09:28:20.243] Tweak future expression to call with '...' arguments ...
[09:28:20.243] {
[09:28:20.243]     do.call(function(...) {
[09:28:20.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.243]             on.exit(options(oopts), add = TRUE)
[09:28:20.243]         }
[09:28:20.243]         {
[09:28:20.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.243]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.243]             })
[09:28:20.243]         }
[09:28:20.243]     }, args = future.call.arguments)
[09:28:20.243] }
[09:28:20.243] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.244] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.244] 
[09:28:20.244] getGlobalsAndPackages() ... DONE
[09:28:20.244] run() for ‘Future’ ...
[09:28:20.244] - state: ‘created’
[09:28:20.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.258] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.258]   - Field: ‘node’
[09:28:20.258]   - Field: ‘label’
[09:28:20.258]   - Field: ‘local’
[09:28:20.258]   - Field: ‘owner’
[09:28:20.258]   - Field: ‘envir’
[09:28:20.258]   - Field: ‘workers’
[09:28:20.258]   - Field: ‘packages’
[09:28:20.258]   - Field: ‘gc’
[09:28:20.259]   - Field: ‘conditions’
[09:28:20.259]   - Field: ‘persistent’
[09:28:20.259]   - Field: ‘expr’
[09:28:20.259]   - Field: ‘uuid’
[09:28:20.259]   - Field: ‘seed’
[09:28:20.259]   - Field: ‘version’
[09:28:20.259]   - Field: ‘result’
[09:28:20.259]   - Field: ‘asynchronous’
[09:28:20.259]   - Field: ‘calls’
[09:28:20.259]   - Field: ‘globals’
[09:28:20.259]   - Field: ‘stdout’
[09:28:20.259]   - Field: ‘earlySignal’
[09:28:20.260]   - Field: ‘lazy’
[09:28:20.260]   - Field: ‘state’
[09:28:20.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.260] - Launch lazy future ...
[09:28:20.260] Packages needed by the future expression (n = 0): <none>
[09:28:20.260] Packages needed by future strategies (n = 0): <none>
[09:28:20.261] {
[09:28:20.261]     {
[09:28:20.261]         {
[09:28:20.261]             ...future.startTime <- base::Sys.time()
[09:28:20.261]             {
[09:28:20.261]                 {
[09:28:20.261]                   {
[09:28:20.261]                     {
[09:28:20.261]                       base::local({
[09:28:20.261]                         has_future <- base::requireNamespace("future", 
[09:28:20.261]                           quietly = TRUE)
[09:28:20.261]                         if (has_future) {
[09:28:20.261]                           ns <- base::getNamespace("future")
[09:28:20.261]                           version <- ns[[".package"]][["version"]]
[09:28:20.261]                           if (is.null(version)) 
[09:28:20.261]                             version <- utils::packageVersion("future")
[09:28:20.261]                         }
[09:28:20.261]                         else {
[09:28:20.261]                           version <- NULL
[09:28:20.261]                         }
[09:28:20.261]                         if (!has_future || version < "1.8.0") {
[09:28:20.261]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.261]                             "", base::R.version$version.string), 
[09:28:20.261]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.261]                               "release", "version")], collapse = " "), 
[09:28:20.261]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.261]                             info)
[09:28:20.261]                           info <- base::paste(info, collapse = "; ")
[09:28:20.261]                           if (!has_future) {
[09:28:20.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.261]                               info)
[09:28:20.261]                           }
[09:28:20.261]                           else {
[09:28:20.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.261]                               info, version)
[09:28:20.261]                           }
[09:28:20.261]                           base::stop(msg)
[09:28:20.261]                         }
[09:28:20.261]                       })
[09:28:20.261]                     }
[09:28:20.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.261]                     base::options(mc.cores = 1L)
[09:28:20.261]                   }
[09:28:20.261]                   ...future.strategy.old <- future::plan("list")
[09:28:20.261]                   options(future.plan = NULL)
[09:28:20.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.261]                 }
[09:28:20.261]                 ...future.workdir <- getwd()
[09:28:20.261]             }
[09:28:20.261]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.261]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.261]         }
[09:28:20.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.261]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.261]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.261]             base::names(...future.oldOptions))
[09:28:20.261]     }
[09:28:20.261]     if (FALSE) {
[09:28:20.261]     }
[09:28:20.261]     else {
[09:28:20.261]         if (TRUE) {
[09:28:20.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.261]                 open = "w")
[09:28:20.261]         }
[09:28:20.261]         else {
[09:28:20.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.261]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.261]         }
[09:28:20.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.261]             base::sink(type = "output", split = FALSE)
[09:28:20.261]             base::close(...future.stdout)
[09:28:20.261]         }, add = TRUE)
[09:28:20.261]     }
[09:28:20.261]     ...future.frame <- base::sys.nframe()
[09:28:20.261]     ...future.conditions <- base::list()
[09:28:20.261]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.261]     if (FALSE) {
[09:28:20.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.261]     }
[09:28:20.261]     ...future.result <- base::tryCatch({
[09:28:20.261]         base::withCallingHandlers({
[09:28:20.261]             ...future.value <- base::withVisible(base::local({
[09:28:20.261]                 ...future.makeSendCondition <- base::local({
[09:28:20.261]                   sendCondition <- NULL
[09:28:20.261]                   function(frame = 1L) {
[09:28:20.261]                     if (is.function(sendCondition)) 
[09:28:20.261]                       return(sendCondition)
[09:28:20.261]                     ns <- getNamespace("parallel")
[09:28:20.261]                     if (exists("sendData", mode = "function", 
[09:28:20.261]                       envir = ns)) {
[09:28:20.261]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.261]                         envir = ns)
[09:28:20.261]                       envir <- sys.frame(frame)
[09:28:20.261]                       master <- NULL
[09:28:20.261]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.261]                         !identical(envir, emptyenv())) {
[09:28:20.261]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.261]                           inherits = FALSE)) {
[09:28:20.261]                           master <- get("master", mode = "list", 
[09:28:20.261]                             envir = envir, inherits = FALSE)
[09:28:20.261]                           if (inherits(master, c("SOCKnode", 
[09:28:20.261]                             "SOCK0node"))) {
[09:28:20.261]                             sendCondition <<- function(cond) {
[09:28:20.261]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.261]                                 success = TRUE)
[09:28:20.261]                               parallel_sendData(master, data)
[09:28:20.261]                             }
[09:28:20.261]                             return(sendCondition)
[09:28:20.261]                           }
[09:28:20.261]                         }
[09:28:20.261]                         frame <- frame + 1L
[09:28:20.261]                         envir <- sys.frame(frame)
[09:28:20.261]                       }
[09:28:20.261]                     }
[09:28:20.261]                     sendCondition <<- function(cond) NULL
[09:28:20.261]                   }
[09:28:20.261]                 })
[09:28:20.261]                 withCallingHandlers({
[09:28:20.261]                   {
[09:28:20.261]                     do.call(function(...) {
[09:28:20.261]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.261]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.261]                         ...future.globals.maxSize)) {
[09:28:20.261]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.261]                         on.exit(options(oopts), add = TRUE)
[09:28:20.261]                       }
[09:28:20.261]                       {
[09:28:20.261]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.261]                           FUN = function(jj) {
[09:28:20.261]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.261]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.261]                           })
[09:28:20.261]                       }
[09:28:20.261]                     }, args = future.call.arguments)
[09:28:20.261]                   }
[09:28:20.261]                 }, immediateCondition = function(cond) {
[09:28:20.261]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.261]                   sendCondition(cond)
[09:28:20.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.261]                   {
[09:28:20.261]                     inherits <- base::inherits
[09:28:20.261]                     invokeRestart <- base::invokeRestart
[09:28:20.261]                     is.null <- base::is.null
[09:28:20.261]                     muffled <- FALSE
[09:28:20.261]                     if (inherits(cond, "message")) {
[09:28:20.261]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.261]                       if (muffled) 
[09:28:20.261]                         invokeRestart("muffleMessage")
[09:28:20.261]                     }
[09:28:20.261]                     else if (inherits(cond, "warning")) {
[09:28:20.261]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.261]                       if (muffled) 
[09:28:20.261]                         invokeRestart("muffleWarning")
[09:28:20.261]                     }
[09:28:20.261]                     else if (inherits(cond, "condition")) {
[09:28:20.261]                       if (!is.null(pattern)) {
[09:28:20.261]                         computeRestarts <- base::computeRestarts
[09:28:20.261]                         grepl <- base::grepl
[09:28:20.261]                         restarts <- computeRestarts(cond)
[09:28:20.261]                         for (restart in restarts) {
[09:28:20.261]                           name <- restart$name
[09:28:20.261]                           if (is.null(name)) 
[09:28:20.261]                             next
[09:28:20.261]                           if (!grepl(pattern, name)) 
[09:28:20.261]                             next
[09:28:20.261]                           invokeRestart(restart)
[09:28:20.261]                           muffled <- TRUE
[09:28:20.261]                           break
[09:28:20.261]                         }
[09:28:20.261]                       }
[09:28:20.261]                     }
[09:28:20.261]                     invisible(muffled)
[09:28:20.261]                   }
[09:28:20.261]                   muffleCondition(cond)
[09:28:20.261]                 })
[09:28:20.261]             }))
[09:28:20.261]             future::FutureResult(value = ...future.value$value, 
[09:28:20.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.261]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.261]                     ...future.globalenv.names))
[09:28:20.261]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.261]         }, condition = base::local({
[09:28:20.261]             c <- base::c
[09:28:20.261]             inherits <- base::inherits
[09:28:20.261]             invokeRestart <- base::invokeRestart
[09:28:20.261]             length <- base::length
[09:28:20.261]             list <- base::list
[09:28:20.261]             seq.int <- base::seq.int
[09:28:20.261]             signalCondition <- base::signalCondition
[09:28:20.261]             sys.calls <- base::sys.calls
[09:28:20.261]             `[[` <- base::`[[`
[09:28:20.261]             `+` <- base::`+`
[09:28:20.261]             `<<-` <- base::`<<-`
[09:28:20.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.261]                   3L)]
[09:28:20.261]             }
[09:28:20.261]             function(cond) {
[09:28:20.261]                 is_error <- inherits(cond, "error")
[09:28:20.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.261]                   NULL)
[09:28:20.261]                 if (is_error) {
[09:28:20.261]                   sessionInformation <- function() {
[09:28:20.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.261]                       search = base::search(), system = base::Sys.info())
[09:28:20.261]                   }
[09:28:20.261]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.261]                     cond$call), session = sessionInformation(), 
[09:28:20.261]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.261]                   signalCondition(cond)
[09:28:20.261]                 }
[09:28:20.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.261]                 "immediateCondition"))) {
[09:28:20.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.261]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.261]                   if (TRUE && !signal) {
[09:28:20.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.261]                     {
[09:28:20.261]                       inherits <- base::inherits
[09:28:20.261]                       invokeRestart <- base::invokeRestart
[09:28:20.261]                       is.null <- base::is.null
[09:28:20.261]                       muffled <- FALSE
[09:28:20.261]                       if (inherits(cond, "message")) {
[09:28:20.261]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.261]                         if (muffled) 
[09:28:20.261]                           invokeRestart("muffleMessage")
[09:28:20.261]                       }
[09:28:20.261]                       else if (inherits(cond, "warning")) {
[09:28:20.261]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.261]                         if (muffled) 
[09:28:20.261]                           invokeRestart("muffleWarning")
[09:28:20.261]                       }
[09:28:20.261]                       else if (inherits(cond, "condition")) {
[09:28:20.261]                         if (!is.null(pattern)) {
[09:28:20.261]                           computeRestarts <- base::computeRestarts
[09:28:20.261]                           grepl <- base::grepl
[09:28:20.261]                           restarts <- computeRestarts(cond)
[09:28:20.261]                           for (restart in restarts) {
[09:28:20.261]                             name <- restart$name
[09:28:20.261]                             if (is.null(name)) 
[09:28:20.261]                               next
[09:28:20.261]                             if (!grepl(pattern, name)) 
[09:28:20.261]                               next
[09:28:20.261]                             invokeRestart(restart)
[09:28:20.261]                             muffled <- TRUE
[09:28:20.261]                             break
[09:28:20.261]                           }
[09:28:20.261]                         }
[09:28:20.261]                       }
[09:28:20.261]                       invisible(muffled)
[09:28:20.261]                     }
[09:28:20.261]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.261]                   }
[09:28:20.261]                 }
[09:28:20.261]                 else {
[09:28:20.261]                   if (TRUE) {
[09:28:20.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.261]                     {
[09:28:20.261]                       inherits <- base::inherits
[09:28:20.261]                       invokeRestart <- base::invokeRestart
[09:28:20.261]                       is.null <- base::is.null
[09:28:20.261]                       muffled <- FALSE
[09:28:20.261]                       if (inherits(cond, "message")) {
[09:28:20.261]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.261]                         if (muffled) 
[09:28:20.261]                           invokeRestart("muffleMessage")
[09:28:20.261]                       }
[09:28:20.261]                       else if (inherits(cond, "warning")) {
[09:28:20.261]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.261]                         if (muffled) 
[09:28:20.261]                           invokeRestart("muffleWarning")
[09:28:20.261]                       }
[09:28:20.261]                       else if (inherits(cond, "condition")) {
[09:28:20.261]                         if (!is.null(pattern)) {
[09:28:20.261]                           computeRestarts <- base::computeRestarts
[09:28:20.261]                           grepl <- base::grepl
[09:28:20.261]                           restarts <- computeRestarts(cond)
[09:28:20.261]                           for (restart in restarts) {
[09:28:20.261]                             name <- restart$name
[09:28:20.261]                             if (is.null(name)) 
[09:28:20.261]                               next
[09:28:20.261]                             if (!grepl(pattern, name)) 
[09:28:20.261]                               next
[09:28:20.261]                             invokeRestart(restart)
[09:28:20.261]                             muffled <- TRUE
[09:28:20.261]                             break
[09:28:20.261]                           }
[09:28:20.261]                         }
[09:28:20.261]                       }
[09:28:20.261]                       invisible(muffled)
[09:28:20.261]                     }
[09:28:20.261]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.261]                   }
[09:28:20.261]                 }
[09:28:20.261]             }
[09:28:20.261]         }))
[09:28:20.261]     }, error = function(ex) {
[09:28:20.261]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.261]                 ...future.rng), started = ...future.startTime, 
[09:28:20.261]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.261]             version = "1.8"), class = "FutureResult")
[09:28:20.261]     }, finally = {
[09:28:20.261]         if (!identical(...future.workdir, getwd())) 
[09:28:20.261]             setwd(...future.workdir)
[09:28:20.261]         {
[09:28:20.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.261]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.261]             }
[09:28:20.261]             base::options(...future.oldOptions)
[09:28:20.261]             if (.Platform$OS.type == "windows") {
[09:28:20.261]                 old_names <- names(...future.oldEnvVars)
[09:28:20.261]                 envs <- base::Sys.getenv()
[09:28:20.261]                 names <- names(envs)
[09:28:20.261]                 common <- intersect(names, old_names)
[09:28:20.261]                 added <- setdiff(names, old_names)
[09:28:20.261]                 removed <- setdiff(old_names, names)
[09:28:20.261]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.261]                   envs[common]]
[09:28:20.261]                 NAMES <- toupper(changed)
[09:28:20.261]                 args <- list()
[09:28:20.261]                 for (kk in seq_along(NAMES)) {
[09:28:20.261]                   name <- changed[[kk]]
[09:28:20.261]                   NAME <- NAMES[[kk]]
[09:28:20.261]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.261]                     next
[09:28:20.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.261]                 }
[09:28:20.261]                 NAMES <- toupper(added)
[09:28:20.261]                 for (kk in seq_along(NAMES)) {
[09:28:20.261]                   name <- added[[kk]]
[09:28:20.261]                   NAME <- NAMES[[kk]]
[09:28:20.261]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.261]                     next
[09:28:20.261]                   args[[name]] <- ""
[09:28:20.261]                 }
[09:28:20.261]                 NAMES <- toupper(removed)
[09:28:20.261]                 for (kk in seq_along(NAMES)) {
[09:28:20.261]                   name <- removed[[kk]]
[09:28:20.261]                   NAME <- NAMES[[kk]]
[09:28:20.261]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.261]                     next
[09:28:20.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.261]                 }
[09:28:20.261]                 if (length(args) > 0) 
[09:28:20.261]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.261]             }
[09:28:20.261]             else {
[09:28:20.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.261]             }
[09:28:20.261]             {
[09:28:20.261]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.261]                   0L) {
[09:28:20.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.261]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.261]                   base::options(opts)
[09:28:20.261]                 }
[09:28:20.261]                 {
[09:28:20.261]                   {
[09:28:20.261]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.261]                     NULL
[09:28:20.261]                   }
[09:28:20.261]                   options(future.plan = NULL)
[09:28:20.261]                   if (is.na(NA_character_)) 
[09:28:20.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.261]                     .init = FALSE)
[09:28:20.261]                 }
[09:28:20.261]             }
[09:28:20.261]         }
[09:28:20.261]     })
[09:28:20.261]     if (TRUE) {
[09:28:20.261]         base::sink(type = "output", split = FALSE)
[09:28:20.261]         if (TRUE) {
[09:28:20.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.261]         }
[09:28:20.261]         else {
[09:28:20.261]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.261]         }
[09:28:20.261]         base::close(...future.stdout)
[09:28:20.261]         ...future.stdout <- NULL
[09:28:20.261]     }
[09:28:20.261]     ...future.result$conditions <- ...future.conditions
[09:28:20.261]     ...future.result$finished <- base::Sys.time()
[09:28:20.261]     ...future.result
[09:28:20.261] }
[09:28:20.264] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[09:28:20.264] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.264] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.264] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[09:28:20.308] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[09:28:20.308] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[09:28:20.309] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[09:28:20.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.310] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.310] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.310] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[09:28:20.310] MultisessionFuture started
[09:28:20.311] - Launch lazy future ... done
[09:28:20.311] run() for ‘MultisessionFuture’ ... done
[09:28:20.311] Created future:
[09:28:20.311] MultisessionFuture:
[09:28:20.311] Label: ‘future_apply-2’
[09:28:20.311] Expression:
[09:28:20.311] {
[09:28:20.311]     do.call(function(...) {
[09:28:20.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.311]             on.exit(options(oopts), add = TRUE)
[09:28:20.311]         }
[09:28:20.311]         {
[09:28:20.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.311]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.311]             })
[09:28:20.311]         }
[09:28:20.311]     }, args = future.call.arguments)
[09:28:20.311] }
[09:28:20.311] Lazy evaluation: FALSE
[09:28:20.311] Asynchronous evaluation: TRUE
[09:28:20.311] Local evaluation: TRUE
[09:28:20.311] Environment: R_GlobalEnv
[09:28:20.311] Capture standard output: TRUE
[09:28:20.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.311] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.311] Packages: <none>
[09:28:20.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.311] Resolved: FALSE
[09:28:20.311] Value: <not collected>
[09:28:20.311] Conditions captured: <none>
[09:28:20.311] Early signaling: FALSE
[09:28:20.311] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.311] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.322] Chunk #2 of 2 ... DONE
[09:28:20.323] Launching 2 futures (chunks) ... DONE
[09:28:20.323] Resolving 2 futures (chunks) ...
[09:28:20.323] resolve() on list ...
[09:28:20.323]  recursive: 0
[09:28:20.323]  length: 2
[09:28:20.323] 
[09:28:20.324] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.324] - Validating connection of MultisessionFuture
[09:28:20.324] - received message: FutureResult
[09:28:20.324] - Received FutureResult
[09:28:20.324] - Erased future from FutureRegistry
[09:28:20.324] result() for ClusterFuture ...
[09:28:20.324] - result already collected: FutureResult
[09:28:20.324] result() for ClusterFuture ... done
[09:28:20.324] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.325] Future #1
[09:28:20.325] result() for ClusterFuture ...
[09:28:20.325] - result already collected: FutureResult
[09:28:20.325] result() for ClusterFuture ... done
[09:28:20.325] result() for ClusterFuture ...
[09:28:20.325] - result already collected: FutureResult
[09:28:20.325] result() for ClusterFuture ... done
[09:28:20.325] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.325] - nx: 2
[09:28:20.325] - relay: TRUE
[09:28:20.325] - stdout: TRUE
[09:28:20.326] - signal: TRUE
[09:28:20.326] - resignal: FALSE
[09:28:20.326] - force: TRUE
[09:28:20.326] - relayed: [n=2] FALSE, FALSE
[09:28:20.326] - queued futures: [n=2] FALSE, FALSE
[09:28:20.326]  - until=1
[09:28:20.326]  - relaying element #1
[09:28:20.326] result() for ClusterFuture ...
[09:28:20.326] - result already collected: FutureResult
[09:28:20.326] result() for ClusterFuture ... done
[09:28:20.326] result() for ClusterFuture ...
[09:28:20.326] - result already collected: FutureResult
[09:28:20.327] result() for ClusterFuture ... done
[09:28:20.327] result() for ClusterFuture ...
[09:28:20.327] - result already collected: FutureResult
[09:28:20.327] result() for ClusterFuture ... done
[09:28:20.327] result() for ClusterFuture ...
[09:28:20.327] - result already collected: FutureResult
[09:28:20.327] result() for ClusterFuture ... done
[09:28:20.327] - relayed: [n=2] TRUE, FALSE
[09:28:20.327] - queued futures: [n=2] TRUE, FALSE
[09:28:20.327] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.327]  length: 1 (resolved future 1)
[09:28:20.357] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.357] - Validating connection of MultisessionFuture
[09:28:20.357] - received message: FutureResult
[09:28:20.357] - Received FutureResult
[09:28:20.357] - Erased future from FutureRegistry
[09:28:20.358] result() for ClusterFuture ...
[09:28:20.358] - result already collected: FutureResult
[09:28:20.358] result() for ClusterFuture ... done
[09:28:20.358] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.358] Future #2
[09:28:20.358] result() for ClusterFuture ...
[09:28:20.358] - result already collected: FutureResult
[09:28:20.358] result() for ClusterFuture ... done
[09:28:20.358] result() for ClusterFuture ...
[09:28:20.358] - result already collected: FutureResult
[09:28:20.358] result() for ClusterFuture ... done
[09:28:20.358] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.359] - nx: 2
[09:28:20.359] - relay: TRUE
[09:28:20.359] - stdout: TRUE
[09:28:20.359] - signal: TRUE
[09:28:20.359] - resignal: FALSE
[09:28:20.359] - force: TRUE
[09:28:20.359] - relayed: [n=2] TRUE, FALSE
[09:28:20.359] - queued futures: [n=2] TRUE, FALSE
[09:28:20.359]  - until=2
[09:28:20.359]  - relaying element #2
[09:28:20.359] result() for ClusterFuture ...
[09:28:20.359] - result already collected: FutureResult
[09:28:20.360] result() for ClusterFuture ... done
[09:28:20.360] result() for ClusterFuture ...
[09:28:20.360] - result already collected: FutureResult
[09:28:20.360] result() for ClusterFuture ... done
[09:28:20.360] result() for ClusterFuture ...
[09:28:20.360] - result already collected: FutureResult
[09:28:20.360] result() for ClusterFuture ... done
[09:28:20.362] result() for ClusterFuture ...
[09:28:20.362] - result already collected: FutureResult
[09:28:20.363] result() for ClusterFuture ... done
[09:28:20.363] - relayed: [n=2] TRUE, TRUE
[09:28:20.363] - queued futures: [n=2] TRUE, TRUE
[09:28:20.363] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.363]  length: 0 (resolved future 2)
[09:28:20.363] Relaying remaining futures
[09:28:20.363] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.363] - nx: 2
[09:28:20.363] - relay: TRUE
[09:28:20.363] - stdout: TRUE
[09:28:20.363] - signal: TRUE
[09:28:20.364] - resignal: FALSE
[09:28:20.364] - force: TRUE
[09:28:20.364] - relayed: [n=2] TRUE, TRUE
[09:28:20.364] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.364] - relayed: [n=2] TRUE, TRUE
[09:28:20.364] - queued futures: [n=2] TRUE, TRUE
[09:28:20.364] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.364] resolve() on list ... DONE
[09:28:20.364] result() for ClusterFuture ...
[09:28:20.364] - result already collected: FutureResult
[09:28:20.364] result() for ClusterFuture ... done
[09:28:20.365] result() for ClusterFuture ...
[09:28:20.365] - result already collected: FutureResult
[09:28:20.365] result() for ClusterFuture ... done
[09:28:20.365] result() for ClusterFuture ...
[09:28:20.365] - result already collected: FutureResult
[09:28:20.365] result() for ClusterFuture ... done
[09:28:20.365] result() for ClusterFuture ...
[09:28:20.365] - result already collected: FutureResult
[09:28:20.365] result() for ClusterFuture ... done
[09:28:20.365]  - Number of value chunks collected: 2
[09:28:20.365] Resolving 2 futures (chunks) ... DONE
[09:28:20.365] Reducing values from 2 chunks ...
[09:28:20.366]  - Number of values collected after concatenation: 2
[09:28:20.366]  - Number of values expected: 2
[09:28:20.366] Reducing values from 2 chunks ... DONE
[09:28:20.366] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[09:28:20.367] getGlobalsAndPackagesXApply() ...
[09:28:20.367]  - future.globals: TRUE
[09:28:20.367] getGlobalsAndPackages() ...
[09:28:20.367] Searching for globals...
[09:28:20.368] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:20.368] Searching for globals ... DONE
[09:28:20.368] Resolving globals: FALSE
[09:28:20.369] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:20.369] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:20.369] - globals: [1] ‘FUN’
[09:28:20.369] - packages: [1] ‘stats’
[09:28:20.369] getGlobalsAndPackages() ... DONE
[09:28:20.369]  - globals found/used: [n=1] ‘FUN’
[09:28:20.369]  - needed namespaces: [n=1] ‘stats’
[09:28:20.370] Finding globals ... DONE
[09:28:20.370]  - use_args: TRUE
[09:28:20.370]  - Getting '...' globals ...
[09:28:20.370] resolve() on list ...
[09:28:20.370]  recursive: 0
[09:28:20.370]  length: 1
[09:28:20.370]  elements: ‘...’
[09:28:20.370]  length: 0 (resolved future 1)
[09:28:20.371] resolve() on list ... DONE
[09:28:20.371]    - '...' content: [n=0] 
[09:28:20.371] List of 1
[09:28:20.371]  $ ...: list()
[09:28:20.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.371]  - attr(*, "where")=List of 1
[09:28:20.371]   ..$ ...:<environment: 0x559ba4a49df8> 
[09:28:20.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.371]  - attr(*, "resolved")= logi TRUE
[09:28:20.371]  - attr(*, "total_size")= num NA
[09:28:20.373]  - Getting '...' globals ... DONE
[09:28:20.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.373] List of 2
[09:28:20.373]  $ ...future.FUN:function (x, ...)  
[09:28:20.373]  $ ...          : list()
[09:28:20.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.373]  - attr(*, "where")=List of 2
[09:28:20.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.373]   ..$ ...          :<environment: 0x559ba4a49df8> 
[09:28:20.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.373]  - attr(*, "resolved")= logi FALSE
[09:28:20.373]  - attr(*, "total_size")= num 1248
[09:28:20.376] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:20.376] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.380] future_lapply() ...
[09:28:20.383] Number of chunks: 2
[09:28:20.383] getGlobalsAndPackagesXApply() ...
[09:28:20.383]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.383]  - use_args: TRUE
[09:28:20.384] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.384] List of 2
[09:28:20.384]  $ ...          : list()
[09:28:20.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.384]  $ ...future.FUN:function (x, ...)  
[09:28:20.384]  - attr(*, "where")=List of 2
[09:28:20.384]   ..$ ...          :<environment: 0x559ba4a49df8> 
[09:28:20.384]   ..$ ...future.FUN:<environment: namespace:stats> 
[09:28:20.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.384]  - attr(*, "resolved")= logi FALSE
[09:28:20.384]  - attr(*, "total_size")= num NA
[09:28:20.386] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:20.386] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.387] Number of futures (= number of chunks): 2
[09:28:20.387] Launching 2 futures (chunks) ...
[09:28:20.387] Chunk #1 of 2 ...
[09:28:20.387]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.387]  - seeds: <none>
[09:28:20.387]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.387] getGlobalsAndPackages() ...
[09:28:20.387] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.388] Resolving globals: FALSE
[09:28:20.388] Tweak future expression to call with '...' arguments ...
[09:28:20.388] {
[09:28:20.388]     do.call(function(...) {
[09:28:20.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.388]             on.exit(options(oopts), add = TRUE)
[09:28:20.388]         }
[09:28:20.388]         {
[09:28:20.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.388]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.388]             })
[09:28:20.388]         }
[09:28:20.388]     }, args = future.call.arguments)
[09:28:20.388] }
[09:28:20.388] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.388] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.389] - packages: [1] ‘stats’
[09:28:20.389] getGlobalsAndPackages() ... DONE
[09:28:20.389] run() for ‘Future’ ...
[09:28:20.389] - state: ‘created’
[09:28:20.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.403]   - Field: ‘node’
[09:28:20.403]   - Field: ‘label’
[09:28:20.403]   - Field: ‘local’
[09:28:20.403]   - Field: ‘owner’
[09:28:20.403]   - Field: ‘envir’
[09:28:20.403]   - Field: ‘workers’
[09:28:20.403]   - Field: ‘packages’
[09:28:20.403]   - Field: ‘gc’
[09:28:20.404]   - Field: ‘conditions’
[09:28:20.404]   - Field: ‘persistent’
[09:28:20.404]   - Field: ‘expr’
[09:28:20.404]   - Field: ‘uuid’
[09:28:20.404]   - Field: ‘seed’
[09:28:20.404]   - Field: ‘version’
[09:28:20.404]   - Field: ‘result’
[09:28:20.404]   - Field: ‘asynchronous’
[09:28:20.404]   - Field: ‘calls’
[09:28:20.404]   - Field: ‘globals’
[09:28:20.405]   - Field: ‘stdout’
[09:28:20.405]   - Field: ‘earlySignal’
[09:28:20.405]   - Field: ‘lazy’
[09:28:20.405]   - Field: ‘state’
[09:28:20.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.405] - Launch lazy future ...
[09:28:20.405] Packages needed by the future expression (n = 1): ‘stats’
[09:28:20.405] Packages needed by future strategies (n = 0): <none>
[09:28:20.406] {
[09:28:20.406]     {
[09:28:20.406]         {
[09:28:20.406]             ...future.startTime <- base::Sys.time()
[09:28:20.406]             {
[09:28:20.406]                 {
[09:28:20.406]                   {
[09:28:20.406]                     {
[09:28:20.406]                       {
[09:28:20.406]                         base::local({
[09:28:20.406]                           has_future <- base::requireNamespace("future", 
[09:28:20.406]                             quietly = TRUE)
[09:28:20.406]                           if (has_future) {
[09:28:20.406]                             ns <- base::getNamespace("future")
[09:28:20.406]                             version <- ns[[".package"]][["version"]]
[09:28:20.406]                             if (is.null(version)) 
[09:28:20.406]                               version <- utils::packageVersion("future")
[09:28:20.406]                           }
[09:28:20.406]                           else {
[09:28:20.406]                             version <- NULL
[09:28:20.406]                           }
[09:28:20.406]                           if (!has_future || version < "1.8.0") {
[09:28:20.406]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.406]                               "", base::R.version$version.string), 
[09:28:20.406]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:20.406]                                 base::R.version$platform, 8 * 
[09:28:20.406]                                   base::.Machine$sizeof.pointer), 
[09:28:20.406]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.406]                                 "release", "version")], collapse = " "), 
[09:28:20.406]                               hostname = base::Sys.info()[["nodename"]])
[09:28:20.406]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.406]                               info)
[09:28:20.406]                             info <- base::paste(info, collapse = "; ")
[09:28:20.406]                             if (!has_future) {
[09:28:20.406]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.406]                                 info)
[09:28:20.406]                             }
[09:28:20.406]                             else {
[09:28:20.406]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.406]                                 info, version)
[09:28:20.406]                             }
[09:28:20.406]                             base::stop(msg)
[09:28:20.406]                           }
[09:28:20.406]                         })
[09:28:20.406]                       }
[09:28:20.406]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.406]                       base::options(mc.cores = 1L)
[09:28:20.406]                     }
[09:28:20.406]                     base::local({
[09:28:20.406]                       for (pkg in "stats") {
[09:28:20.406]                         base::loadNamespace(pkg)
[09:28:20.406]                         base::library(pkg, character.only = TRUE)
[09:28:20.406]                       }
[09:28:20.406]                     })
[09:28:20.406]                   }
[09:28:20.406]                   ...future.strategy.old <- future::plan("list")
[09:28:20.406]                   options(future.plan = NULL)
[09:28:20.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.406]                 }
[09:28:20.406]                 ...future.workdir <- getwd()
[09:28:20.406]             }
[09:28:20.406]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.406]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.406]         }
[09:28:20.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.406]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.406]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.406]             base::names(...future.oldOptions))
[09:28:20.406]     }
[09:28:20.406]     if (FALSE) {
[09:28:20.406]     }
[09:28:20.406]     else {
[09:28:20.406]         if (TRUE) {
[09:28:20.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.406]                 open = "w")
[09:28:20.406]         }
[09:28:20.406]         else {
[09:28:20.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.406]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.406]         }
[09:28:20.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.406]             base::sink(type = "output", split = FALSE)
[09:28:20.406]             base::close(...future.stdout)
[09:28:20.406]         }, add = TRUE)
[09:28:20.406]     }
[09:28:20.406]     ...future.frame <- base::sys.nframe()
[09:28:20.406]     ...future.conditions <- base::list()
[09:28:20.406]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.406]     if (FALSE) {
[09:28:20.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.406]     }
[09:28:20.406]     ...future.result <- base::tryCatch({
[09:28:20.406]         base::withCallingHandlers({
[09:28:20.406]             ...future.value <- base::withVisible(base::local({
[09:28:20.406]                 ...future.makeSendCondition <- base::local({
[09:28:20.406]                   sendCondition <- NULL
[09:28:20.406]                   function(frame = 1L) {
[09:28:20.406]                     if (is.function(sendCondition)) 
[09:28:20.406]                       return(sendCondition)
[09:28:20.406]                     ns <- getNamespace("parallel")
[09:28:20.406]                     if (exists("sendData", mode = "function", 
[09:28:20.406]                       envir = ns)) {
[09:28:20.406]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.406]                         envir = ns)
[09:28:20.406]                       envir <- sys.frame(frame)
[09:28:20.406]                       master <- NULL
[09:28:20.406]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.406]                         !identical(envir, emptyenv())) {
[09:28:20.406]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.406]                           inherits = FALSE)) {
[09:28:20.406]                           master <- get("master", mode = "list", 
[09:28:20.406]                             envir = envir, inherits = FALSE)
[09:28:20.406]                           if (inherits(master, c("SOCKnode", 
[09:28:20.406]                             "SOCK0node"))) {
[09:28:20.406]                             sendCondition <<- function(cond) {
[09:28:20.406]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.406]                                 success = TRUE)
[09:28:20.406]                               parallel_sendData(master, data)
[09:28:20.406]                             }
[09:28:20.406]                             return(sendCondition)
[09:28:20.406]                           }
[09:28:20.406]                         }
[09:28:20.406]                         frame <- frame + 1L
[09:28:20.406]                         envir <- sys.frame(frame)
[09:28:20.406]                       }
[09:28:20.406]                     }
[09:28:20.406]                     sendCondition <<- function(cond) NULL
[09:28:20.406]                   }
[09:28:20.406]                 })
[09:28:20.406]                 withCallingHandlers({
[09:28:20.406]                   {
[09:28:20.406]                     do.call(function(...) {
[09:28:20.406]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.406]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.406]                         ...future.globals.maxSize)) {
[09:28:20.406]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.406]                         on.exit(options(oopts), add = TRUE)
[09:28:20.406]                       }
[09:28:20.406]                       {
[09:28:20.406]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.406]                           FUN = function(jj) {
[09:28:20.406]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.406]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.406]                           })
[09:28:20.406]                       }
[09:28:20.406]                     }, args = future.call.arguments)
[09:28:20.406]                   }
[09:28:20.406]                 }, immediateCondition = function(cond) {
[09:28:20.406]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.406]                   sendCondition(cond)
[09:28:20.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.406]                   {
[09:28:20.406]                     inherits <- base::inherits
[09:28:20.406]                     invokeRestart <- base::invokeRestart
[09:28:20.406]                     is.null <- base::is.null
[09:28:20.406]                     muffled <- FALSE
[09:28:20.406]                     if (inherits(cond, "message")) {
[09:28:20.406]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.406]                       if (muffled) 
[09:28:20.406]                         invokeRestart("muffleMessage")
[09:28:20.406]                     }
[09:28:20.406]                     else if (inherits(cond, "warning")) {
[09:28:20.406]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.406]                       if (muffled) 
[09:28:20.406]                         invokeRestart("muffleWarning")
[09:28:20.406]                     }
[09:28:20.406]                     else if (inherits(cond, "condition")) {
[09:28:20.406]                       if (!is.null(pattern)) {
[09:28:20.406]                         computeRestarts <- base::computeRestarts
[09:28:20.406]                         grepl <- base::grepl
[09:28:20.406]                         restarts <- computeRestarts(cond)
[09:28:20.406]                         for (restart in restarts) {
[09:28:20.406]                           name <- restart$name
[09:28:20.406]                           if (is.null(name)) 
[09:28:20.406]                             next
[09:28:20.406]                           if (!grepl(pattern, name)) 
[09:28:20.406]                             next
[09:28:20.406]                           invokeRestart(restart)
[09:28:20.406]                           muffled <- TRUE
[09:28:20.406]                           break
[09:28:20.406]                         }
[09:28:20.406]                       }
[09:28:20.406]                     }
[09:28:20.406]                     invisible(muffled)
[09:28:20.406]                   }
[09:28:20.406]                   muffleCondition(cond)
[09:28:20.406]                 })
[09:28:20.406]             }))
[09:28:20.406]             future::FutureResult(value = ...future.value$value, 
[09:28:20.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.406]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.406]                     ...future.globalenv.names))
[09:28:20.406]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.406]         }, condition = base::local({
[09:28:20.406]             c <- base::c
[09:28:20.406]             inherits <- base::inherits
[09:28:20.406]             invokeRestart <- base::invokeRestart
[09:28:20.406]             length <- base::length
[09:28:20.406]             list <- base::list
[09:28:20.406]             seq.int <- base::seq.int
[09:28:20.406]             signalCondition <- base::signalCondition
[09:28:20.406]             sys.calls <- base::sys.calls
[09:28:20.406]             `[[` <- base::`[[`
[09:28:20.406]             `+` <- base::`+`
[09:28:20.406]             `<<-` <- base::`<<-`
[09:28:20.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.406]                   3L)]
[09:28:20.406]             }
[09:28:20.406]             function(cond) {
[09:28:20.406]                 is_error <- inherits(cond, "error")
[09:28:20.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.406]                   NULL)
[09:28:20.406]                 if (is_error) {
[09:28:20.406]                   sessionInformation <- function() {
[09:28:20.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.406]                       search = base::search(), system = base::Sys.info())
[09:28:20.406]                   }
[09:28:20.406]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.406]                     cond$call), session = sessionInformation(), 
[09:28:20.406]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.406]                   signalCondition(cond)
[09:28:20.406]                 }
[09:28:20.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.406]                 "immediateCondition"))) {
[09:28:20.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.406]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.406]                   if (TRUE && !signal) {
[09:28:20.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.406]                     {
[09:28:20.406]                       inherits <- base::inherits
[09:28:20.406]                       invokeRestart <- base::invokeRestart
[09:28:20.406]                       is.null <- base::is.null
[09:28:20.406]                       muffled <- FALSE
[09:28:20.406]                       if (inherits(cond, "message")) {
[09:28:20.406]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.406]                         if (muffled) 
[09:28:20.406]                           invokeRestart("muffleMessage")
[09:28:20.406]                       }
[09:28:20.406]                       else if (inherits(cond, "warning")) {
[09:28:20.406]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.406]                         if (muffled) 
[09:28:20.406]                           invokeRestart("muffleWarning")
[09:28:20.406]                       }
[09:28:20.406]                       else if (inherits(cond, "condition")) {
[09:28:20.406]                         if (!is.null(pattern)) {
[09:28:20.406]                           computeRestarts <- base::computeRestarts
[09:28:20.406]                           grepl <- base::grepl
[09:28:20.406]                           restarts <- computeRestarts(cond)
[09:28:20.406]                           for (restart in restarts) {
[09:28:20.406]                             name <- restart$name
[09:28:20.406]                             if (is.null(name)) 
[09:28:20.406]                               next
[09:28:20.406]                             if (!grepl(pattern, name)) 
[09:28:20.406]                               next
[09:28:20.406]                             invokeRestart(restart)
[09:28:20.406]                             muffled <- TRUE
[09:28:20.406]                             break
[09:28:20.406]                           }
[09:28:20.406]                         }
[09:28:20.406]                       }
[09:28:20.406]                       invisible(muffled)
[09:28:20.406]                     }
[09:28:20.406]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.406]                   }
[09:28:20.406]                 }
[09:28:20.406]                 else {
[09:28:20.406]                   if (TRUE) {
[09:28:20.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.406]                     {
[09:28:20.406]                       inherits <- base::inherits
[09:28:20.406]                       invokeRestart <- base::invokeRestart
[09:28:20.406]                       is.null <- base::is.null
[09:28:20.406]                       muffled <- FALSE
[09:28:20.406]                       if (inherits(cond, "message")) {
[09:28:20.406]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.406]                         if (muffled) 
[09:28:20.406]                           invokeRestart("muffleMessage")
[09:28:20.406]                       }
[09:28:20.406]                       else if (inherits(cond, "warning")) {
[09:28:20.406]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.406]                         if (muffled) 
[09:28:20.406]                           invokeRestart("muffleWarning")
[09:28:20.406]                       }
[09:28:20.406]                       else if (inherits(cond, "condition")) {
[09:28:20.406]                         if (!is.null(pattern)) {
[09:28:20.406]                           computeRestarts <- base::computeRestarts
[09:28:20.406]                           grepl <- base::grepl
[09:28:20.406]                           restarts <- computeRestarts(cond)
[09:28:20.406]                           for (restart in restarts) {
[09:28:20.406]                             name <- restart$name
[09:28:20.406]                             if (is.null(name)) 
[09:28:20.406]                               next
[09:28:20.406]                             if (!grepl(pattern, name)) 
[09:28:20.406]                               next
[09:28:20.406]                             invokeRestart(restart)
[09:28:20.406]                             muffled <- TRUE
[09:28:20.406]                             break
[09:28:20.406]                           }
[09:28:20.406]                         }
[09:28:20.406]                       }
[09:28:20.406]                       invisible(muffled)
[09:28:20.406]                     }
[09:28:20.406]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.406]                   }
[09:28:20.406]                 }
[09:28:20.406]             }
[09:28:20.406]         }))
[09:28:20.406]     }, error = function(ex) {
[09:28:20.406]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.406]                 ...future.rng), started = ...future.startTime, 
[09:28:20.406]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.406]             version = "1.8"), class = "FutureResult")
[09:28:20.406]     }, finally = {
[09:28:20.406]         if (!identical(...future.workdir, getwd())) 
[09:28:20.406]             setwd(...future.workdir)
[09:28:20.406]         {
[09:28:20.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.406]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.406]             }
[09:28:20.406]             base::options(...future.oldOptions)
[09:28:20.406]             if (.Platform$OS.type == "windows") {
[09:28:20.406]                 old_names <- names(...future.oldEnvVars)
[09:28:20.406]                 envs <- base::Sys.getenv()
[09:28:20.406]                 names <- names(envs)
[09:28:20.406]                 common <- intersect(names, old_names)
[09:28:20.406]                 added <- setdiff(names, old_names)
[09:28:20.406]                 removed <- setdiff(old_names, names)
[09:28:20.406]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.406]                   envs[common]]
[09:28:20.406]                 NAMES <- toupper(changed)
[09:28:20.406]                 args <- list()
[09:28:20.406]                 for (kk in seq_along(NAMES)) {
[09:28:20.406]                   name <- changed[[kk]]
[09:28:20.406]                   NAME <- NAMES[[kk]]
[09:28:20.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.406]                     next
[09:28:20.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.406]                 }
[09:28:20.406]                 NAMES <- toupper(added)
[09:28:20.406]                 for (kk in seq_along(NAMES)) {
[09:28:20.406]                   name <- added[[kk]]
[09:28:20.406]                   NAME <- NAMES[[kk]]
[09:28:20.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.406]                     next
[09:28:20.406]                   args[[name]] <- ""
[09:28:20.406]                 }
[09:28:20.406]                 NAMES <- toupper(removed)
[09:28:20.406]                 for (kk in seq_along(NAMES)) {
[09:28:20.406]                   name <- removed[[kk]]
[09:28:20.406]                   NAME <- NAMES[[kk]]
[09:28:20.406]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.406]                     next
[09:28:20.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.406]                 }
[09:28:20.406]                 if (length(args) > 0) 
[09:28:20.406]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.406]             }
[09:28:20.406]             else {
[09:28:20.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.406]             }
[09:28:20.406]             {
[09:28:20.406]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.406]                   0L) {
[09:28:20.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.406]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.406]                   base::options(opts)
[09:28:20.406]                 }
[09:28:20.406]                 {
[09:28:20.406]                   {
[09:28:20.406]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.406]                     NULL
[09:28:20.406]                   }
[09:28:20.406]                   options(future.plan = NULL)
[09:28:20.406]                   if (is.na(NA_character_)) 
[09:28:20.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.406]                     .init = FALSE)
[09:28:20.406]                 }
[09:28:20.406]             }
[09:28:20.406]         }
[09:28:20.406]     })
[09:28:20.406]     if (TRUE) {
[09:28:20.406]         base::sink(type = "output", split = FALSE)
[09:28:20.406]         if (TRUE) {
[09:28:20.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.406]         }
[09:28:20.406]         else {
[09:28:20.406]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.406]         }
[09:28:20.406]         base::close(...future.stdout)
[09:28:20.406]         ...future.stdout <- NULL
[09:28:20.406]     }
[09:28:20.406]     ...future.result$conditions <- ...future.conditions
[09:28:20.406]     ...future.result$finished <- base::Sys.time()
[09:28:20.406]     ...future.result
[09:28:20.406] }
[09:28:20.409] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[09:28:20.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.409] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[09:28:20.410] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:28:20.410] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[09:28:20.410] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[09:28:20.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.411] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.411] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.411] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[09:28:20.411] MultisessionFuture started
[09:28:20.412] - Launch lazy future ... done
[09:28:20.412] run() for ‘MultisessionFuture’ ... done
[09:28:20.412] Created future:
[09:28:20.412] MultisessionFuture:
[09:28:20.412] Label: ‘future_apply-1’
[09:28:20.412] Expression:
[09:28:20.412] {
[09:28:20.412]     do.call(function(...) {
[09:28:20.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.412]             on.exit(options(oopts), add = TRUE)
[09:28:20.412]         }
[09:28:20.412]         {
[09:28:20.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.412]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.412]             })
[09:28:20.412]         }
[09:28:20.412]     }, args = future.call.arguments)
[09:28:20.412] }
[09:28:20.412] Lazy evaluation: FALSE
[09:28:20.412] Asynchronous evaluation: TRUE
[09:28:20.412] Local evaluation: TRUE
[09:28:20.412] Environment: R_GlobalEnv
[09:28:20.412] Capture standard output: TRUE
[09:28:20.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.412] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.412] Packages: 1 packages (‘stats’)
[09:28:20.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.412] Resolved: FALSE
[09:28:20.412] Value: <not collected>
[09:28:20.412] Conditions captured: <none>
[09:28:20.412] Early signaling: FALSE
[09:28:20.412] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.423] Chunk #1 of 2 ... DONE
[09:28:20.423] Chunk #2 of 2 ...
[09:28:20.424]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.424]  - seeds: <none>
[09:28:20.424]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.424] getGlobalsAndPackages() ...
[09:28:20.424] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.424] Resolving globals: FALSE
[09:28:20.424] Tweak future expression to call with '...' arguments ...
[09:28:20.424] {
[09:28:20.424]     do.call(function(...) {
[09:28:20.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.424]             on.exit(options(oopts), add = TRUE)
[09:28:20.424]         }
[09:28:20.424]         {
[09:28:20.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.424]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.424]             })
[09:28:20.424]         }
[09:28:20.424]     }, args = future.call.arguments)
[09:28:20.424] }
[09:28:20.425] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.425] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.425] - packages: [1] ‘stats’
[09:28:20.425] getGlobalsAndPackages() ... DONE
[09:28:20.425] run() for ‘Future’ ...
[09:28:20.426] - state: ‘created’
[09:28:20.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.439]   - Field: ‘node’
[09:28:20.439]   - Field: ‘label’
[09:28:20.439]   - Field: ‘local’
[09:28:20.439]   - Field: ‘owner’
[09:28:20.439]   - Field: ‘envir’
[09:28:20.440]   - Field: ‘workers’
[09:28:20.440]   - Field: ‘packages’
[09:28:20.440]   - Field: ‘gc’
[09:28:20.440]   - Field: ‘conditions’
[09:28:20.440]   - Field: ‘persistent’
[09:28:20.440]   - Field: ‘expr’
[09:28:20.440]   - Field: ‘uuid’
[09:28:20.440]   - Field: ‘seed’
[09:28:20.440]   - Field: ‘version’
[09:28:20.440]   - Field: ‘result’
[09:28:20.440]   - Field: ‘asynchronous’
[09:28:20.441]   - Field: ‘calls’
[09:28:20.441]   - Field: ‘globals’
[09:28:20.441]   - Field: ‘stdout’
[09:28:20.441]   - Field: ‘earlySignal’
[09:28:20.441]   - Field: ‘lazy’
[09:28:20.441]   - Field: ‘state’
[09:28:20.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.441] - Launch lazy future ...
[09:28:20.441] Packages needed by the future expression (n = 1): ‘stats’
[09:28:20.442] Packages needed by future strategies (n = 0): <none>
[09:28:20.442] {
[09:28:20.442]     {
[09:28:20.442]         {
[09:28:20.442]             ...future.startTime <- base::Sys.time()
[09:28:20.442]             {
[09:28:20.442]                 {
[09:28:20.442]                   {
[09:28:20.442]                     {
[09:28:20.442]                       {
[09:28:20.442]                         base::local({
[09:28:20.442]                           has_future <- base::requireNamespace("future", 
[09:28:20.442]                             quietly = TRUE)
[09:28:20.442]                           if (has_future) {
[09:28:20.442]                             ns <- base::getNamespace("future")
[09:28:20.442]                             version <- ns[[".package"]][["version"]]
[09:28:20.442]                             if (is.null(version)) 
[09:28:20.442]                               version <- utils::packageVersion("future")
[09:28:20.442]                           }
[09:28:20.442]                           else {
[09:28:20.442]                             version <- NULL
[09:28:20.442]                           }
[09:28:20.442]                           if (!has_future || version < "1.8.0") {
[09:28:20.442]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.442]                               "", base::R.version$version.string), 
[09:28:20.442]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:20.442]                                 base::R.version$platform, 8 * 
[09:28:20.442]                                   base::.Machine$sizeof.pointer), 
[09:28:20.442]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.442]                                 "release", "version")], collapse = " "), 
[09:28:20.442]                               hostname = base::Sys.info()[["nodename"]])
[09:28:20.442]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.442]                               info)
[09:28:20.442]                             info <- base::paste(info, collapse = "; ")
[09:28:20.442]                             if (!has_future) {
[09:28:20.442]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.442]                                 info)
[09:28:20.442]                             }
[09:28:20.442]                             else {
[09:28:20.442]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.442]                                 info, version)
[09:28:20.442]                             }
[09:28:20.442]                             base::stop(msg)
[09:28:20.442]                           }
[09:28:20.442]                         })
[09:28:20.442]                       }
[09:28:20.442]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.442]                       base::options(mc.cores = 1L)
[09:28:20.442]                     }
[09:28:20.442]                     base::local({
[09:28:20.442]                       for (pkg in "stats") {
[09:28:20.442]                         base::loadNamespace(pkg)
[09:28:20.442]                         base::library(pkg, character.only = TRUE)
[09:28:20.442]                       }
[09:28:20.442]                     })
[09:28:20.442]                   }
[09:28:20.442]                   ...future.strategy.old <- future::plan("list")
[09:28:20.442]                   options(future.plan = NULL)
[09:28:20.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.442]                 }
[09:28:20.442]                 ...future.workdir <- getwd()
[09:28:20.442]             }
[09:28:20.442]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.442]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.442]         }
[09:28:20.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.442]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.442]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.442]             base::names(...future.oldOptions))
[09:28:20.442]     }
[09:28:20.442]     if (FALSE) {
[09:28:20.442]     }
[09:28:20.442]     else {
[09:28:20.442]         if (TRUE) {
[09:28:20.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.442]                 open = "w")
[09:28:20.442]         }
[09:28:20.442]         else {
[09:28:20.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.442]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.442]         }
[09:28:20.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.442]             base::sink(type = "output", split = FALSE)
[09:28:20.442]             base::close(...future.stdout)
[09:28:20.442]         }, add = TRUE)
[09:28:20.442]     }
[09:28:20.442]     ...future.frame <- base::sys.nframe()
[09:28:20.442]     ...future.conditions <- base::list()
[09:28:20.442]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.442]     if (FALSE) {
[09:28:20.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.442]     }
[09:28:20.442]     ...future.result <- base::tryCatch({
[09:28:20.442]         base::withCallingHandlers({
[09:28:20.442]             ...future.value <- base::withVisible(base::local({
[09:28:20.442]                 ...future.makeSendCondition <- base::local({
[09:28:20.442]                   sendCondition <- NULL
[09:28:20.442]                   function(frame = 1L) {
[09:28:20.442]                     if (is.function(sendCondition)) 
[09:28:20.442]                       return(sendCondition)
[09:28:20.442]                     ns <- getNamespace("parallel")
[09:28:20.442]                     if (exists("sendData", mode = "function", 
[09:28:20.442]                       envir = ns)) {
[09:28:20.442]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.442]                         envir = ns)
[09:28:20.442]                       envir <- sys.frame(frame)
[09:28:20.442]                       master <- NULL
[09:28:20.442]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.442]                         !identical(envir, emptyenv())) {
[09:28:20.442]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.442]                           inherits = FALSE)) {
[09:28:20.442]                           master <- get("master", mode = "list", 
[09:28:20.442]                             envir = envir, inherits = FALSE)
[09:28:20.442]                           if (inherits(master, c("SOCKnode", 
[09:28:20.442]                             "SOCK0node"))) {
[09:28:20.442]                             sendCondition <<- function(cond) {
[09:28:20.442]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.442]                                 success = TRUE)
[09:28:20.442]                               parallel_sendData(master, data)
[09:28:20.442]                             }
[09:28:20.442]                             return(sendCondition)
[09:28:20.442]                           }
[09:28:20.442]                         }
[09:28:20.442]                         frame <- frame + 1L
[09:28:20.442]                         envir <- sys.frame(frame)
[09:28:20.442]                       }
[09:28:20.442]                     }
[09:28:20.442]                     sendCondition <<- function(cond) NULL
[09:28:20.442]                   }
[09:28:20.442]                 })
[09:28:20.442]                 withCallingHandlers({
[09:28:20.442]                   {
[09:28:20.442]                     do.call(function(...) {
[09:28:20.442]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.442]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.442]                         ...future.globals.maxSize)) {
[09:28:20.442]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.442]                         on.exit(options(oopts), add = TRUE)
[09:28:20.442]                       }
[09:28:20.442]                       {
[09:28:20.442]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.442]                           FUN = function(jj) {
[09:28:20.442]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.442]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.442]                           })
[09:28:20.442]                       }
[09:28:20.442]                     }, args = future.call.arguments)
[09:28:20.442]                   }
[09:28:20.442]                 }, immediateCondition = function(cond) {
[09:28:20.442]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.442]                   sendCondition(cond)
[09:28:20.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.442]                   {
[09:28:20.442]                     inherits <- base::inherits
[09:28:20.442]                     invokeRestart <- base::invokeRestart
[09:28:20.442]                     is.null <- base::is.null
[09:28:20.442]                     muffled <- FALSE
[09:28:20.442]                     if (inherits(cond, "message")) {
[09:28:20.442]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.442]                       if (muffled) 
[09:28:20.442]                         invokeRestart("muffleMessage")
[09:28:20.442]                     }
[09:28:20.442]                     else if (inherits(cond, "warning")) {
[09:28:20.442]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.442]                       if (muffled) 
[09:28:20.442]                         invokeRestart("muffleWarning")
[09:28:20.442]                     }
[09:28:20.442]                     else if (inherits(cond, "condition")) {
[09:28:20.442]                       if (!is.null(pattern)) {
[09:28:20.442]                         computeRestarts <- base::computeRestarts
[09:28:20.442]                         grepl <- base::grepl
[09:28:20.442]                         restarts <- computeRestarts(cond)
[09:28:20.442]                         for (restart in restarts) {
[09:28:20.442]                           name <- restart$name
[09:28:20.442]                           if (is.null(name)) 
[09:28:20.442]                             next
[09:28:20.442]                           if (!grepl(pattern, name)) 
[09:28:20.442]                             next
[09:28:20.442]                           invokeRestart(restart)
[09:28:20.442]                           muffled <- TRUE
[09:28:20.442]                           break
[09:28:20.442]                         }
[09:28:20.442]                       }
[09:28:20.442]                     }
[09:28:20.442]                     invisible(muffled)
[09:28:20.442]                   }
[09:28:20.442]                   muffleCondition(cond)
[09:28:20.442]                 })
[09:28:20.442]             }))
[09:28:20.442]             future::FutureResult(value = ...future.value$value, 
[09:28:20.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.442]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.442]                     ...future.globalenv.names))
[09:28:20.442]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.442]         }, condition = base::local({
[09:28:20.442]             c <- base::c
[09:28:20.442]             inherits <- base::inherits
[09:28:20.442]             invokeRestart <- base::invokeRestart
[09:28:20.442]             length <- base::length
[09:28:20.442]             list <- base::list
[09:28:20.442]             seq.int <- base::seq.int
[09:28:20.442]             signalCondition <- base::signalCondition
[09:28:20.442]             sys.calls <- base::sys.calls
[09:28:20.442]             `[[` <- base::`[[`
[09:28:20.442]             `+` <- base::`+`
[09:28:20.442]             `<<-` <- base::`<<-`
[09:28:20.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.442]                   3L)]
[09:28:20.442]             }
[09:28:20.442]             function(cond) {
[09:28:20.442]                 is_error <- inherits(cond, "error")
[09:28:20.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.442]                   NULL)
[09:28:20.442]                 if (is_error) {
[09:28:20.442]                   sessionInformation <- function() {
[09:28:20.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.442]                       search = base::search(), system = base::Sys.info())
[09:28:20.442]                   }
[09:28:20.442]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.442]                     cond$call), session = sessionInformation(), 
[09:28:20.442]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.442]                   signalCondition(cond)
[09:28:20.442]                 }
[09:28:20.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.442]                 "immediateCondition"))) {
[09:28:20.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.442]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.442]                   if (TRUE && !signal) {
[09:28:20.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.442]                     {
[09:28:20.442]                       inherits <- base::inherits
[09:28:20.442]                       invokeRestart <- base::invokeRestart
[09:28:20.442]                       is.null <- base::is.null
[09:28:20.442]                       muffled <- FALSE
[09:28:20.442]                       if (inherits(cond, "message")) {
[09:28:20.442]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.442]                         if (muffled) 
[09:28:20.442]                           invokeRestart("muffleMessage")
[09:28:20.442]                       }
[09:28:20.442]                       else if (inherits(cond, "warning")) {
[09:28:20.442]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.442]                         if (muffled) 
[09:28:20.442]                           invokeRestart("muffleWarning")
[09:28:20.442]                       }
[09:28:20.442]                       else if (inherits(cond, "condition")) {
[09:28:20.442]                         if (!is.null(pattern)) {
[09:28:20.442]                           computeRestarts <- base::computeRestarts
[09:28:20.442]                           grepl <- base::grepl
[09:28:20.442]                           restarts <- computeRestarts(cond)
[09:28:20.442]                           for (restart in restarts) {
[09:28:20.442]                             name <- restart$name
[09:28:20.442]                             if (is.null(name)) 
[09:28:20.442]                               next
[09:28:20.442]                             if (!grepl(pattern, name)) 
[09:28:20.442]                               next
[09:28:20.442]                             invokeRestart(restart)
[09:28:20.442]                             muffled <- TRUE
[09:28:20.442]                             break
[09:28:20.442]                           }
[09:28:20.442]                         }
[09:28:20.442]                       }
[09:28:20.442]                       invisible(muffled)
[09:28:20.442]                     }
[09:28:20.442]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.442]                   }
[09:28:20.442]                 }
[09:28:20.442]                 else {
[09:28:20.442]                   if (TRUE) {
[09:28:20.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.442]                     {
[09:28:20.442]                       inherits <- base::inherits
[09:28:20.442]                       invokeRestart <- base::invokeRestart
[09:28:20.442]                       is.null <- base::is.null
[09:28:20.442]                       muffled <- FALSE
[09:28:20.442]                       if (inherits(cond, "message")) {
[09:28:20.442]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.442]                         if (muffled) 
[09:28:20.442]                           invokeRestart("muffleMessage")
[09:28:20.442]                       }
[09:28:20.442]                       else if (inherits(cond, "warning")) {
[09:28:20.442]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.442]                         if (muffled) 
[09:28:20.442]                           invokeRestart("muffleWarning")
[09:28:20.442]                       }
[09:28:20.442]                       else if (inherits(cond, "condition")) {
[09:28:20.442]                         if (!is.null(pattern)) {
[09:28:20.442]                           computeRestarts <- base::computeRestarts
[09:28:20.442]                           grepl <- base::grepl
[09:28:20.442]                           restarts <- computeRestarts(cond)
[09:28:20.442]                           for (restart in restarts) {
[09:28:20.442]                             name <- restart$name
[09:28:20.442]                             if (is.null(name)) 
[09:28:20.442]                               next
[09:28:20.442]                             if (!grepl(pattern, name)) 
[09:28:20.442]                               next
[09:28:20.442]                             invokeRestart(restart)
[09:28:20.442]                             muffled <- TRUE
[09:28:20.442]                             break
[09:28:20.442]                           }
[09:28:20.442]                         }
[09:28:20.442]                       }
[09:28:20.442]                       invisible(muffled)
[09:28:20.442]                     }
[09:28:20.442]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.442]                   }
[09:28:20.442]                 }
[09:28:20.442]             }
[09:28:20.442]         }))
[09:28:20.442]     }, error = function(ex) {
[09:28:20.442]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.442]                 ...future.rng), started = ...future.startTime, 
[09:28:20.442]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.442]             version = "1.8"), class = "FutureResult")
[09:28:20.442]     }, finally = {
[09:28:20.442]         if (!identical(...future.workdir, getwd())) 
[09:28:20.442]             setwd(...future.workdir)
[09:28:20.442]         {
[09:28:20.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.442]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.442]             }
[09:28:20.442]             base::options(...future.oldOptions)
[09:28:20.442]             if (.Platform$OS.type == "windows") {
[09:28:20.442]                 old_names <- names(...future.oldEnvVars)
[09:28:20.442]                 envs <- base::Sys.getenv()
[09:28:20.442]                 names <- names(envs)
[09:28:20.442]                 common <- intersect(names, old_names)
[09:28:20.442]                 added <- setdiff(names, old_names)
[09:28:20.442]                 removed <- setdiff(old_names, names)
[09:28:20.442]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.442]                   envs[common]]
[09:28:20.442]                 NAMES <- toupper(changed)
[09:28:20.442]                 args <- list()
[09:28:20.442]                 for (kk in seq_along(NAMES)) {
[09:28:20.442]                   name <- changed[[kk]]
[09:28:20.442]                   NAME <- NAMES[[kk]]
[09:28:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.442]                     next
[09:28:20.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.442]                 }
[09:28:20.442]                 NAMES <- toupper(added)
[09:28:20.442]                 for (kk in seq_along(NAMES)) {
[09:28:20.442]                   name <- added[[kk]]
[09:28:20.442]                   NAME <- NAMES[[kk]]
[09:28:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.442]                     next
[09:28:20.442]                   args[[name]] <- ""
[09:28:20.442]                 }
[09:28:20.442]                 NAMES <- toupper(removed)
[09:28:20.442]                 for (kk in seq_along(NAMES)) {
[09:28:20.442]                   name <- removed[[kk]]
[09:28:20.442]                   NAME <- NAMES[[kk]]
[09:28:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.442]                     next
[09:28:20.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.442]                 }
[09:28:20.442]                 if (length(args) > 0) 
[09:28:20.442]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.442]             }
[09:28:20.442]             else {
[09:28:20.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.442]             }
[09:28:20.442]             {
[09:28:20.442]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.442]                   0L) {
[09:28:20.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.442]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.442]                   base::options(opts)
[09:28:20.442]                 }
[09:28:20.442]                 {
[09:28:20.442]                   {
[09:28:20.442]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.442]                     NULL
[09:28:20.442]                   }
[09:28:20.442]                   options(future.plan = NULL)
[09:28:20.442]                   if (is.na(NA_character_)) 
[09:28:20.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.442]                     .init = FALSE)
[09:28:20.442]                 }
[09:28:20.442]             }
[09:28:20.442]         }
[09:28:20.442]     })
[09:28:20.442]     if (TRUE) {
[09:28:20.442]         base::sink(type = "output", split = FALSE)
[09:28:20.442]         if (TRUE) {
[09:28:20.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.442]         }
[09:28:20.442]         else {
[09:28:20.442]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.442]         }
[09:28:20.442]         base::close(...future.stdout)
[09:28:20.442]         ...future.stdout <- NULL
[09:28:20.442]     }
[09:28:20.442]     ...future.result$conditions <- ...future.conditions
[09:28:20.442]     ...future.result$finished <- base::Sys.time()
[09:28:20.442]     ...future.result
[09:28:20.442] }
[09:28:20.445] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[09:28:20.445] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.445] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.445] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[09:28:20.446] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[09:28:20.446] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[09:28:20.446] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[09:28:20.446] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.447] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.447] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.447] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.447] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[09:28:20.448] MultisessionFuture started
[09:28:20.448] - Launch lazy future ... done
[09:28:20.448] run() for ‘MultisessionFuture’ ... done
[09:28:20.448] Created future:
[09:28:20.448] MultisessionFuture:
[09:28:20.448] Label: ‘future_apply-2’
[09:28:20.448] Expression:
[09:28:20.448] {
[09:28:20.448]     do.call(function(...) {
[09:28:20.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.448]             on.exit(options(oopts), add = TRUE)
[09:28:20.448]         }
[09:28:20.448]         {
[09:28:20.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.448]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.448]             })
[09:28:20.448]         }
[09:28:20.448]     }, args = future.call.arguments)
[09:28:20.448] }
[09:28:20.448] Lazy evaluation: FALSE
[09:28:20.448] Asynchronous evaluation: TRUE
[09:28:20.448] Local evaluation: TRUE
[09:28:20.448] Environment: R_GlobalEnv
[09:28:20.448] Capture standard output: TRUE
[09:28:20.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.448] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.448] Packages: 1 packages (‘stats’)
[09:28:20.448] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.448] Resolved: FALSE
[09:28:20.448] Value: <not collected>
[09:28:20.448] Conditions captured: <none>
[09:28:20.448] Early signaling: FALSE
[09:28:20.448] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.448] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.459] Chunk #2 of 2 ... DONE
[09:28:20.459] Launching 2 futures (chunks) ... DONE
[09:28:20.460] Resolving 2 futures (chunks) ...
[09:28:20.460] resolve() on list ...
[09:28:20.460]  recursive: 0
[09:28:20.460]  length: 2
[09:28:20.460] 
[09:28:20.461] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.461] - Validating connection of MultisessionFuture
[09:28:20.461] - received message: FutureResult
[09:28:20.461] - Received FutureResult
[09:28:20.461] - Erased future from FutureRegistry
[09:28:20.461] result() for ClusterFuture ...
[09:28:20.461] - result already collected: FutureResult
[09:28:20.461] result() for ClusterFuture ... done
[09:28:20.461] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.461] Future #1
[09:28:20.462] result() for ClusterFuture ...
[09:28:20.462] - result already collected: FutureResult
[09:28:20.462] result() for ClusterFuture ... done
[09:28:20.462] result() for ClusterFuture ...
[09:28:20.462] - result already collected: FutureResult
[09:28:20.462] result() for ClusterFuture ... done
[09:28:20.462] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.462] - nx: 2
[09:28:20.462] - relay: TRUE
[09:28:20.462] - stdout: TRUE
[09:28:20.462] - signal: TRUE
[09:28:20.462] - resignal: FALSE
[09:28:20.463] - force: TRUE
[09:28:20.463] - relayed: [n=2] FALSE, FALSE
[09:28:20.463] - queued futures: [n=2] FALSE, FALSE
[09:28:20.463]  - until=1
[09:28:20.463]  - relaying element #1
[09:28:20.463] result() for ClusterFuture ...
[09:28:20.463] - result already collected: FutureResult
[09:28:20.463] result() for ClusterFuture ... done
[09:28:20.463] result() for ClusterFuture ...
[09:28:20.463] - result already collected: FutureResult
[09:28:20.463] result() for ClusterFuture ... done
[09:28:20.464] result() for ClusterFuture ...
[09:28:20.464] - result already collected: FutureResult
[09:28:20.464] result() for ClusterFuture ... done
[09:28:20.464] result() for ClusterFuture ...
[09:28:20.464] - result already collected: FutureResult
[09:28:20.464] result() for ClusterFuture ... done
[09:28:20.464] - relayed: [n=2] TRUE, FALSE
[09:28:20.464] - queued futures: [n=2] TRUE, FALSE
[09:28:20.464] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.464]  length: 1 (resolved future 1)
[09:28:20.491] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.491] - Validating connection of MultisessionFuture
[09:28:20.492] - received message: FutureResult
[09:28:20.492] - Received FutureResult
[09:28:20.492] - Erased future from FutureRegistry
[09:28:20.492] result() for ClusterFuture ...
[09:28:20.492] - result already collected: FutureResult
[09:28:20.492] result() for ClusterFuture ... done
[09:28:20.492] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.492] Future #2
[09:28:20.492] result() for ClusterFuture ...
[09:28:20.492] - result already collected: FutureResult
[09:28:20.493] result() for ClusterFuture ... done
[09:28:20.493] result() for ClusterFuture ...
[09:28:20.493] - result already collected: FutureResult
[09:28:20.493] result() for ClusterFuture ... done
[09:28:20.493] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.493] - nx: 2
[09:28:20.493] - relay: TRUE
[09:28:20.493] - stdout: TRUE
[09:28:20.493] - signal: TRUE
[09:28:20.493] - resignal: FALSE
[09:28:20.493] - force: TRUE
[09:28:20.493] - relayed: [n=2] TRUE, FALSE
[09:28:20.494] - queued futures: [n=2] TRUE, FALSE
[09:28:20.494]  - until=2
[09:28:20.494]  - relaying element #2
[09:28:20.494] result() for ClusterFuture ...
[09:28:20.494] - result already collected: FutureResult
[09:28:20.494] result() for ClusterFuture ... done
[09:28:20.494] result() for ClusterFuture ...
[09:28:20.494] - result already collected: FutureResult
[09:28:20.494] result() for ClusterFuture ... done
[09:28:20.494] result() for ClusterFuture ...
[09:28:20.494] - result already collected: FutureResult
[09:28:20.495] result() for ClusterFuture ... done
[09:28:20.495] result() for ClusterFuture ...
[09:28:20.495] - result already collected: FutureResult
[09:28:20.495] result() for ClusterFuture ... done
[09:28:20.495] - relayed: [n=2] TRUE, TRUE
[09:28:20.495] - queued futures: [n=2] TRUE, TRUE
[09:28:20.495] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.495]  length: 0 (resolved future 2)
[09:28:20.495] Relaying remaining futures
[09:28:20.495] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.495] - nx: 2
[09:28:20.495] - relay: TRUE
[09:28:20.496] - stdout: TRUE
[09:28:20.496] - signal: TRUE
[09:28:20.496] - resignal: FALSE
[09:28:20.496] - force: TRUE
[09:28:20.496] - relayed: [n=2] TRUE, TRUE
[09:28:20.496] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.496] - relayed: [n=2] TRUE, TRUE
[09:28:20.496] - queued futures: [n=2] TRUE, TRUE
[09:28:20.496] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.496] resolve() on list ... DONE
[09:28:20.496] result() for ClusterFuture ...
[09:28:20.497] - result already collected: FutureResult
[09:28:20.497] result() for ClusterFuture ... done
[09:28:20.497] result() for ClusterFuture ...
[09:28:20.497] - result already collected: FutureResult
[09:28:20.497] result() for ClusterFuture ... done
[09:28:20.497] result() for ClusterFuture ...
[09:28:20.497] - result already collected: FutureResult
[09:28:20.497] result() for ClusterFuture ... done
[09:28:20.497] result() for ClusterFuture ...
[09:28:20.497] - result already collected: FutureResult
[09:28:20.497] result() for ClusterFuture ... done
[09:28:20.497]  - Number of value chunks collected: 2
[09:28:20.498] Resolving 2 futures (chunks) ... DONE
[09:28:20.498] Reducing values from 2 chunks ...
[09:28:20.498]  - Number of values collected after concatenation: 2
[09:28:20.498]  - Number of values expected: 2
[09:28:20.498] Reducing values from 2 chunks ... DONE
[09:28:20.498] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[09:28:20.498] getGlobalsAndPackagesXApply() ...
[09:28:20.499]  - future.globals: TRUE
[09:28:20.499] getGlobalsAndPackages() ...
[09:28:20.499] Searching for globals...
[09:28:20.500] - globals found: [1] ‘FUN’
[09:28:20.500] Searching for globals ... DONE
[09:28:20.500] Resolving globals: FALSE
[09:28:20.500] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:20.501] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:20.501] - globals: [1] ‘FUN’
[09:28:20.501] 
[09:28:20.501] getGlobalsAndPackages() ... DONE
[09:28:20.501]  - globals found/used: [n=1] ‘FUN’
[09:28:20.501]  - needed namespaces: [n=0] 
[09:28:20.501] Finding globals ... DONE
[09:28:20.501]  - use_args: TRUE
[09:28:20.501]  - Getting '...' globals ...
[09:28:20.502] resolve() on list ...
[09:28:20.502]  recursive: 0
[09:28:20.502]  length: 1
[09:28:20.502]  elements: ‘...’
[09:28:20.502]  length: 0 (resolved future 1)
[09:28:20.502] resolve() on list ... DONE
[09:28:20.502]    - '...' content: [n=0] 
[09:28:20.502] List of 1
[09:28:20.502]  $ ...: list()
[09:28:20.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.502]  - attr(*, "where")=List of 1
[09:28:20.502]   ..$ ...:<environment: 0x559ba5995340> 
[09:28:20.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.502]  - attr(*, "resolved")= logi TRUE
[09:28:20.502]  - attr(*, "total_size")= num NA
[09:28:20.505]  - Getting '...' globals ... DONE
[09:28:20.505] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.505] List of 2
[09:28:20.505]  $ ...future.FUN:function (x)  
[09:28:20.505]  $ ...          : list()
[09:28:20.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.505]  - attr(*, "where")=List of 2
[09:28:20.505]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.505]   ..$ ...          :<environment: 0x559ba5995340> 
[09:28:20.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.505]  - attr(*, "resolved")= logi FALSE
[09:28:20.505]  - attr(*, "total_size")= num 848
[09:28:20.507] Packages to be attached in all futures: [n=0] 
[09:28:20.508] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.511] future_lapply() ...
[09:28:20.514] Number of chunks: 2
[09:28:20.514] getGlobalsAndPackagesXApply() ...
[09:28:20.514]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.515]  - use_args: TRUE
[09:28:20.515] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.515] List of 2
[09:28:20.515]  $ ...          : list()
[09:28:20.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.515]  $ ...future.FUN:function (x)  
[09:28:20.515]  - attr(*, "where")=List of 2
[09:28:20.515]   ..$ ...          :<environment: 0x559ba5995340> 
[09:28:20.515]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:20.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.515]  - attr(*, "resolved")= logi FALSE
[09:28:20.515]  - attr(*, "total_size")= num NA
[09:28:20.520] Packages to be attached in all futures: [n=0] 
[09:28:20.520] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.520] Number of futures (= number of chunks): 2
[09:28:20.521] Launching 2 futures (chunks) ...
[09:28:20.521] Chunk #1 of 2 ...
[09:28:20.521]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.521]  - seeds: <none>
[09:28:20.521]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.521] getGlobalsAndPackages() ...
[09:28:20.521] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.521] Resolving globals: FALSE
[09:28:20.521] Tweak future expression to call with '...' arguments ...
[09:28:20.521] {
[09:28:20.521]     do.call(function(...) {
[09:28:20.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.521]             on.exit(options(oopts), add = TRUE)
[09:28:20.521]         }
[09:28:20.521]         {
[09:28:20.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.521]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.521]             })
[09:28:20.521]         }
[09:28:20.521]     }, args = future.call.arguments)
[09:28:20.521] }
[09:28:20.522] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.522] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.522] 
[09:28:20.522] getGlobalsAndPackages() ... DONE
[09:28:20.523] run() for ‘Future’ ...
[09:28:20.523] - state: ‘created’
[09:28:20.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.537]   - Field: ‘node’
[09:28:20.537]   - Field: ‘label’
[09:28:20.537]   - Field: ‘local’
[09:28:20.537]   - Field: ‘owner’
[09:28:20.537]   - Field: ‘envir’
[09:28:20.537]   - Field: ‘workers’
[09:28:20.537]   - Field: ‘packages’
[09:28:20.537]   - Field: ‘gc’
[09:28:20.537]   - Field: ‘conditions’
[09:28:20.537]   - Field: ‘persistent’
[09:28:20.537]   - Field: ‘expr’
[09:28:20.538]   - Field: ‘uuid’
[09:28:20.538]   - Field: ‘seed’
[09:28:20.538]   - Field: ‘version’
[09:28:20.538]   - Field: ‘result’
[09:28:20.538]   - Field: ‘asynchronous’
[09:28:20.538]   - Field: ‘calls’
[09:28:20.538]   - Field: ‘globals’
[09:28:20.538]   - Field: ‘stdout’
[09:28:20.538]   - Field: ‘earlySignal’
[09:28:20.538]   - Field: ‘lazy’
[09:28:20.538]   - Field: ‘state’
[09:28:20.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.539] - Launch lazy future ...
[09:28:20.539] Packages needed by the future expression (n = 0): <none>
[09:28:20.539] Packages needed by future strategies (n = 0): <none>
[09:28:20.539] {
[09:28:20.539]     {
[09:28:20.539]         {
[09:28:20.539]             ...future.startTime <- base::Sys.time()
[09:28:20.539]             {
[09:28:20.539]                 {
[09:28:20.539]                   {
[09:28:20.539]                     {
[09:28:20.539]                       base::local({
[09:28:20.539]                         has_future <- base::requireNamespace("future", 
[09:28:20.539]                           quietly = TRUE)
[09:28:20.539]                         if (has_future) {
[09:28:20.539]                           ns <- base::getNamespace("future")
[09:28:20.539]                           version <- ns[[".package"]][["version"]]
[09:28:20.539]                           if (is.null(version)) 
[09:28:20.539]                             version <- utils::packageVersion("future")
[09:28:20.539]                         }
[09:28:20.539]                         else {
[09:28:20.539]                           version <- NULL
[09:28:20.539]                         }
[09:28:20.539]                         if (!has_future || version < "1.8.0") {
[09:28:20.539]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.539]                             "", base::R.version$version.string), 
[09:28:20.539]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.539]                               "release", "version")], collapse = " "), 
[09:28:20.539]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.539]                             info)
[09:28:20.539]                           info <- base::paste(info, collapse = "; ")
[09:28:20.539]                           if (!has_future) {
[09:28:20.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.539]                               info)
[09:28:20.539]                           }
[09:28:20.539]                           else {
[09:28:20.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.539]                               info, version)
[09:28:20.539]                           }
[09:28:20.539]                           base::stop(msg)
[09:28:20.539]                         }
[09:28:20.539]                       })
[09:28:20.539]                     }
[09:28:20.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.539]                     base::options(mc.cores = 1L)
[09:28:20.539]                   }
[09:28:20.539]                   ...future.strategy.old <- future::plan("list")
[09:28:20.539]                   options(future.plan = NULL)
[09:28:20.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.539]                 }
[09:28:20.539]                 ...future.workdir <- getwd()
[09:28:20.539]             }
[09:28:20.539]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.539]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.539]         }
[09:28:20.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.539]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.539]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.539]             base::names(...future.oldOptions))
[09:28:20.539]     }
[09:28:20.539]     if (FALSE) {
[09:28:20.539]     }
[09:28:20.539]     else {
[09:28:20.539]         if (TRUE) {
[09:28:20.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.539]                 open = "w")
[09:28:20.539]         }
[09:28:20.539]         else {
[09:28:20.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.539]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.539]         }
[09:28:20.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.539]             base::sink(type = "output", split = FALSE)
[09:28:20.539]             base::close(...future.stdout)
[09:28:20.539]         }, add = TRUE)
[09:28:20.539]     }
[09:28:20.539]     ...future.frame <- base::sys.nframe()
[09:28:20.539]     ...future.conditions <- base::list()
[09:28:20.539]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.539]     if (FALSE) {
[09:28:20.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.539]     }
[09:28:20.539]     ...future.result <- base::tryCatch({
[09:28:20.539]         base::withCallingHandlers({
[09:28:20.539]             ...future.value <- base::withVisible(base::local({
[09:28:20.539]                 ...future.makeSendCondition <- base::local({
[09:28:20.539]                   sendCondition <- NULL
[09:28:20.539]                   function(frame = 1L) {
[09:28:20.539]                     if (is.function(sendCondition)) 
[09:28:20.539]                       return(sendCondition)
[09:28:20.539]                     ns <- getNamespace("parallel")
[09:28:20.539]                     if (exists("sendData", mode = "function", 
[09:28:20.539]                       envir = ns)) {
[09:28:20.539]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.539]                         envir = ns)
[09:28:20.539]                       envir <- sys.frame(frame)
[09:28:20.539]                       master <- NULL
[09:28:20.539]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.539]                         !identical(envir, emptyenv())) {
[09:28:20.539]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.539]                           inherits = FALSE)) {
[09:28:20.539]                           master <- get("master", mode = "list", 
[09:28:20.539]                             envir = envir, inherits = FALSE)
[09:28:20.539]                           if (inherits(master, c("SOCKnode", 
[09:28:20.539]                             "SOCK0node"))) {
[09:28:20.539]                             sendCondition <<- function(cond) {
[09:28:20.539]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.539]                                 success = TRUE)
[09:28:20.539]                               parallel_sendData(master, data)
[09:28:20.539]                             }
[09:28:20.539]                             return(sendCondition)
[09:28:20.539]                           }
[09:28:20.539]                         }
[09:28:20.539]                         frame <- frame + 1L
[09:28:20.539]                         envir <- sys.frame(frame)
[09:28:20.539]                       }
[09:28:20.539]                     }
[09:28:20.539]                     sendCondition <<- function(cond) NULL
[09:28:20.539]                   }
[09:28:20.539]                 })
[09:28:20.539]                 withCallingHandlers({
[09:28:20.539]                   {
[09:28:20.539]                     do.call(function(...) {
[09:28:20.539]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.539]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.539]                         ...future.globals.maxSize)) {
[09:28:20.539]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.539]                         on.exit(options(oopts), add = TRUE)
[09:28:20.539]                       }
[09:28:20.539]                       {
[09:28:20.539]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.539]                           FUN = function(jj) {
[09:28:20.539]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.539]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.539]                           })
[09:28:20.539]                       }
[09:28:20.539]                     }, args = future.call.arguments)
[09:28:20.539]                   }
[09:28:20.539]                 }, immediateCondition = function(cond) {
[09:28:20.539]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.539]                   sendCondition(cond)
[09:28:20.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.539]                   {
[09:28:20.539]                     inherits <- base::inherits
[09:28:20.539]                     invokeRestart <- base::invokeRestart
[09:28:20.539]                     is.null <- base::is.null
[09:28:20.539]                     muffled <- FALSE
[09:28:20.539]                     if (inherits(cond, "message")) {
[09:28:20.539]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.539]                       if (muffled) 
[09:28:20.539]                         invokeRestart("muffleMessage")
[09:28:20.539]                     }
[09:28:20.539]                     else if (inherits(cond, "warning")) {
[09:28:20.539]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.539]                       if (muffled) 
[09:28:20.539]                         invokeRestart("muffleWarning")
[09:28:20.539]                     }
[09:28:20.539]                     else if (inherits(cond, "condition")) {
[09:28:20.539]                       if (!is.null(pattern)) {
[09:28:20.539]                         computeRestarts <- base::computeRestarts
[09:28:20.539]                         grepl <- base::grepl
[09:28:20.539]                         restarts <- computeRestarts(cond)
[09:28:20.539]                         for (restart in restarts) {
[09:28:20.539]                           name <- restart$name
[09:28:20.539]                           if (is.null(name)) 
[09:28:20.539]                             next
[09:28:20.539]                           if (!grepl(pattern, name)) 
[09:28:20.539]                             next
[09:28:20.539]                           invokeRestart(restart)
[09:28:20.539]                           muffled <- TRUE
[09:28:20.539]                           break
[09:28:20.539]                         }
[09:28:20.539]                       }
[09:28:20.539]                     }
[09:28:20.539]                     invisible(muffled)
[09:28:20.539]                   }
[09:28:20.539]                   muffleCondition(cond)
[09:28:20.539]                 })
[09:28:20.539]             }))
[09:28:20.539]             future::FutureResult(value = ...future.value$value, 
[09:28:20.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.539]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.539]                     ...future.globalenv.names))
[09:28:20.539]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.539]         }, condition = base::local({
[09:28:20.539]             c <- base::c
[09:28:20.539]             inherits <- base::inherits
[09:28:20.539]             invokeRestart <- base::invokeRestart
[09:28:20.539]             length <- base::length
[09:28:20.539]             list <- base::list
[09:28:20.539]             seq.int <- base::seq.int
[09:28:20.539]             signalCondition <- base::signalCondition
[09:28:20.539]             sys.calls <- base::sys.calls
[09:28:20.539]             `[[` <- base::`[[`
[09:28:20.539]             `+` <- base::`+`
[09:28:20.539]             `<<-` <- base::`<<-`
[09:28:20.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.539]                   3L)]
[09:28:20.539]             }
[09:28:20.539]             function(cond) {
[09:28:20.539]                 is_error <- inherits(cond, "error")
[09:28:20.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.539]                   NULL)
[09:28:20.539]                 if (is_error) {
[09:28:20.539]                   sessionInformation <- function() {
[09:28:20.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.539]                       search = base::search(), system = base::Sys.info())
[09:28:20.539]                   }
[09:28:20.539]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.539]                     cond$call), session = sessionInformation(), 
[09:28:20.539]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.539]                   signalCondition(cond)
[09:28:20.539]                 }
[09:28:20.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.539]                 "immediateCondition"))) {
[09:28:20.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.539]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.539]                   if (TRUE && !signal) {
[09:28:20.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.539]                     {
[09:28:20.539]                       inherits <- base::inherits
[09:28:20.539]                       invokeRestart <- base::invokeRestart
[09:28:20.539]                       is.null <- base::is.null
[09:28:20.539]                       muffled <- FALSE
[09:28:20.539]                       if (inherits(cond, "message")) {
[09:28:20.539]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.539]                         if (muffled) 
[09:28:20.539]                           invokeRestart("muffleMessage")
[09:28:20.539]                       }
[09:28:20.539]                       else if (inherits(cond, "warning")) {
[09:28:20.539]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.539]                         if (muffled) 
[09:28:20.539]                           invokeRestart("muffleWarning")
[09:28:20.539]                       }
[09:28:20.539]                       else if (inherits(cond, "condition")) {
[09:28:20.539]                         if (!is.null(pattern)) {
[09:28:20.539]                           computeRestarts <- base::computeRestarts
[09:28:20.539]                           grepl <- base::grepl
[09:28:20.539]                           restarts <- computeRestarts(cond)
[09:28:20.539]                           for (restart in restarts) {
[09:28:20.539]                             name <- restart$name
[09:28:20.539]                             if (is.null(name)) 
[09:28:20.539]                               next
[09:28:20.539]                             if (!grepl(pattern, name)) 
[09:28:20.539]                               next
[09:28:20.539]                             invokeRestart(restart)
[09:28:20.539]                             muffled <- TRUE
[09:28:20.539]                             break
[09:28:20.539]                           }
[09:28:20.539]                         }
[09:28:20.539]                       }
[09:28:20.539]                       invisible(muffled)
[09:28:20.539]                     }
[09:28:20.539]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.539]                   }
[09:28:20.539]                 }
[09:28:20.539]                 else {
[09:28:20.539]                   if (TRUE) {
[09:28:20.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.539]                     {
[09:28:20.539]                       inherits <- base::inherits
[09:28:20.539]                       invokeRestart <- base::invokeRestart
[09:28:20.539]                       is.null <- base::is.null
[09:28:20.539]                       muffled <- FALSE
[09:28:20.539]                       if (inherits(cond, "message")) {
[09:28:20.539]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.539]                         if (muffled) 
[09:28:20.539]                           invokeRestart("muffleMessage")
[09:28:20.539]                       }
[09:28:20.539]                       else if (inherits(cond, "warning")) {
[09:28:20.539]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.539]                         if (muffled) 
[09:28:20.539]                           invokeRestart("muffleWarning")
[09:28:20.539]                       }
[09:28:20.539]                       else if (inherits(cond, "condition")) {
[09:28:20.539]                         if (!is.null(pattern)) {
[09:28:20.539]                           computeRestarts <- base::computeRestarts
[09:28:20.539]                           grepl <- base::grepl
[09:28:20.539]                           restarts <- computeRestarts(cond)
[09:28:20.539]                           for (restart in restarts) {
[09:28:20.539]                             name <- restart$name
[09:28:20.539]                             if (is.null(name)) 
[09:28:20.539]                               next
[09:28:20.539]                             if (!grepl(pattern, name)) 
[09:28:20.539]                               next
[09:28:20.539]                             invokeRestart(restart)
[09:28:20.539]                             muffled <- TRUE
[09:28:20.539]                             break
[09:28:20.539]                           }
[09:28:20.539]                         }
[09:28:20.539]                       }
[09:28:20.539]                       invisible(muffled)
[09:28:20.539]                     }
[09:28:20.539]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.539]                   }
[09:28:20.539]                 }
[09:28:20.539]             }
[09:28:20.539]         }))
[09:28:20.539]     }, error = function(ex) {
[09:28:20.539]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.539]                 ...future.rng), started = ...future.startTime, 
[09:28:20.539]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.539]             version = "1.8"), class = "FutureResult")
[09:28:20.539]     }, finally = {
[09:28:20.539]         if (!identical(...future.workdir, getwd())) 
[09:28:20.539]             setwd(...future.workdir)
[09:28:20.539]         {
[09:28:20.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.539]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.539]             }
[09:28:20.539]             base::options(...future.oldOptions)
[09:28:20.539]             if (.Platform$OS.type == "windows") {
[09:28:20.539]                 old_names <- names(...future.oldEnvVars)
[09:28:20.539]                 envs <- base::Sys.getenv()
[09:28:20.539]                 names <- names(envs)
[09:28:20.539]                 common <- intersect(names, old_names)
[09:28:20.539]                 added <- setdiff(names, old_names)
[09:28:20.539]                 removed <- setdiff(old_names, names)
[09:28:20.539]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.539]                   envs[common]]
[09:28:20.539]                 NAMES <- toupper(changed)
[09:28:20.539]                 args <- list()
[09:28:20.539]                 for (kk in seq_along(NAMES)) {
[09:28:20.539]                   name <- changed[[kk]]
[09:28:20.539]                   NAME <- NAMES[[kk]]
[09:28:20.539]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.539]                     next
[09:28:20.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.539]                 }
[09:28:20.539]                 NAMES <- toupper(added)
[09:28:20.539]                 for (kk in seq_along(NAMES)) {
[09:28:20.539]                   name <- added[[kk]]
[09:28:20.539]                   NAME <- NAMES[[kk]]
[09:28:20.539]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.539]                     next
[09:28:20.539]                   args[[name]] <- ""
[09:28:20.539]                 }
[09:28:20.539]                 NAMES <- toupper(removed)
[09:28:20.539]                 for (kk in seq_along(NAMES)) {
[09:28:20.539]                   name <- removed[[kk]]
[09:28:20.539]                   NAME <- NAMES[[kk]]
[09:28:20.539]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.539]                     next
[09:28:20.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.539]                 }
[09:28:20.539]                 if (length(args) > 0) 
[09:28:20.539]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.539]             }
[09:28:20.539]             else {
[09:28:20.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.539]             }
[09:28:20.539]             {
[09:28:20.539]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.539]                   0L) {
[09:28:20.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.539]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.539]                   base::options(opts)
[09:28:20.539]                 }
[09:28:20.539]                 {
[09:28:20.539]                   {
[09:28:20.539]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.539]                     NULL
[09:28:20.539]                   }
[09:28:20.539]                   options(future.plan = NULL)
[09:28:20.539]                   if (is.na(NA_character_)) 
[09:28:20.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.539]                     .init = FALSE)
[09:28:20.539]                 }
[09:28:20.539]             }
[09:28:20.539]         }
[09:28:20.539]     })
[09:28:20.539]     if (TRUE) {
[09:28:20.539]         base::sink(type = "output", split = FALSE)
[09:28:20.539]         if (TRUE) {
[09:28:20.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.539]         }
[09:28:20.539]         else {
[09:28:20.539]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.539]         }
[09:28:20.539]         base::close(...future.stdout)
[09:28:20.539]         ...future.stdout <- NULL
[09:28:20.539]     }
[09:28:20.539]     ...future.result$conditions <- ...future.conditions
[09:28:20.539]     ...future.result$finished <- base::Sys.time()
[09:28:20.539]     ...future.result
[09:28:20.539] }
[09:28:20.542] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[09:28:20.542] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.543] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.543] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:28:20.543] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:28:20.543] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:28:20.543] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:28:20.544] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.544] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.544] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.544] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.544] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[09:28:20.545] MultisessionFuture started
[09:28:20.545] - Launch lazy future ... done
[09:28:20.545] run() for ‘MultisessionFuture’ ... done
[09:28:20.545] Created future:
[09:28:20.545] MultisessionFuture:
[09:28:20.545] Label: ‘future_apply-1’
[09:28:20.545] Expression:
[09:28:20.545] {
[09:28:20.545]     do.call(function(...) {
[09:28:20.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.545]             on.exit(options(oopts), add = TRUE)
[09:28:20.545]         }
[09:28:20.545]         {
[09:28:20.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.545]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.545]             })
[09:28:20.545]         }
[09:28:20.545]     }, args = future.call.arguments)
[09:28:20.545] }
[09:28:20.545] Lazy evaluation: FALSE
[09:28:20.545] Asynchronous evaluation: TRUE
[09:28:20.545] Local evaluation: TRUE
[09:28:20.545] Environment: R_GlobalEnv
[09:28:20.545] Capture standard output: TRUE
[09:28:20.545] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.545] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.545] Packages: <none>
[09:28:20.545] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.545] Resolved: FALSE
[09:28:20.545] Value: <not collected>
[09:28:20.545] Conditions captured: <none>
[09:28:20.545] Early signaling: FALSE
[09:28:20.545] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.545] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.557] Chunk #1 of 2 ... DONE
[09:28:20.557] Chunk #2 of 2 ...
[09:28:20.557]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.557]  - seeds: <none>
[09:28:20.557]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.557] getGlobalsAndPackages() ...
[09:28:20.557] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.557] Resolving globals: FALSE
[09:28:20.557] Tweak future expression to call with '...' arguments ...
[09:28:20.557] {
[09:28:20.557]     do.call(function(...) {
[09:28:20.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.557]             on.exit(options(oopts), add = TRUE)
[09:28:20.557]         }
[09:28:20.557]         {
[09:28:20.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.557]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.557]             })
[09:28:20.557]         }
[09:28:20.557]     }, args = future.call.arguments)
[09:28:20.557] }
[09:28:20.558] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.558] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.558] 
[09:28:20.558] getGlobalsAndPackages() ... DONE
[09:28:20.558] run() for ‘Future’ ...
[09:28:20.559] - state: ‘created’
[09:28:20.559] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.572]   - Field: ‘node’
[09:28:20.572]   - Field: ‘label’
[09:28:20.573]   - Field: ‘local’
[09:28:20.573]   - Field: ‘owner’
[09:28:20.573]   - Field: ‘envir’
[09:28:20.573]   - Field: ‘workers’
[09:28:20.573]   - Field: ‘packages’
[09:28:20.573]   - Field: ‘gc’
[09:28:20.573]   - Field: ‘conditions’
[09:28:20.573]   - Field: ‘persistent’
[09:28:20.573]   - Field: ‘expr’
[09:28:20.573]   - Field: ‘uuid’
[09:28:20.574]   - Field: ‘seed’
[09:28:20.574]   - Field: ‘version’
[09:28:20.574]   - Field: ‘result’
[09:28:20.574]   - Field: ‘asynchronous’
[09:28:20.574]   - Field: ‘calls’
[09:28:20.574]   - Field: ‘globals’
[09:28:20.574]   - Field: ‘stdout’
[09:28:20.574]   - Field: ‘earlySignal’
[09:28:20.574]   - Field: ‘lazy’
[09:28:20.574]   - Field: ‘state’
[09:28:20.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.575] - Launch lazy future ...
[09:28:20.575] Packages needed by the future expression (n = 0): <none>
[09:28:20.575] Packages needed by future strategies (n = 0): <none>
[09:28:20.575] {
[09:28:20.575]     {
[09:28:20.575]         {
[09:28:20.575]             ...future.startTime <- base::Sys.time()
[09:28:20.575]             {
[09:28:20.575]                 {
[09:28:20.575]                   {
[09:28:20.575]                     {
[09:28:20.575]                       base::local({
[09:28:20.575]                         has_future <- base::requireNamespace("future", 
[09:28:20.575]                           quietly = TRUE)
[09:28:20.575]                         if (has_future) {
[09:28:20.575]                           ns <- base::getNamespace("future")
[09:28:20.575]                           version <- ns[[".package"]][["version"]]
[09:28:20.575]                           if (is.null(version)) 
[09:28:20.575]                             version <- utils::packageVersion("future")
[09:28:20.575]                         }
[09:28:20.575]                         else {
[09:28:20.575]                           version <- NULL
[09:28:20.575]                         }
[09:28:20.575]                         if (!has_future || version < "1.8.0") {
[09:28:20.575]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.575]                             "", base::R.version$version.string), 
[09:28:20.575]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.575]                               "release", "version")], collapse = " "), 
[09:28:20.575]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.575]                             info)
[09:28:20.575]                           info <- base::paste(info, collapse = "; ")
[09:28:20.575]                           if (!has_future) {
[09:28:20.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.575]                               info)
[09:28:20.575]                           }
[09:28:20.575]                           else {
[09:28:20.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.575]                               info, version)
[09:28:20.575]                           }
[09:28:20.575]                           base::stop(msg)
[09:28:20.575]                         }
[09:28:20.575]                       })
[09:28:20.575]                     }
[09:28:20.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.575]                     base::options(mc.cores = 1L)
[09:28:20.575]                   }
[09:28:20.575]                   ...future.strategy.old <- future::plan("list")
[09:28:20.575]                   options(future.plan = NULL)
[09:28:20.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.575]                 }
[09:28:20.575]                 ...future.workdir <- getwd()
[09:28:20.575]             }
[09:28:20.575]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.575]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.575]         }
[09:28:20.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.575]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.575]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.575]             base::names(...future.oldOptions))
[09:28:20.575]     }
[09:28:20.575]     if (FALSE) {
[09:28:20.575]     }
[09:28:20.575]     else {
[09:28:20.575]         if (TRUE) {
[09:28:20.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.575]                 open = "w")
[09:28:20.575]         }
[09:28:20.575]         else {
[09:28:20.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.575]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.575]         }
[09:28:20.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.575]             base::sink(type = "output", split = FALSE)
[09:28:20.575]             base::close(...future.stdout)
[09:28:20.575]         }, add = TRUE)
[09:28:20.575]     }
[09:28:20.575]     ...future.frame <- base::sys.nframe()
[09:28:20.575]     ...future.conditions <- base::list()
[09:28:20.575]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.575]     if (FALSE) {
[09:28:20.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.575]     }
[09:28:20.575]     ...future.result <- base::tryCatch({
[09:28:20.575]         base::withCallingHandlers({
[09:28:20.575]             ...future.value <- base::withVisible(base::local({
[09:28:20.575]                 ...future.makeSendCondition <- base::local({
[09:28:20.575]                   sendCondition <- NULL
[09:28:20.575]                   function(frame = 1L) {
[09:28:20.575]                     if (is.function(sendCondition)) 
[09:28:20.575]                       return(sendCondition)
[09:28:20.575]                     ns <- getNamespace("parallel")
[09:28:20.575]                     if (exists("sendData", mode = "function", 
[09:28:20.575]                       envir = ns)) {
[09:28:20.575]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.575]                         envir = ns)
[09:28:20.575]                       envir <- sys.frame(frame)
[09:28:20.575]                       master <- NULL
[09:28:20.575]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.575]                         !identical(envir, emptyenv())) {
[09:28:20.575]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.575]                           inherits = FALSE)) {
[09:28:20.575]                           master <- get("master", mode = "list", 
[09:28:20.575]                             envir = envir, inherits = FALSE)
[09:28:20.575]                           if (inherits(master, c("SOCKnode", 
[09:28:20.575]                             "SOCK0node"))) {
[09:28:20.575]                             sendCondition <<- function(cond) {
[09:28:20.575]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.575]                                 success = TRUE)
[09:28:20.575]                               parallel_sendData(master, data)
[09:28:20.575]                             }
[09:28:20.575]                             return(sendCondition)
[09:28:20.575]                           }
[09:28:20.575]                         }
[09:28:20.575]                         frame <- frame + 1L
[09:28:20.575]                         envir <- sys.frame(frame)
[09:28:20.575]                       }
[09:28:20.575]                     }
[09:28:20.575]                     sendCondition <<- function(cond) NULL
[09:28:20.575]                   }
[09:28:20.575]                 })
[09:28:20.575]                 withCallingHandlers({
[09:28:20.575]                   {
[09:28:20.575]                     do.call(function(...) {
[09:28:20.575]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.575]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.575]                         ...future.globals.maxSize)) {
[09:28:20.575]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.575]                         on.exit(options(oopts), add = TRUE)
[09:28:20.575]                       }
[09:28:20.575]                       {
[09:28:20.575]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.575]                           FUN = function(jj) {
[09:28:20.575]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.575]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.575]                           })
[09:28:20.575]                       }
[09:28:20.575]                     }, args = future.call.arguments)
[09:28:20.575]                   }
[09:28:20.575]                 }, immediateCondition = function(cond) {
[09:28:20.575]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.575]                   sendCondition(cond)
[09:28:20.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.575]                   {
[09:28:20.575]                     inherits <- base::inherits
[09:28:20.575]                     invokeRestart <- base::invokeRestart
[09:28:20.575]                     is.null <- base::is.null
[09:28:20.575]                     muffled <- FALSE
[09:28:20.575]                     if (inherits(cond, "message")) {
[09:28:20.575]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.575]                       if (muffled) 
[09:28:20.575]                         invokeRestart("muffleMessage")
[09:28:20.575]                     }
[09:28:20.575]                     else if (inherits(cond, "warning")) {
[09:28:20.575]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.575]                       if (muffled) 
[09:28:20.575]                         invokeRestart("muffleWarning")
[09:28:20.575]                     }
[09:28:20.575]                     else if (inherits(cond, "condition")) {
[09:28:20.575]                       if (!is.null(pattern)) {
[09:28:20.575]                         computeRestarts <- base::computeRestarts
[09:28:20.575]                         grepl <- base::grepl
[09:28:20.575]                         restarts <- computeRestarts(cond)
[09:28:20.575]                         for (restart in restarts) {
[09:28:20.575]                           name <- restart$name
[09:28:20.575]                           if (is.null(name)) 
[09:28:20.575]                             next
[09:28:20.575]                           if (!grepl(pattern, name)) 
[09:28:20.575]                             next
[09:28:20.575]                           invokeRestart(restart)
[09:28:20.575]                           muffled <- TRUE
[09:28:20.575]                           break
[09:28:20.575]                         }
[09:28:20.575]                       }
[09:28:20.575]                     }
[09:28:20.575]                     invisible(muffled)
[09:28:20.575]                   }
[09:28:20.575]                   muffleCondition(cond)
[09:28:20.575]                 })
[09:28:20.575]             }))
[09:28:20.575]             future::FutureResult(value = ...future.value$value, 
[09:28:20.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.575]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.575]                     ...future.globalenv.names))
[09:28:20.575]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.575]         }, condition = base::local({
[09:28:20.575]             c <- base::c
[09:28:20.575]             inherits <- base::inherits
[09:28:20.575]             invokeRestart <- base::invokeRestart
[09:28:20.575]             length <- base::length
[09:28:20.575]             list <- base::list
[09:28:20.575]             seq.int <- base::seq.int
[09:28:20.575]             signalCondition <- base::signalCondition
[09:28:20.575]             sys.calls <- base::sys.calls
[09:28:20.575]             `[[` <- base::`[[`
[09:28:20.575]             `+` <- base::`+`
[09:28:20.575]             `<<-` <- base::`<<-`
[09:28:20.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.575]                   3L)]
[09:28:20.575]             }
[09:28:20.575]             function(cond) {
[09:28:20.575]                 is_error <- inherits(cond, "error")
[09:28:20.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.575]                   NULL)
[09:28:20.575]                 if (is_error) {
[09:28:20.575]                   sessionInformation <- function() {
[09:28:20.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.575]                       search = base::search(), system = base::Sys.info())
[09:28:20.575]                   }
[09:28:20.575]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.575]                     cond$call), session = sessionInformation(), 
[09:28:20.575]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.575]                   signalCondition(cond)
[09:28:20.575]                 }
[09:28:20.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.575]                 "immediateCondition"))) {
[09:28:20.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.575]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.575]                   if (TRUE && !signal) {
[09:28:20.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.575]                     {
[09:28:20.575]                       inherits <- base::inherits
[09:28:20.575]                       invokeRestart <- base::invokeRestart
[09:28:20.575]                       is.null <- base::is.null
[09:28:20.575]                       muffled <- FALSE
[09:28:20.575]                       if (inherits(cond, "message")) {
[09:28:20.575]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.575]                         if (muffled) 
[09:28:20.575]                           invokeRestart("muffleMessage")
[09:28:20.575]                       }
[09:28:20.575]                       else if (inherits(cond, "warning")) {
[09:28:20.575]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.575]                         if (muffled) 
[09:28:20.575]                           invokeRestart("muffleWarning")
[09:28:20.575]                       }
[09:28:20.575]                       else if (inherits(cond, "condition")) {
[09:28:20.575]                         if (!is.null(pattern)) {
[09:28:20.575]                           computeRestarts <- base::computeRestarts
[09:28:20.575]                           grepl <- base::grepl
[09:28:20.575]                           restarts <- computeRestarts(cond)
[09:28:20.575]                           for (restart in restarts) {
[09:28:20.575]                             name <- restart$name
[09:28:20.575]                             if (is.null(name)) 
[09:28:20.575]                               next
[09:28:20.575]                             if (!grepl(pattern, name)) 
[09:28:20.575]                               next
[09:28:20.575]                             invokeRestart(restart)
[09:28:20.575]                             muffled <- TRUE
[09:28:20.575]                             break
[09:28:20.575]                           }
[09:28:20.575]                         }
[09:28:20.575]                       }
[09:28:20.575]                       invisible(muffled)
[09:28:20.575]                     }
[09:28:20.575]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.575]                   }
[09:28:20.575]                 }
[09:28:20.575]                 else {
[09:28:20.575]                   if (TRUE) {
[09:28:20.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.575]                     {
[09:28:20.575]                       inherits <- base::inherits
[09:28:20.575]                       invokeRestart <- base::invokeRestart
[09:28:20.575]                       is.null <- base::is.null
[09:28:20.575]                       muffled <- FALSE
[09:28:20.575]                       if (inherits(cond, "message")) {
[09:28:20.575]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.575]                         if (muffled) 
[09:28:20.575]                           invokeRestart("muffleMessage")
[09:28:20.575]                       }
[09:28:20.575]                       else if (inherits(cond, "warning")) {
[09:28:20.575]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.575]                         if (muffled) 
[09:28:20.575]                           invokeRestart("muffleWarning")
[09:28:20.575]                       }
[09:28:20.575]                       else if (inherits(cond, "condition")) {
[09:28:20.575]                         if (!is.null(pattern)) {
[09:28:20.575]                           computeRestarts <- base::computeRestarts
[09:28:20.575]                           grepl <- base::grepl
[09:28:20.575]                           restarts <- computeRestarts(cond)
[09:28:20.575]                           for (restart in restarts) {
[09:28:20.575]                             name <- restart$name
[09:28:20.575]                             if (is.null(name)) 
[09:28:20.575]                               next
[09:28:20.575]                             if (!grepl(pattern, name)) 
[09:28:20.575]                               next
[09:28:20.575]                             invokeRestart(restart)
[09:28:20.575]                             muffled <- TRUE
[09:28:20.575]                             break
[09:28:20.575]                           }
[09:28:20.575]                         }
[09:28:20.575]                       }
[09:28:20.575]                       invisible(muffled)
[09:28:20.575]                     }
[09:28:20.575]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.575]                   }
[09:28:20.575]                 }
[09:28:20.575]             }
[09:28:20.575]         }))
[09:28:20.575]     }, error = function(ex) {
[09:28:20.575]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.575]                 ...future.rng), started = ...future.startTime, 
[09:28:20.575]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.575]             version = "1.8"), class = "FutureResult")
[09:28:20.575]     }, finally = {
[09:28:20.575]         if (!identical(...future.workdir, getwd())) 
[09:28:20.575]             setwd(...future.workdir)
[09:28:20.575]         {
[09:28:20.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.575]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.575]             }
[09:28:20.575]             base::options(...future.oldOptions)
[09:28:20.575]             if (.Platform$OS.type == "windows") {
[09:28:20.575]                 old_names <- names(...future.oldEnvVars)
[09:28:20.575]                 envs <- base::Sys.getenv()
[09:28:20.575]                 names <- names(envs)
[09:28:20.575]                 common <- intersect(names, old_names)
[09:28:20.575]                 added <- setdiff(names, old_names)
[09:28:20.575]                 removed <- setdiff(old_names, names)
[09:28:20.575]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.575]                   envs[common]]
[09:28:20.575]                 NAMES <- toupper(changed)
[09:28:20.575]                 args <- list()
[09:28:20.575]                 for (kk in seq_along(NAMES)) {
[09:28:20.575]                   name <- changed[[kk]]
[09:28:20.575]                   NAME <- NAMES[[kk]]
[09:28:20.575]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.575]                     next
[09:28:20.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.575]                 }
[09:28:20.575]                 NAMES <- toupper(added)
[09:28:20.575]                 for (kk in seq_along(NAMES)) {
[09:28:20.575]                   name <- added[[kk]]
[09:28:20.575]                   NAME <- NAMES[[kk]]
[09:28:20.575]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.575]                     next
[09:28:20.575]                   args[[name]] <- ""
[09:28:20.575]                 }
[09:28:20.575]                 NAMES <- toupper(removed)
[09:28:20.575]                 for (kk in seq_along(NAMES)) {
[09:28:20.575]                   name <- removed[[kk]]
[09:28:20.575]                   NAME <- NAMES[[kk]]
[09:28:20.575]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.575]                     next
[09:28:20.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.575]                 }
[09:28:20.575]                 if (length(args) > 0) 
[09:28:20.575]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.575]             }
[09:28:20.575]             else {
[09:28:20.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.575]             }
[09:28:20.575]             {
[09:28:20.575]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.575]                   0L) {
[09:28:20.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.575]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.575]                   base::options(opts)
[09:28:20.575]                 }
[09:28:20.575]                 {
[09:28:20.575]                   {
[09:28:20.575]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.575]                     NULL
[09:28:20.575]                   }
[09:28:20.575]                   options(future.plan = NULL)
[09:28:20.575]                   if (is.na(NA_character_)) 
[09:28:20.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.575]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.575]                     .init = FALSE)
[09:28:20.575]                 }
[09:28:20.575]             }
[09:28:20.575]         }
[09:28:20.575]     })
[09:28:20.575]     if (TRUE) {
[09:28:20.575]         base::sink(type = "output", split = FALSE)
[09:28:20.575]         if (TRUE) {
[09:28:20.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.575]         }
[09:28:20.575]         else {
[09:28:20.575]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.575]         }
[09:28:20.575]         base::close(...future.stdout)
[09:28:20.575]         ...future.stdout <- NULL
[09:28:20.575]     }
[09:28:20.575]     ...future.result$conditions <- ...future.conditions
[09:28:20.575]     ...future.result$finished <- base::Sys.time()
[09:28:20.575]     ...future.result
[09:28:20.575] }
[09:28:20.578] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[09:28:20.578] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.579] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.579] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[09:28:20.579] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[09:28:20.579] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:28:20.579] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:28:20.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.580] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.580] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.580] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.580] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[09:28:20.581] MultisessionFuture started
[09:28:20.581] - Launch lazy future ... done
[09:28:20.581] run() for ‘MultisessionFuture’ ... done
[09:28:20.581] Created future:
[09:28:20.581] MultisessionFuture:
[09:28:20.581] Label: ‘future_apply-2’
[09:28:20.581] Expression:
[09:28:20.581] {
[09:28:20.581]     do.call(function(...) {
[09:28:20.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.581]             on.exit(options(oopts), add = TRUE)
[09:28:20.581]         }
[09:28:20.581]         {
[09:28:20.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.581]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.581]             })
[09:28:20.581]         }
[09:28:20.581]     }, args = future.call.arguments)
[09:28:20.581] }
[09:28:20.581] Lazy evaluation: FALSE
[09:28:20.581] Asynchronous evaluation: TRUE
[09:28:20.581] Local evaluation: TRUE
[09:28:20.581] Environment: R_GlobalEnv
[09:28:20.581] Capture standard output: TRUE
[09:28:20.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.581] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.581] Packages: <none>
[09:28:20.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.581] Resolved: FALSE
[09:28:20.581] Value: <not collected>
[09:28:20.581] Conditions captured: <none>
[09:28:20.581] Early signaling: FALSE
[09:28:20.581] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.581] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.593] Chunk #2 of 2 ... DONE
[09:28:20.593] Launching 2 futures (chunks) ... DONE
[09:28:20.593] Resolving 2 futures (chunks) ...
[09:28:20.593] resolve() on list ...
[09:28:20.593]  recursive: 0
[09:28:20.593]  length: 2
[09:28:20.593] 
[09:28:20.594] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.594] - Validating connection of MultisessionFuture
[09:28:20.594] - received message: FutureResult
[09:28:20.594] - Received FutureResult
[09:28:20.594] - Erased future from FutureRegistry
[09:28:20.594] result() for ClusterFuture ...
[09:28:20.594] - result already collected: FutureResult
[09:28:20.594] result() for ClusterFuture ... done
[09:28:20.594] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.594] Future #1
[09:28:20.595] result() for ClusterFuture ...
[09:28:20.595] - result already collected: FutureResult
[09:28:20.595] result() for ClusterFuture ... done
[09:28:20.595] result() for ClusterFuture ...
[09:28:20.595] - result already collected: FutureResult
[09:28:20.595] result() for ClusterFuture ... done
[09:28:20.595] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.595] - nx: 2
[09:28:20.595] - relay: TRUE
[09:28:20.595] - stdout: TRUE
[09:28:20.595] - signal: TRUE
[09:28:20.596] - resignal: FALSE
[09:28:20.596] - force: TRUE
[09:28:20.596] - relayed: [n=2] FALSE, FALSE
[09:28:20.596] - queued futures: [n=2] FALSE, FALSE
[09:28:20.596]  - until=1
[09:28:20.596]  - relaying element #1
[09:28:20.596] result() for ClusterFuture ...
[09:28:20.596] - result already collected: FutureResult
[09:28:20.596] result() for ClusterFuture ... done
[09:28:20.596] result() for ClusterFuture ...
[09:28:20.596] - result already collected: FutureResult
[09:28:20.596] result() for ClusterFuture ... done
[09:28:20.597] result() for ClusterFuture ...
[09:28:20.597] - result already collected: FutureResult
[09:28:20.597] result() for ClusterFuture ... done
[09:28:20.597] result() for ClusterFuture ...
[09:28:20.597] - result already collected: FutureResult
[09:28:20.597] result() for ClusterFuture ... done
[09:28:20.597] - relayed: [n=2] TRUE, FALSE
[09:28:20.597] - queued futures: [n=2] TRUE, FALSE
[09:28:20.597] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.597]  length: 1 (resolved future 1)
[09:28:20.625] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.625] - Validating connection of MultisessionFuture
[09:28:20.626] - received message: FutureResult
[09:28:20.626] - Received FutureResult
[09:28:20.626] - Erased future from FutureRegistry
[09:28:20.626] result() for ClusterFuture ...
[09:28:20.626] - result already collected: FutureResult
[09:28:20.626] result() for ClusterFuture ... done
[09:28:20.626] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.626] Future #2
[09:28:20.626] result() for ClusterFuture ...
[09:28:20.627] - result already collected: FutureResult
[09:28:20.627] result() for ClusterFuture ... done
[09:28:20.627] result() for ClusterFuture ...
[09:28:20.627] - result already collected: FutureResult
[09:28:20.627] result() for ClusterFuture ... done
[09:28:20.627] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.627] - nx: 2
[09:28:20.627] - relay: TRUE
[09:28:20.627] - stdout: TRUE
[09:28:20.627] - signal: TRUE
[09:28:20.627] - resignal: FALSE
[09:28:20.627] - force: TRUE
[09:28:20.628] - relayed: [n=2] TRUE, FALSE
[09:28:20.628] - queued futures: [n=2] TRUE, FALSE
[09:28:20.628]  - until=2
[09:28:20.628]  - relaying element #2
[09:28:20.628] result() for ClusterFuture ...
[09:28:20.628] - result already collected: FutureResult
[09:28:20.628] result() for ClusterFuture ... done
[09:28:20.628] result() for ClusterFuture ...
[09:28:20.628] - result already collected: FutureResult
[09:28:20.628] result() for ClusterFuture ... done
[09:28:20.628] result() for ClusterFuture ...
[09:28:20.629] - result already collected: FutureResult
[09:28:20.629] result() for ClusterFuture ... done
[09:28:20.629] result() for ClusterFuture ...
[09:28:20.629] - result already collected: FutureResult
[09:28:20.629] result() for ClusterFuture ... done
[09:28:20.629] - relayed: [n=2] TRUE, TRUE
[09:28:20.629] - queued futures: [n=2] TRUE, TRUE
[09:28:20.629] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.629]  length: 0 (resolved future 2)
[09:28:20.629] Relaying remaining futures
[09:28:20.629] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.629] - nx: 2
[09:28:20.630] - relay: TRUE
[09:28:20.630] - stdout: TRUE
[09:28:20.630] - signal: TRUE
[09:28:20.630] - resignal: FALSE
[09:28:20.630] - force: TRUE
[09:28:20.630] - relayed: [n=2] TRUE, TRUE
[09:28:20.630] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.630] - relayed: [n=2] TRUE, TRUE
[09:28:20.630] - queued futures: [n=2] TRUE, TRUE
[09:28:20.630] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.630] resolve() on list ... DONE
[09:28:20.630] result() for ClusterFuture ...
[09:28:20.631] - result already collected: FutureResult
[09:28:20.631] result() for ClusterFuture ... done
[09:28:20.631] result() for ClusterFuture ...
[09:28:20.631] - result already collected: FutureResult
[09:28:20.631] result() for ClusterFuture ... done
[09:28:20.631] result() for ClusterFuture ...
[09:28:20.631] - result already collected: FutureResult
[09:28:20.631] result() for ClusterFuture ... done
[09:28:20.631] result() for ClusterFuture ...
[09:28:20.631] - result already collected: FutureResult
[09:28:20.631] result() for ClusterFuture ... done
[09:28:20.632]  - Number of value chunks collected: 2
[09:28:20.632] Resolving 2 futures (chunks) ... DONE
[09:28:20.632] Reducing values from 2 chunks ...
[09:28:20.632]  - Number of values collected after concatenation: 2
[09:28:20.632]  - Number of values expected: 2
[09:28:20.632] Reducing values from 2 chunks ... DONE
[09:28:20.632] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[09:28:20.632] getGlobalsAndPackagesXApply() ...
[09:28:20.632]  - future.globals: TRUE
[09:28:20.633] getGlobalsAndPackages() ...
[09:28:20.633] Searching for globals...
[09:28:20.634] - globals found: [1] ‘FUN’
[09:28:20.634] Searching for globals ... DONE
[09:28:20.634] Resolving globals: FALSE
[09:28:20.634] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:20.634] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:20.635] - globals: [1] ‘FUN’
[09:28:20.635] 
[09:28:20.635] getGlobalsAndPackages() ... DONE
[09:28:20.635]  - globals found/used: [n=1] ‘FUN’
[09:28:20.635]  - needed namespaces: [n=0] 
[09:28:20.635] Finding globals ... DONE
[09:28:20.635]  - use_args: TRUE
[09:28:20.635]  - Getting '...' globals ...
[09:28:20.635] resolve() on list ...
[09:28:20.636]  recursive: 0
[09:28:20.636]  length: 1
[09:28:20.636]  elements: ‘...’
[09:28:20.636]  length: 0 (resolved future 1)
[09:28:20.636] resolve() on list ... DONE
[09:28:20.636]    - '...' content: [n=0] 
[09:28:20.636] List of 1
[09:28:20.636]  $ ...: list()
[09:28:20.636]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.636]  - attr(*, "where")=List of 1
[09:28:20.636]   ..$ ...:<environment: 0x559ba5708480> 
[09:28:20.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.636]  - attr(*, "resolved")= logi TRUE
[09:28:20.636]  - attr(*, "total_size")= num NA
[09:28:20.639]  - Getting '...' globals ... DONE
[09:28:20.639] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.639] List of 2
[09:28:20.639]  $ ...future.FUN:function (x)  
[09:28:20.639]  $ ...          : list()
[09:28:20.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.639]  - attr(*, "where")=List of 2
[09:28:20.639]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.639]   ..$ ...          :<environment: 0x559ba5708480> 
[09:28:20.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.639]  - attr(*, "resolved")= logi FALSE
[09:28:20.639]  - attr(*, "total_size")= num 848
[09:28:20.641] Packages to be attached in all futures: [n=0] 
[09:28:20.641] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.645] future_lapply() ...
[09:28:20.648] Number of chunks: 2
[09:28:20.648] getGlobalsAndPackagesXApply() ...
[09:28:20.648]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.649]  - use_args: TRUE
[09:28:20.649] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.649] List of 2
[09:28:20.649]  $ ...          : list()
[09:28:20.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.649]  $ ...future.FUN:function (x)  
[09:28:20.649]  - attr(*, "where")=List of 2
[09:28:20.649]   ..$ ...          :<environment: 0x559ba5708480> 
[09:28:20.649]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:20.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.649]  - attr(*, "resolved")= logi FALSE
[09:28:20.649]  - attr(*, "total_size")= num NA
[09:28:20.652] Packages to be attached in all futures: [n=0] 
[09:28:20.652] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.652] Number of futures (= number of chunks): 2
[09:28:20.652] Launching 2 futures (chunks) ...
[09:28:20.653] Chunk #1 of 2 ...
[09:28:20.653]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.653]  - seeds: <none>
[09:28:20.653]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.653] getGlobalsAndPackages() ...
[09:28:20.653] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.653] Resolving globals: FALSE
[09:28:20.653] Tweak future expression to call with '...' arguments ...
[09:28:20.653] {
[09:28:20.653]     do.call(function(...) {
[09:28:20.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.653]             on.exit(options(oopts), add = TRUE)
[09:28:20.653]         }
[09:28:20.653]         {
[09:28:20.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.653]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.653]             })
[09:28:20.653]         }
[09:28:20.653]     }, args = future.call.arguments)
[09:28:20.653] }
[09:28:20.654] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.654] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.654] 
[09:28:20.654] getGlobalsAndPackages() ... DONE
[09:28:20.654] run() for ‘Future’ ...
[09:28:20.655] - state: ‘created’
[09:28:20.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.668] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.668]   - Field: ‘node’
[09:28:20.668]   - Field: ‘label’
[09:28:20.669]   - Field: ‘local’
[09:28:20.669]   - Field: ‘owner’
[09:28:20.669]   - Field: ‘envir’
[09:28:20.669]   - Field: ‘workers’
[09:28:20.669]   - Field: ‘packages’
[09:28:20.669]   - Field: ‘gc’
[09:28:20.669]   - Field: ‘conditions’
[09:28:20.669]   - Field: ‘persistent’
[09:28:20.669]   - Field: ‘expr’
[09:28:20.669]   - Field: ‘uuid’
[09:28:20.669]   - Field: ‘seed’
[09:28:20.670]   - Field: ‘version’
[09:28:20.670]   - Field: ‘result’
[09:28:20.670]   - Field: ‘asynchronous’
[09:28:20.670]   - Field: ‘calls’
[09:28:20.670]   - Field: ‘globals’
[09:28:20.670]   - Field: ‘stdout’
[09:28:20.670]   - Field: ‘earlySignal’
[09:28:20.670]   - Field: ‘lazy’
[09:28:20.670]   - Field: ‘state’
[09:28:20.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.670] - Launch lazy future ...
[09:28:20.671] Packages needed by the future expression (n = 0): <none>
[09:28:20.671] Packages needed by future strategies (n = 0): <none>
[09:28:20.671] {
[09:28:20.671]     {
[09:28:20.671]         {
[09:28:20.671]             ...future.startTime <- base::Sys.time()
[09:28:20.671]             {
[09:28:20.671]                 {
[09:28:20.671]                   {
[09:28:20.671]                     {
[09:28:20.671]                       base::local({
[09:28:20.671]                         has_future <- base::requireNamespace("future", 
[09:28:20.671]                           quietly = TRUE)
[09:28:20.671]                         if (has_future) {
[09:28:20.671]                           ns <- base::getNamespace("future")
[09:28:20.671]                           version <- ns[[".package"]][["version"]]
[09:28:20.671]                           if (is.null(version)) 
[09:28:20.671]                             version <- utils::packageVersion("future")
[09:28:20.671]                         }
[09:28:20.671]                         else {
[09:28:20.671]                           version <- NULL
[09:28:20.671]                         }
[09:28:20.671]                         if (!has_future || version < "1.8.0") {
[09:28:20.671]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.671]                             "", base::R.version$version.string), 
[09:28:20.671]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.671]                               "release", "version")], collapse = " "), 
[09:28:20.671]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.671]                             info)
[09:28:20.671]                           info <- base::paste(info, collapse = "; ")
[09:28:20.671]                           if (!has_future) {
[09:28:20.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.671]                               info)
[09:28:20.671]                           }
[09:28:20.671]                           else {
[09:28:20.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.671]                               info, version)
[09:28:20.671]                           }
[09:28:20.671]                           base::stop(msg)
[09:28:20.671]                         }
[09:28:20.671]                       })
[09:28:20.671]                     }
[09:28:20.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.671]                     base::options(mc.cores = 1L)
[09:28:20.671]                   }
[09:28:20.671]                   ...future.strategy.old <- future::plan("list")
[09:28:20.671]                   options(future.plan = NULL)
[09:28:20.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.671]                 }
[09:28:20.671]                 ...future.workdir <- getwd()
[09:28:20.671]             }
[09:28:20.671]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.671]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.671]         }
[09:28:20.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.671]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.671]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.671]             base::names(...future.oldOptions))
[09:28:20.671]     }
[09:28:20.671]     if (FALSE) {
[09:28:20.671]     }
[09:28:20.671]     else {
[09:28:20.671]         if (TRUE) {
[09:28:20.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.671]                 open = "w")
[09:28:20.671]         }
[09:28:20.671]         else {
[09:28:20.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.671]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.671]         }
[09:28:20.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.671]             base::sink(type = "output", split = FALSE)
[09:28:20.671]             base::close(...future.stdout)
[09:28:20.671]         }, add = TRUE)
[09:28:20.671]     }
[09:28:20.671]     ...future.frame <- base::sys.nframe()
[09:28:20.671]     ...future.conditions <- base::list()
[09:28:20.671]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.671]     if (FALSE) {
[09:28:20.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.671]     }
[09:28:20.671]     ...future.result <- base::tryCatch({
[09:28:20.671]         base::withCallingHandlers({
[09:28:20.671]             ...future.value <- base::withVisible(base::local({
[09:28:20.671]                 ...future.makeSendCondition <- base::local({
[09:28:20.671]                   sendCondition <- NULL
[09:28:20.671]                   function(frame = 1L) {
[09:28:20.671]                     if (is.function(sendCondition)) 
[09:28:20.671]                       return(sendCondition)
[09:28:20.671]                     ns <- getNamespace("parallel")
[09:28:20.671]                     if (exists("sendData", mode = "function", 
[09:28:20.671]                       envir = ns)) {
[09:28:20.671]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.671]                         envir = ns)
[09:28:20.671]                       envir <- sys.frame(frame)
[09:28:20.671]                       master <- NULL
[09:28:20.671]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.671]                         !identical(envir, emptyenv())) {
[09:28:20.671]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.671]                           inherits = FALSE)) {
[09:28:20.671]                           master <- get("master", mode = "list", 
[09:28:20.671]                             envir = envir, inherits = FALSE)
[09:28:20.671]                           if (inherits(master, c("SOCKnode", 
[09:28:20.671]                             "SOCK0node"))) {
[09:28:20.671]                             sendCondition <<- function(cond) {
[09:28:20.671]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.671]                                 success = TRUE)
[09:28:20.671]                               parallel_sendData(master, data)
[09:28:20.671]                             }
[09:28:20.671]                             return(sendCondition)
[09:28:20.671]                           }
[09:28:20.671]                         }
[09:28:20.671]                         frame <- frame + 1L
[09:28:20.671]                         envir <- sys.frame(frame)
[09:28:20.671]                       }
[09:28:20.671]                     }
[09:28:20.671]                     sendCondition <<- function(cond) NULL
[09:28:20.671]                   }
[09:28:20.671]                 })
[09:28:20.671]                 withCallingHandlers({
[09:28:20.671]                   {
[09:28:20.671]                     do.call(function(...) {
[09:28:20.671]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.671]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.671]                         ...future.globals.maxSize)) {
[09:28:20.671]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.671]                         on.exit(options(oopts), add = TRUE)
[09:28:20.671]                       }
[09:28:20.671]                       {
[09:28:20.671]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.671]                           FUN = function(jj) {
[09:28:20.671]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.671]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.671]                           })
[09:28:20.671]                       }
[09:28:20.671]                     }, args = future.call.arguments)
[09:28:20.671]                   }
[09:28:20.671]                 }, immediateCondition = function(cond) {
[09:28:20.671]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.671]                   sendCondition(cond)
[09:28:20.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.671]                   {
[09:28:20.671]                     inherits <- base::inherits
[09:28:20.671]                     invokeRestart <- base::invokeRestart
[09:28:20.671]                     is.null <- base::is.null
[09:28:20.671]                     muffled <- FALSE
[09:28:20.671]                     if (inherits(cond, "message")) {
[09:28:20.671]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.671]                       if (muffled) 
[09:28:20.671]                         invokeRestart("muffleMessage")
[09:28:20.671]                     }
[09:28:20.671]                     else if (inherits(cond, "warning")) {
[09:28:20.671]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.671]                       if (muffled) 
[09:28:20.671]                         invokeRestart("muffleWarning")
[09:28:20.671]                     }
[09:28:20.671]                     else if (inherits(cond, "condition")) {
[09:28:20.671]                       if (!is.null(pattern)) {
[09:28:20.671]                         computeRestarts <- base::computeRestarts
[09:28:20.671]                         grepl <- base::grepl
[09:28:20.671]                         restarts <- computeRestarts(cond)
[09:28:20.671]                         for (restart in restarts) {
[09:28:20.671]                           name <- restart$name
[09:28:20.671]                           if (is.null(name)) 
[09:28:20.671]                             next
[09:28:20.671]                           if (!grepl(pattern, name)) 
[09:28:20.671]                             next
[09:28:20.671]                           invokeRestart(restart)
[09:28:20.671]                           muffled <- TRUE
[09:28:20.671]                           break
[09:28:20.671]                         }
[09:28:20.671]                       }
[09:28:20.671]                     }
[09:28:20.671]                     invisible(muffled)
[09:28:20.671]                   }
[09:28:20.671]                   muffleCondition(cond)
[09:28:20.671]                 })
[09:28:20.671]             }))
[09:28:20.671]             future::FutureResult(value = ...future.value$value, 
[09:28:20.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.671]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.671]                     ...future.globalenv.names))
[09:28:20.671]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.671]         }, condition = base::local({
[09:28:20.671]             c <- base::c
[09:28:20.671]             inherits <- base::inherits
[09:28:20.671]             invokeRestart <- base::invokeRestart
[09:28:20.671]             length <- base::length
[09:28:20.671]             list <- base::list
[09:28:20.671]             seq.int <- base::seq.int
[09:28:20.671]             signalCondition <- base::signalCondition
[09:28:20.671]             sys.calls <- base::sys.calls
[09:28:20.671]             `[[` <- base::`[[`
[09:28:20.671]             `+` <- base::`+`
[09:28:20.671]             `<<-` <- base::`<<-`
[09:28:20.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.671]                   3L)]
[09:28:20.671]             }
[09:28:20.671]             function(cond) {
[09:28:20.671]                 is_error <- inherits(cond, "error")
[09:28:20.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.671]                   NULL)
[09:28:20.671]                 if (is_error) {
[09:28:20.671]                   sessionInformation <- function() {
[09:28:20.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.671]                       search = base::search(), system = base::Sys.info())
[09:28:20.671]                   }
[09:28:20.671]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.671]                     cond$call), session = sessionInformation(), 
[09:28:20.671]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.671]                   signalCondition(cond)
[09:28:20.671]                 }
[09:28:20.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.671]                 "immediateCondition"))) {
[09:28:20.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.671]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.671]                   if (TRUE && !signal) {
[09:28:20.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.671]                     {
[09:28:20.671]                       inherits <- base::inherits
[09:28:20.671]                       invokeRestart <- base::invokeRestart
[09:28:20.671]                       is.null <- base::is.null
[09:28:20.671]                       muffled <- FALSE
[09:28:20.671]                       if (inherits(cond, "message")) {
[09:28:20.671]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.671]                         if (muffled) 
[09:28:20.671]                           invokeRestart("muffleMessage")
[09:28:20.671]                       }
[09:28:20.671]                       else if (inherits(cond, "warning")) {
[09:28:20.671]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.671]                         if (muffled) 
[09:28:20.671]                           invokeRestart("muffleWarning")
[09:28:20.671]                       }
[09:28:20.671]                       else if (inherits(cond, "condition")) {
[09:28:20.671]                         if (!is.null(pattern)) {
[09:28:20.671]                           computeRestarts <- base::computeRestarts
[09:28:20.671]                           grepl <- base::grepl
[09:28:20.671]                           restarts <- computeRestarts(cond)
[09:28:20.671]                           for (restart in restarts) {
[09:28:20.671]                             name <- restart$name
[09:28:20.671]                             if (is.null(name)) 
[09:28:20.671]                               next
[09:28:20.671]                             if (!grepl(pattern, name)) 
[09:28:20.671]                               next
[09:28:20.671]                             invokeRestart(restart)
[09:28:20.671]                             muffled <- TRUE
[09:28:20.671]                             break
[09:28:20.671]                           }
[09:28:20.671]                         }
[09:28:20.671]                       }
[09:28:20.671]                       invisible(muffled)
[09:28:20.671]                     }
[09:28:20.671]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.671]                   }
[09:28:20.671]                 }
[09:28:20.671]                 else {
[09:28:20.671]                   if (TRUE) {
[09:28:20.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.671]                     {
[09:28:20.671]                       inherits <- base::inherits
[09:28:20.671]                       invokeRestart <- base::invokeRestart
[09:28:20.671]                       is.null <- base::is.null
[09:28:20.671]                       muffled <- FALSE
[09:28:20.671]                       if (inherits(cond, "message")) {
[09:28:20.671]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.671]                         if (muffled) 
[09:28:20.671]                           invokeRestart("muffleMessage")
[09:28:20.671]                       }
[09:28:20.671]                       else if (inherits(cond, "warning")) {
[09:28:20.671]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.671]                         if (muffled) 
[09:28:20.671]                           invokeRestart("muffleWarning")
[09:28:20.671]                       }
[09:28:20.671]                       else if (inherits(cond, "condition")) {
[09:28:20.671]                         if (!is.null(pattern)) {
[09:28:20.671]                           computeRestarts <- base::computeRestarts
[09:28:20.671]                           grepl <- base::grepl
[09:28:20.671]                           restarts <- computeRestarts(cond)
[09:28:20.671]                           for (restart in restarts) {
[09:28:20.671]                             name <- restart$name
[09:28:20.671]                             if (is.null(name)) 
[09:28:20.671]                               next
[09:28:20.671]                             if (!grepl(pattern, name)) 
[09:28:20.671]                               next
[09:28:20.671]                             invokeRestart(restart)
[09:28:20.671]                             muffled <- TRUE
[09:28:20.671]                             break
[09:28:20.671]                           }
[09:28:20.671]                         }
[09:28:20.671]                       }
[09:28:20.671]                       invisible(muffled)
[09:28:20.671]                     }
[09:28:20.671]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.671]                   }
[09:28:20.671]                 }
[09:28:20.671]             }
[09:28:20.671]         }))
[09:28:20.671]     }, error = function(ex) {
[09:28:20.671]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.671]                 ...future.rng), started = ...future.startTime, 
[09:28:20.671]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.671]             version = "1.8"), class = "FutureResult")
[09:28:20.671]     }, finally = {
[09:28:20.671]         if (!identical(...future.workdir, getwd())) 
[09:28:20.671]             setwd(...future.workdir)
[09:28:20.671]         {
[09:28:20.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.671]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.671]             }
[09:28:20.671]             base::options(...future.oldOptions)
[09:28:20.671]             if (.Platform$OS.type == "windows") {
[09:28:20.671]                 old_names <- names(...future.oldEnvVars)
[09:28:20.671]                 envs <- base::Sys.getenv()
[09:28:20.671]                 names <- names(envs)
[09:28:20.671]                 common <- intersect(names, old_names)
[09:28:20.671]                 added <- setdiff(names, old_names)
[09:28:20.671]                 removed <- setdiff(old_names, names)
[09:28:20.671]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.671]                   envs[common]]
[09:28:20.671]                 NAMES <- toupper(changed)
[09:28:20.671]                 args <- list()
[09:28:20.671]                 for (kk in seq_along(NAMES)) {
[09:28:20.671]                   name <- changed[[kk]]
[09:28:20.671]                   NAME <- NAMES[[kk]]
[09:28:20.671]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.671]                     next
[09:28:20.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.671]                 }
[09:28:20.671]                 NAMES <- toupper(added)
[09:28:20.671]                 for (kk in seq_along(NAMES)) {
[09:28:20.671]                   name <- added[[kk]]
[09:28:20.671]                   NAME <- NAMES[[kk]]
[09:28:20.671]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.671]                     next
[09:28:20.671]                   args[[name]] <- ""
[09:28:20.671]                 }
[09:28:20.671]                 NAMES <- toupper(removed)
[09:28:20.671]                 for (kk in seq_along(NAMES)) {
[09:28:20.671]                   name <- removed[[kk]]
[09:28:20.671]                   NAME <- NAMES[[kk]]
[09:28:20.671]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.671]                     next
[09:28:20.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.671]                 }
[09:28:20.671]                 if (length(args) > 0) 
[09:28:20.671]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.671]             }
[09:28:20.671]             else {
[09:28:20.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.671]             }
[09:28:20.671]             {
[09:28:20.671]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.671]                   0L) {
[09:28:20.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.671]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.671]                   base::options(opts)
[09:28:20.671]                 }
[09:28:20.671]                 {
[09:28:20.671]                   {
[09:28:20.671]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.671]                     NULL
[09:28:20.671]                   }
[09:28:20.671]                   options(future.plan = NULL)
[09:28:20.671]                   if (is.na(NA_character_)) 
[09:28:20.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.671]                     .init = FALSE)
[09:28:20.671]                 }
[09:28:20.671]             }
[09:28:20.671]         }
[09:28:20.671]     })
[09:28:20.671]     if (TRUE) {
[09:28:20.671]         base::sink(type = "output", split = FALSE)
[09:28:20.671]         if (TRUE) {
[09:28:20.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.671]         }
[09:28:20.671]         else {
[09:28:20.671]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.671]         }
[09:28:20.671]         base::close(...future.stdout)
[09:28:20.671]         ...future.stdout <- NULL
[09:28:20.671]     }
[09:28:20.671]     ...future.result$conditions <- ...future.conditions
[09:28:20.671]     ...future.result$finished <- base::Sys.time()
[09:28:20.671]     ...future.result
[09:28:20.671] }
[09:28:20.674] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:20.674] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.675] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.675] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:28:20.675] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:28:20.675] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[09:28:20.676] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[09:28:20.676] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.676] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.676] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.676] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.677] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:20.677] MultisessionFuture started
[09:28:20.677] - Launch lazy future ... done
[09:28:20.677] run() for ‘MultisessionFuture’ ... done
[09:28:20.677] Created future:
[09:28:20.677] MultisessionFuture:
[09:28:20.677] Label: ‘future_apply-1’
[09:28:20.677] Expression:
[09:28:20.677] {
[09:28:20.677]     do.call(function(...) {
[09:28:20.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.677]             on.exit(options(oopts), add = TRUE)
[09:28:20.677]         }
[09:28:20.677]         {
[09:28:20.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.677]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.677]             })
[09:28:20.677]         }
[09:28:20.677]     }, args = future.call.arguments)
[09:28:20.677] }
[09:28:20.677] Lazy evaluation: FALSE
[09:28:20.677] Asynchronous evaluation: TRUE
[09:28:20.677] Local evaluation: TRUE
[09:28:20.677] Environment: R_GlobalEnv
[09:28:20.677] Capture standard output: TRUE
[09:28:20.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.677] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.677] Packages: <none>
[09:28:20.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.677] Resolved: FALSE
[09:28:20.677] Value: <not collected>
[09:28:20.677] Conditions captured: <none>
[09:28:20.677] Early signaling: FALSE
[09:28:20.677] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.677] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.689] Chunk #1 of 2 ... DONE
[09:28:20.689] Chunk #2 of 2 ...
[09:28:20.689]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.689]  - seeds: <none>
[09:28:20.689]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.689] getGlobalsAndPackages() ...
[09:28:20.689] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.690] Resolving globals: FALSE
[09:28:20.690] Tweak future expression to call with '...' arguments ...
[09:28:20.690] {
[09:28:20.690]     do.call(function(...) {
[09:28:20.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.690]             on.exit(options(oopts), add = TRUE)
[09:28:20.690]         }
[09:28:20.690]         {
[09:28:20.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.690]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.690]             })
[09:28:20.690]         }
[09:28:20.690]     }, args = future.call.arguments)
[09:28:20.690] }
[09:28:20.690] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.690] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.690] 
[09:28:20.691] getGlobalsAndPackages() ... DONE
[09:28:20.691] run() for ‘Future’ ...
[09:28:20.691] - state: ‘created’
[09:28:20.691] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.705]   - Field: ‘node’
[09:28:20.705]   - Field: ‘label’
[09:28:20.705]   - Field: ‘local’
[09:28:20.705]   - Field: ‘owner’
[09:28:20.705]   - Field: ‘envir’
[09:28:20.705]   - Field: ‘workers’
[09:28:20.705]   - Field: ‘packages’
[09:28:20.705]   - Field: ‘gc’
[09:28:20.705]   - Field: ‘conditions’
[09:28:20.706]   - Field: ‘persistent’
[09:28:20.706]   - Field: ‘expr’
[09:28:20.706]   - Field: ‘uuid’
[09:28:20.706]   - Field: ‘seed’
[09:28:20.706]   - Field: ‘version’
[09:28:20.706]   - Field: ‘result’
[09:28:20.706]   - Field: ‘asynchronous’
[09:28:20.706]   - Field: ‘calls’
[09:28:20.706]   - Field: ‘globals’
[09:28:20.706]   - Field: ‘stdout’
[09:28:20.706]   - Field: ‘earlySignal’
[09:28:20.707]   - Field: ‘lazy’
[09:28:20.707]   - Field: ‘state’
[09:28:20.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.707] - Launch lazy future ...
[09:28:20.707] Packages needed by the future expression (n = 0): <none>
[09:28:20.707] Packages needed by future strategies (n = 0): <none>
[09:28:20.709] {
[09:28:20.709]     {
[09:28:20.709]         {
[09:28:20.709]             ...future.startTime <- base::Sys.time()
[09:28:20.709]             {
[09:28:20.709]                 {
[09:28:20.709]                   {
[09:28:20.709]                     {
[09:28:20.709]                       base::local({
[09:28:20.709]                         has_future <- base::requireNamespace("future", 
[09:28:20.709]                           quietly = TRUE)
[09:28:20.709]                         if (has_future) {
[09:28:20.709]                           ns <- base::getNamespace("future")
[09:28:20.709]                           version <- ns[[".package"]][["version"]]
[09:28:20.709]                           if (is.null(version)) 
[09:28:20.709]                             version <- utils::packageVersion("future")
[09:28:20.709]                         }
[09:28:20.709]                         else {
[09:28:20.709]                           version <- NULL
[09:28:20.709]                         }
[09:28:20.709]                         if (!has_future || version < "1.8.0") {
[09:28:20.709]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.709]                             "", base::R.version$version.string), 
[09:28:20.709]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.709]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.709]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.709]                               "release", "version")], collapse = " "), 
[09:28:20.709]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.709]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.709]                             info)
[09:28:20.709]                           info <- base::paste(info, collapse = "; ")
[09:28:20.709]                           if (!has_future) {
[09:28:20.709]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.709]                               info)
[09:28:20.709]                           }
[09:28:20.709]                           else {
[09:28:20.709]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.709]                               info, version)
[09:28:20.709]                           }
[09:28:20.709]                           base::stop(msg)
[09:28:20.709]                         }
[09:28:20.709]                       })
[09:28:20.709]                     }
[09:28:20.709]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.709]                     base::options(mc.cores = 1L)
[09:28:20.709]                   }
[09:28:20.709]                   ...future.strategy.old <- future::plan("list")
[09:28:20.709]                   options(future.plan = NULL)
[09:28:20.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.709]                 }
[09:28:20.709]                 ...future.workdir <- getwd()
[09:28:20.709]             }
[09:28:20.709]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.709]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.709]         }
[09:28:20.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.709]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.709]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.709]             base::names(...future.oldOptions))
[09:28:20.709]     }
[09:28:20.709]     if (FALSE) {
[09:28:20.709]     }
[09:28:20.709]     else {
[09:28:20.709]         if (TRUE) {
[09:28:20.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.709]                 open = "w")
[09:28:20.709]         }
[09:28:20.709]         else {
[09:28:20.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.709]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.709]         }
[09:28:20.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.709]             base::sink(type = "output", split = FALSE)
[09:28:20.709]             base::close(...future.stdout)
[09:28:20.709]         }, add = TRUE)
[09:28:20.709]     }
[09:28:20.709]     ...future.frame <- base::sys.nframe()
[09:28:20.709]     ...future.conditions <- base::list()
[09:28:20.709]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.709]     if (FALSE) {
[09:28:20.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.709]     }
[09:28:20.709]     ...future.result <- base::tryCatch({
[09:28:20.709]         base::withCallingHandlers({
[09:28:20.709]             ...future.value <- base::withVisible(base::local({
[09:28:20.709]                 ...future.makeSendCondition <- base::local({
[09:28:20.709]                   sendCondition <- NULL
[09:28:20.709]                   function(frame = 1L) {
[09:28:20.709]                     if (is.function(sendCondition)) 
[09:28:20.709]                       return(sendCondition)
[09:28:20.709]                     ns <- getNamespace("parallel")
[09:28:20.709]                     if (exists("sendData", mode = "function", 
[09:28:20.709]                       envir = ns)) {
[09:28:20.709]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.709]                         envir = ns)
[09:28:20.709]                       envir <- sys.frame(frame)
[09:28:20.709]                       master <- NULL
[09:28:20.709]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.709]                         !identical(envir, emptyenv())) {
[09:28:20.709]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.709]                           inherits = FALSE)) {
[09:28:20.709]                           master <- get("master", mode = "list", 
[09:28:20.709]                             envir = envir, inherits = FALSE)
[09:28:20.709]                           if (inherits(master, c("SOCKnode", 
[09:28:20.709]                             "SOCK0node"))) {
[09:28:20.709]                             sendCondition <<- function(cond) {
[09:28:20.709]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.709]                                 success = TRUE)
[09:28:20.709]                               parallel_sendData(master, data)
[09:28:20.709]                             }
[09:28:20.709]                             return(sendCondition)
[09:28:20.709]                           }
[09:28:20.709]                         }
[09:28:20.709]                         frame <- frame + 1L
[09:28:20.709]                         envir <- sys.frame(frame)
[09:28:20.709]                       }
[09:28:20.709]                     }
[09:28:20.709]                     sendCondition <<- function(cond) NULL
[09:28:20.709]                   }
[09:28:20.709]                 })
[09:28:20.709]                 withCallingHandlers({
[09:28:20.709]                   {
[09:28:20.709]                     do.call(function(...) {
[09:28:20.709]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.709]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.709]                         ...future.globals.maxSize)) {
[09:28:20.709]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.709]                         on.exit(options(oopts), add = TRUE)
[09:28:20.709]                       }
[09:28:20.709]                       {
[09:28:20.709]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.709]                           FUN = function(jj) {
[09:28:20.709]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.709]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.709]                           })
[09:28:20.709]                       }
[09:28:20.709]                     }, args = future.call.arguments)
[09:28:20.709]                   }
[09:28:20.709]                 }, immediateCondition = function(cond) {
[09:28:20.709]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.709]                   sendCondition(cond)
[09:28:20.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.709]                   {
[09:28:20.709]                     inherits <- base::inherits
[09:28:20.709]                     invokeRestart <- base::invokeRestart
[09:28:20.709]                     is.null <- base::is.null
[09:28:20.709]                     muffled <- FALSE
[09:28:20.709]                     if (inherits(cond, "message")) {
[09:28:20.709]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.709]                       if (muffled) 
[09:28:20.709]                         invokeRestart("muffleMessage")
[09:28:20.709]                     }
[09:28:20.709]                     else if (inherits(cond, "warning")) {
[09:28:20.709]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.709]                       if (muffled) 
[09:28:20.709]                         invokeRestart("muffleWarning")
[09:28:20.709]                     }
[09:28:20.709]                     else if (inherits(cond, "condition")) {
[09:28:20.709]                       if (!is.null(pattern)) {
[09:28:20.709]                         computeRestarts <- base::computeRestarts
[09:28:20.709]                         grepl <- base::grepl
[09:28:20.709]                         restarts <- computeRestarts(cond)
[09:28:20.709]                         for (restart in restarts) {
[09:28:20.709]                           name <- restart$name
[09:28:20.709]                           if (is.null(name)) 
[09:28:20.709]                             next
[09:28:20.709]                           if (!grepl(pattern, name)) 
[09:28:20.709]                             next
[09:28:20.709]                           invokeRestart(restart)
[09:28:20.709]                           muffled <- TRUE
[09:28:20.709]                           break
[09:28:20.709]                         }
[09:28:20.709]                       }
[09:28:20.709]                     }
[09:28:20.709]                     invisible(muffled)
[09:28:20.709]                   }
[09:28:20.709]                   muffleCondition(cond)
[09:28:20.709]                 })
[09:28:20.709]             }))
[09:28:20.709]             future::FutureResult(value = ...future.value$value, 
[09:28:20.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.709]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.709]                     ...future.globalenv.names))
[09:28:20.709]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.709]         }, condition = base::local({
[09:28:20.709]             c <- base::c
[09:28:20.709]             inherits <- base::inherits
[09:28:20.709]             invokeRestart <- base::invokeRestart
[09:28:20.709]             length <- base::length
[09:28:20.709]             list <- base::list
[09:28:20.709]             seq.int <- base::seq.int
[09:28:20.709]             signalCondition <- base::signalCondition
[09:28:20.709]             sys.calls <- base::sys.calls
[09:28:20.709]             `[[` <- base::`[[`
[09:28:20.709]             `+` <- base::`+`
[09:28:20.709]             `<<-` <- base::`<<-`
[09:28:20.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.709]                   3L)]
[09:28:20.709]             }
[09:28:20.709]             function(cond) {
[09:28:20.709]                 is_error <- inherits(cond, "error")
[09:28:20.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.709]                   NULL)
[09:28:20.709]                 if (is_error) {
[09:28:20.709]                   sessionInformation <- function() {
[09:28:20.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.709]                       search = base::search(), system = base::Sys.info())
[09:28:20.709]                   }
[09:28:20.709]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.709]                     cond$call), session = sessionInformation(), 
[09:28:20.709]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.709]                   signalCondition(cond)
[09:28:20.709]                 }
[09:28:20.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.709]                 "immediateCondition"))) {
[09:28:20.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.709]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.709]                   if (TRUE && !signal) {
[09:28:20.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.709]                     {
[09:28:20.709]                       inherits <- base::inherits
[09:28:20.709]                       invokeRestart <- base::invokeRestart
[09:28:20.709]                       is.null <- base::is.null
[09:28:20.709]                       muffled <- FALSE
[09:28:20.709]                       if (inherits(cond, "message")) {
[09:28:20.709]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.709]                         if (muffled) 
[09:28:20.709]                           invokeRestart("muffleMessage")
[09:28:20.709]                       }
[09:28:20.709]                       else if (inherits(cond, "warning")) {
[09:28:20.709]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.709]                         if (muffled) 
[09:28:20.709]                           invokeRestart("muffleWarning")
[09:28:20.709]                       }
[09:28:20.709]                       else if (inherits(cond, "condition")) {
[09:28:20.709]                         if (!is.null(pattern)) {
[09:28:20.709]                           computeRestarts <- base::computeRestarts
[09:28:20.709]                           grepl <- base::grepl
[09:28:20.709]                           restarts <- computeRestarts(cond)
[09:28:20.709]                           for (restart in restarts) {
[09:28:20.709]                             name <- restart$name
[09:28:20.709]                             if (is.null(name)) 
[09:28:20.709]                               next
[09:28:20.709]                             if (!grepl(pattern, name)) 
[09:28:20.709]                               next
[09:28:20.709]                             invokeRestart(restart)
[09:28:20.709]                             muffled <- TRUE
[09:28:20.709]                             break
[09:28:20.709]                           }
[09:28:20.709]                         }
[09:28:20.709]                       }
[09:28:20.709]                       invisible(muffled)
[09:28:20.709]                     }
[09:28:20.709]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.709]                   }
[09:28:20.709]                 }
[09:28:20.709]                 else {
[09:28:20.709]                   if (TRUE) {
[09:28:20.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.709]                     {
[09:28:20.709]                       inherits <- base::inherits
[09:28:20.709]                       invokeRestart <- base::invokeRestart
[09:28:20.709]                       is.null <- base::is.null
[09:28:20.709]                       muffled <- FALSE
[09:28:20.709]                       if (inherits(cond, "message")) {
[09:28:20.709]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.709]                         if (muffled) 
[09:28:20.709]                           invokeRestart("muffleMessage")
[09:28:20.709]                       }
[09:28:20.709]                       else if (inherits(cond, "warning")) {
[09:28:20.709]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.709]                         if (muffled) 
[09:28:20.709]                           invokeRestart("muffleWarning")
[09:28:20.709]                       }
[09:28:20.709]                       else if (inherits(cond, "condition")) {
[09:28:20.709]                         if (!is.null(pattern)) {
[09:28:20.709]                           computeRestarts <- base::computeRestarts
[09:28:20.709]                           grepl <- base::grepl
[09:28:20.709]                           restarts <- computeRestarts(cond)
[09:28:20.709]                           for (restart in restarts) {
[09:28:20.709]                             name <- restart$name
[09:28:20.709]                             if (is.null(name)) 
[09:28:20.709]                               next
[09:28:20.709]                             if (!grepl(pattern, name)) 
[09:28:20.709]                               next
[09:28:20.709]                             invokeRestart(restart)
[09:28:20.709]                             muffled <- TRUE
[09:28:20.709]                             break
[09:28:20.709]                           }
[09:28:20.709]                         }
[09:28:20.709]                       }
[09:28:20.709]                       invisible(muffled)
[09:28:20.709]                     }
[09:28:20.709]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.709]                   }
[09:28:20.709]                 }
[09:28:20.709]             }
[09:28:20.709]         }))
[09:28:20.709]     }, error = function(ex) {
[09:28:20.709]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.709]                 ...future.rng), started = ...future.startTime, 
[09:28:20.709]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.709]             version = "1.8"), class = "FutureResult")
[09:28:20.709]     }, finally = {
[09:28:20.709]         if (!identical(...future.workdir, getwd())) 
[09:28:20.709]             setwd(...future.workdir)
[09:28:20.709]         {
[09:28:20.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.709]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.709]             }
[09:28:20.709]             base::options(...future.oldOptions)
[09:28:20.709]             if (.Platform$OS.type == "windows") {
[09:28:20.709]                 old_names <- names(...future.oldEnvVars)
[09:28:20.709]                 envs <- base::Sys.getenv()
[09:28:20.709]                 names <- names(envs)
[09:28:20.709]                 common <- intersect(names, old_names)
[09:28:20.709]                 added <- setdiff(names, old_names)
[09:28:20.709]                 removed <- setdiff(old_names, names)
[09:28:20.709]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.709]                   envs[common]]
[09:28:20.709]                 NAMES <- toupper(changed)
[09:28:20.709]                 args <- list()
[09:28:20.709]                 for (kk in seq_along(NAMES)) {
[09:28:20.709]                   name <- changed[[kk]]
[09:28:20.709]                   NAME <- NAMES[[kk]]
[09:28:20.709]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.709]                     next
[09:28:20.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.709]                 }
[09:28:20.709]                 NAMES <- toupper(added)
[09:28:20.709]                 for (kk in seq_along(NAMES)) {
[09:28:20.709]                   name <- added[[kk]]
[09:28:20.709]                   NAME <- NAMES[[kk]]
[09:28:20.709]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.709]                     next
[09:28:20.709]                   args[[name]] <- ""
[09:28:20.709]                 }
[09:28:20.709]                 NAMES <- toupper(removed)
[09:28:20.709]                 for (kk in seq_along(NAMES)) {
[09:28:20.709]                   name <- removed[[kk]]
[09:28:20.709]                   NAME <- NAMES[[kk]]
[09:28:20.709]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.709]                     next
[09:28:20.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.709]                 }
[09:28:20.709]                 if (length(args) > 0) 
[09:28:20.709]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.709]             }
[09:28:20.709]             else {
[09:28:20.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.709]             }
[09:28:20.709]             {
[09:28:20.709]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.709]                   0L) {
[09:28:20.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.709]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.709]                   base::options(opts)
[09:28:20.709]                 }
[09:28:20.709]                 {
[09:28:20.709]                   {
[09:28:20.709]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.709]                     NULL
[09:28:20.709]                   }
[09:28:20.709]                   options(future.plan = NULL)
[09:28:20.709]                   if (is.na(NA_character_)) 
[09:28:20.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.709]                     .init = FALSE)
[09:28:20.709]                 }
[09:28:20.709]             }
[09:28:20.709]         }
[09:28:20.709]     })
[09:28:20.709]     if (TRUE) {
[09:28:20.709]         base::sink(type = "output", split = FALSE)
[09:28:20.709]         if (TRUE) {
[09:28:20.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.709]         }
[09:28:20.709]         else {
[09:28:20.709]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.709]         }
[09:28:20.709]         base::close(...future.stdout)
[09:28:20.709]         ...future.stdout <- NULL
[09:28:20.709]     }
[09:28:20.709]     ...future.result$conditions <- ...future.conditions
[09:28:20.709]     ...future.result$finished <- base::Sys.time()
[09:28:20.709]     ...future.result
[09:28:20.709] }
[09:28:20.712] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[09:28:20.712] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.712] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.713] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[09:28:20.713] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[09:28:20.713] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[09:28:20.713] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[09:28:20.713] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.714] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.714] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.714] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.714] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[09:28:20.715] MultisessionFuture started
[09:28:20.715] - Launch lazy future ... done
[09:28:20.715] run() for ‘MultisessionFuture’ ... done
[09:28:20.715] Created future:
[09:28:20.715] MultisessionFuture:
[09:28:20.715] Label: ‘future_apply-2’
[09:28:20.715] Expression:
[09:28:20.715] {
[09:28:20.715]     do.call(function(...) {
[09:28:20.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.715]             on.exit(options(oopts), add = TRUE)
[09:28:20.715]         }
[09:28:20.715]         {
[09:28:20.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.715]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.715]             })
[09:28:20.715]         }
[09:28:20.715]     }, args = future.call.arguments)
[09:28:20.715] }
[09:28:20.715] Lazy evaluation: FALSE
[09:28:20.715] Asynchronous evaluation: TRUE
[09:28:20.715] Local evaluation: TRUE
[09:28:20.715] Environment: R_GlobalEnv
[09:28:20.715] Capture standard output: TRUE
[09:28:20.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.715] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.715] Packages: <none>
[09:28:20.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.715] Resolved: FALSE
[09:28:20.715] Value: <not collected>
[09:28:20.715] Conditions captured: <none>
[09:28:20.715] Early signaling: FALSE
[09:28:20.715] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.715] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.726] Chunk #2 of 2 ... DONE
[09:28:20.727] Launching 2 futures (chunks) ... DONE
[09:28:20.727] Resolving 2 futures (chunks) ...
[09:28:20.727] resolve() on list ...
[09:28:20.727]  recursive: 0
[09:28:20.727]  length: 2
[09:28:20.727] 
[09:28:20.727] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.728] - Validating connection of MultisessionFuture
[09:28:20.728] - received message: FutureResult
[09:28:20.728] - Received FutureResult
[09:28:20.728] - Erased future from FutureRegistry
[09:28:20.728] result() for ClusterFuture ...
[09:28:20.728] - result already collected: FutureResult
[09:28:20.728] result() for ClusterFuture ... done
[09:28:20.728] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.728] Future #1
[09:28:20.728] result() for ClusterFuture ...
[09:28:20.729] - result already collected: FutureResult
[09:28:20.729] result() for ClusterFuture ... done
[09:28:20.729] result() for ClusterFuture ...
[09:28:20.729] - result already collected: FutureResult
[09:28:20.729] result() for ClusterFuture ... done
[09:28:20.729] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.729] - nx: 2
[09:28:20.729] - relay: TRUE
[09:28:20.729] - stdout: TRUE
[09:28:20.729] - signal: TRUE
[09:28:20.729] - resignal: FALSE
[09:28:20.729] - force: TRUE
[09:28:20.730] - relayed: [n=2] FALSE, FALSE
[09:28:20.730] - queued futures: [n=2] FALSE, FALSE
[09:28:20.730]  - until=1
[09:28:20.730]  - relaying element #1
[09:28:20.730] result() for ClusterFuture ...
[09:28:20.730] - result already collected: FutureResult
[09:28:20.730] result() for ClusterFuture ... done
[09:28:20.730] result() for ClusterFuture ...
[09:28:20.730] - result already collected: FutureResult
[09:28:20.730] result() for ClusterFuture ... done
[09:28:20.730] result() for ClusterFuture ...
[09:28:20.731] - result already collected: FutureResult
[09:28:20.731] result() for ClusterFuture ... done
[09:28:20.731] result() for ClusterFuture ...
[09:28:20.731] - result already collected: FutureResult
[09:28:20.731] result() for ClusterFuture ... done
[09:28:20.731] - relayed: [n=2] TRUE, FALSE
[09:28:20.731] - queued futures: [n=2] TRUE, FALSE
[09:28:20.731] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.731]  length: 1 (resolved future 1)
[09:28:20.757] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.757] - Validating connection of MultisessionFuture
[09:28:20.758] - received message: FutureResult
[09:28:20.758] - Received FutureResult
[09:28:20.758] - Erased future from FutureRegistry
[09:28:20.758] result() for ClusterFuture ...
[09:28:20.758] - result already collected: FutureResult
[09:28:20.758] result() for ClusterFuture ... done
[09:28:20.758] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.758] Future #2
[09:28:20.758] result() for ClusterFuture ...
[09:28:20.758] - result already collected: FutureResult
[09:28:20.758] result() for ClusterFuture ... done
[09:28:20.759] result() for ClusterFuture ...
[09:28:20.759] - result already collected: FutureResult
[09:28:20.759] result() for ClusterFuture ... done
[09:28:20.759] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.759] - nx: 2
[09:28:20.759] - relay: TRUE
[09:28:20.759] - stdout: TRUE
[09:28:20.759] - signal: TRUE
[09:28:20.759] - resignal: FALSE
[09:28:20.759] - force: TRUE
[09:28:20.759] - relayed: [n=2] TRUE, FALSE
[09:28:20.759] - queued futures: [n=2] TRUE, FALSE
[09:28:20.760]  - until=2
[09:28:20.760]  - relaying element #2
[09:28:20.760] result() for ClusterFuture ...
[09:28:20.760] - result already collected: FutureResult
[09:28:20.760] result() for ClusterFuture ... done
[09:28:20.760] result() for ClusterFuture ...
[09:28:20.760] - result already collected: FutureResult
[09:28:20.760] result() for ClusterFuture ... done
[09:28:20.760] result() for ClusterFuture ...
[09:28:20.760] - result already collected: FutureResult
[09:28:20.760] result() for ClusterFuture ... done
[09:28:20.761] result() for ClusterFuture ...
[09:28:20.761] - result already collected: FutureResult
[09:28:20.761] result() for ClusterFuture ... done
[09:28:20.761] - relayed: [n=2] TRUE, TRUE
[09:28:20.761] - queued futures: [n=2] TRUE, TRUE
[09:28:20.761] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.761]  length: 0 (resolved future 2)
[09:28:20.761] Relaying remaining futures
[09:28:20.761] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.761] - nx: 2
[09:28:20.761] - relay: TRUE
[09:28:20.761] - stdout: TRUE
[09:28:20.762] - signal: TRUE
[09:28:20.762] - resignal: FALSE
[09:28:20.762] - force: TRUE
[09:28:20.762] - relayed: [n=2] TRUE, TRUE
[09:28:20.762] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.762] - relayed: [n=2] TRUE, TRUE
[09:28:20.762] - queued futures: [n=2] TRUE, TRUE
[09:28:20.762] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.762] resolve() on list ... DONE
[09:28:20.762] result() for ClusterFuture ...
[09:28:20.762] - result already collected: FutureResult
[09:28:20.763] result() for ClusterFuture ... done
[09:28:20.763] result() for ClusterFuture ...
[09:28:20.763] - result already collected: FutureResult
[09:28:20.763] result() for ClusterFuture ... done
[09:28:20.763] result() for ClusterFuture ...
[09:28:20.763] - result already collected: FutureResult
[09:28:20.763] result() for ClusterFuture ... done
[09:28:20.763] result() for ClusterFuture ...
[09:28:20.763] - result already collected: FutureResult
[09:28:20.763] result() for ClusterFuture ... done
[09:28:20.763]  - Number of value chunks collected: 2
[09:28:20.763] Resolving 2 futures (chunks) ... DONE
[09:28:20.764] Reducing values from 2 chunks ...
[09:28:20.764]  - Number of values collected after concatenation: 6
[09:28:20.764]  - Number of values expected: 6
[09:28:20.764] Reducing values from 2 chunks ... DONE
[09:28:20.764] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[09:28:20.764] getGlobalsAndPackagesXApply() ...
[09:28:20.765]  - future.globals: TRUE
[09:28:20.765] getGlobalsAndPackages() ...
[09:28:20.765] Searching for globals...
[09:28:20.766] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[09:28:20.766] Searching for globals ... DONE
[09:28:20.766] Resolving globals: FALSE
[09:28:20.766] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[09:28:20.767] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[09:28:20.767] - globals: [1] ‘FUN’
[09:28:20.767] 
[09:28:20.767] getGlobalsAndPackages() ... DONE
[09:28:20.767]  - globals found/used: [n=1] ‘FUN’
[09:28:20.767]  - needed namespaces: [n=0] 
[09:28:20.767] Finding globals ... DONE
[09:28:20.767]  - use_args: TRUE
[09:28:20.767]  - Getting '...' globals ...
[09:28:20.768] resolve() on list ...
[09:28:20.768]  recursive: 0
[09:28:20.768]  length: 1
[09:28:20.768]  elements: ‘...’
[09:28:20.768]  length: 0 (resolved future 1)
[09:28:20.768] resolve() on list ... DONE
[09:28:20.768]    - '...' content: [n=0] 
[09:28:20.769] List of 1
[09:28:20.769]  $ ...: list()
[09:28:20.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.769]  - attr(*, "where")=List of 1
[09:28:20.769]   ..$ ...:<environment: 0x559ba2519e78> 
[09:28:20.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.769]  - attr(*, "resolved")= logi TRUE
[09:28:20.769]  - attr(*, "total_size")= num NA
[09:28:20.771]  - Getting '...' globals ... DONE
[09:28:20.771] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.771] List of 2
[09:28:20.771]  $ ...future.FUN:function (x)  
[09:28:20.771]  $ ...          : list()
[09:28:20.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.771]  - attr(*, "where")=List of 2
[09:28:20.771]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.771]   ..$ ...          :<environment: 0x559ba2519e78> 
[09:28:20.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.771]  - attr(*, "resolved")= logi FALSE
[09:28:20.771]  - attr(*, "total_size")= num 1768
[09:28:20.774] Packages to be attached in all futures: [n=0] 
[09:28:20.774] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.777] future_lapply() ...
[09:28:20.781] Number of chunks: 2
[09:28:20.781] getGlobalsAndPackagesXApply() ...
[09:28:20.781]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.782]  - use_args: TRUE
[09:28:20.782] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.782] List of 2
[09:28:20.782]  $ ...          : list()
[09:28:20.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.782]  $ ...future.FUN:function (x)  
[09:28:20.782]  - attr(*, "where")=List of 2
[09:28:20.782]   ..$ ...          :<environment: 0x559ba2519e78> 
[09:28:20.782]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:20.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.782]  - attr(*, "resolved")= logi FALSE
[09:28:20.782]  - attr(*, "total_size")= num NA
[09:28:20.785] Packages to be attached in all futures: [n=0] 
[09:28:20.785] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.785] Number of futures (= number of chunks): 2
[09:28:20.785] Launching 2 futures (chunks) ...
[09:28:20.785] Chunk #1 of 2 ...
[09:28:20.785]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.785]  - seeds: <none>
[09:28:20.785]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.785] getGlobalsAndPackages() ...
[09:28:20.786] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.786] Resolving globals: FALSE
[09:28:20.786] Tweak future expression to call with '...' arguments ...
[09:28:20.786] {
[09:28:20.786]     do.call(function(...) {
[09:28:20.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.786]             on.exit(options(oopts), add = TRUE)
[09:28:20.786]         }
[09:28:20.786]         {
[09:28:20.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.786]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.786]             })
[09:28:20.786]         }
[09:28:20.786]     }, args = future.call.arguments)
[09:28:20.786] }
[09:28:20.786] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.786] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.787] 
[09:28:20.787] getGlobalsAndPackages() ... DONE
[09:28:20.787] run() for ‘Future’ ...
[09:28:20.787] - state: ‘created’
[09:28:20.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.801]   - Field: ‘node’
[09:28:20.801]   - Field: ‘label’
[09:28:20.801]   - Field: ‘local’
[09:28:20.801]   - Field: ‘owner’
[09:28:20.801]   - Field: ‘envir’
[09:28:20.801]   - Field: ‘workers’
[09:28:20.801]   - Field: ‘packages’
[09:28:20.801]   - Field: ‘gc’
[09:28:20.801]   - Field: ‘conditions’
[09:28:20.801]   - Field: ‘persistent’
[09:28:20.802]   - Field: ‘expr’
[09:28:20.802]   - Field: ‘uuid’
[09:28:20.802]   - Field: ‘seed’
[09:28:20.802]   - Field: ‘version’
[09:28:20.802]   - Field: ‘result’
[09:28:20.802]   - Field: ‘asynchronous’
[09:28:20.802]   - Field: ‘calls’
[09:28:20.802]   - Field: ‘globals’
[09:28:20.802]   - Field: ‘stdout’
[09:28:20.802]   - Field: ‘earlySignal’
[09:28:20.802]   - Field: ‘lazy’
[09:28:20.803]   - Field: ‘state’
[09:28:20.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.803] - Launch lazy future ...
[09:28:20.803] Packages needed by the future expression (n = 0): <none>
[09:28:20.803] Packages needed by future strategies (n = 0): <none>
[09:28:20.803] {
[09:28:20.803]     {
[09:28:20.803]         {
[09:28:20.803]             ...future.startTime <- base::Sys.time()
[09:28:20.803]             {
[09:28:20.803]                 {
[09:28:20.803]                   {
[09:28:20.803]                     {
[09:28:20.803]                       base::local({
[09:28:20.803]                         has_future <- base::requireNamespace("future", 
[09:28:20.803]                           quietly = TRUE)
[09:28:20.803]                         if (has_future) {
[09:28:20.803]                           ns <- base::getNamespace("future")
[09:28:20.803]                           version <- ns[[".package"]][["version"]]
[09:28:20.803]                           if (is.null(version)) 
[09:28:20.803]                             version <- utils::packageVersion("future")
[09:28:20.803]                         }
[09:28:20.803]                         else {
[09:28:20.803]                           version <- NULL
[09:28:20.803]                         }
[09:28:20.803]                         if (!has_future || version < "1.8.0") {
[09:28:20.803]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.803]                             "", base::R.version$version.string), 
[09:28:20.803]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.803]                               "release", "version")], collapse = " "), 
[09:28:20.803]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.803]                             info)
[09:28:20.803]                           info <- base::paste(info, collapse = "; ")
[09:28:20.803]                           if (!has_future) {
[09:28:20.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.803]                               info)
[09:28:20.803]                           }
[09:28:20.803]                           else {
[09:28:20.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.803]                               info, version)
[09:28:20.803]                           }
[09:28:20.803]                           base::stop(msg)
[09:28:20.803]                         }
[09:28:20.803]                       })
[09:28:20.803]                     }
[09:28:20.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.803]                     base::options(mc.cores = 1L)
[09:28:20.803]                   }
[09:28:20.803]                   ...future.strategy.old <- future::plan("list")
[09:28:20.803]                   options(future.plan = NULL)
[09:28:20.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.803]                 }
[09:28:20.803]                 ...future.workdir <- getwd()
[09:28:20.803]             }
[09:28:20.803]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.803]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.803]         }
[09:28:20.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.803]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.803]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.803]             base::names(...future.oldOptions))
[09:28:20.803]     }
[09:28:20.803]     if (FALSE) {
[09:28:20.803]     }
[09:28:20.803]     else {
[09:28:20.803]         if (TRUE) {
[09:28:20.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.803]                 open = "w")
[09:28:20.803]         }
[09:28:20.803]         else {
[09:28:20.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.803]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.803]         }
[09:28:20.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.803]             base::sink(type = "output", split = FALSE)
[09:28:20.803]             base::close(...future.stdout)
[09:28:20.803]         }, add = TRUE)
[09:28:20.803]     }
[09:28:20.803]     ...future.frame <- base::sys.nframe()
[09:28:20.803]     ...future.conditions <- base::list()
[09:28:20.803]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.803]     if (FALSE) {
[09:28:20.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.803]     }
[09:28:20.803]     ...future.result <- base::tryCatch({
[09:28:20.803]         base::withCallingHandlers({
[09:28:20.803]             ...future.value <- base::withVisible(base::local({
[09:28:20.803]                 ...future.makeSendCondition <- base::local({
[09:28:20.803]                   sendCondition <- NULL
[09:28:20.803]                   function(frame = 1L) {
[09:28:20.803]                     if (is.function(sendCondition)) 
[09:28:20.803]                       return(sendCondition)
[09:28:20.803]                     ns <- getNamespace("parallel")
[09:28:20.803]                     if (exists("sendData", mode = "function", 
[09:28:20.803]                       envir = ns)) {
[09:28:20.803]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.803]                         envir = ns)
[09:28:20.803]                       envir <- sys.frame(frame)
[09:28:20.803]                       master <- NULL
[09:28:20.803]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.803]                         !identical(envir, emptyenv())) {
[09:28:20.803]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.803]                           inherits = FALSE)) {
[09:28:20.803]                           master <- get("master", mode = "list", 
[09:28:20.803]                             envir = envir, inherits = FALSE)
[09:28:20.803]                           if (inherits(master, c("SOCKnode", 
[09:28:20.803]                             "SOCK0node"))) {
[09:28:20.803]                             sendCondition <<- function(cond) {
[09:28:20.803]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.803]                                 success = TRUE)
[09:28:20.803]                               parallel_sendData(master, data)
[09:28:20.803]                             }
[09:28:20.803]                             return(sendCondition)
[09:28:20.803]                           }
[09:28:20.803]                         }
[09:28:20.803]                         frame <- frame + 1L
[09:28:20.803]                         envir <- sys.frame(frame)
[09:28:20.803]                       }
[09:28:20.803]                     }
[09:28:20.803]                     sendCondition <<- function(cond) NULL
[09:28:20.803]                   }
[09:28:20.803]                 })
[09:28:20.803]                 withCallingHandlers({
[09:28:20.803]                   {
[09:28:20.803]                     do.call(function(...) {
[09:28:20.803]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.803]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.803]                         ...future.globals.maxSize)) {
[09:28:20.803]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.803]                         on.exit(options(oopts), add = TRUE)
[09:28:20.803]                       }
[09:28:20.803]                       {
[09:28:20.803]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.803]                           FUN = function(jj) {
[09:28:20.803]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.803]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.803]                           })
[09:28:20.803]                       }
[09:28:20.803]                     }, args = future.call.arguments)
[09:28:20.803]                   }
[09:28:20.803]                 }, immediateCondition = function(cond) {
[09:28:20.803]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.803]                   sendCondition(cond)
[09:28:20.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.803]                   {
[09:28:20.803]                     inherits <- base::inherits
[09:28:20.803]                     invokeRestart <- base::invokeRestart
[09:28:20.803]                     is.null <- base::is.null
[09:28:20.803]                     muffled <- FALSE
[09:28:20.803]                     if (inherits(cond, "message")) {
[09:28:20.803]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.803]                       if (muffled) 
[09:28:20.803]                         invokeRestart("muffleMessage")
[09:28:20.803]                     }
[09:28:20.803]                     else if (inherits(cond, "warning")) {
[09:28:20.803]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.803]                       if (muffled) 
[09:28:20.803]                         invokeRestart("muffleWarning")
[09:28:20.803]                     }
[09:28:20.803]                     else if (inherits(cond, "condition")) {
[09:28:20.803]                       if (!is.null(pattern)) {
[09:28:20.803]                         computeRestarts <- base::computeRestarts
[09:28:20.803]                         grepl <- base::grepl
[09:28:20.803]                         restarts <- computeRestarts(cond)
[09:28:20.803]                         for (restart in restarts) {
[09:28:20.803]                           name <- restart$name
[09:28:20.803]                           if (is.null(name)) 
[09:28:20.803]                             next
[09:28:20.803]                           if (!grepl(pattern, name)) 
[09:28:20.803]                             next
[09:28:20.803]                           invokeRestart(restart)
[09:28:20.803]                           muffled <- TRUE
[09:28:20.803]                           break
[09:28:20.803]                         }
[09:28:20.803]                       }
[09:28:20.803]                     }
[09:28:20.803]                     invisible(muffled)
[09:28:20.803]                   }
[09:28:20.803]                   muffleCondition(cond)
[09:28:20.803]                 })
[09:28:20.803]             }))
[09:28:20.803]             future::FutureResult(value = ...future.value$value, 
[09:28:20.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.803]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.803]                     ...future.globalenv.names))
[09:28:20.803]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.803]         }, condition = base::local({
[09:28:20.803]             c <- base::c
[09:28:20.803]             inherits <- base::inherits
[09:28:20.803]             invokeRestart <- base::invokeRestart
[09:28:20.803]             length <- base::length
[09:28:20.803]             list <- base::list
[09:28:20.803]             seq.int <- base::seq.int
[09:28:20.803]             signalCondition <- base::signalCondition
[09:28:20.803]             sys.calls <- base::sys.calls
[09:28:20.803]             `[[` <- base::`[[`
[09:28:20.803]             `+` <- base::`+`
[09:28:20.803]             `<<-` <- base::`<<-`
[09:28:20.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.803]                   3L)]
[09:28:20.803]             }
[09:28:20.803]             function(cond) {
[09:28:20.803]                 is_error <- inherits(cond, "error")
[09:28:20.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.803]                   NULL)
[09:28:20.803]                 if (is_error) {
[09:28:20.803]                   sessionInformation <- function() {
[09:28:20.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.803]                       search = base::search(), system = base::Sys.info())
[09:28:20.803]                   }
[09:28:20.803]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.803]                     cond$call), session = sessionInformation(), 
[09:28:20.803]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.803]                   signalCondition(cond)
[09:28:20.803]                 }
[09:28:20.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.803]                 "immediateCondition"))) {
[09:28:20.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.803]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.803]                   if (TRUE && !signal) {
[09:28:20.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.803]                     {
[09:28:20.803]                       inherits <- base::inherits
[09:28:20.803]                       invokeRestart <- base::invokeRestart
[09:28:20.803]                       is.null <- base::is.null
[09:28:20.803]                       muffled <- FALSE
[09:28:20.803]                       if (inherits(cond, "message")) {
[09:28:20.803]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.803]                         if (muffled) 
[09:28:20.803]                           invokeRestart("muffleMessage")
[09:28:20.803]                       }
[09:28:20.803]                       else if (inherits(cond, "warning")) {
[09:28:20.803]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.803]                         if (muffled) 
[09:28:20.803]                           invokeRestart("muffleWarning")
[09:28:20.803]                       }
[09:28:20.803]                       else if (inherits(cond, "condition")) {
[09:28:20.803]                         if (!is.null(pattern)) {
[09:28:20.803]                           computeRestarts <- base::computeRestarts
[09:28:20.803]                           grepl <- base::grepl
[09:28:20.803]                           restarts <- computeRestarts(cond)
[09:28:20.803]                           for (restart in restarts) {
[09:28:20.803]                             name <- restart$name
[09:28:20.803]                             if (is.null(name)) 
[09:28:20.803]                               next
[09:28:20.803]                             if (!grepl(pattern, name)) 
[09:28:20.803]                               next
[09:28:20.803]                             invokeRestart(restart)
[09:28:20.803]                             muffled <- TRUE
[09:28:20.803]                             break
[09:28:20.803]                           }
[09:28:20.803]                         }
[09:28:20.803]                       }
[09:28:20.803]                       invisible(muffled)
[09:28:20.803]                     }
[09:28:20.803]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.803]                   }
[09:28:20.803]                 }
[09:28:20.803]                 else {
[09:28:20.803]                   if (TRUE) {
[09:28:20.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.803]                     {
[09:28:20.803]                       inherits <- base::inherits
[09:28:20.803]                       invokeRestart <- base::invokeRestart
[09:28:20.803]                       is.null <- base::is.null
[09:28:20.803]                       muffled <- FALSE
[09:28:20.803]                       if (inherits(cond, "message")) {
[09:28:20.803]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.803]                         if (muffled) 
[09:28:20.803]                           invokeRestart("muffleMessage")
[09:28:20.803]                       }
[09:28:20.803]                       else if (inherits(cond, "warning")) {
[09:28:20.803]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.803]                         if (muffled) 
[09:28:20.803]                           invokeRestart("muffleWarning")
[09:28:20.803]                       }
[09:28:20.803]                       else if (inherits(cond, "condition")) {
[09:28:20.803]                         if (!is.null(pattern)) {
[09:28:20.803]                           computeRestarts <- base::computeRestarts
[09:28:20.803]                           grepl <- base::grepl
[09:28:20.803]                           restarts <- computeRestarts(cond)
[09:28:20.803]                           for (restart in restarts) {
[09:28:20.803]                             name <- restart$name
[09:28:20.803]                             if (is.null(name)) 
[09:28:20.803]                               next
[09:28:20.803]                             if (!grepl(pattern, name)) 
[09:28:20.803]                               next
[09:28:20.803]                             invokeRestart(restart)
[09:28:20.803]                             muffled <- TRUE
[09:28:20.803]                             break
[09:28:20.803]                           }
[09:28:20.803]                         }
[09:28:20.803]                       }
[09:28:20.803]                       invisible(muffled)
[09:28:20.803]                     }
[09:28:20.803]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.803]                   }
[09:28:20.803]                 }
[09:28:20.803]             }
[09:28:20.803]         }))
[09:28:20.803]     }, error = function(ex) {
[09:28:20.803]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.803]                 ...future.rng), started = ...future.startTime, 
[09:28:20.803]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.803]             version = "1.8"), class = "FutureResult")
[09:28:20.803]     }, finally = {
[09:28:20.803]         if (!identical(...future.workdir, getwd())) 
[09:28:20.803]             setwd(...future.workdir)
[09:28:20.803]         {
[09:28:20.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.803]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.803]             }
[09:28:20.803]             base::options(...future.oldOptions)
[09:28:20.803]             if (.Platform$OS.type == "windows") {
[09:28:20.803]                 old_names <- names(...future.oldEnvVars)
[09:28:20.803]                 envs <- base::Sys.getenv()
[09:28:20.803]                 names <- names(envs)
[09:28:20.803]                 common <- intersect(names, old_names)
[09:28:20.803]                 added <- setdiff(names, old_names)
[09:28:20.803]                 removed <- setdiff(old_names, names)
[09:28:20.803]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.803]                   envs[common]]
[09:28:20.803]                 NAMES <- toupper(changed)
[09:28:20.803]                 args <- list()
[09:28:20.803]                 for (kk in seq_along(NAMES)) {
[09:28:20.803]                   name <- changed[[kk]]
[09:28:20.803]                   NAME <- NAMES[[kk]]
[09:28:20.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.803]                     next
[09:28:20.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.803]                 }
[09:28:20.803]                 NAMES <- toupper(added)
[09:28:20.803]                 for (kk in seq_along(NAMES)) {
[09:28:20.803]                   name <- added[[kk]]
[09:28:20.803]                   NAME <- NAMES[[kk]]
[09:28:20.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.803]                     next
[09:28:20.803]                   args[[name]] <- ""
[09:28:20.803]                 }
[09:28:20.803]                 NAMES <- toupper(removed)
[09:28:20.803]                 for (kk in seq_along(NAMES)) {
[09:28:20.803]                   name <- removed[[kk]]
[09:28:20.803]                   NAME <- NAMES[[kk]]
[09:28:20.803]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.803]                     next
[09:28:20.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.803]                 }
[09:28:20.803]                 if (length(args) > 0) 
[09:28:20.803]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.803]             }
[09:28:20.803]             else {
[09:28:20.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.803]             }
[09:28:20.803]             {
[09:28:20.803]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.803]                   0L) {
[09:28:20.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.803]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.803]                   base::options(opts)
[09:28:20.803]                 }
[09:28:20.803]                 {
[09:28:20.803]                   {
[09:28:20.803]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.803]                     NULL
[09:28:20.803]                   }
[09:28:20.803]                   options(future.plan = NULL)
[09:28:20.803]                   if (is.na(NA_character_)) 
[09:28:20.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.803]                     .init = FALSE)
[09:28:20.803]                 }
[09:28:20.803]             }
[09:28:20.803]         }
[09:28:20.803]     })
[09:28:20.803]     if (TRUE) {
[09:28:20.803]         base::sink(type = "output", split = FALSE)
[09:28:20.803]         if (TRUE) {
[09:28:20.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.803]         }
[09:28:20.803]         else {
[09:28:20.803]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.803]         }
[09:28:20.803]         base::close(...future.stdout)
[09:28:20.803]         ...future.stdout <- NULL
[09:28:20.803]     }
[09:28:20.803]     ...future.result$conditions <- ...future.conditions
[09:28:20.803]     ...future.result$finished <- base::Sys.time()
[09:28:20.803]     ...future.result
[09:28:20.803] }
[09:28:20.806] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[09:28:20.806] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.807] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.807] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[09:28:20.807] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[09:28:20.807] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[09:28:20.808] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[09:28:20.808] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.808] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.808] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.809] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.809] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[09:28:20.809] MultisessionFuture started
[09:28:20.809] - Launch lazy future ... done
[09:28:20.809] run() for ‘MultisessionFuture’ ... done
[09:28:20.809] Created future:
[09:28:20.810] MultisessionFuture:
[09:28:20.810] Label: ‘future_apply-1’
[09:28:20.810] Expression:
[09:28:20.810] {
[09:28:20.810]     do.call(function(...) {
[09:28:20.810]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.810]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.810]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.810]             on.exit(options(oopts), add = TRUE)
[09:28:20.810]         }
[09:28:20.810]         {
[09:28:20.810]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.810]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.810]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.810]             })
[09:28:20.810]         }
[09:28:20.810]     }, args = future.call.arguments)
[09:28:20.810] }
[09:28:20.810] Lazy evaluation: FALSE
[09:28:20.810] Asynchronous evaluation: TRUE
[09:28:20.810] Local evaluation: TRUE
[09:28:20.810] Environment: R_GlobalEnv
[09:28:20.810] Capture standard output: TRUE
[09:28:20.810] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.810] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.810] Packages: <none>
[09:28:20.810] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.810] Resolved: FALSE
[09:28:20.810] Value: <not collected>
[09:28:20.810] Conditions captured: <none>
[09:28:20.810] Early signaling: FALSE
[09:28:20.810] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.810] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.821] Chunk #1 of 2 ... DONE
[09:28:20.821] Chunk #2 of 2 ...
[09:28:20.821]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.821]  - seeds: <none>
[09:28:20.821]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.821] getGlobalsAndPackages() ...
[09:28:20.822] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.822] Resolving globals: FALSE
[09:28:20.822] Tweak future expression to call with '...' arguments ...
[09:28:20.822] {
[09:28:20.822]     do.call(function(...) {
[09:28:20.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.822]             on.exit(options(oopts), add = TRUE)
[09:28:20.822]         }
[09:28:20.822]         {
[09:28:20.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.822]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.822]             })
[09:28:20.822]         }
[09:28:20.822]     }, args = future.call.arguments)
[09:28:20.822] }
[09:28:20.822] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.822] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.823] 
[09:28:20.823] getGlobalsAndPackages() ... DONE
[09:28:20.823] run() for ‘Future’ ...
[09:28:20.823] - state: ‘created’
[09:28:20.823] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.836] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.837]   - Field: ‘node’
[09:28:20.837]   - Field: ‘label’
[09:28:20.837]   - Field: ‘local’
[09:28:20.837]   - Field: ‘owner’
[09:28:20.837]   - Field: ‘envir’
[09:28:20.837]   - Field: ‘workers’
[09:28:20.837]   - Field: ‘packages’
[09:28:20.837]   - Field: ‘gc’
[09:28:20.837]   - Field: ‘conditions’
[09:28:20.837]   - Field: ‘persistent’
[09:28:20.837]   - Field: ‘expr’
[09:28:20.838]   - Field: ‘uuid’
[09:28:20.838]   - Field: ‘seed’
[09:28:20.838]   - Field: ‘version’
[09:28:20.838]   - Field: ‘result’
[09:28:20.838]   - Field: ‘asynchronous’
[09:28:20.838]   - Field: ‘calls’
[09:28:20.838]   - Field: ‘globals’
[09:28:20.838]   - Field: ‘stdout’
[09:28:20.838]   - Field: ‘earlySignal’
[09:28:20.838]   - Field: ‘lazy’
[09:28:20.838]   - Field: ‘state’
[09:28:20.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.839] - Launch lazy future ...
[09:28:20.839] Packages needed by the future expression (n = 0): <none>
[09:28:20.839] Packages needed by future strategies (n = 0): <none>
[09:28:20.839] {
[09:28:20.839]     {
[09:28:20.839]         {
[09:28:20.839]             ...future.startTime <- base::Sys.time()
[09:28:20.839]             {
[09:28:20.839]                 {
[09:28:20.839]                   {
[09:28:20.839]                     {
[09:28:20.839]                       base::local({
[09:28:20.839]                         has_future <- base::requireNamespace("future", 
[09:28:20.839]                           quietly = TRUE)
[09:28:20.839]                         if (has_future) {
[09:28:20.839]                           ns <- base::getNamespace("future")
[09:28:20.839]                           version <- ns[[".package"]][["version"]]
[09:28:20.839]                           if (is.null(version)) 
[09:28:20.839]                             version <- utils::packageVersion("future")
[09:28:20.839]                         }
[09:28:20.839]                         else {
[09:28:20.839]                           version <- NULL
[09:28:20.839]                         }
[09:28:20.839]                         if (!has_future || version < "1.8.0") {
[09:28:20.839]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.839]                             "", base::R.version$version.string), 
[09:28:20.839]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.839]                               "release", "version")], collapse = " "), 
[09:28:20.839]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.839]                             info)
[09:28:20.839]                           info <- base::paste(info, collapse = "; ")
[09:28:20.839]                           if (!has_future) {
[09:28:20.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.839]                               info)
[09:28:20.839]                           }
[09:28:20.839]                           else {
[09:28:20.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.839]                               info, version)
[09:28:20.839]                           }
[09:28:20.839]                           base::stop(msg)
[09:28:20.839]                         }
[09:28:20.839]                       })
[09:28:20.839]                     }
[09:28:20.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.839]                     base::options(mc.cores = 1L)
[09:28:20.839]                   }
[09:28:20.839]                   ...future.strategy.old <- future::plan("list")
[09:28:20.839]                   options(future.plan = NULL)
[09:28:20.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.839]                 }
[09:28:20.839]                 ...future.workdir <- getwd()
[09:28:20.839]             }
[09:28:20.839]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.839]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.839]         }
[09:28:20.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.839]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.839]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.839]             base::names(...future.oldOptions))
[09:28:20.839]     }
[09:28:20.839]     if (FALSE) {
[09:28:20.839]     }
[09:28:20.839]     else {
[09:28:20.839]         if (TRUE) {
[09:28:20.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.839]                 open = "w")
[09:28:20.839]         }
[09:28:20.839]         else {
[09:28:20.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.839]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.839]         }
[09:28:20.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.839]             base::sink(type = "output", split = FALSE)
[09:28:20.839]             base::close(...future.stdout)
[09:28:20.839]         }, add = TRUE)
[09:28:20.839]     }
[09:28:20.839]     ...future.frame <- base::sys.nframe()
[09:28:20.839]     ...future.conditions <- base::list()
[09:28:20.839]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.839]     if (FALSE) {
[09:28:20.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.839]     }
[09:28:20.839]     ...future.result <- base::tryCatch({
[09:28:20.839]         base::withCallingHandlers({
[09:28:20.839]             ...future.value <- base::withVisible(base::local({
[09:28:20.839]                 ...future.makeSendCondition <- base::local({
[09:28:20.839]                   sendCondition <- NULL
[09:28:20.839]                   function(frame = 1L) {
[09:28:20.839]                     if (is.function(sendCondition)) 
[09:28:20.839]                       return(sendCondition)
[09:28:20.839]                     ns <- getNamespace("parallel")
[09:28:20.839]                     if (exists("sendData", mode = "function", 
[09:28:20.839]                       envir = ns)) {
[09:28:20.839]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.839]                         envir = ns)
[09:28:20.839]                       envir <- sys.frame(frame)
[09:28:20.839]                       master <- NULL
[09:28:20.839]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.839]                         !identical(envir, emptyenv())) {
[09:28:20.839]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.839]                           inherits = FALSE)) {
[09:28:20.839]                           master <- get("master", mode = "list", 
[09:28:20.839]                             envir = envir, inherits = FALSE)
[09:28:20.839]                           if (inherits(master, c("SOCKnode", 
[09:28:20.839]                             "SOCK0node"))) {
[09:28:20.839]                             sendCondition <<- function(cond) {
[09:28:20.839]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.839]                                 success = TRUE)
[09:28:20.839]                               parallel_sendData(master, data)
[09:28:20.839]                             }
[09:28:20.839]                             return(sendCondition)
[09:28:20.839]                           }
[09:28:20.839]                         }
[09:28:20.839]                         frame <- frame + 1L
[09:28:20.839]                         envir <- sys.frame(frame)
[09:28:20.839]                       }
[09:28:20.839]                     }
[09:28:20.839]                     sendCondition <<- function(cond) NULL
[09:28:20.839]                   }
[09:28:20.839]                 })
[09:28:20.839]                 withCallingHandlers({
[09:28:20.839]                   {
[09:28:20.839]                     do.call(function(...) {
[09:28:20.839]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.839]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.839]                         ...future.globals.maxSize)) {
[09:28:20.839]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.839]                         on.exit(options(oopts), add = TRUE)
[09:28:20.839]                       }
[09:28:20.839]                       {
[09:28:20.839]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.839]                           FUN = function(jj) {
[09:28:20.839]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.839]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.839]                           })
[09:28:20.839]                       }
[09:28:20.839]                     }, args = future.call.arguments)
[09:28:20.839]                   }
[09:28:20.839]                 }, immediateCondition = function(cond) {
[09:28:20.839]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.839]                   sendCondition(cond)
[09:28:20.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.839]                   {
[09:28:20.839]                     inherits <- base::inherits
[09:28:20.839]                     invokeRestart <- base::invokeRestart
[09:28:20.839]                     is.null <- base::is.null
[09:28:20.839]                     muffled <- FALSE
[09:28:20.839]                     if (inherits(cond, "message")) {
[09:28:20.839]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.839]                       if (muffled) 
[09:28:20.839]                         invokeRestart("muffleMessage")
[09:28:20.839]                     }
[09:28:20.839]                     else if (inherits(cond, "warning")) {
[09:28:20.839]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.839]                       if (muffled) 
[09:28:20.839]                         invokeRestart("muffleWarning")
[09:28:20.839]                     }
[09:28:20.839]                     else if (inherits(cond, "condition")) {
[09:28:20.839]                       if (!is.null(pattern)) {
[09:28:20.839]                         computeRestarts <- base::computeRestarts
[09:28:20.839]                         grepl <- base::grepl
[09:28:20.839]                         restarts <- computeRestarts(cond)
[09:28:20.839]                         for (restart in restarts) {
[09:28:20.839]                           name <- restart$name
[09:28:20.839]                           if (is.null(name)) 
[09:28:20.839]                             next
[09:28:20.839]                           if (!grepl(pattern, name)) 
[09:28:20.839]                             next
[09:28:20.839]                           invokeRestart(restart)
[09:28:20.839]                           muffled <- TRUE
[09:28:20.839]                           break
[09:28:20.839]                         }
[09:28:20.839]                       }
[09:28:20.839]                     }
[09:28:20.839]                     invisible(muffled)
[09:28:20.839]                   }
[09:28:20.839]                   muffleCondition(cond)
[09:28:20.839]                 })
[09:28:20.839]             }))
[09:28:20.839]             future::FutureResult(value = ...future.value$value, 
[09:28:20.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.839]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.839]                     ...future.globalenv.names))
[09:28:20.839]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.839]         }, condition = base::local({
[09:28:20.839]             c <- base::c
[09:28:20.839]             inherits <- base::inherits
[09:28:20.839]             invokeRestart <- base::invokeRestart
[09:28:20.839]             length <- base::length
[09:28:20.839]             list <- base::list
[09:28:20.839]             seq.int <- base::seq.int
[09:28:20.839]             signalCondition <- base::signalCondition
[09:28:20.839]             sys.calls <- base::sys.calls
[09:28:20.839]             `[[` <- base::`[[`
[09:28:20.839]             `+` <- base::`+`
[09:28:20.839]             `<<-` <- base::`<<-`
[09:28:20.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.839]                   3L)]
[09:28:20.839]             }
[09:28:20.839]             function(cond) {
[09:28:20.839]                 is_error <- inherits(cond, "error")
[09:28:20.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.839]                   NULL)
[09:28:20.839]                 if (is_error) {
[09:28:20.839]                   sessionInformation <- function() {
[09:28:20.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.839]                       search = base::search(), system = base::Sys.info())
[09:28:20.839]                   }
[09:28:20.839]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.839]                     cond$call), session = sessionInformation(), 
[09:28:20.839]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.839]                   signalCondition(cond)
[09:28:20.839]                 }
[09:28:20.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.839]                 "immediateCondition"))) {
[09:28:20.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.839]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.839]                   if (TRUE && !signal) {
[09:28:20.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.839]                     {
[09:28:20.839]                       inherits <- base::inherits
[09:28:20.839]                       invokeRestart <- base::invokeRestart
[09:28:20.839]                       is.null <- base::is.null
[09:28:20.839]                       muffled <- FALSE
[09:28:20.839]                       if (inherits(cond, "message")) {
[09:28:20.839]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.839]                         if (muffled) 
[09:28:20.839]                           invokeRestart("muffleMessage")
[09:28:20.839]                       }
[09:28:20.839]                       else if (inherits(cond, "warning")) {
[09:28:20.839]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.839]                         if (muffled) 
[09:28:20.839]                           invokeRestart("muffleWarning")
[09:28:20.839]                       }
[09:28:20.839]                       else if (inherits(cond, "condition")) {
[09:28:20.839]                         if (!is.null(pattern)) {
[09:28:20.839]                           computeRestarts <- base::computeRestarts
[09:28:20.839]                           grepl <- base::grepl
[09:28:20.839]                           restarts <- computeRestarts(cond)
[09:28:20.839]                           for (restart in restarts) {
[09:28:20.839]                             name <- restart$name
[09:28:20.839]                             if (is.null(name)) 
[09:28:20.839]                               next
[09:28:20.839]                             if (!grepl(pattern, name)) 
[09:28:20.839]                               next
[09:28:20.839]                             invokeRestart(restart)
[09:28:20.839]                             muffled <- TRUE
[09:28:20.839]                             break
[09:28:20.839]                           }
[09:28:20.839]                         }
[09:28:20.839]                       }
[09:28:20.839]                       invisible(muffled)
[09:28:20.839]                     }
[09:28:20.839]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.839]                   }
[09:28:20.839]                 }
[09:28:20.839]                 else {
[09:28:20.839]                   if (TRUE) {
[09:28:20.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.839]                     {
[09:28:20.839]                       inherits <- base::inherits
[09:28:20.839]                       invokeRestart <- base::invokeRestart
[09:28:20.839]                       is.null <- base::is.null
[09:28:20.839]                       muffled <- FALSE
[09:28:20.839]                       if (inherits(cond, "message")) {
[09:28:20.839]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.839]                         if (muffled) 
[09:28:20.839]                           invokeRestart("muffleMessage")
[09:28:20.839]                       }
[09:28:20.839]                       else if (inherits(cond, "warning")) {
[09:28:20.839]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.839]                         if (muffled) 
[09:28:20.839]                           invokeRestart("muffleWarning")
[09:28:20.839]                       }
[09:28:20.839]                       else if (inherits(cond, "condition")) {
[09:28:20.839]                         if (!is.null(pattern)) {
[09:28:20.839]                           computeRestarts <- base::computeRestarts
[09:28:20.839]                           grepl <- base::grepl
[09:28:20.839]                           restarts <- computeRestarts(cond)
[09:28:20.839]                           for (restart in restarts) {
[09:28:20.839]                             name <- restart$name
[09:28:20.839]                             if (is.null(name)) 
[09:28:20.839]                               next
[09:28:20.839]                             if (!grepl(pattern, name)) 
[09:28:20.839]                               next
[09:28:20.839]                             invokeRestart(restart)
[09:28:20.839]                             muffled <- TRUE
[09:28:20.839]                             break
[09:28:20.839]                           }
[09:28:20.839]                         }
[09:28:20.839]                       }
[09:28:20.839]                       invisible(muffled)
[09:28:20.839]                     }
[09:28:20.839]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.839]                   }
[09:28:20.839]                 }
[09:28:20.839]             }
[09:28:20.839]         }))
[09:28:20.839]     }, error = function(ex) {
[09:28:20.839]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.839]                 ...future.rng), started = ...future.startTime, 
[09:28:20.839]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.839]             version = "1.8"), class = "FutureResult")
[09:28:20.839]     }, finally = {
[09:28:20.839]         if (!identical(...future.workdir, getwd())) 
[09:28:20.839]             setwd(...future.workdir)
[09:28:20.839]         {
[09:28:20.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.839]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.839]             }
[09:28:20.839]             base::options(...future.oldOptions)
[09:28:20.839]             if (.Platform$OS.type == "windows") {
[09:28:20.839]                 old_names <- names(...future.oldEnvVars)
[09:28:20.839]                 envs <- base::Sys.getenv()
[09:28:20.839]                 names <- names(envs)
[09:28:20.839]                 common <- intersect(names, old_names)
[09:28:20.839]                 added <- setdiff(names, old_names)
[09:28:20.839]                 removed <- setdiff(old_names, names)
[09:28:20.839]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.839]                   envs[common]]
[09:28:20.839]                 NAMES <- toupper(changed)
[09:28:20.839]                 args <- list()
[09:28:20.839]                 for (kk in seq_along(NAMES)) {
[09:28:20.839]                   name <- changed[[kk]]
[09:28:20.839]                   NAME <- NAMES[[kk]]
[09:28:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.839]                     next
[09:28:20.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.839]                 }
[09:28:20.839]                 NAMES <- toupper(added)
[09:28:20.839]                 for (kk in seq_along(NAMES)) {
[09:28:20.839]                   name <- added[[kk]]
[09:28:20.839]                   NAME <- NAMES[[kk]]
[09:28:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.839]                     next
[09:28:20.839]                   args[[name]] <- ""
[09:28:20.839]                 }
[09:28:20.839]                 NAMES <- toupper(removed)
[09:28:20.839]                 for (kk in seq_along(NAMES)) {
[09:28:20.839]                   name <- removed[[kk]]
[09:28:20.839]                   NAME <- NAMES[[kk]]
[09:28:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.839]                     next
[09:28:20.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.839]                 }
[09:28:20.839]                 if (length(args) > 0) 
[09:28:20.839]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.839]             }
[09:28:20.839]             else {
[09:28:20.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.839]             }
[09:28:20.839]             {
[09:28:20.839]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.839]                   0L) {
[09:28:20.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.839]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.839]                   base::options(opts)
[09:28:20.839]                 }
[09:28:20.839]                 {
[09:28:20.839]                   {
[09:28:20.839]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.839]                     NULL
[09:28:20.839]                   }
[09:28:20.839]                   options(future.plan = NULL)
[09:28:20.839]                   if (is.na(NA_character_)) 
[09:28:20.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.839]                     .init = FALSE)
[09:28:20.839]                 }
[09:28:20.839]             }
[09:28:20.839]         }
[09:28:20.839]     })
[09:28:20.839]     if (TRUE) {
[09:28:20.839]         base::sink(type = "output", split = FALSE)
[09:28:20.839]         if (TRUE) {
[09:28:20.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.839]         }
[09:28:20.839]         else {
[09:28:20.839]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.839]         }
[09:28:20.839]         base::close(...future.stdout)
[09:28:20.839]         ...future.stdout <- NULL
[09:28:20.839]     }
[09:28:20.839]     ...future.result$conditions <- ...future.conditions
[09:28:20.839]     ...future.result$finished <- base::Sys.time()
[09:28:20.839]     ...future.result
[09:28:20.839] }
[09:28:20.842] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[09:28:20.842] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.843] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.843] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[09:28:20.843] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[09:28:20.843] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[09:28:20.844] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[09:28:20.844] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.844] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.844] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.844] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.845] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[09:28:20.845] MultisessionFuture started
[09:28:20.845] - Launch lazy future ... done
[09:28:20.845] run() for ‘MultisessionFuture’ ... done
[09:28:20.845] Created future:
[09:28:20.845] MultisessionFuture:
[09:28:20.845] Label: ‘future_apply-2’
[09:28:20.845] Expression:
[09:28:20.845] {
[09:28:20.845]     do.call(function(...) {
[09:28:20.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.845]             on.exit(options(oopts), add = TRUE)
[09:28:20.845]         }
[09:28:20.845]         {
[09:28:20.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.845]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.845]             })
[09:28:20.845]         }
[09:28:20.845]     }, args = future.call.arguments)
[09:28:20.845] }
[09:28:20.845] Lazy evaluation: FALSE
[09:28:20.845] Asynchronous evaluation: TRUE
[09:28:20.845] Local evaluation: TRUE
[09:28:20.845] Environment: R_GlobalEnv
[09:28:20.845] Capture standard output: TRUE
[09:28:20.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.845] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.845] Packages: <none>
[09:28:20.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.845] Resolved: FALSE
[09:28:20.845] Value: <not collected>
[09:28:20.845] Conditions captured: <none>
[09:28:20.845] Early signaling: FALSE
[09:28:20.845] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.845] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.857] Chunk #2 of 2 ... DONE
[09:28:20.857] Launching 2 futures (chunks) ... DONE
[09:28:20.857] Resolving 2 futures (chunks) ...
[09:28:20.857] resolve() on list ...
[09:28:20.857]  recursive: 0
[09:28:20.857]  length: 2
[09:28:20.857] 
[09:28:20.858] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.858] - Validating connection of MultisessionFuture
[09:28:20.858] - received message: FutureResult
[09:28:20.858] - Received FutureResult
[09:28:20.858] - Erased future from FutureRegistry
[09:28:20.859] result() for ClusterFuture ...
[09:28:20.859] - result already collected: FutureResult
[09:28:20.859] result() for ClusterFuture ... done
[09:28:20.859] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.859] Future #1
[09:28:20.859] result() for ClusterFuture ...
[09:28:20.859] - result already collected: FutureResult
[09:28:20.859] result() for ClusterFuture ... done
[09:28:20.859] result() for ClusterFuture ...
[09:28:20.859] - result already collected: FutureResult
[09:28:20.859] result() for ClusterFuture ... done
[09:28:20.859] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.860] - nx: 2
[09:28:20.860] - relay: TRUE
[09:28:20.860] - stdout: TRUE
[09:28:20.860] - signal: TRUE
[09:28:20.860] - resignal: FALSE
[09:28:20.860] - force: TRUE
[09:28:20.860] - relayed: [n=2] FALSE, FALSE
[09:28:20.860] - queued futures: [n=2] FALSE, FALSE
[09:28:20.860]  - until=1
[09:28:20.860]  - relaying element #1
[09:28:20.860] result() for ClusterFuture ...
[09:28:20.861] - result already collected: FutureResult
[09:28:20.861] result() for ClusterFuture ... done
[09:28:20.861] result() for ClusterFuture ...
[09:28:20.861] - result already collected: FutureResult
[09:28:20.861] result() for ClusterFuture ... done
[09:28:20.861] result() for ClusterFuture ...
[09:28:20.861] - result already collected: FutureResult
[09:28:20.861] result() for ClusterFuture ... done
[09:28:20.861] result() for ClusterFuture ...
[09:28:20.861] - result already collected: FutureResult
[09:28:20.861] result() for ClusterFuture ... done
[09:28:20.861] - relayed: [n=2] TRUE, FALSE
[09:28:20.862] - queued futures: [n=2] TRUE, FALSE
[09:28:20.862] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.862]  length: 1 (resolved future 1)
[09:28:20.889] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.890] - Validating connection of MultisessionFuture
[09:28:20.890] - received message: FutureResult
[09:28:20.890] - Received FutureResult
[09:28:20.890] - Erased future from FutureRegistry
[09:28:20.890] result() for ClusterFuture ...
[09:28:20.890] - result already collected: FutureResult
[09:28:20.890] result() for ClusterFuture ... done
[09:28:20.890] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.890] Future #2
[09:28:20.890] result() for ClusterFuture ...
[09:28:20.891] - result already collected: FutureResult
[09:28:20.891] result() for ClusterFuture ... done
[09:28:20.891] result() for ClusterFuture ...
[09:28:20.891] - result already collected: FutureResult
[09:28:20.891] result() for ClusterFuture ... done
[09:28:20.891] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:20.891] - nx: 2
[09:28:20.891] - relay: TRUE
[09:28:20.891] - stdout: TRUE
[09:28:20.891] - signal: TRUE
[09:28:20.891] - resignal: FALSE
[09:28:20.891] - force: TRUE
[09:28:20.892] - relayed: [n=2] TRUE, FALSE
[09:28:20.892] - queued futures: [n=2] TRUE, FALSE
[09:28:20.892]  - until=2
[09:28:20.892]  - relaying element #2
[09:28:20.892] result() for ClusterFuture ...
[09:28:20.892] - result already collected: FutureResult
[09:28:20.892] result() for ClusterFuture ... done
[09:28:20.892] result() for ClusterFuture ...
[09:28:20.892] - result already collected: FutureResult
[09:28:20.892] result() for ClusterFuture ... done
[09:28:20.892] result() for ClusterFuture ...
[09:28:20.893] - result already collected: FutureResult
[09:28:20.893] result() for ClusterFuture ... done
[09:28:20.893] result() for ClusterFuture ...
[09:28:20.893] - result already collected: FutureResult
[09:28:20.893] result() for ClusterFuture ... done
[09:28:20.893] - relayed: [n=2] TRUE, TRUE
[09:28:20.893] - queued futures: [n=2] TRUE, TRUE
[09:28:20.893] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:20.893]  length: 0 (resolved future 2)
[09:28:20.893] Relaying remaining futures
[09:28:20.893] signalConditionsASAP(NULL, pos=0) ...
[09:28:20.893] - nx: 2
[09:28:20.894] - relay: TRUE
[09:28:20.894] - stdout: TRUE
[09:28:20.894] - signal: TRUE
[09:28:20.894] - resignal: FALSE
[09:28:20.894] - force: TRUE
[09:28:20.894] - relayed: [n=2] TRUE, TRUE
[09:28:20.894] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:20.894] - relayed: [n=2] TRUE, TRUE
[09:28:20.894] - queued futures: [n=2] TRUE, TRUE
[09:28:20.894] signalConditionsASAP(NULL, pos=0) ... done
[09:28:20.894] resolve() on list ... DONE
[09:28:20.895] result() for ClusterFuture ...
[09:28:20.895] - result already collected: FutureResult
[09:28:20.895] result() for ClusterFuture ... done
[09:28:20.895] result() for ClusterFuture ...
[09:28:20.895] - result already collected: FutureResult
[09:28:20.895] result() for ClusterFuture ... done
[09:28:20.895] result() for ClusterFuture ...
[09:28:20.895] - result already collected: FutureResult
[09:28:20.895] result() for ClusterFuture ... done
[09:28:20.895] result() for ClusterFuture ...
[09:28:20.895] - result already collected: FutureResult
[09:28:20.895] result() for ClusterFuture ... done
[09:28:20.896]  - Number of value chunks collected: 2
[09:28:20.896] Resolving 2 futures (chunks) ... DONE
[09:28:20.896] Reducing values from 2 chunks ...
[09:28:20.896]  - Number of values collected after concatenation: 6
[09:28:20.896]  - Number of values expected: 6
[09:28:20.896] Reducing values from 2 chunks ... DONE
[09:28:20.896] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[09:28:20.897] getGlobalsAndPackagesXApply() ...
[09:28:20.897]  - future.globals: TRUE
[09:28:20.897] getGlobalsAndPackages() ...
[09:28:20.897] Searching for globals...
[09:28:20.898] - globals found: [1] ‘FUN’
[09:28:20.898] Searching for globals ... DONE
[09:28:20.898] Resolving globals: FALSE
[09:28:20.900] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:20.901] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:20.901] - globals: [1] ‘FUN’
[09:28:20.901] 
[09:28:20.901] getGlobalsAndPackages() ... DONE
[09:28:20.901]  - globals found/used: [n=1] ‘FUN’
[09:28:20.901]  - needed namespaces: [n=0] 
[09:28:20.902] Finding globals ... DONE
[09:28:20.902]  - use_args: TRUE
[09:28:20.902]  - Getting '...' globals ...
[09:28:20.902] resolve() on list ...
[09:28:20.902]  recursive: 0
[09:28:20.902]  length: 1
[09:28:20.902]  elements: ‘...’
[09:28:20.902]  length: 0 (resolved future 1)
[09:28:20.903] resolve() on list ... DONE
[09:28:20.903]    - '...' content: [n=0] 
[09:28:20.903] List of 1
[09:28:20.903]  $ ...: list()
[09:28:20.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.903]  - attr(*, "where")=List of 1
[09:28:20.903]   ..$ ...:<environment: 0x559ba65c37c0> 
[09:28:20.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.903]  - attr(*, "resolved")= logi TRUE
[09:28:20.903]  - attr(*, "total_size")= num NA
[09:28:20.905]  - Getting '...' globals ... DONE
[09:28:20.905] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:20.906] List of 2
[09:28:20.906]  $ ...future.FUN:function (x)  
[09:28:20.906]  $ ...          : list()
[09:28:20.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.906]  - attr(*, "where")=List of 2
[09:28:20.906]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:20.906]   ..$ ...          :<environment: 0x559ba65c37c0> 
[09:28:20.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.906]  - attr(*, "resolved")= logi FALSE
[09:28:20.906]  - attr(*, "total_size")= num 848
[09:28:20.908] Packages to be attached in all futures: [n=0] 
[09:28:20.908] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.912] future_lapply() ...
[09:28:20.915] Number of chunks: 2
[09:28:20.916] getGlobalsAndPackagesXApply() ...
[09:28:20.916]  - future.globals: <name-value list> with names ‘list()’
[09:28:20.916]  - use_args: TRUE
[09:28:20.916] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:20.916] List of 2
[09:28:20.916]  $ ...          : list()
[09:28:20.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:20.916]  $ ...future.FUN:function (x)  
[09:28:20.916]  - attr(*, "where")=List of 2
[09:28:20.916]   ..$ ...          :<environment: 0x559ba65c37c0> 
[09:28:20.916]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:20.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:20.916]  - attr(*, "resolved")= logi FALSE
[09:28:20.916]  - attr(*, "total_size")= num NA
[09:28:20.919] Packages to be attached in all futures: [n=0] 
[09:28:20.919] getGlobalsAndPackagesXApply() ... DONE
[09:28:20.920] Number of futures (= number of chunks): 2
[09:28:20.920] Launching 2 futures (chunks) ...
[09:28:20.920] Chunk #1 of 2 ...
[09:28:20.920]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.920]  - seeds: <none>
[09:28:20.920]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.920] getGlobalsAndPackages() ...
[09:28:20.920] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.920] Resolving globals: FALSE
[09:28:20.921] Tweak future expression to call with '...' arguments ...
[09:28:20.921] {
[09:28:20.921]     do.call(function(...) {
[09:28:20.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.921]             on.exit(options(oopts), add = TRUE)
[09:28:20.921]         }
[09:28:20.921]         {
[09:28:20.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.921]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.921]             })
[09:28:20.921]         }
[09:28:20.921]     }, args = future.call.arguments)
[09:28:20.921] }
[09:28:20.921] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.921] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.921] 
[09:28:20.922] getGlobalsAndPackages() ... DONE
[09:28:20.922] run() for ‘Future’ ...
[09:28:20.922] - state: ‘created’
[09:28:20.922] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.935]   - Field: ‘node’
[09:28:20.936]   - Field: ‘label’
[09:28:20.936]   - Field: ‘local’
[09:28:20.936]   - Field: ‘owner’
[09:28:20.936]   - Field: ‘envir’
[09:28:20.936]   - Field: ‘workers’
[09:28:20.936]   - Field: ‘packages’
[09:28:20.936]   - Field: ‘gc’
[09:28:20.936]   - Field: ‘conditions’
[09:28:20.936]   - Field: ‘persistent’
[09:28:20.936]   - Field: ‘expr’
[09:28:20.937]   - Field: ‘uuid’
[09:28:20.937]   - Field: ‘seed’
[09:28:20.937]   - Field: ‘version’
[09:28:20.937]   - Field: ‘result’
[09:28:20.937]   - Field: ‘asynchronous’
[09:28:20.937]   - Field: ‘calls’
[09:28:20.937]   - Field: ‘globals’
[09:28:20.937]   - Field: ‘stdout’
[09:28:20.937]   - Field: ‘earlySignal’
[09:28:20.937]   - Field: ‘lazy’
[09:28:20.937]   - Field: ‘state’
[09:28:20.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.938] - Launch lazy future ...
[09:28:20.938] Packages needed by the future expression (n = 0): <none>
[09:28:20.938] Packages needed by future strategies (n = 0): <none>
[09:28:20.938] {
[09:28:20.938]     {
[09:28:20.938]         {
[09:28:20.938]             ...future.startTime <- base::Sys.time()
[09:28:20.938]             {
[09:28:20.938]                 {
[09:28:20.938]                   {
[09:28:20.938]                     {
[09:28:20.938]                       base::local({
[09:28:20.938]                         has_future <- base::requireNamespace("future", 
[09:28:20.938]                           quietly = TRUE)
[09:28:20.938]                         if (has_future) {
[09:28:20.938]                           ns <- base::getNamespace("future")
[09:28:20.938]                           version <- ns[[".package"]][["version"]]
[09:28:20.938]                           if (is.null(version)) 
[09:28:20.938]                             version <- utils::packageVersion("future")
[09:28:20.938]                         }
[09:28:20.938]                         else {
[09:28:20.938]                           version <- NULL
[09:28:20.938]                         }
[09:28:20.938]                         if (!has_future || version < "1.8.0") {
[09:28:20.938]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.938]                             "", base::R.version$version.string), 
[09:28:20.938]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.938]                               "release", "version")], collapse = " "), 
[09:28:20.938]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.938]                             info)
[09:28:20.938]                           info <- base::paste(info, collapse = "; ")
[09:28:20.938]                           if (!has_future) {
[09:28:20.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.938]                               info)
[09:28:20.938]                           }
[09:28:20.938]                           else {
[09:28:20.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.938]                               info, version)
[09:28:20.938]                           }
[09:28:20.938]                           base::stop(msg)
[09:28:20.938]                         }
[09:28:20.938]                       })
[09:28:20.938]                     }
[09:28:20.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.938]                     base::options(mc.cores = 1L)
[09:28:20.938]                   }
[09:28:20.938]                   ...future.strategy.old <- future::plan("list")
[09:28:20.938]                   options(future.plan = NULL)
[09:28:20.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.938]                 }
[09:28:20.938]                 ...future.workdir <- getwd()
[09:28:20.938]             }
[09:28:20.938]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.938]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.938]         }
[09:28:20.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.938]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.938]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.938]             base::names(...future.oldOptions))
[09:28:20.938]     }
[09:28:20.938]     if (FALSE) {
[09:28:20.938]     }
[09:28:20.938]     else {
[09:28:20.938]         if (TRUE) {
[09:28:20.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.938]                 open = "w")
[09:28:20.938]         }
[09:28:20.938]         else {
[09:28:20.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.938]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.938]         }
[09:28:20.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.938]             base::sink(type = "output", split = FALSE)
[09:28:20.938]             base::close(...future.stdout)
[09:28:20.938]         }, add = TRUE)
[09:28:20.938]     }
[09:28:20.938]     ...future.frame <- base::sys.nframe()
[09:28:20.938]     ...future.conditions <- base::list()
[09:28:20.938]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.938]     if (FALSE) {
[09:28:20.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.938]     }
[09:28:20.938]     ...future.result <- base::tryCatch({
[09:28:20.938]         base::withCallingHandlers({
[09:28:20.938]             ...future.value <- base::withVisible(base::local({
[09:28:20.938]                 ...future.makeSendCondition <- base::local({
[09:28:20.938]                   sendCondition <- NULL
[09:28:20.938]                   function(frame = 1L) {
[09:28:20.938]                     if (is.function(sendCondition)) 
[09:28:20.938]                       return(sendCondition)
[09:28:20.938]                     ns <- getNamespace("parallel")
[09:28:20.938]                     if (exists("sendData", mode = "function", 
[09:28:20.938]                       envir = ns)) {
[09:28:20.938]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.938]                         envir = ns)
[09:28:20.938]                       envir <- sys.frame(frame)
[09:28:20.938]                       master <- NULL
[09:28:20.938]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.938]                         !identical(envir, emptyenv())) {
[09:28:20.938]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.938]                           inherits = FALSE)) {
[09:28:20.938]                           master <- get("master", mode = "list", 
[09:28:20.938]                             envir = envir, inherits = FALSE)
[09:28:20.938]                           if (inherits(master, c("SOCKnode", 
[09:28:20.938]                             "SOCK0node"))) {
[09:28:20.938]                             sendCondition <<- function(cond) {
[09:28:20.938]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.938]                                 success = TRUE)
[09:28:20.938]                               parallel_sendData(master, data)
[09:28:20.938]                             }
[09:28:20.938]                             return(sendCondition)
[09:28:20.938]                           }
[09:28:20.938]                         }
[09:28:20.938]                         frame <- frame + 1L
[09:28:20.938]                         envir <- sys.frame(frame)
[09:28:20.938]                       }
[09:28:20.938]                     }
[09:28:20.938]                     sendCondition <<- function(cond) NULL
[09:28:20.938]                   }
[09:28:20.938]                 })
[09:28:20.938]                 withCallingHandlers({
[09:28:20.938]                   {
[09:28:20.938]                     do.call(function(...) {
[09:28:20.938]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.938]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.938]                         ...future.globals.maxSize)) {
[09:28:20.938]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.938]                         on.exit(options(oopts), add = TRUE)
[09:28:20.938]                       }
[09:28:20.938]                       {
[09:28:20.938]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.938]                           FUN = function(jj) {
[09:28:20.938]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.938]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.938]                           })
[09:28:20.938]                       }
[09:28:20.938]                     }, args = future.call.arguments)
[09:28:20.938]                   }
[09:28:20.938]                 }, immediateCondition = function(cond) {
[09:28:20.938]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.938]                   sendCondition(cond)
[09:28:20.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.938]                   {
[09:28:20.938]                     inherits <- base::inherits
[09:28:20.938]                     invokeRestart <- base::invokeRestart
[09:28:20.938]                     is.null <- base::is.null
[09:28:20.938]                     muffled <- FALSE
[09:28:20.938]                     if (inherits(cond, "message")) {
[09:28:20.938]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.938]                       if (muffled) 
[09:28:20.938]                         invokeRestart("muffleMessage")
[09:28:20.938]                     }
[09:28:20.938]                     else if (inherits(cond, "warning")) {
[09:28:20.938]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.938]                       if (muffled) 
[09:28:20.938]                         invokeRestart("muffleWarning")
[09:28:20.938]                     }
[09:28:20.938]                     else if (inherits(cond, "condition")) {
[09:28:20.938]                       if (!is.null(pattern)) {
[09:28:20.938]                         computeRestarts <- base::computeRestarts
[09:28:20.938]                         grepl <- base::grepl
[09:28:20.938]                         restarts <- computeRestarts(cond)
[09:28:20.938]                         for (restart in restarts) {
[09:28:20.938]                           name <- restart$name
[09:28:20.938]                           if (is.null(name)) 
[09:28:20.938]                             next
[09:28:20.938]                           if (!grepl(pattern, name)) 
[09:28:20.938]                             next
[09:28:20.938]                           invokeRestart(restart)
[09:28:20.938]                           muffled <- TRUE
[09:28:20.938]                           break
[09:28:20.938]                         }
[09:28:20.938]                       }
[09:28:20.938]                     }
[09:28:20.938]                     invisible(muffled)
[09:28:20.938]                   }
[09:28:20.938]                   muffleCondition(cond)
[09:28:20.938]                 })
[09:28:20.938]             }))
[09:28:20.938]             future::FutureResult(value = ...future.value$value, 
[09:28:20.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.938]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.938]                     ...future.globalenv.names))
[09:28:20.938]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.938]         }, condition = base::local({
[09:28:20.938]             c <- base::c
[09:28:20.938]             inherits <- base::inherits
[09:28:20.938]             invokeRestart <- base::invokeRestart
[09:28:20.938]             length <- base::length
[09:28:20.938]             list <- base::list
[09:28:20.938]             seq.int <- base::seq.int
[09:28:20.938]             signalCondition <- base::signalCondition
[09:28:20.938]             sys.calls <- base::sys.calls
[09:28:20.938]             `[[` <- base::`[[`
[09:28:20.938]             `+` <- base::`+`
[09:28:20.938]             `<<-` <- base::`<<-`
[09:28:20.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.938]                   3L)]
[09:28:20.938]             }
[09:28:20.938]             function(cond) {
[09:28:20.938]                 is_error <- inherits(cond, "error")
[09:28:20.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.938]                   NULL)
[09:28:20.938]                 if (is_error) {
[09:28:20.938]                   sessionInformation <- function() {
[09:28:20.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.938]                       search = base::search(), system = base::Sys.info())
[09:28:20.938]                   }
[09:28:20.938]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.938]                     cond$call), session = sessionInformation(), 
[09:28:20.938]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.938]                   signalCondition(cond)
[09:28:20.938]                 }
[09:28:20.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.938]                 "immediateCondition"))) {
[09:28:20.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.938]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.938]                   if (TRUE && !signal) {
[09:28:20.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.938]                     {
[09:28:20.938]                       inherits <- base::inherits
[09:28:20.938]                       invokeRestart <- base::invokeRestart
[09:28:20.938]                       is.null <- base::is.null
[09:28:20.938]                       muffled <- FALSE
[09:28:20.938]                       if (inherits(cond, "message")) {
[09:28:20.938]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.938]                         if (muffled) 
[09:28:20.938]                           invokeRestart("muffleMessage")
[09:28:20.938]                       }
[09:28:20.938]                       else if (inherits(cond, "warning")) {
[09:28:20.938]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.938]                         if (muffled) 
[09:28:20.938]                           invokeRestart("muffleWarning")
[09:28:20.938]                       }
[09:28:20.938]                       else if (inherits(cond, "condition")) {
[09:28:20.938]                         if (!is.null(pattern)) {
[09:28:20.938]                           computeRestarts <- base::computeRestarts
[09:28:20.938]                           grepl <- base::grepl
[09:28:20.938]                           restarts <- computeRestarts(cond)
[09:28:20.938]                           for (restart in restarts) {
[09:28:20.938]                             name <- restart$name
[09:28:20.938]                             if (is.null(name)) 
[09:28:20.938]                               next
[09:28:20.938]                             if (!grepl(pattern, name)) 
[09:28:20.938]                               next
[09:28:20.938]                             invokeRestart(restart)
[09:28:20.938]                             muffled <- TRUE
[09:28:20.938]                             break
[09:28:20.938]                           }
[09:28:20.938]                         }
[09:28:20.938]                       }
[09:28:20.938]                       invisible(muffled)
[09:28:20.938]                     }
[09:28:20.938]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.938]                   }
[09:28:20.938]                 }
[09:28:20.938]                 else {
[09:28:20.938]                   if (TRUE) {
[09:28:20.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.938]                     {
[09:28:20.938]                       inherits <- base::inherits
[09:28:20.938]                       invokeRestart <- base::invokeRestart
[09:28:20.938]                       is.null <- base::is.null
[09:28:20.938]                       muffled <- FALSE
[09:28:20.938]                       if (inherits(cond, "message")) {
[09:28:20.938]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.938]                         if (muffled) 
[09:28:20.938]                           invokeRestart("muffleMessage")
[09:28:20.938]                       }
[09:28:20.938]                       else if (inherits(cond, "warning")) {
[09:28:20.938]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.938]                         if (muffled) 
[09:28:20.938]                           invokeRestart("muffleWarning")
[09:28:20.938]                       }
[09:28:20.938]                       else if (inherits(cond, "condition")) {
[09:28:20.938]                         if (!is.null(pattern)) {
[09:28:20.938]                           computeRestarts <- base::computeRestarts
[09:28:20.938]                           grepl <- base::grepl
[09:28:20.938]                           restarts <- computeRestarts(cond)
[09:28:20.938]                           for (restart in restarts) {
[09:28:20.938]                             name <- restart$name
[09:28:20.938]                             if (is.null(name)) 
[09:28:20.938]                               next
[09:28:20.938]                             if (!grepl(pattern, name)) 
[09:28:20.938]                               next
[09:28:20.938]                             invokeRestart(restart)
[09:28:20.938]                             muffled <- TRUE
[09:28:20.938]                             break
[09:28:20.938]                           }
[09:28:20.938]                         }
[09:28:20.938]                       }
[09:28:20.938]                       invisible(muffled)
[09:28:20.938]                     }
[09:28:20.938]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.938]                   }
[09:28:20.938]                 }
[09:28:20.938]             }
[09:28:20.938]         }))
[09:28:20.938]     }, error = function(ex) {
[09:28:20.938]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.938]                 ...future.rng), started = ...future.startTime, 
[09:28:20.938]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.938]             version = "1.8"), class = "FutureResult")
[09:28:20.938]     }, finally = {
[09:28:20.938]         if (!identical(...future.workdir, getwd())) 
[09:28:20.938]             setwd(...future.workdir)
[09:28:20.938]         {
[09:28:20.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.938]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.938]             }
[09:28:20.938]             base::options(...future.oldOptions)
[09:28:20.938]             if (.Platform$OS.type == "windows") {
[09:28:20.938]                 old_names <- names(...future.oldEnvVars)
[09:28:20.938]                 envs <- base::Sys.getenv()
[09:28:20.938]                 names <- names(envs)
[09:28:20.938]                 common <- intersect(names, old_names)
[09:28:20.938]                 added <- setdiff(names, old_names)
[09:28:20.938]                 removed <- setdiff(old_names, names)
[09:28:20.938]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.938]                   envs[common]]
[09:28:20.938]                 NAMES <- toupper(changed)
[09:28:20.938]                 args <- list()
[09:28:20.938]                 for (kk in seq_along(NAMES)) {
[09:28:20.938]                   name <- changed[[kk]]
[09:28:20.938]                   NAME <- NAMES[[kk]]
[09:28:20.938]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.938]                     next
[09:28:20.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.938]                 }
[09:28:20.938]                 NAMES <- toupper(added)
[09:28:20.938]                 for (kk in seq_along(NAMES)) {
[09:28:20.938]                   name <- added[[kk]]
[09:28:20.938]                   NAME <- NAMES[[kk]]
[09:28:20.938]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.938]                     next
[09:28:20.938]                   args[[name]] <- ""
[09:28:20.938]                 }
[09:28:20.938]                 NAMES <- toupper(removed)
[09:28:20.938]                 for (kk in seq_along(NAMES)) {
[09:28:20.938]                   name <- removed[[kk]]
[09:28:20.938]                   NAME <- NAMES[[kk]]
[09:28:20.938]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.938]                     next
[09:28:20.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.938]                 }
[09:28:20.938]                 if (length(args) > 0) 
[09:28:20.938]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.938]             }
[09:28:20.938]             else {
[09:28:20.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.938]             }
[09:28:20.938]             {
[09:28:20.938]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.938]                   0L) {
[09:28:20.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.938]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.938]                   base::options(opts)
[09:28:20.938]                 }
[09:28:20.938]                 {
[09:28:20.938]                   {
[09:28:20.938]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.938]                     NULL
[09:28:20.938]                   }
[09:28:20.938]                   options(future.plan = NULL)
[09:28:20.938]                   if (is.na(NA_character_)) 
[09:28:20.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.938]                     .init = FALSE)
[09:28:20.938]                 }
[09:28:20.938]             }
[09:28:20.938]         }
[09:28:20.938]     })
[09:28:20.938]     if (TRUE) {
[09:28:20.938]         base::sink(type = "output", split = FALSE)
[09:28:20.938]         if (TRUE) {
[09:28:20.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.938]         }
[09:28:20.938]         else {
[09:28:20.938]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.938]         }
[09:28:20.938]         base::close(...future.stdout)
[09:28:20.938]         ...future.stdout <- NULL
[09:28:20.938]     }
[09:28:20.938]     ...future.result$conditions <- ...future.conditions
[09:28:20.938]     ...future.result$finished <- base::Sys.time()
[09:28:20.938]     ...future.result
[09:28:20.938] }
[09:28:20.941] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[09:28:20.942] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:20.942] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.942] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:28:20.942] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:28:20.943] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:28:20.943] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.943] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:20.943] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:20.944] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:20.944] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:20.944] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[09:28:20.945] MultisessionFuture started
[09:28:20.945] - Launch lazy future ... done
[09:28:20.945] run() for ‘MultisessionFuture’ ... done
[09:28:20.945] Created future:
[09:28:20.945] MultisessionFuture:
[09:28:20.945] Label: ‘future_apply-1’
[09:28:20.945] Expression:
[09:28:20.945] {
[09:28:20.945]     do.call(function(...) {
[09:28:20.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.945]             on.exit(options(oopts), add = TRUE)
[09:28:20.945]         }
[09:28:20.945]         {
[09:28:20.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.945]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.945]             })
[09:28:20.945]         }
[09:28:20.945]     }, args = future.call.arguments)
[09:28:20.945] }
[09:28:20.945] Lazy evaluation: FALSE
[09:28:20.945] Asynchronous evaluation: TRUE
[09:28:20.945] Local evaluation: TRUE
[09:28:20.945] Environment: R_GlobalEnv
[09:28:20.945] Capture standard output: TRUE
[09:28:20.945] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.945] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.945] Packages: <none>
[09:28:20.945] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.945] Resolved: FALSE
[09:28:20.945] Value: <not collected>
[09:28:20.945] Conditions captured: <none>
[09:28:20.945] Early signaling: FALSE
[09:28:20.945] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.945] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.956] Chunk #1 of 2 ... DONE
[09:28:20.956] Chunk #2 of 2 ...
[09:28:20.957]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:20.957]  - seeds: <none>
[09:28:20.957]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.957] getGlobalsAndPackages() ...
[09:28:20.957] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.957] Resolving globals: FALSE
[09:28:20.957] Tweak future expression to call with '...' arguments ...
[09:28:20.957] {
[09:28:20.957]     do.call(function(...) {
[09:28:20.957]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.957]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.957]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.957]             on.exit(options(oopts), add = TRUE)
[09:28:20.957]         }
[09:28:20.957]         {
[09:28:20.957]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.957]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.957]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.957]             })
[09:28:20.957]         }
[09:28:20.957]     }, args = future.call.arguments)
[09:28:20.957] }
[09:28:20.958] Tweak future expression to call with '...' arguments ... DONE
[09:28:20.958] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:20.958] 
[09:28:20.958] getGlobalsAndPackages() ... DONE
[09:28:20.958] run() for ‘Future’ ...
[09:28:20.958] - state: ‘created’
[09:28:20.959] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:20.972] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:20.972]   - Field: ‘node’
[09:28:20.972]   - Field: ‘label’
[09:28:20.972]   - Field: ‘local’
[09:28:20.972]   - Field: ‘owner’
[09:28:20.972]   - Field: ‘envir’
[09:28:20.973]   - Field: ‘workers’
[09:28:20.973]   - Field: ‘packages’
[09:28:20.973]   - Field: ‘gc’
[09:28:20.973]   - Field: ‘conditions’
[09:28:20.973]   - Field: ‘persistent’
[09:28:20.973]   - Field: ‘expr’
[09:28:20.973]   - Field: ‘uuid’
[09:28:20.973]   - Field: ‘seed’
[09:28:20.973]   - Field: ‘version’
[09:28:20.973]   - Field: ‘result’
[09:28:20.973]   - Field: ‘asynchronous’
[09:28:20.974]   - Field: ‘calls’
[09:28:20.974]   - Field: ‘globals’
[09:28:20.974]   - Field: ‘stdout’
[09:28:20.974]   - Field: ‘earlySignal’
[09:28:20.974]   - Field: ‘lazy’
[09:28:20.974]   - Field: ‘state’
[09:28:20.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:20.974] - Launch lazy future ...
[09:28:20.974] Packages needed by the future expression (n = 0): <none>
[09:28:20.975] Packages needed by future strategies (n = 0): <none>
[09:28:20.975] {
[09:28:20.975]     {
[09:28:20.975]         {
[09:28:20.975]             ...future.startTime <- base::Sys.time()
[09:28:20.975]             {
[09:28:20.975]                 {
[09:28:20.975]                   {
[09:28:20.975]                     {
[09:28:20.975]                       base::local({
[09:28:20.975]                         has_future <- base::requireNamespace("future", 
[09:28:20.975]                           quietly = TRUE)
[09:28:20.975]                         if (has_future) {
[09:28:20.975]                           ns <- base::getNamespace("future")
[09:28:20.975]                           version <- ns[[".package"]][["version"]]
[09:28:20.975]                           if (is.null(version)) 
[09:28:20.975]                             version <- utils::packageVersion("future")
[09:28:20.975]                         }
[09:28:20.975]                         else {
[09:28:20.975]                           version <- NULL
[09:28:20.975]                         }
[09:28:20.975]                         if (!has_future || version < "1.8.0") {
[09:28:20.975]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:20.975]                             "", base::R.version$version.string), 
[09:28:20.975]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:20.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:20.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:20.975]                               "release", "version")], collapse = " "), 
[09:28:20.975]                             hostname = base::Sys.info()[["nodename"]])
[09:28:20.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:20.975]                             info)
[09:28:20.975]                           info <- base::paste(info, collapse = "; ")
[09:28:20.975]                           if (!has_future) {
[09:28:20.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:20.975]                               info)
[09:28:20.975]                           }
[09:28:20.975]                           else {
[09:28:20.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:20.975]                               info, version)
[09:28:20.975]                           }
[09:28:20.975]                           base::stop(msg)
[09:28:20.975]                         }
[09:28:20.975]                       })
[09:28:20.975]                     }
[09:28:20.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:20.975]                     base::options(mc.cores = 1L)
[09:28:20.975]                   }
[09:28:20.975]                   ...future.strategy.old <- future::plan("list")
[09:28:20.975]                   options(future.plan = NULL)
[09:28:20.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:20.975]                 }
[09:28:20.975]                 ...future.workdir <- getwd()
[09:28:20.975]             }
[09:28:20.975]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:20.975]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:20.975]         }
[09:28:20.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:20.975]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:20.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:20.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:20.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:20.975]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:20.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:20.975]             base::names(...future.oldOptions))
[09:28:20.975]     }
[09:28:20.975]     if (FALSE) {
[09:28:20.975]     }
[09:28:20.975]     else {
[09:28:20.975]         if (TRUE) {
[09:28:20.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:20.975]                 open = "w")
[09:28:20.975]         }
[09:28:20.975]         else {
[09:28:20.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:20.975]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:20.975]         }
[09:28:20.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:20.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:20.975]             base::sink(type = "output", split = FALSE)
[09:28:20.975]             base::close(...future.stdout)
[09:28:20.975]         }, add = TRUE)
[09:28:20.975]     }
[09:28:20.975]     ...future.frame <- base::sys.nframe()
[09:28:20.975]     ...future.conditions <- base::list()
[09:28:20.975]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:20.975]     if (FALSE) {
[09:28:20.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:20.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:20.975]     }
[09:28:20.975]     ...future.result <- base::tryCatch({
[09:28:20.975]         base::withCallingHandlers({
[09:28:20.975]             ...future.value <- base::withVisible(base::local({
[09:28:20.975]                 ...future.makeSendCondition <- base::local({
[09:28:20.975]                   sendCondition <- NULL
[09:28:20.975]                   function(frame = 1L) {
[09:28:20.975]                     if (is.function(sendCondition)) 
[09:28:20.975]                       return(sendCondition)
[09:28:20.975]                     ns <- getNamespace("parallel")
[09:28:20.975]                     if (exists("sendData", mode = "function", 
[09:28:20.975]                       envir = ns)) {
[09:28:20.975]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:20.975]                         envir = ns)
[09:28:20.975]                       envir <- sys.frame(frame)
[09:28:20.975]                       master <- NULL
[09:28:20.975]                       while (!identical(envir, .GlobalEnv) && 
[09:28:20.975]                         !identical(envir, emptyenv())) {
[09:28:20.975]                         if (exists("master", mode = "list", envir = envir, 
[09:28:20.975]                           inherits = FALSE)) {
[09:28:20.975]                           master <- get("master", mode = "list", 
[09:28:20.975]                             envir = envir, inherits = FALSE)
[09:28:20.975]                           if (inherits(master, c("SOCKnode", 
[09:28:20.975]                             "SOCK0node"))) {
[09:28:20.975]                             sendCondition <<- function(cond) {
[09:28:20.975]                               data <- list(type = "VALUE", value = cond, 
[09:28:20.975]                                 success = TRUE)
[09:28:20.975]                               parallel_sendData(master, data)
[09:28:20.975]                             }
[09:28:20.975]                             return(sendCondition)
[09:28:20.975]                           }
[09:28:20.975]                         }
[09:28:20.975]                         frame <- frame + 1L
[09:28:20.975]                         envir <- sys.frame(frame)
[09:28:20.975]                       }
[09:28:20.975]                     }
[09:28:20.975]                     sendCondition <<- function(cond) NULL
[09:28:20.975]                   }
[09:28:20.975]                 })
[09:28:20.975]                 withCallingHandlers({
[09:28:20.975]                   {
[09:28:20.975]                     do.call(function(...) {
[09:28:20.975]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.975]                       if (!identical(...future.globals.maxSize.org, 
[09:28:20.975]                         ...future.globals.maxSize)) {
[09:28:20.975]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.975]                         on.exit(options(oopts), add = TRUE)
[09:28:20.975]                       }
[09:28:20.975]                       {
[09:28:20.975]                         lapply(seq_along(...future.elements_ii), 
[09:28:20.975]                           FUN = function(jj) {
[09:28:20.975]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.975]                             ...future.FUN(...future.X_jj, ...)
[09:28:20.975]                           })
[09:28:20.975]                       }
[09:28:20.975]                     }, args = future.call.arguments)
[09:28:20.975]                   }
[09:28:20.975]                 }, immediateCondition = function(cond) {
[09:28:20.975]                   sendCondition <- ...future.makeSendCondition()
[09:28:20.975]                   sendCondition(cond)
[09:28:20.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.975]                   {
[09:28:20.975]                     inherits <- base::inherits
[09:28:20.975]                     invokeRestart <- base::invokeRestart
[09:28:20.975]                     is.null <- base::is.null
[09:28:20.975]                     muffled <- FALSE
[09:28:20.975]                     if (inherits(cond, "message")) {
[09:28:20.975]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:20.975]                       if (muffled) 
[09:28:20.975]                         invokeRestart("muffleMessage")
[09:28:20.975]                     }
[09:28:20.975]                     else if (inherits(cond, "warning")) {
[09:28:20.975]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:20.975]                       if (muffled) 
[09:28:20.975]                         invokeRestart("muffleWarning")
[09:28:20.975]                     }
[09:28:20.975]                     else if (inherits(cond, "condition")) {
[09:28:20.975]                       if (!is.null(pattern)) {
[09:28:20.975]                         computeRestarts <- base::computeRestarts
[09:28:20.975]                         grepl <- base::grepl
[09:28:20.975]                         restarts <- computeRestarts(cond)
[09:28:20.975]                         for (restart in restarts) {
[09:28:20.975]                           name <- restart$name
[09:28:20.975]                           if (is.null(name)) 
[09:28:20.975]                             next
[09:28:20.975]                           if (!grepl(pattern, name)) 
[09:28:20.975]                             next
[09:28:20.975]                           invokeRestart(restart)
[09:28:20.975]                           muffled <- TRUE
[09:28:20.975]                           break
[09:28:20.975]                         }
[09:28:20.975]                       }
[09:28:20.975]                     }
[09:28:20.975]                     invisible(muffled)
[09:28:20.975]                   }
[09:28:20.975]                   muffleCondition(cond)
[09:28:20.975]                 })
[09:28:20.975]             }))
[09:28:20.975]             future::FutureResult(value = ...future.value$value, 
[09:28:20.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.975]                   ...future.rng), globalenv = if (FALSE) 
[09:28:20.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:20.975]                     ...future.globalenv.names))
[09:28:20.975]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:20.975]         }, condition = base::local({
[09:28:20.975]             c <- base::c
[09:28:20.975]             inherits <- base::inherits
[09:28:20.975]             invokeRestart <- base::invokeRestart
[09:28:20.975]             length <- base::length
[09:28:20.975]             list <- base::list
[09:28:20.975]             seq.int <- base::seq.int
[09:28:20.975]             signalCondition <- base::signalCondition
[09:28:20.975]             sys.calls <- base::sys.calls
[09:28:20.975]             `[[` <- base::`[[`
[09:28:20.975]             `+` <- base::`+`
[09:28:20.975]             `<<-` <- base::`<<-`
[09:28:20.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:20.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:20.975]                   3L)]
[09:28:20.975]             }
[09:28:20.975]             function(cond) {
[09:28:20.975]                 is_error <- inherits(cond, "error")
[09:28:20.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:20.975]                   NULL)
[09:28:20.975]                 if (is_error) {
[09:28:20.975]                   sessionInformation <- function() {
[09:28:20.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:20.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:20.975]                       search = base::search(), system = base::Sys.info())
[09:28:20.975]                   }
[09:28:20.975]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:20.975]                     cond$call), session = sessionInformation(), 
[09:28:20.975]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:20.975]                   signalCondition(cond)
[09:28:20.975]                 }
[09:28:20.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:20.975]                 "immediateCondition"))) {
[09:28:20.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:20.975]                   ...future.conditions[[length(...future.conditions) + 
[09:28:20.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:20.975]                   if (TRUE && !signal) {
[09:28:20.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.975]                     {
[09:28:20.975]                       inherits <- base::inherits
[09:28:20.975]                       invokeRestart <- base::invokeRestart
[09:28:20.975]                       is.null <- base::is.null
[09:28:20.975]                       muffled <- FALSE
[09:28:20.975]                       if (inherits(cond, "message")) {
[09:28:20.975]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.975]                         if (muffled) 
[09:28:20.975]                           invokeRestart("muffleMessage")
[09:28:20.975]                       }
[09:28:20.975]                       else if (inherits(cond, "warning")) {
[09:28:20.975]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.975]                         if (muffled) 
[09:28:20.975]                           invokeRestart("muffleWarning")
[09:28:20.975]                       }
[09:28:20.975]                       else if (inherits(cond, "condition")) {
[09:28:20.975]                         if (!is.null(pattern)) {
[09:28:20.975]                           computeRestarts <- base::computeRestarts
[09:28:20.975]                           grepl <- base::grepl
[09:28:20.975]                           restarts <- computeRestarts(cond)
[09:28:20.975]                           for (restart in restarts) {
[09:28:20.975]                             name <- restart$name
[09:28:20.975]                             if (is.null(name)) 
[09:28:20.975]                               next
[09:28:20.975]                             if (!grepl(pattern, name)) 
[09:28:20.975]                               next
[09:28:20.975]                             invokeRestart(restart)
[09:28:20.975]                             muffled <- TRUE
[09:28:20.975]                             break
[09:28:20.975]                           }
[09:28:20.975]                         }
[09:28:20.975]                       }
[09:28:20.975]                       invisible(muffled)
[09:28:20.975]                     }
[09:28:20.975]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.975]                   }
[09:28:20.975]                 }
[09:28:20.975]                 else {
[09:28:20.975]                   if (TRUE) {
[09:28:20.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:20.975]                     {
[09:28:20.975]                       inherits <- base::inherits
[09:28:20.975]                       invokeRestart <- base::invokeRestart
[09:28:20.975]                       is.null <- base::is.null
[09:28:20.975]                       muffled <- FALSE
[09:28:20.975]                       if (inherits(cond, "message")) {
[09:28:20.975]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:20.975]                         if (muffled) 
[09:28:20.975]                           invokeRestart("muffleMessage")
[09:28:20.975]                       }
[09:28:20.975]                       else if (inherits(cond, "warning")) {
[09:28:20.975]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:20.975]                         if (muffled) 
[09:28:20.975]                           invokeRestart("muffleWarning")
[09:28:20.975]                       }
[09:28:20.975]                       else if (inherits(cond, "condition")) {
[09:28:20.975]                         if (!is.null(pattern)) {
[09:28:20.975]                           computeRestarts <- base::computeRestarts
[09:28:20.975]                           grepl <- base::grepl
[09:28:20.975]                           restarts <- computeRestarts(cond)
[09:28:20.975]                           for (restart in restarts) {
[09:28:20.975]                             name <- restart$name
[09:28:20.975]                             if (is.null(name)) 
[09:28:20.975]                               next
[09:28:20.975]                             if (!grepl(pattern, name)) 
[09:28:20.975]                               next
[09:28:20.975]                             invokeRestart(restart)
[09:28:20.975]                             muffled <- TRUE
[09:28:20.975]                             break
[09:28:20.975]                           }
[09:28:20.975]                         }
[09:28:20.975]                       }
[09:28:20.975]                       invisible(muffled)
[09:28:20.975]                     }
[09:28:20.975]                     muffleCondition(cond, pattern = "^muffle")
[09:28:20.975]                   }
[09:28:20.975]                 }
[09:28:20.975]             }
[09:28:20.975]         }))
[09:28:20.975]     }, error = function(ex) {
[09:28:20.975]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:20.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:20.975]                 ...future.rng), started = ...future.startTime, 
[09:28:20.975]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:20.975]             version = "1.8"), class = "FutureResult")
[09:28:20.975]     }, finally = {
[09:28:20.975]         if (!identical(...future.workdir, getwd())) 
[09:28:20.975]             setwd(...future.workdir)
[09:28:20.975]         {
[09:28:20.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:20.975]                 ...future.oldOptions$nwarnings <- NULL
[09:28:20.975]             }
[09:28:20.975]             base::options(...future.oldOptions)
[09:28:20.975]             if (.Platform$OS.type == "windows") {
[09:28:20.975]                 old_names <- names(...future.oldEnvVars)
[09:28:20.975]                 envs <- base::Sys.getenv()
[09:28:20.975]                 names <- names(envs)
[09:28:20.975]                 common <- intersect(names, old_names)
[09:28:20.975]                 added <- setdiff(names, old_names)
[09:28:20.975]                 removed <- setdiff(old_names, names)
[09:28:20.975]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:20.975]                   envs[common]]
[09:28:20.975]                 NAMES <- toupper(changed)
[09:28:20.975]                 args <- list()
[09:28:20.975]                 for (kk in seq_along(NAMES)) {
[09:28:20.975]                   name <- changed[[kk]]
[09:28:20.975]                   NAME <- NAMES[[kk]]
[09:28:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.975]                     next
[09:28:20.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.975]                 }
[09:28:20.975]                 NAMES <- toupper(added)
[09:28:20.975]                 for (kk in seq_along(NAMES)) {
[09:28:20.975]                   name <- added[[kk]]
[09:28:20.975]                   NAME <- NAMES[[kk]]
[09:28:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.975]                     next
[09:28:20.975]                   args[[name]] <- ""
[09:28:20.975]                 }
[09:28:20.975]                 NAMES <- toupper(removed)
[09:28:20.975]                 for (kk in seq_along(NAMES)) {
[09:28:20.975]                   name <- removed[[kk]]
[09:28:20.975]                   NAME <- NAMES[[kk]]
[09:28:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:20.975]                     next
[09:28:20.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:20.975]                 }
[09:28:20.975]                 if (length(args) > 0) 
[09:28:20.975]                   base::do.call(base::Sys.setenv, args = args)
[09:28:20.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:20.975]             }
[09:28:20.975]             else {
[09:28:20.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:20.975]             }
[09:28:20.975]             {
[09:28:20.975]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:20.975]                   0L) {
[09:28:20.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:20.975]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:20.975]                   base::options(opts)
[09:28:20.975]                 }
[09:28:20.975]                 {
[09:28:20.975]                   {
[09:28:20.975]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:20.975]                     NULL
[09:28:20.975]                   }
[09:28:20.975]                   options(future.plan = NULL)
[09:28:20.975]                   if (is.na(NA_character_)) 
[09:28:20.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:20.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:20.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:20.975]                     .init = FALSE)
[09:28:20.975]                 }
[09:28:20.975]             }
[09:28:20.975]         }
[09:28:20.975]     })
[09:28:20.975]     if (TRUE) {
[09:28:20.975]         base::sink(type = "output", split = FALSE)
[09:28:20.975]         if (TRUE) {
[09:28:20.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:20.975]         }
[09:28:20.975]         else {
[09:28:20.975]             ...future.result["stdout"] <- base::list(NULL)
[09:28:20.975]         }
[09:28:20.975]         base::close(...future.stdout)
[09:28:20.975]         ...future.stdout <- NULL
[09:28:20.975]     }
[09:28:20.975]     ...future.result$conditions <- ...future.conditions
[09:28:20.975]     ...future.result$finished <- base::Sys.time()
[09:28:20.975]     ...future.result
[09:28:20.975] }
[09:28:20.978] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[09:28:20.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:20.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.978] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[09:28:20.979] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[09:28:20.979] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:28:20.979] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:20.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:20.980] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:20.980] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:20.980] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[09:28:20.981] MultisessionFuture started
[09:28:20.981] - Launch lazy future ... done
[09:28:20.981] run() for ‘MultisessionFuture’ ... done
[09:28:20.981] Created future:
[09:28:20.981] MultisessionFuture:
[09:28:20.981] Label: ‘future_apply-2’
[09:28:20.981] Expression:
[09:28:20.981] {
[09:28:20.981]     do.call(function(...) {
[09:28:20.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:20.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:20.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:20.981]             on.exit(options(oopts), add = TRUE)
[09:28:20.981]         }
[09:28:20.981]         {
[09:28:20.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:20.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:20.981]                 ...future.FUN(...future.X_jj, ...)
[09:28:20.981]             })
[09:28:20.981]         }
[09:28:20.981]     }, args = future.call.arguments)
[09:28:20.981] }
[09:28:20.981] Lazy evaluation: FALSE
[09:28:20.981] Asynchronous evaluation: TRUE
[09:28:20.981] Local evaluation: TRUE
[09:28:20.981] Environment: R_GlobalEnv
[09:28:20.981] Capture standard output: TRUE
[09:28:20.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:20.981] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:20.981] Packages: <none>
[09:28:20.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:20.981] Resolved: FALSE
[09:28:20.981] Value: <not collected>
[09:28:20.981] Conditions captured: <none>
[09:28:20.981] Early signaling: FALSE
[09:28:20.981] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:20.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:20.992] Chunk #2 of 2 ... DONE
[09:28:20.992] Launching 2 futures (chunks) ... DONE
[09:28:20.992] Resolving 2 futures (chunks) ...
[09:28:20.993] resolve() on list ...
[09:28:20.993]  recursive: 0
[09:28:20.993]  length: 2
[09:28:20.993] 
[09:28:20.993] receiveMessageFromWorker() for ClusterFuture ...
[09:28:20.993] - Validating connection of MultisessionFuture
[09:28:20.994] - received message: FutureResult
[09:28:20.994] - Received FutureResult
[09:28:20.994] - Erased future from FutureRegistry
[09:28:20.994] result() for ClusterFuture ...
[09:28:20.994] - result already collected: FutureResult
[09:28:20.994] result() for ClusterFuture ... done
[09:28:20.994] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:20.994] Future #1
[09:28:20.994] result() for ClusterFuture ...
[09:28:20.994] - result already collected: FutureResult
[09:28:20.994] result() for ClusterFuture ... done
[09:28:20.995] result() for ClusterFuture ...
[09:28:20.995] - result already collected: FutureResult
[09:28:20.995] result() for ClusterFuture ... done
[09:28:20.995] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:20.995] - nx: 2
[09:28:20.995] - relay: TRUE
[09:28:20.995] - stdout: TRUE
[09:28:20.995] - signal: TRUE
[09:28:20.995] - resignal: FALSE
[09:28:20.995] - force: TRUE
[09:28:20.995] - relayed: [n=2] FALSE, FALSE
[09:28:20.996] - queued futures: [n=2] FALSE, FALSE
[09:28:20.996]  - until=1
[09:28:20.996]  - relaying element #1
[09:28:20.996] result() for ClusterFuture ...
[09:28:20.996] - result already collected: FutureResult
[09:28:20.996] result() for ClusterFuture ... done
[09:28:20.996] result() for ClusterFuture ...
[09:28:20.996] - result already collected: FutureResult
[09:28:20.996] result() for ClusterFuture ... done
[09:28:20.996] result() for ClusterFuture ...
[09:28:20.996] - result already collected: FutureResult
[09:28:20.997] result() for ClusterFuture ... done
[09:28:20.997] result() for ClusterFuture ...
[09:28:20.997] - result already collected: FutureResult
[09:28:20.997] result() for ClusterFuture ... done
[09:28:20.997] - relayed: [n=2] TRUE, FALSE
[09:28:20.997] - queued futures: [n=2] TRUE, FALSE
[09:28:20.997] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:20.997]  length: 1 (resolved future 1)
[09:28:21.025] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.025] - Validating connection of MultisessionFuture
[09:28:21.025] - received message: FutureResult
[09:28:21.026] - Received FutureResult
[09:28:21.026] - Erased future from FutureRegistry
[09:28:21.026] result() for ClusterFuture ...
[09:28:21.026] - result already collected: FutureResult
[09:28:21.026] result() for ClusterFuture ... done
[09:28:21.026] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.026] Future #2
[09:28:21.026] result() for ClusterFuture ...
[09:28:21.026] - result already collected: FutureResult
[09:28:21.026] result() for ClusterFuture ... done
[09:28:21.027] result() for ClusterFuture ...
[09:28:21.027] - result already collected: FutureResult
[09:28:21.027] result() for ClusterFuture ... done
[09:28:21.027] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:21.027] - nx: 2
[09:28:21.027] - relay: TRUE
[09:28:21.027] - stdout: TRUE
[09:28:21.027] - signal: TRUE
[09:28:21.027] - resignal: FALSE
[09:28:21.027] - force: TRUE
[09:28:21.027] - relayed: [n=2] TRUE, FALSE
[09:28:21.027] - queued futures: [n=2] TRUE, FALSE
[09:28:21.028]  - until=2
[09:28:21.028]  - relaying element #2
[09:28:21.028] result() for ClusterFuture ...
[09:28:21.028] - result already collected: FutureResult
[09:28:21.028] result() for ClusterFuture ... done
[09:28:21.028] result() for ClusterFuture ...
[09:28:21.028] - result already collected: FutureResult
[09:28:21.028] result() for ClusterFuture ... done
[09:28:21.028] result() for ClusterFuture ...
[09:28:21.028] - result already collected: FutureResult
[09:28:21.029] result() for ClusterFuture ... done
[09:28:21.029] result() for ClusterFuture ...
[09:28:21.029] - result already collected: FutureResult
[09:28:21.029] result() for ClusterFuture ... done
[09:28:21.029] - relayed: [n=2] TRUE, TRUE
[09:28:21.029] - queued futures: [n=2] TRUE, TRUE
[09:28:21.029] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:21.029]  length: 0 (resolved future 2)
[09:28:21.029] Relaying remaining futures
[09:28:21.029] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.029] - nx: 2
[09:28:21.029] - relay: TRUE
[09:28:21.030] - stdout: TRUE
[09:28:21.030] - signal: TRUE
[09:28:21.030] - resignal: FALSE
[09:28:21.030] - force: TRUE
[09:28:21.030] - relayed: [n=2] TRUE, TRUE
[09:28:21.030] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:21.030] - relayed: [n=2] TRUE, TRUE
[09:28:21.030] - queued futures: [n=2] TRUE, TRUE
[09:28:21.030] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.030] resolve() on list ... DONE
[09:28:21.030] result() for ClusterFuture ...
[09:28:21.031] - result already collected: FutureResult
[09:28:21.031] result() for ClusterFuture ... done
[09:28:21.031] result() for ClusterFuture ...
[09:28:21.031] - result already collected: FutureResult
[09:28:21.031] result() for ClusterFuture ... done
[09:28:21.031] result() for ClusterFuture ...
[09:28:21.031] - result already collected: FutureResult
[09:28:21.031] result() for ClusterFuture ... done
[09:28:21.031] result() for ClusterFuture ...
[09:28:21.031] - result already collected: FutureResult
[09:28:21.031] result() for ClusterFuture ... done
[09:28:21.031]  - Number of value chunks collected: 2
[09:28:21.032] Resolving 2 futures (chunks) ... DONE
[09:28:21.032] Reducing values from 2 chunks ...
[09:28:21.032]  - Number of values collected after concatenation: 2
[09:28:21.032]  - Number of values expected: 2
[09:28:21.032] Reducing values from 2 chunks ... DONE
[09:28:21.032] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[09:28:21.032] getGlobalsAndPackagesXApply() ...
[09:28:21.032]  - future.globals: TRUE
[09:28:21.033] getGlobalsAndPackages() ...
[09:28:21.033] Searching for globals...
[09:28:21.034] - globals found: [1] ‘FUN’
[09:28:21.034] Searching for globals ... DONE
[09:28:21.034] Resolving globals: FALSE
[09:28:21.034] The total size of the 1 globals is 848 bytes (848 bytes)
[09:28:21.034] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[09:28:21.034] - globals: [1] ‘FUN’
[09:28:21.035] 
[09:28:21.035] getGlobalsAndPackages() ... DONE
[09:28:21.035]  - globals found/used: [n=1] ‘FUN’
[09:28:21.035]  - needed namespaces: [n=0] 
[09:28:21.035] Finding globals ... DONE
[09:28:21.035]  - use_args: TRUE
[09:28:21.035]  - Getting '...' globals ...
[09:28:21.035] resolve() on list ...
[09:28:21.035]  recursive: 0
[09:28:21.036]  length: 1
[09:28:21.036]  elements: ‘...’
[09:28:21.036]  length: 0 (resolved future 1)
[09:28:21.036] resolve() on list ... DONE
[09:28:21.036]    - '...' content: [n=0] 
[09:28:21.036] List of 1
[09:28:21.036]  $ ...: list()
[09:28:21.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.036]  - attr(*, "where")=List of 1
[09:28:21.036]   ..$ ...:<environment: 0x559ba5b5f6d0> 
[09:28:21.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.036]  - attr(*, "resolved")= logi TRUE
[09:28:21.036]  - attr(*, "total_size")= num NA
[09:28:21.039]  - Getting '...' globals ... DONE
[09:28:21.039] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:21.039] List of 2
[09:28:21.039]  $ ...future.FUN:function (x)  
[09:28:21.039]  $ ...          : list()
[09:28:21.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.039]  - attr(*, "where")=List of 2
[09:28:21.039]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:21.039]   ..$ ...          :<environment: 0x559ba5b5f6d0> 
[09:28:21.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.039]  - attr(*, "resolved")= logi FALSE
[09:28:21.039]  - attr(*, "total_size")= num 848
[09:28:21.041] Packages to be attached in all futures: [n=0] 
[09:28:21.041] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.045] future_lapply() ...
[09:28:21.048] Number of chunks: 2
[09:28:21.048] getGlobalsAndPackagesXApply() ...
[09:28:21.049]  - future.globals: <name-value list> with names ‘list()’
[09:28:21.049]  - use_args: TRUE
[09:28:21.049] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:21.049] List of 2
[09:28:21.049]  $ ...          : list()
[09:28:21.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.049]  $ ...future.FUN:function (x)  
[09:28:21.049]  - attr(*, "where")=List of 2
[09:28:21.049]   ..$ ...          :<environment: 0x559ba5b5f6d0> 
[09:28:21.049]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:21.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.049]  - attr(*, "resolved")= logi FALSE
[09:28:21.049]  - attr(*, "total_size")= num NA
[09:28:21.052] Packages to be attached in all futures: [n=0] 
[09:28:21.052] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.053] Number of futures (= number of chunks): 2
[09:28:21.053] Launching 2 futures (chunks) ...
[09:28:21.053] Chunk #1 of 2 ...
[09:28:21.053]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.053]  - seeds: <none>
[09:28:21.053]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.053] getGlobalsAndPackages() ...
[09:28:21.053] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.053] Resolving globals: FALSE
[09:28:21.054] Tweak future expression to call with '...' arguments ...
[09:28:21.054] {
[09:28:21.054]     do.call(function(...) {
[09:28:21.054]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.054]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.054]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.054]             on.exit(options(oopts), add = TRUE)
[09:28:21.054]         }
[09:28:21.054]         {
[09:28:21.054]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.054]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.054]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.054]             })
[09:28:21.054]         }
[09:28:21.054]     }, args = future.call.arguments)
[09:28:21.054] }
[09:28:21.054] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.054] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.054] 
[09:28:21.054] getGlobalsAndPackages() ... DONE
[09:28:21.055] run() for ‘Future’ ...
[09:28:21.055] - state: ‘created’
[09:28:21.055] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.069]   - Field: ‘node’
[09:28:21.069]   - Field: ‘label’
[09:28:21.069]   - Field: ‘local’
[09:28:21.069]   - Field: ‘owner’
[09:28:21.071]   - Field: ‘envir’
[09:28:21.071]   - Field: ‘workers’
[09:28:21.071]   - Field: ‘packages’
[09:28:21.071]   - Field: ‘gc’
[09:28:21.071]   - Field: ‘conditions’
[09:28:21.071]   - Field: ‘persistent’
[09:28:21.072]   - Field: ‘expr’
[09:28:21.072]   - Field: ‘uuid’
[09:28:21.072]   - Field: ‘seed’
[09:28:21.072]   - Field: ‘version’
[09:28:21.072]   - Field: ‘result’
[09:28:21.072]   - Field: ‘asynchronous’
[09:28:21.072]   - Field: ‘calls’
[09:28:21.072]   - Field: ‘globals’
[09:28:21.072]   - Field: ‘stdout’
[09:28:21.072]   - Field: ‘earlySignal’
[09:28:21.072]   - Field: ‘lazy’
[09:28:21.073]   - Field: ‘state’
[09:28:21.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.073] - Launch lazy future ...
[09:28:21.073] Packages needed by the future expression (n = 0): <none>
[09:28:21.073] Packages needed by future strategies (n = 0): <none>
[09:28:21.074] {
[09:28:21.074]     {
[09:28:21.074]         {
[09:28:21.074]             ...future.startTime <- base::Sys.time()
[09:28:21.074]             {
[09:28:21.074]                 {
[09:28:21.074]                   {
[09:28:21.074]                     {
[09:28:21.074]                       base::local({
[09:28:21.074]                         has_future <- base::requireNamespace("future", 
[09:28:21.074]                           quietly = TRUE)
[09:28:21.074]                         if (has_future) {
[09:28:21.074]                           ns <- base::getNamespace("future")
[09:28:21.074]                           version <- ns[[".package"]][["version"]]
[09:28:21.074]                           if (is.null(version)) 
[09:28:21.074]                             version <- utils::packageVersion("future")
[09:28:21.074]                         }
[09:28:21.074]                         else {
[09:28:21.074]                           version <- NULL
[09:28:21.074]                         }
[09:28:21.074]                         if (!has_future || version < "1.8.0") {
[09:28:21.074]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.074]                             "", base::R.version$version.string), 
[09:28:21.074]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.074]                               "release", "version")], collapse = " "), 
[09:28:21.074]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.074]                             info)
[09:28:21.074]                           info <- base::paste(info, collapse = "; ")
[09:28:21.074]                           if (!has_future) {
[09:28:21.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.074]                               info)
[09:28:21.074]                           }
[09:28:21.074]                           else {
[09:28:21.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.074]                               info, version)
[09:28:21.074]                           }
[09:28:21.074]                           base::stop(msg)
[09:28:21.074]                         }
[09:28:21.074]                       })
[09:28:21.074]                     }
[09:28:21.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.074]                     base::options(mc.cores = 1L)
[09:28:21.074]                   }
[09:28:21.074]                   ...future.strategy.old <- future::plan("list")
[09:28:21.074]                   options(future.plan = NULL)
[09:28:21.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.074]                 }
[09:28:21.074]                 ...future.workdir <- getwd()
[09:28:21.074]             }
[09:28:21.074]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.074]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.074]         }
[09:28:21.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.074]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.074]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.074]             base::names(...future.oldOptions))
[09:28:21.074]     }
[09:28:21.074]     if (FALSE) {
[09:28:21.074]     }
[09:28:21.074]     else {
[09:28:21.074]         if (TRUE) {
[09:28:21.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.074]                 open = "w")
[09:28:21.074]         }
[09:28:21.074]         else {
[09:28:21.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.074]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.074]         }
[09:28:21.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.074]             base::sink(type = "output", split = FALSE)
[09:28:21.074]             base::close(...future.stdout)
[09:28:21.074]         }, add = TRUE)
[09:28:21.074]     }
[09:28:21.074]     ...future.frame <- base::sys.nframe()
[09:28:21.074]     ...future.conditions <- base::list()
[09:28:21.074]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.074]     if (FALSE) {
[09:28:21.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.074]     }
[09:28:21.074]     ...future.result <- base::tryCatch({
[09:28:21.074]         base::withCallingHandlers({
[09:28:21.074]             ...future.value <- base::withVisible(base::local({
[09:28:21.074]                 ...future.makeSendCondition <- base::local({
[09:28:21.074]                   sendCondition <- NULL
[09:28:21.074]                   function(frame = 1L) {
[09:28:21.074]                     if (is.function(sendCondition)) 
[09:28:21.074]                       return(sendCondition)
[09:28:21.074]                     ns <- getNamespace("parallel")
[09:28:21.074]                     if (exists("sendData", mode = "function", 
[09:28:21.074]                       envir = ns)) {
[09:28:21.074]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.074]                         envir = ns)
[09:28:21.074]                       envir <- sys.frame(frame)
[09:28:21.074]                       master <- NULL
[09:28:21.074]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.074]                         !identical(envir, emptyenv())) {
[09:28:21.074]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.074]                           inherits = FALSE)) {
[09:28:21.074]                           master <- get("master", mode = "list", 
[09:28:21.074]                             envir = envir, inherits = FALSE)
[09:28:21.074]                           if (inherits(master, c("SOCKnode", 
[09:28:21.074]                             "SOCK0node"))) {
[09:28:21.074]                             sendCondition <<- function(cond) {
[09:28:21.074]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.074]                                 success = TRUE)
[09:28:21.074]                               parallel_sendData(master, data)
[09:28:21.074]                             }
[09:28:21.074]                             return(sendCondition)
[09:28:21.074]                           }
[09:28:21.074]                         }
[09:28:21.074]                         frame <- frame + 1L
[09:28:21.074]                         envir <- sys.frame(frame)
[09:28:21.074]                       }
[09:28:21.074]                     }
[09:28:21.074]                     sendCondition <<- function(cond) NULL
[09:28:21.074]                   }
[09:28:21.074]                 })
[09:28:21.074]                 withCallingHandlers({
[09:28:21.074]                   {
[09:28:21.074]                     do.call(function(...) {
[09:28:21.074]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.074]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.074]                         ...future.globals.maxSize)) {
[09:28:21.074]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.074]                         on.exit(options(oopts), add = TRUE)
[09:28:21.074]                       }
[09:28:21.074]                       {
[09:28:21.074]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.074]                           FUN = function(jj) {
[09:28:21.074]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.074]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.074]                           })
[09:28:21.074]                       }
[09:28:21.074]                     }, args = future.call.arguments)
[09:28:21.074]                   }
[09:28:21.074]                 }, immediateCondition = function(cond) {
[09:28:21.074]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.074]                   sendCondition(cond)
[09:28:21.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.074]                   {
[09:28:21.074]                     inherits <- base::inherits
[09:28:21.074]                     invokeRestart <- base::invokeRestart
[09:28:21.074]                     is.null <- base::is.null
[09:28:21.074]                     muffled <- FALSE
[09:28:21.074]                     if (inherits(cond, "message")) {
[09:28:21.074]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.074]                       if (muffled) 
[09:28:21.074]                         invokeRestart("muffleMessage")
[09:28:21.074]                     }
[09:28:21.074]                     else if (inherits(cond, "warning")) {
[09:28:21.074]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.074]                       if (muffled) 
[09:28:21.074]                         invokeRestart("muffleWarning")
[09:28:21.074]                     }
[09:28:21.074]                     else if (inherits(cond, "condition")) {
[09:28:21.074]                       if (!is.null(pattern)) {
[09:28:21.074]                         computeRestarts <- base::computeRestarts
[09:28:21.074]                         grepl <- base::grepl
[09:28:21.074]                         restarts <- computeRestarts(cond)
[09:28:21.074]                         for (restart in restarts) {
[09:28:21.074]                           name <- restart$name
[09:28:21.074]                           if (is.null(name)) 
[09:28:21.074]                             next
[09:28:21.074]                           if (!grepl(pattern, name)) 
[09:28:21.074]                             next
[09:28:21.074]                           invokeRestart(restart)
[09:28:21.074]                           muffled <- TRUE
[09:28:21.074]                           break
[09:28:21.074]                         }
[09:28:21.074]                       }
[09:28:21.074]                     }
[09:28:21.074]                     invisible(muffled)
[09:28:21.074]                   }
[09:28:21.074]                   muffleCondition(cond)
[09:28:21.074]                 })
[09:28:21.074]             }))
[09:28:21.074]             future::FutureResult(value = ...future.value$value, 
[09:28:21.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.074]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.074]                     ...future.globalenv.names))
[09:28:21.074]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.074]         }, condition = base::local({
[09:28:21.074]             c <- base::c
[09:28:21.074]             inherits <- base::inherits
[09:28:21.074]             invokeRestart <- base::invokeRestart
[09:28:21.074]             length <- base::length
[09:28:21.074]             list <- base::list
[09:28:21.074]             seq.int <- base::seq.int
[09:28:21.074]             signalCondition <- base::signalCondition
[09:28:21.074]             sys.calls <- base::sys.calls
[09:28:21.074]             `[[` <- base::`[[`
[09:28:21.074]             `+` <- base::`+`
[09:28:21.074]             `<<-` <- base::`<<-`
[09:28:21.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.074]                   3L)]
[09:28:21.074]             }
[09:28:21.074]             function(cond) {
[09:28:21.074]                 is_error <- inherits(cond, "error")
[09:28:21.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.074]                   NULL)
[09:28:21.074]                 if (is_error) {
[09:28:21.074]                   sessionInformation <- function() {
[09:28:21.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.074]                       search = base::search(), system = base::Sys.info())
[09:28:21.074]                   }
[09:28:21.074]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.074]                     cond$call), session = sessionInformation(), 
[09:28:21.074]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.074]                   signalCondition(cond)
[09:28:21.074]                 }
[09:28:21.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.074]                 "immediateCondition"))) {
[09:28:21.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.074]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.074]                   if (TRUE && !signal) {
[09:28:21.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.074]                     {
[09:28:21.074]                       inherits <- base::inherits
[09:28:21.074]                       invokeRestart <- base::invokeRestart
[09:28:21.074]                       is.null <- base::is.null
[09:28:21.074]                       muffled <- FALSE
[09:28:21.074]                       if (inherits(cond, "message")) {
[09:28:21.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.074]                         if (muffled) 
[09:28:21.074]                           invokeRestart("muffleMessage")
[09:28:21.074]                       }
[09:28:21.074]                       else if (inherits(cond, "warning")) {
[09:28:21.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.074]                         if (muffled) 
[09:28:21.074]                           invokeRestart("muffleWarning")
[09:28:21.074]                       }
[09:28:21.074]                       else if (inherits(cond, "condition")) {
[09:28:21.074]                         if (!is.null(pattern)) {
[09:28:21.074]                           computeRestarts <- base::computeRestarts
[09:28:21.074]                           grepl <- base::grepl
[09:28:21.074]                           restarts <- computeRestarts(cond)
[09:28:21.074]                           for (restart in restarts) {
[09:28:21.074]                             name <- restart$name
[09:28:21.074]                             if (is.null(name)) 
[09:28:21.074]                               next
[09:28:21.074]                             if (!grepl(pattern, name)) 
[09:28:21.074]                               next
[09:28:21.074]                             invokeRestart(restart)
[09:28:21.074]                             muffled <- TRUE
[09:28:21.074]                             break
[09:28:21.074]                           }
[09:28:21.074]                         }
[09:28:21.074]                       }
[09:28:21.074]                       invisible(muffled)
[09:28:21.074]                     }
[09:28:21.074]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.074]                   }
[09:28:21.074]                 }
[09:28:21.074]                 else {
[09:28:21.074]                   if (TRUE) {
[09:28:21.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.074]                     {
[09:28:21.074]                       inherits <- base::inherits
[09:28:21.074]                       invokeRestart <- base::invokeRestart
[09:28:21.074]                       is.null <- base::is.null
[09:28:21.074]                       muffled <- FALSE
[09:28:21.074]                       if (inherits(cond, "message")) {
[09:28:21.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.074]                         if (muffled) 
[09:28:21.074]                           invokeRestart("muffleMessage")
[09:28:21.074]                       }
[09:28:21.074]                       else if (inherits(cond, "warning")) {
[09:28:21.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.074]                         if (muffled) 
[09:28:21.074]                           invokeRestart("muffleWarning")
[09:28:21.074]                       }
[09:28:21.074]                       else if (inherits(cond, "condition")) {
[09:28:21.074]                         if (!is.null(pattern)) {
[09:28:21.074]                           computeRestarts <- base::computeRestarts
[09:28:21.074]                           grepl <- base::grepl
[09:28:21.074]                           restarts <- computeRestarts(cond)
[09:28:21.074]                           for (restart in restarts) {
[09:28:21.074]                             name <- restart$name
[09:28:21.074]                             if (is.null(name)) 
[09:28:21.074]                               next
[09:28:21.074]                             if (!grepl(pattern, name)) 
[09:28:21.074]                               next
[09:28:21.074]                             invokeRestart(restart)
[09:28:21.074]                             muffled <- TRUE
[09:28:21.074]                             break
[09:28:21.074]                           }
[09:28:21.074]                         }
[09:28:21.074]                       }
[09:28:21.074]                       invisible(muffled)
[09:28:21.074]                     }
[09:28:21.074]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.074]                   }
[09:28:21.074]                 }
[09:28:21.074]             }
[09:28:21.074]         }))
[09:28:21.074]     }, error = function(ex) {
[09:28:21.074]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.074]                 ...future.rng), started = ...future.startTime, 
[09:28:21.074]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.074]             version = "1.8"), class = "FutureResult")
[09:28:21.074]     }, finally = {
[09:28:21.074]         if (!identical(...future.workdir, getwd())) 
[09:28:21.074]             setwd(...future.workdir)
[09:28:21.074]         {
[09:28:21.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.074]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.074]             }
[09:28:21.074]             base::options(...future.oldOptions)
[09:28:21.074]             if (.Platform$OS.type == "windows") {
[09:28:21.074]                 old_names <- names(...future.oldEnvVars)
[09:28:21.074]                 envs <- base::Sys.getenv()
[09:28:21.074]                 names <- names(envs)
[09:28:21.074]                 common <- intersect(names, old_names)
[09:28:21.074]                 added <- setdiff(names, old_names)
[09:28:21.074]                 removed <- setdiff(old_names, names)
[09:28:21.074]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.074]                   envs[common]]
[09:28:21.074]                 NAMES <- toupper(changed)
[09:28:21.074]                 args <- list()
[09:28:21.074]                 for (kk in seq_along(NAMES)) {
[09:28:21.074]                   name <- changed[[kk]]
[09:28:21.074]                   NAME <- NAMES[[kk]]
[09:28:21.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.074]                     next
[09:28:21.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.074]                 }
[09:28:21.074]                 NAMES <- toupper(added)
[09:28:21.074]                 for (kk in seq_along(NAMES)) {
[09:28:21.074]                   name <- added[[kk]]
[09:28:21.074]                   NAME <- NAMES[[kk]]
[09:28:21.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.074]                     next
[09:28:21.074]                   args[[name]] <- ""
[09:28:21.074]                 }
[09:28:21.074]                 NAMES <- toupper(removed)
[09:28:21.074]                 for (kk in seq_along(NAMES)) {
[09:28:21.074]                   name <- removed[[kk]]
[09:28:21.074]                   NAME <- NAMES[[kk]]
[09:28:21.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.074]                     next
[09:28:21.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.074]                 }
[09:28:21.074]                 if (length(args) > 0) 
[09:28:21.074]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.074]             }
[09:28:21.074]             else {
[09:28:21.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.074]             }
[09:28:21.074]             {
[09:28:21.074]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.074]                   0L) {
[09:28:21.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.074]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.074]                   base::options(opts)
[09:28:21.074]                 }
[09:28:21.074]                 {
[09:28:21.074]                   {
[09:28:21.074]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.074]                     NULL
[09:28:21.074]                   }
[09:28:21.074]                   options(future.plan = NULL)
[09:28:21.074]                   if (is.na(NA_character_)) 
[09:28:21.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.074]                     .init = FALSE)
[09:28:21.074]                 }
[09:28:21.074]             }
[09:28:21.074]         }
[09:28:21.074]     })
[09:28:21.074]     if (TRUE) {
[09:28:21.074]         base::sink(type = "output", split = FALSE)
[09:28:21.074]         if (TRUE) {
[09:28:21.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.074]         }
[09:28:21.074]         else {
[09:28:21.074]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.074]         }
[09:28:21.074]         base::close(...future.stdout)
[09:28:21.074]         ...future.stdout <- NULL
[09:28:21.074]     }
[09:28:21.074]     ...future.result$conditions <- ...future.conditions
[09:28:21.074]     ...future.result$finished <- base::Sys.time()
[09:28:21.074]     ...future.result
[09:28:21.074] }
[09:28:21.076] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[09:28:21.077] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:21.077] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:21.077] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[09:28:21.077] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[09:28:21.077] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[09:28:21.078] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[09:28:21.078] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:21.078] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:21.078] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:21.079] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:21.079] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[09:28:21.079] MultisessionFuture started
[09:28:21.079] - Launch lazy future ... done
[09:28:21.079] run() for ‘MultisessionFuture’ ... done
[09:28:21.079] Created future:
[09:28:21.080] MultisessionFuture:
[09:28:21.080] Label: ‘future_apply-1’
[09:28:21.080] Expression:
[09:28:21.080] {
[09:28:21.080]     do.call(function(...) {
[09:28:21.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.080]             on.exit(options(oopts), add = TRUE)
[09:28:21.080]         }
[09:28:21.080]         {
[09:28:21.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.080]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.080]             })
[09:28:21.080]         }
[09:28:21.080]     }, args = future.call.arguments)
[09:28:21.080] }
[09:28:21.080] Lazy evaluation: FALSE
[09:28:21.080] Asynchronous evaluation: TRUE
[09:28:21.080] Local evaluation: TRUE
[09:28:21.080] Environment: R_GlobalEnv
[09:28:21.080] Capture standard output: TRUE
[09:28:21.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.080] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.080] Packages: <none>
[09:28:21.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.080] Resolved: FALSE
[09:28:21.080] Value: <not collected>
[09:28:21.080] Conditions captured: <none>
[09:28:21.080] Early signaling: FALSE
[09:28:21.080] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.080] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.091] Chunk #1 of 2 ... DONE
[09:28:21.091] Chunk #2 of 2 ...
[09:28:21.091]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.091]  - seeds: <none>
[09:28:21.092]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.092] getGlobalsAndPackages() ...
[09:28:21.092] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.092] Resolving globals: FALSE
[09:28:21.092] Tweak future expression to call with '...' arguments ...
[09:28:21.092] {
[09:28:21.092]     do.call(function(...) {
[09:28:21.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.092]             on.exit(options(oopts), add = TRUE)
[09:28:21.092]         }
[09:28:21.092]         {
[09:28:21.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.092]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.092]             })
[09:28:21.092]         }
[09:28:21.092]     }, args = future.call.arguments)
[09:28:21.092] }
[09:28:21.092] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.093] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.093] 
[09:28:21.093] getGlobalsAndPackages() ... DONE
[09:28:21.093] run() for ‘Future’ ...
[09:28:21.093] - state: ‘created’
[09:28:21.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.107]   - Field: ‘node’
[09:28:21.107]   - Field: ‘label’
[09:28:21.107]   - Field: ‘local’
[09:28:21.107]   - Field: ‘owner’
[09:28:21.107]   - Field: ‘envir’
[09:28:21.107]   - Field: ‘workers’
[09:28:21.108]   - Field: ‘packages’
[09:28:21.108]   - Field: ‘gc’
[09:28:21.108]   - Field: ‘conditions’
[09:28:21.108]   - Field: ‘persistent’
[09:28:21.108]   - Field: ‘expr’
[09:28:21.108]   - Field: ‘uuid’
[09:28:21.108]   - Field: ‘seed’
[09:28:21.108]   - Field: ‘version’
[09:28:21.108]   - Field: ‘result’
[09:28:21.108]   - Field: ‘asynchronous’
[09:28:21.109]   - Field: ‘calls’
[09:28:21.109]   - Field: ‘globals’
[09:28:21.109]   - Field: ‘stdout’
[09:28:21.109]   - Field: ‘earlySignal’
[09:28:21.109]   - Field: ‘lazy’
[09:28:21.109]   - Field: ‘state’
[09:28:21.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.109] - Launch lazy future ...
[09:28:21.109] Packages needed by the future expression (n = 0): <none>
[09:28:21.109] Packages needed by future strategies (n = 0): <none>
[09:28:21.110] {
[09:28:21.110]     {
[09:28:21.110]         {
[09:28:21.110]             ...future.startTime <- base::Sys.time()
[09:28:21.110]             {
[09:28:21.110]                 {
[09:28:21.110]                   {
[09:28:21.110]                     {
[09:28:21.110]                       base::local({
[09:28:21.110]                         has_future <- base::requireNamespace("future", 
[09:28:21.110]                           quietly = TRUE)
[09:28:21.110]                         if (has_future) {
[09:28:21.110]                           ns <- base::getNamespace("future")
[09:28:21.110]                           version <- ns[[".package"]][["version"]]
[09:28:21.110]                           if (is.null(version)) 
[09:28:21.110]                             version <- utils::packageVersion("future")
[09:28:21.110]                         }
[09:28:21.110]                         else {
[09:28:21.110]                           version <- NULL
[09:28:21.110]                         }
[09:28:21.110]                         if (!has_future || version < "1.8.0") {
[09:28:21.110]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.110]                             "", base::R.version$version.string), 
[09:28:21.110]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.110]                               "release", "version")], collapse = " "), 
[09:28:21.110]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.110]                             info)
[09:28:21.110]                           info <- base::paste(info, collapse = "; ")
[09:28:21.110]                           if (!has_future) {
[09:28:21.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.110]                               info)
[09:28:21.110]                           }
[09:28:21.110]                           else {
[09:28:21.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.110]                               info, version)
[09:28:21.110]                           }
[09:28:21.110]                           base::stop(msg)
[09:28:21.110]                         }
[09:28:21.110]                       })
[09:28:21.110]                     }
[09:28:21.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.110]                     base::options(mc.cores = 1L)
[09:28:21.110]                   }
[09:28:21.110]                   ...future.strategy.old <- future::plan("list")
[09:28:21.110]                   options(future.plan = NULL)
[09:28:21.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.110]                 }
[09:28:21.110]                 ...future.workdir <- getwd()
[09:28:21.110]             }
[09:28:21.110]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.110]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.110]         }
[09:28:21.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.110]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.110]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.110]             base::names(...future.oldOptions))
[09:28:21.110]     }
[09:28:21.110]     if (FALSE) {
[09:28:21.110]     }
[09:28:21.110]     else {
[09:28:21.110]         if (TRUE) {
[09:28:21.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.110]                 open = "w")
[09:28:21.110]         }
[09:28:21.110]         else {
[09:28:21.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.110]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.110]         }
[09:28:21.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.110]             base::sink(type = "output", split = FALSE)
[09:28:21.110]             base::close(...future.stdout)
[09:28:21.110]         }, add = TRUE)
[09:28:21.110]     }
[09:28:21.110]     ...future.frame <- base::sys.nframe()
[09:28:21.110]     ...future.conditions <- base::list()
[09:28:21.110]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.110]     if (FALSE) {
[09:28:21.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.110]     }
[09:28:21.110]     ...future.result <- base::tryCatch({
[09:28:21.110]         base::withCallingHandlers({
[09:28:21.110]             ...future.value <- base::withVisible(base::local({
[09:28:21.110]                 ...future.makeSendCondition <- base::local({
[09:28:21.110]                   sendCondition <- NULL
[09:28:21.110]                   function(frame = 1L) {
[09:28:21.110]                     if (is.function(sendCondition)) 
[09:28:21.110]                       return(sendCondition)
[09:28:21.110]                     ns <- getNamespace("parallel")
[09:28:21.110]                     if (exists("sendData", mode = "function", 
[09:28:21.110]                       envir = ns)) {
[09:28:21.110]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.110]                         envir = ns)
[09:28:21.110]                       envir <- sys.frame(frame)
[09:28:21.110]                       master <- NULL
[09:28:21.110]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.110]                         !identical(envir, emptyenv())) {
[09:28:21.110]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.110]                           inherits = FALSE)) {
[09:28:21.110]                           master <- get("master", mode = "list", 
[09:28:21.110]                             envir = envir, inherits = FALSE)
[09:28:21.110]                           if (inherits(master, c("SOCKnode", 
[09:28:21.110]                             "SOCK0node"))) {
[09:28:21.110]                             sendCondition <<- function(cond) {
[09:28:21.110]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.110]                                 success = TRUE)
[09:28:21.110]                               parallel_sendData(master, data)
[09:28:21.110]                             }
[09:28:21.110]                             return(sendCondition)
[09:28:21.110]                           }
[09:28:21.110]                         }
[09:28:21.110]                         frame <- frame + 1L
[09:28:21.110]                         envir <- sys.frame(frame)
[09:28:21.110]                       }
[09:28:21.110]                     }
[09:28:21.110]                     sendCondition <<- function(cond) NULL
[09:28:21.110]                   }
[09:28:21.110]                 })
[09:28:21.110]                 withCallingHandlers({
[09:28:21.110]                   {
[09:28:21.110]                     do.call(function(...) {
[09:28:21.110]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.110]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.110]                         ...future.globals.maxSize)) {
[09:28:21.110]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.110]                         on.exit(options(oopts), add = TRUE)
[09:28:21.110]                       }
[09:28:21.110]                       {
[09:28:21.110]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.110]                           FUN = function(jj) {
[09:28:21.110]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.110]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.110]                           })
[09:28:21.110]                       }
[09:28:21.110]                     }, args = future.call.arguments)
[09:28:21.110]                   }
[09:28:21.110]                 }, immediateCondition = function(cond) {
[09:28:21.110]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.110]                   sendCondition(cond)
[09:28:21.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.110]                   {
[09:28:21.110]                     inherits <- base::inherits
[09:28:21.110]                     invokeRestart <- base::invokeRestart
[09:28:21.110]                     is.null <- base::is.null
[09:28:21.110]                     muffled <- FALSE
[09:28:21.110]                     if (inherits(cond, "message")) {
[09:28:21.110]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.110]                       if (muffled) 
[09:28:21.110]                         invokeRestart("muffleMessage")
[09:28:21.110]                     }
[09:28:21.110]                     else if (inherits(cond, "warning")) {
[09:28:21.110]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.110]                       if (muffled) 
[09:28:21.110]                         invokeRestart("muffleWarning")
[09:28:21.110]                     }
[09:28:21.110]                     else if (inherits(cond, "condition")) {
[09:28:21.110]                       if (!is.null(pattern)) {
[09:28:21.110]                         computeRestarts <- base::computeRestarts
[09:28:21.110]                         grepl <- base::grepl
[09:28:21.110]                         restarts <- computeRestarts(cond)
[09:28:21.110]                         for (restart in restarts) {
[09:28:21.110]                           name <- restart$name
[09:28:21.110]                           if (is.null(name)) 
[09:28:21.110]                             next
[09:28:21.110]                           if (!grepl(pattern, name)) 
[09:28:21.110]                             next
[09:28:21.110]                           invokeRestart(restart)
[09:28:21.110]                           muffled <- TRUE
[09:28:21.110]                           break
[09:28:21.110]                         }
[09:28:21.110]                       }
[09:28:21.110]                     }
[09:28:21.110]                     invisible(muffled)
[09:28:21.110]                   }
[09:28:21.110]                   muffleCondition(cond)
[09:28:21.110]                 })
[09:28:21.110]             }))
[09:28:21.110]             future::FutureResult(value = ...future.value$value, 
[09:28:21.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.110]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.110]                     ...future.globalenv.names))
[09:28:21.110]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.110]         }, condition = base::local({
[09:28:21.110]             c <- base::c
[09:28:21.110]             inherits <- base::inherits
[09:28:21.110]             invokeRestart <- base::invokeRestart
[09:28:21.110]             length <- base::length
[09:28:21.110]             list <- base::list
[09:28:21.110]             seq.int <- base::seq.int
[09:28:21.110]             signalCondition <- base::signalCondition
[09:28:21.110]             sys.calls <- base::sys.calls
[09:28:21.110]             `[[` <- base::`[[`
[09:28:21.110]             `+` <- base::`+`
[09:28:21.110]             `<<-` <- base::`<<-`
[09:28:21.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.110]                   3L)]
[09:28:21.110]             }
[09:28:21.110]             function(cond) {
[09:28:21.110]                 is_error <- inherits(cond, "error")
[09:28:21.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.110]                   NULL)
[09:28:21.110]                 if (is_error) {
[09:28:21.110]                   sessionInformation <- function() {
[09:28:21.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.110]                       search = base::search(), system = base::Sys.info())
[09:28:21.110]                   }
[09:28:21.110]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.110]                     cond$call), session = sessionInformation(), 
[09:28:21.110]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.110]                   signalCondition(cond)
[09:28:21.110]                 }
[09:28:21.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.110]                 "immediateCondition"))) {
[09:28:21.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.110]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.110]                   if (TRUE && !signal) {
[09:28:21.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.110]                     {
[09:28:21.110]                       inherits <- base::inherits
[09:28:21.110]                       invokeRestart <- base::invokeRestart
[09:28:21.110]                       is.null <- base::is.null
[09:28:21.110]                       muffled <- FALSE
[09:28:21.110]                       if (inherits(cond, "message")) {
[09:28:21.110]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.110]                         if (muffled) 
[09:28:21.110]                           invokeRestart("muffleMessage")
[09:28:21.110]                       }
[09:28:21.110]                       else if (inherits(cond, "warning")) {
[09:28:21.110]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.110]                         if (muffled) 
[09:28:21.110]                           invokeRestart("muffleWarning")
[09:28:21.110]                       }
[09:28:21.110]                       else if (inherits(cond, "condition")) {
[09:28:21.110]                         if (!is.null(pattern)) {
[09:28:21.110]                           computeRestarts <- base::computeRestarts
[09:28:21.110]                           grepl <- base::grepl
[09:28:21.110]                           restarts <- computeRestarts(cond)
[09:28:21.110]                           for (restart in restarts) {
[09:28:21.110]                             name <- restart$name
[09:28:21.110]                             if (is.null(name)) 
[09:28:21.110]                               next
[09:28:21.110]                             if (!grepl(pattern, name)) 
[09:28:21.110]                               next
[09:28:21.110]                             invokeRestart(restart)
[09:28:21.110]                             muffled <- TRUE
[09:28:21.110]                             break
[09:28:21.110]                           }
[09:28:21.110]                         }
[09:28:21.110]                       }
[09:28:21.110]                       invisible(muffled)
[09:28:21.110]                     }
[09:28:21.110]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.110]                   }
[09:28:21.110]                 }
[09:28:21.110]                 else {
[09:28:21.110]                   if (TRUE) {
[09:28:21.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.110]                     {
[09:28:21.110]                       inherits <- base::inherits
[09:28:21.110]                       invokeRestart <- base::invokeRestart
[09:28:21.110]                       is.null <- base::is.null
[09:28:21.110]                       muffled <- FALSE
[09:28:21.110]                       if (inherits(cond, "message")) {
[09:28:21.110]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.110]                         if (muffled) 
[09:28:21.110]                           invokeRestart("muffleMessage")
[09:28:21.110]                       }
[09:28:21.110]                       else if (inherits(cond, "warning")) {
[09:28:21.110]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.110]                         if (muffled) 
[09:28:21.110]                           invokeRestart("muffleWarning")
[09:28:21.110]                       }
[09:28:21.110]                       else if (inherits(cond, "condition")) {
[09:28:21.110]                         if (!is.null(pattern)) {
[09:28:21.110]                           computeRestarts <- base::computeRestarts
[09:28:21.110]                           grepl <- base::grepl
[09:28:21.110]                           restarts <- computeRestarts(cond)
[09:28:21.110]                           for (restart in restarts) {
[09:28:21.110]                             name <- restart$name
[09:28:21.110]                             if (is.null(name)) 
[09:28:21.110]                               next
[09:28:21.110]                             if (!grepl(pattern, name)) 
[09:28:21.110]                               next
[09:28:21.110]                             invokeRestart(restart)
[09:28:21.110]                             muffled <- TRUE
[09:28:21.110]                             break
[09:28:21.110]                           }
[09:28:21.110]                         }
[09:28:21.110]                       }
[09:28:21.110]                       invisible(muffled)
[09:28:21.110]                     }
[09:28:21.110]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.110]                   }
[09:28:21.110]                 }
[09:28:21.110]             }
[09:28:21.110]         }))
[09:28:21.110]     }, error = function(ex) {
[09:28:21.110]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.110]                 ...future.rng), started = ...future.startTime, 
[09:28:21.110]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.110]             version = "1.8"), class = "FutureResult")
[09:28:21.110]     }, finally = {
[09:28:21.110]         if (!identical(...future.workdir, getwd())) 
[09:28:21.110]             setwd(...future.workdir)
[09:28:21.110]         {
[09:28:21.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.110]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.110]             }
[09:28:21.110]             base::options(...future.oldOptions)
[09:28:21.110]             if (.Platform$OS.type == "windows") {
[09:28:21.110]                 old_names <- names(...future.oldEnvVars)
[09:28:21.110]                 envs <- base::Sys.getenv()
[09:28:21.110]                 names <- names(envs)
[09:28:21.110]                 common <- intersect(names, old_names)
[09:28:21.110]                 added <- setdiff(names, old_names)
[09:28:21.110]                 removed <- setdiff(old_names, names)
[09:28:21.110]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.110]                   envs[common]]
[09:28:21.110]                 NAMES <- toupper(changed)
[09:28:21.110]                 args <- list()
[09:28:21.110]                 for (kk in seq_along(NAMES)) {
[09:28:21.110]                   name <- changed[[kk]]
[09:28:21.110]                   NAME <- NAMES[[kk]]
[09:28:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.110]                     next
[09:28:21.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.110]                 }
[09:28:21.110]                 NAMES <- toupper(added)
[09:28:21.110]                 for (kk in seq_along(NAMES)) {
[09:28:21.110]                   name <- added[[kk]]
[09:28:21.110]                   NAME <- NAMES[[kk]]
[09:28:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.110]                     next
[09:28:21.110]                   args[[name]] <- ""
[09:28:21.110]                 }
[09:28:21.110]                 NAMES <- toupper(removed)
[09:28:21.110]                 for (kk in seq_along(NAMES)) {
[09:28:21.110]                   name <- removed[[kk]]
[09:28:21.110]                   NAME <- NAMES[[kk]]
[09:28:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.110]                     next
[09:28:21.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.110]                 }
[09:28:21.110]                 if (length(args) > 0) 
[09:28:21.110]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.110]             }
[09:28:21.110]             else {
[09:28:21.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.110]             }
[09:28:21.110]             {
[09:28:21.110]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.110]                   0L) {
[09:28:21.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.110]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.110]                   base::options(opts)
[09:28:21.110]                 }
[09:28:21.110]                 {
[09:28:21.110]                   {
[09:28:21.110]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.110]                     NULL
[09:28:21.110]                   }
[09:28:21.110]                   options(future.plan = NULL)
[09:28:21.110]                   if (is.na(NA_character_)) 
[09:28:21.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.110]                     .init = FALSE)
[09:28:21.110]                 }
[09:28:21.110]             }
[09:28:21.110]         }
[09:28:21.110]     })
[09:28:21.110]     if (TRUE) {
[09:28:21.110]         base::sink(type = "output", split = FALSE)
[09:28:21.110]         if (TRUE) {
[09:28:21.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.110]         }
[09:28:21.110]         else {
[09:28:21.110]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.110]         }
[09:28:21.110]         base::close(...future.stdout)
[09:28:21.110]         ...future.stdout <- NULL
[09:28:21.110]     }
[09:28:21.110]     ...future.result$conditions <- ...future.conditions
[09:28:21.110]     ...future.result$finished <- base::Sys.time()
[09:28:21.110]     ...future.result
[09:28:21.110] }
[09:28:21.113] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[09:28:21.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:21.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:21.113] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[09:28:21.114] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[09:28:21.114] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[09:28:21.114] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[09:28:21.114] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:21.115] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:21.115] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:21.115] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:21.115] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[09:28:21.115] MultisessionFuture started
[09:28:21.116] - Launch lazy future ... done
[09:28:21.116] run() for ‘MultisessionFuture’ ... done
[09:28:21.116] Created future:
[09:28:21.116] MultisessionFuture:
[09:28:21.116] Label: ‘future_apply-2’
[09:28:21.116] Expression:
[09:28:21.116] {
[09:28:21.116]     do.call(function(...) {
[09:28:21.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.116]             on.exit(options(oopts), add = TRUE)
[09:28:21.116]         }
[09:28:21.116]         {
[09:28:21.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.116]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.116]             })
[09:28:21.116]         }
[09:28:21.116]     }, args = future.call.arguments)
[09:28:21.116] }
[09:28:21.116] Lazy evaluation: FALSE
[09:28:21.116] Asynchronous evaluation: TRUE
[09:28:21.116] Local evaluation: TRUE
[09:28:21.116] Environment: R_GlobalEnv
[09:28:21.116] Capture standard output: TRUE
[09:28:21.116] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.116] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.116] Packages: <none>
[09:28:21.116] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.116] Resolved: FALSE
[09:28:21.116] Value: <not collected>
[09:28:21.116] Conditions captured: <none>
[09:28:21.116] Early signaling: FALSE
[09:28:21.116] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.116] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.127] Chunk #2 of 2 ... DONE
[09:28:21.127] Launching 2 futures (chunks) ... DONE
[09:28:21.127] Resolving 2 futures (chunks) ...
[09:28:21.128] resolve() on list ...
[09:28:21.128]  recursive: 0
[09:28:21.128]  length: 2
[09:28:21.128] 
[09:28:21.128] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.128] - Validating connection of MultisessionFuture
[09:28:21.129] - received message: FutureResult
[09:28:21.129] - Received FutureResult
[09:28:21.129] - Erased future from FutureRegistry
[09:28:21.129] result() for ClusterFuture ...
[09:28:21.129] - result already collected: FutureResult
[09:28:21.129] result() for ClusterFuture ... done
[09:28:21.129] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.129] Future #1
[09:28:21.129] result() for ClusterFuture ...
[09:28:21.129] - result already collected: FutureResult
[09:28:21.129] result() for ClusterFuture ... done
[09:28:21.130] result() for ClusterFuture ...
[09:28:21.130] - result already collected: FutureResult
[09:28:21.130] result() for ClusterFuture ... done
[09:28:21.130] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:21.130] - nx: 2
[09:28:21.130] - relay: TRUE
[09:28:21.130] - stdout: TRUE
[09:28:21.130] - signal: TRUE
[09:28:21.130] - resignal: FALSE
[09:28:21.130] - force: TRUE
[09:28:21.130] - relayed: [n=2] FALSE, FALSE
[09:28:21.131] - queued futures: [n=2] FALSE, FALSE
[09:28:21.131]  - until=1
[09:28:21.131]  - relaying element #1
[09:28:21.131] result() for ClusterFuture ...
[09:28:21.131] - result already collected: FutureResult
[09:28:21.131] result() for ClusterFuture ... done
[09:28:21.131] result() for ClusterFuture ...
[09:28:21.131] - result already collected: FutureResult
[09:28:21.131] result() for ClusterFuture ... done
[09:28:21.131] result() for ClusterFuture ...
[09:28:21.131] - result already collected: FutureResult
[09:28:21.132] result() for ClusterFuture ... done
[09:28:21.132] result() for ClusterFuture ...
[09:28:21.132] - result already collected: FutureResult
[09:28:21.132] result() for ClusterFuture ... done
[09:28:21.132] - relayed: [n=2] TRUE, FALSE
[09:28:21.132] - queued futures: [n=2] TRUE, FALSE
[09:28:21.132] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:21.132]  length: 1 (resolved future 1)
[09:28:21.157] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.157] - Validating connection of MultisessionFuture
[09:28:21.157] - received message: FutureResult
[09:28:21.158] - Received FutureResult
[09:28:21.158] - Erased future from FutureRegistry
[09:28:21.158] result() for ClusterFuture ...
[09:28:21.158] - result already collected: FutureResult
[09:28:21.158] result() for ClusterFuture ... done
[09:28:21.158] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.158] Future #2
[09:28:21.158] result() for ClusterFuture ...
[09:28:21.158] - result already collected: FutureResult
[09:28:21.158] result() for ClusterFuture ... done
[09:28:21.158] result() for ClusterFuture ...
[09:28:21.159] - result already collected: FutureResult
[09:28:21.159] result() for ClusterFuture ... done
[09:28:21.159] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:21.159] - nx: 2
[09:28:21.159] - relay: TRUE
[09:28:21.159] - stdout: TRUE
[09:28:21.159] - signal: TRUE
[09:28:21.159] - resignal: FALSE
[09:28:21.159] - force: TRUE
[09:28:21.159] - relayed: [n=2] TRUE, FALSE
[09:28:21.159] - queued futures: [n=2] TRUE, FALSE
[09:28:21.159]  - until=2
[09:28:21.160]  - relaying element #2
[09:28:21.160] result() for ClusterFuture ...
[09:28:21.160] - result already collected: FutureResult
[09:28:21.160] result() for ClusterFuture ... done
[09:28:21.160] result() for ClusterFuture ...
[09:28:21.160] - result already collected: FutureResult
[09:28:21.160] result() for ClusterFuture ... done
[09:28:21.160] result() for ClusterFuture ...
[09:28:21.160] - result already collected: FutureResult
[09:28:21.160] result() for ClusterFuture ... done
[09:28:21.161] result() for ClusterFuture ...
[09:28:21.161] - result already collected: FutureResult
[09:28:21.161] result() for ClusterFuture ... done
[09:28:21.161] - relayed: [n=2] TRUE, TRUE
[09:28:21.161] - queued futures: [n=2] TRUE, TRUE
[09:28:21.161] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:21.161]  length: 0 (resolved future 2)
[09:28:21.161] Relaying remaining futures
[09:28:21.161] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.161] - nx: 2
[09:28:21.161] - relay: TRUE
[09:28:21.161] - stdout: TRUE
[09:28:21.162] - signal: TRUE
[09:28:21.162] - resignal: FALSE
[09:28:21.162] - force: TRUE
[09:28:21.162] - relayed: [n=2] TRUE, TRUE
[09:28:21.162] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:21.162] - relayed: [n=2] TRUE, TRUE
[09:28:21.162] - queued futures: [n=2] TRUE, TRUE
[09:28:21.162] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.162] resolve() on list ... DONE
[09:28:21.162] result() for ClusterFuture ...
[09:28:21.162] - result already collected: FutureResult
[09:28:21.162] result() for ClusterFuture ... done
[09:28:21.163] result() for ClusterFuture ...
[09:28:21.163] - result already collected: FutureResult
[09:28:21.163] result() for ClusterFuture ... done
[09:28:21.163] result() for ClusterFuture ...
[09:28:21.163] - result already collected: FutureResult
[09:28:21.163] result() for ClusterFuture ... done
[09:28:21.163] result() for ClusterFuture ...
[09:28:21.163] - result already collected: FutureResult
[09:28:21.163] result() for ClusterFuture ... done
[09:28:21.163]  - Number of value chunks collected: 2
[09:28:21.163] Resolving 2 futures (chunks) ... DONE
[09:28:21.164] Reducing values from 2 chunks ...
[09:28:21.164]  - Number of values collected after concatenation: 2
[09:28:21.164]  - Number of values expected: 2
[09:28:21.164] Reducing values from 2 chunks ... DONE
[09:28:21.164] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[09:28:21.164] getGlobalsAndPackagesXApply() ...
[09:28:21.164]  - future.globals: TRUE
[09:28:21.164] getGlobalsAndPackages() ...
[09:28:21.165] Searching for globals...
[09:28:21.167] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[09:28:21.167] Searching for globals ... DONE
[09:28:21.167] Resolving globals: FALSE
[09:28:21.167] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[09:28:21.168] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[09:28:21.168] - globals: [1] ‘FUN’
[09:28:21.168] 
[09:28:21.168] getGlobalsAndPackages() ... DONE
[09:28:21.168]  - globals found/used: [n=1] ‘FUN’
[09:28:21.168]  - needed namespaces: [n=0] 
[09:28:21.168] Finding globals ... DONE
[09:28:21.168]  - use_args: TRUE
[09:28:21.169]  - Getting '...' globals ...
[09:28:21.169] resolve() on list ...
[09:28:21.169]  recursive: 0
[09:28:21.169]  length: 1
[09:28:21.169]  elements: ‘...’
[09:28:21.169]  length: 0 (resolved future 1)
[09:28:21.169] resolve() on list ... DONE
[09:28:21.169]    - '...' content: [n=0] 
[09:28:21.170] List of 1
[09:28:21.170]  $ ...: list()
[09:28:21.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.170]  - attr(*, "where")=List of 1
[09:28:21.170]   ..$ ...:<environment: 0x559ba6a2ef78> 
[09:28:21.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.170]  - attr(*, "resolved")= logi TRUE
[09:28:21.170]  - attr(*, "total_size")= num NA
[09:28:21.172]  - Getting '...' globals ... DONE
[09:28:21.172] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:21.172] List of 2
[09:28:21.172]  $ ...future.FUN:function (x)  
[09:28:21.172]  $ ...          : list()
[09:28:21.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.172]  - attr(*, "where")=List of 2
[09:28:21.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:21.172]   ..$ ...          :<environment: 0x559ba6a2ef78> 
[09:28:21.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.172]  - attr(*, "resolved")= logi FALSE
[09:28:21.172]  - attr(*, "total_size")= num 9888
[09:28:21.175] Packages to be attached in all futures: [n=0] 
[09:28:21.175] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.178] future_lapply() ...
[09:28:21.183] Number of chunks: 2
[09:28:21.183] getGlobalsAndPackagesXApply() ...
[09:28:21.183]  - future.globals: <name-value list> with names ‘list()’
[09:28:21.183]  - use_args: TRUE
[09:28:21.183] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:21.183] List of 2
[09:28:21.183]  $ ...          : list()
[09:28:21.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.183]  $ ...future.FUN:function (x)  
[09:28:21.183]  - attr(*, "where")=List of 2
[09:28:21.183]   ..$ ...          :<environment: 0x559ba6a2ef78> 
[09:28:21.183]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[09:28:21.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.183]  - attr(*, "resolved")= logi FALSE
[09:28:21.183]  - attr(*, "total_size")= num NA
[09:28:21.186] Packages to be attached in all futures: [n=0] 
[09:28:21.186] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.186] Number of futures (= number of chunks): 2
[09:28:21.186] Launching 2 futures (chunks) ...
[09:28:21.186] Chunk #1 of 2 ...
[09:28:21.186]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.187]  - seeds: <none>
[09:28:21.187]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.187] getGlobalsAndPackages() ...
[09:28:21.187] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.187] Resolving globals: FALSE
[09:28:21.187] Tweak future expression to call with '...' arguments ...
[09:28:21.187] {
[09:28:21.187]     do.call(function(...) {
[09:28:21.187]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.187]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.187]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.187]             on.exit(options(oopts), add = TRUE)
[09:28:21.187]         }
[09:28:21.187]         {
[09:28:21.187]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.187]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.187]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.187]             })
[09:28:21.187]         }
[09:28:21.187]     }, args = future.call.arguments)
[09:28:21.187] }
[09:28:21.187] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.188] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.188] 
[09:28:21.188] getGlobalsAndPackages() ... DONE
[09:28:21.188] run() for ‘Future’ ...
[09:28:21.188] - state: ‘created’
[09:28:21.188] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.202]   - Field: ‘node’
[09:28:21.202]   - Field: ‘label’
[09:28:21.202]   - Field: ‘local’
[09:28:21.202]   - Field: ‘owner’
[09:28:21.202]   - Field: ‘envir’
[09:28:21.202]   - Field: ‘workers’
[09:28:21.202]   - Field: ‘packages’
[09:28:21.202]   - Field: ‘gc’
[09:28:21.203]   - Field: ‘conditions’
[09:28:21.203]   - Field: ‘persistent’
[09:28:21.203]   - Field: ‘expr’
[09:28:21.203]   - Field: ‘uuid’
[09:28:21.203]   - Field: ‘seed’
[09:28:21.203]   - Field: ‘version’
[09:28:21.203]   - Field: ‘result’
[09:28:21.203]   - Field: ‘asynchronous’
[09:28:21.203]   - Field: ‘calls’
[09:28:21.203]   - Field: ‘globals’
[09:28:21.203]   - Field: ‘stdout’
[09:28:21.204]   - Field: ‘earlySignal’
[09:28:21.204]   - Field: ‘lazy’
[09:28:21.204]   - Field: ‘state’
[09:28:21.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.204] - Launch lazy future ...
[09:28:21.204] Packages needed by the future expression (n = 0): <none>
[09:28:21.204] Packages needed by future strategies (n = 0): <none>
[09:28:21.205] {
[09:28:21.205]     {
[09:28:21.205]         {
[09:28:21.205]             ...future.startTime <- base::Sys.time()
[09:28:21.205]             {
[09:28:21.205]                 {
[09:28:21.205]                   {
[09:28:21.205]                     {
[09:28:21.205]                       base::local({
[09:28:21.205]                         has_future <- base::requireNamespace("future", 
[09:28:21.205]                           quietly = TRUE)
[09:28:21.205]                         if (has_future) {
[09:28:21.205]                           ns <- base::getNamespace("future")
[09:28:21.205]                           version <- ns[[".package"]][["version"]]
[09:28:21.205]                           if (is.null(version)) 
[09:28:21.205]                             version <- utils::packageVersion("future")
[09:28:21.205]                         }
[09:28:21.205]                         else {
[09:28:21.205]                           version <- NULL
[09:28:21.205]                         }
[09:28:21.205]                         if (!has_future || version < "1.8.0") {
[09:28:21.205]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.205]                             "", base::R.version$version.string), 
[09:28:21.205]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.205]                               "release", "version")], collapse = " "), 
[09:28:21.205]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.205]                             info)
[09:28:21.205]                           info <- base::paste(info, collapse = "; ")
[09:28:21.205]                           if (!has_future) {
[09:28:21.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.205]                               info)
[09:28:21.205]                           }
[09:28:21.205]                           else {
[09:28:21.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.205]                               info, version)
[09:28:21.205]                           }
[09:28:21.205]                           base::stop(msg)
[09:28:21.205]                         }
[09:28:21.205]                       })
[09:28:21.205]                     }
[09:28:21.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.205]                     base::options(mc.cores = 1L)
[09:28:21.205]                   }
[09:28:21.205]                   ...future.strategy.old <- future::plan("list")
[09:28:21.205]                   options(future.plan = NULL)
[09:28:21.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.205]                 }
[09:28:21.205]                 ...future.workdir <- getwd()
[09:28:21.205]             }
[09:28:21.205]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.205]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.205]         }
[09:28:21.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.205]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.205]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.205]             base::names(...future.oldOptions))
[09:28:21.205]     }
[09:28:21.205]     if (FALSE) {
[09:28:21.205]     }
[09:28:21.205]     else {
[09:28:21.205]         if (TRUE) {
[09:28:21.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.205]                 open = "w")
[09:28:21.205]         }
[09:28:21.205]         else {
[09:28:21.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.205]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.205]         }
[09:28:21.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.205]             base::sink(type = "output", split = FALSE)
[09:28:21.205]             base::close(...future.stdout)
[09:28:21.205]         }, add = TRUE)
[09:28:21.205]     }
[09:28:21.205]     ...future.frame <- base::sys.nframe()
[09:28:21.205]     ...future.conditions <- base::list()
[09:28:21.205]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.205]     if (FALSE) {
[09:28:21.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.205]     }
[09:28:21.205]     ...future.result <- base::tryCatch({
[09:28:21.205]         base::withCallingHandlers({
[09:28:21.205]             ...future.value <- base::withVisible(base::local({
[09:28:21.205]                 ...future.makeSendCondition <- base::local({
[09:28:21.205]                   sendCondition <- NULL
[09:28:21.205]                   function(frame = 1L) {
[09:28:21.205]                     if (is.function(sendCondition)) 
[09:28:21.205]                       return(sendCondition)
[09:28:21.205]                     ns <- getNamespace("parallel")
[09:28:21.205]                     if (exists("sendData", mode = "function", 
[09:28:21.205]                       envir = ns)) {
[09:28:21.205]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.205]                         envir = ns)
[09:28:21.205]                       envir <- sys.frame(frame)
[09:28:21.205]                       master <- NULL
[09:28:21.205]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.205]                         !identical(envir, emptyenv())) {
[09:28:21.205]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.205]                           inherits = FALSE)) {
[09:28:21.205]                           master <- get("master", mode = "list", 
[09:28:21.205]                             envir = envir, inherits = FALSE)
[09:28:21.205]                           if (inherits(master, c("SOCKnode", 
[09:28:21.205]                             "SOCK0node"))) {
[09:28:21.205]                             sendCondition <<- function(cond) {
[09:28:21.205]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.205]                                 success = TRUE)
[09:28:21.205]                               parallel_sendData(master, data)
[09:28:21.205]                             }
[09:28:21.205]                             return(sendCondition)
[09:28:21.205]                           }
[09:28:21.205]                         }
[09:28:21.205]                         frame <- frame + 1L
[09:28:21.205]                         envir <- sys.frame(frame)
[09:28:21.205]                       }
[09:28:21.205]                     }
[09:28:21.205]                     sendCondition <<- function(cond) NULL
[09:28:21.205]                   }
[09:28:21.205]                 })
[09:28:21.205]                 withCallingHandlers({
[09:28:21.205]                   {
[09:28:21.205]                     do.call(function(...) {
[09:28:21.205]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.205]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.205]                         ...future.globals.maxSize)) {
[09:28:21.205]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.205]                         on.exit(options(oopts), add = TRUE)
[09:28:21.205]                       }
[09:28:21.205]                       {
[09:28:21.205]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.205]                           FUN = function(jj) {
[09:28:21.205]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.205]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.205]                           })
[09:28:21.205]                       }
[09:28:21.205]                     }, args = future.call.arguments)
[09:28:21.205]                   }
[09:28:21.205]                 }, immediateCondition = function(cond) {
[09:28:21.205]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.205]                   sendCondition(cond)
[09:28:21.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.205]                   {
[09:28:21.205]                     inherits <- base::inherits
[09:28:21.205]                     invokeRestart <- base::invokeRestart
[09:28:21.205]                     is.null <- base::is.null
[09:28:21.205]                     muffled <- FALSE
[09:28:21.205]                     if (inherits(cond, "message")) {
[09:28:21.205]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.205]                       if (muffled) 
[09:28:21.205]                         invokeRestart("muffleMessage")
[09:28:21.205]                     }
[09:28:21.205]                     else if (inherits(cond, "warning")) {
[09:28:21.205]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.205]                       if (muffled) 
[09:28:21.205]                         invokeRestart("muffleWarning")
[09:28:21.205]                     }
[09:28:21.205]                     else if (inherits(cond, "condition")) {
[09:28:21.205]                       if (!is.null(pattern)) {
[09:28:21.205]                         computeRestarts <- base::computeRestarts
[09:28:21.205]                         grepl <- base::grepl
[09:28:21.205]                         restarts <- computeRestarts(cond)
[09:28:21.205]                         for (restart in restarts) {
[09:28:21.205]                           name <- restart$name
[09:28:21.205]                           if (is.null(name)) 
[09:28:21.205]                             next
[09:28:21.205]                           if (!grepl(pattern, name)) 
[09:28:21.205]                             next
[09:28:21.205]                           invokeRestart(restart)
[09:28:21.205]                           muffled <- TRUE
[09:28:21.205]                           break
[09:28:21.205]                         }
[09:28:21.205]                       }
[09:28:21.205]                     }
[09:28:21.205]                     invisible(muffled)
[09:28:21.205]                   }
[09:28:21.205]                   muffleCondition(cond)
[09:28:21.205]                 })
[09:28:21.205]             }))
[09:28:21.205]             future::FutureResult(value = ...future.value$value, 
[09:28:21.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.205]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.205]                     ...future.globalenv.names))
[09:28:21.205]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.205]         }, condition = base::local({
[09:28:21.205]             c <- base::c
[09:28:21.205]             inherits <- base::inherits
[09:28:21.205]             invokeRestart <- base::invokeRestart
[09:28:21.205]             length <- base::length
[09:28:21.205]             list <- base::list
[09:28:21.205]             seq.int <- base::seq.int
[09:28:21.205]             signalCondition <- base::signalCondition
[09:28:21.205]             sys.calls <- base::sys.calls
[09:28:21.205]             `[[` <- base::`[[`
[09:28:21.205]             `+` <- base::`+`
[09:28:21.205]             `<<-` <- base::`<<-`
[09:28:21.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.205]                   3L)]
[09:28:21.205]             }
[09:28:21.205]             function(cond) {
[09:28:21.205]                 is_error <- inherits(cond, "error")
[09:28:21.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.205]                   NULL)
[09:28:21.205]                 if (is_error) {
[09:28:21.205]                   sessionInformation <- function() {
[09:28:21.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.205]                       search = base::search(), system = base::Sys.info())
[09:28:21.205]                   }
[09:28:21.205]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.205]                     cond$call), session = sessionInformation(), 
[09:28:21.205]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.205]                   signalCondition(cond)
[09:28:21.205]                 }
[09:28:21.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.205]                 "immediateCondition"))) {
[09:28:21.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.205]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.205]                   if (TRUE && !signal) {
[09:28:21.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.205]                     {
[09:28:21.205]                       inherits <- base::inherits
[09:28:21.205]                       invokeRestart <- base::invokeRestart
[09:28:21.205]                       is.null <- base::is.null
[09:28:21.205]                       muffled <- FALSE
[09:28:21.205]                       if (inherits(cond, "message")) {
[09:28:21.205]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.205]                         if (muffled) 
[09:28:21.205]                           invokeRestart("muffleMessage")
[09:28:21.205]                       }
[09:28:21.205]                       else if (inherits(cond, "warning")) {
[09:28:21.205]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.205]                         if (muffled) 
[09:28:21.205]                           invokeRestart("muffleWarning")
[09:28:21.205]                       }
[09:28:21.205]                       else if (inherits(cond, "condition")) {
[09:28:21.205]                         if (!is.null(pattern)) {
[09:28:21.205]                           computeRestarts <- base::computeRestarts
[09:28:21.205]                           grepl <- base::grepl
[09:28:21.205]                           restarts <- computeRestarts(cond)
[09:28:21.205]                           for (restart in restarts) {
[09:28:21.205]                             name <- restart$name
[09:28:21.205]                             if (is.null(name)) 
[09:28:21.205]                               next
[09:28:21.205]                             if (!grepl(pattern, name)) 
[09:28:21.205]                               next
[09:28:21.205]                             invokeRestart(restart)
[09:28:21.205]                             muffled <- TRUE
[09:28:21.205]                             break
[09:28:21.205]                           }
[09:28:21.205]                         }
[09:28:21.205]                       }
[09:28:21.205]                       invisible(muffled)
[09:28:21.205]                     }
[09:28:21.205]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.205]                   }
[09:28:21.205]                 }
[09:28:21.205]                 else {
[09:28:21.205]                   if (TRUE) {
[09:28:21.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.205]                     {
[09:28:21.205]                       inherits <- base::inherits
[09:28:21.205]                       invokeRestart <- base::invokeRestart
[09:28:21.205]                       is.null <- base::is.null
[09:28:21.205]                       muffled <- FALSE
[09:28:21.205]                       if (inherits(cond, "message")) {
[09:28:21.205]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.205]                         if (muffled) 
[09:28:21.205]                           invokeRestart("muffleMessage")
[09:28:21.205]                       }
[09:28:21.205]                       else if (inherits(cond, "warning")) {
[09:28:21.205]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.205]                         if (muffled) 
[09:28:21.205]                           invokeRestart("muffleWarning")
[09:28:21.205]                       }
[09:28:21.205]                       else if (inherits(cond, "condition")) {
[09:28:21.205]                         if (!is.null(pattern)) {
[09:28:21.205]                           computeRestarts <- base::computeRestarts
[09:28:21.205]                           grepl <- base::grepl
[09:28:21.205]                           restarts <- computeRestarts(cond)
[09:28:21.205]                           for (restart in restarts) {
[09:28:21.205]                             name <- restart$name
[09:28:21.205]                             if (is.null(name)) 
[09:28:21.205]                               next
[09:28:21.205]                             if (!grepl(pattern, name)) 
[09:28:21.205]                               next
[09:28:21.205]                             invokeRestart(restart)
[09:28:21.205]                             muffled <- TRUE
[09:28:21.205]                             break
[09:28:21.205]                           }
[09:28:21.205]                         }
[09:28:21.205]                       }
[09:28:21.205]                       invisible(muffled)
[09:28:21.205]                     }
[09:28:21.205]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.205]                   }
[09:28:21.205]                 }
[09:28:21.205]             }
[09:28:21.205]         }))
[09:28:21.205]     }, error = function(ex) {
[09:28:21.205]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.205]                 ...future.rng), started = ...future.startTime, 
[09:28:21.205]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.205]             version = "1.8"), class = "FutureResult")
[09:28:21.205]     }, finally = {
[09:28:21.205]         if (!identical(...future.workdir, getwd())) 
[09:28:21.205]             setwd(...future.workdir)
[09:28:21.205]         {
[09:28:21.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.205]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.205]             }
[09:28:21.205]             base::options(...future.oldOptions)
[09:28:21.205]             if (.Platform$OS.type == "windows") {
[09:28:21.205]                 old_names <- names(...future.oldEnvVars)
[09:28:21.205]                 envs <- base::Sys.getenv()
[09:28:21.205]                 names <- names(envs)
[09:28:21.205]                 common <- intersect(names, old_names)
[09:28:21.205]                 added <- setdiff(names, old_names)
[09:28:21.205]                 removed <- setdiff(old_names, names)
[09:28:21.205]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.205]                   envs[common]]
[09:28:21.205]                 NAMES <- toupper(changed)
[09:28:21.205]                 args <- list()
[09:28:21.205]                 for (kk in seq_along(NAMES)) {
[09:28:21.205]                   name <- changed[[kk]]
[09:28:21.205]                   NAME <- NAMES[[kk]]
[09:28:21.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.205]                     next
[09:28:21.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.205]                 }
[09:28:21.205]                 NAMES <- toupper(added)
[09:28:21.205]                 for (kk in seq_along(NAMES)) {
[09:28:21.205]                   name <- added[[kk]]
[09:28:21.205]                   NAME <- NAMES[[kk]]
[09:28:21.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.205]                     next
[09:28:21.205]                   args[[name]] <- ""
[09:28:21.205]                 }
[09:28:21.205]                 NAMES <- toupper(removed)
[09:28:21.205]                 for (kk in seq_along(NAMES)) {
[09:28:21.205]                   name <- removed[[kk]]
[09:28:21.205]                   NAME <- NAMES[[kk]]
[09:28:21.205]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.205]                     next
[09:28:21.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.205]                 }
[09:28:21.205]                 if (length(args) > 0) 
[09:28:21.205]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.205]             }
[09:28:21.205]             else {
[09:28:21.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.205]             }
[09:28:21.205]             {
[09:28:21.205]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.205]                   0L) {
[09:28:21.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.205]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.205]                   base::options(opts)
[09:28:21.205]                 }
[09:28:21.205]                 {
[09:28:21.205]                   {
[09:28:21.205]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.205]                     NULL
[09:28:21.205]                   }
[09:28:21.205]                   options(future.plan = NULL)
[09:28:21.205]                   if (is.na(NA_character_)) 
[09:28:21.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.205]                     .init = FALSE)
[09:28:21.205]                 }
[09:28:21.205]             }
[09:28:21.205]         }
[09:28:21.205]     })
[09:28:21.205]     if (TRUE) {
[09:28:21.205]         base::sink(type = "output", split = FALSE)
[09:28:21.205]         if (TRUE) {
[09:28:21.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.205]         }
[09:28:21.205]         else {
[09:28:21.205]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.205]         }
[09:28:21.205]         base::close(...future.stdout)
[09:28:21.205]         ...future.stdout <- NULL
[09:28:21.205]     }
[09:28:21.205]     ...future.result$conditions <- ...future.conditions
[09:28:21.205]     ...future.result$finished <- base::Sys.time()
[09:28:21.205]     ...future.result
[09:28:21.205] }
[09:28:21.207] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[09:28:21.208] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:21.208] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:21.208] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[09:28:21.209] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[09:28:21.209] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:28:21.209] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:28:21.209] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:21.209] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:21.209] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:21.210] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:21.210] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[09:28:21.210] MultisessionFuture started
[09:28:21.210] - Launch lazy future ... done
[09:28:21.210] run() for ‘MultisessionFuture’ ... done
[09:28:21.211] Created future:
[09:28:21.211] MultisessionFuture:
[09:28:21.211] Label: ‘future_apply-1’
[09:28:21.211] Expression:
[09:28:21.211] {
[09:28:21.211]     do.call(function(...) {
[09:28:21.211]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.211]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.211]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.211]             on.exit(options(oopts), add = TRUE)
[09:28:21.211]         }
[09:28:21.211]         {
[09:28:21.211]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.211]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.211]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.211]             })
[09:28:21.211]         }
[09:28:21.211]     }, args = future.call.arguments)
[09:28:21.211] }
[09:28:21.211] Lazy evaluation: FALSE
[09:28:21.211] Asynchronous evaluation: TRUE
[09:28:21.211] Local evaluation: TRUE
[09:28:21.211] Environment: R_GlobalEnv
[09:28:21.211] Capture standard output: TRUE
[09:28:21.211] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.211] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.211] Packages: <none>
[09:28:21.211] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.211] Resolved: FALSE
[09:28:21.211] Value: <not collected>
[09:28:21.211] Conditions captured: <none>
[09:28:21.211] Early signaling: FALSE
[09:28:21.211] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.211] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.222] Chunk #1 of 2 ... DONE
[09:28:21.222] Chunk #2 of 2 ...
[09:28:21.222]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.223]  - seeds: <none>
[09:28:21.223]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.223] getGlobalsAndPackages() ...
[09:28:21.223] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.223] Resolving globals: FALSE
[09:28:21.223] Tweak future expression to call with '...' arguments ...
[09:28:21.223] {
[09:28:21.223]     do.call(function(...) {
[09:28:21.223]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.223]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.223]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.223]             on.exit(options(oopts), add = TRUE)
[09:28:21.223]         }
[09:28:21.223]         {
[09:28:21.223]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.223]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.223]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.223]             })
[09:28:21.223]         }
[09:28:21.223]     }, args = future.call.arguments)
[09:28:21.223] }
[09:28:21.223] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.224] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.224] 
[09:28:21.224] getGlobalsAndPackages() ... DONE
[09:28:21.224] run() for ‘Future’ ...
[09:28:21.224] - state: ‘created’
[09:28:21.224] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.238] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.238]   - Field: ‘node’
[09:28:21.238]   - Field: ‘label’
[09:28:21.238]   - Field: ‘local’
[09:28:21.239]   - Field: ‘owner’
[09:28:21.239]   - Field: ‘envir’
[09:28:21.239]   - Field: ‘workers’
[09:28:21.239]   - Field: ‘packages’
[09:28:21.239]   - Field: ‘gc’
[09:28:21.239]   - Field: ‘conditions’
[09:28:21.239]   - Field: ‘persistent’
[09:28:21.239]   - Field: ‘expr’
[09:28:21.239]   - Field: ‘uuid’
[09:28:21.239]   - Field: ‘seed’
[09:28:21.239]   - Field: ‘version’
[09:28:21.240]   - Field: ‘result’
[09:28:21.240]   - Field: ‘asynchronous’
[09:28:21.240]   - Field: ‘calls’
[09:28:21.240]   - Field: ‘globals’
[09:28:21.240]   - Field: ‘stdout’
[09:28:21.240]   - Field: ‘earlySignal’
[09:28:21.240]   - Field: ‘lazy’
[09:28:21.240]   - Field: ‘state’
[09:28:21.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.240] - Launch lazy future ...
[09:28:21.241] Packages needed by the future expression (n = 0): <none>
[09:28:21.241] Packages needed by future strategies (n = 0): <none>
[09:28:21.241] {
[09:28:21.241]     {
[09:28:21.241]         {
[09:28:21.241]             ...future.startTime <- base::Sys.time()
[09:28:21.241]             {
[09:28:21.241]                 {
[09:28:21.241]                   {
[09:28:21.241]                     {
[09:28:21.241]                       base::local({
[09:28:21.241]                         has_future <- base::requireNamespace("future", 
[09:28:21.241]                           quietly = TRUE)
[09:28:21.241]                         if (has_future) {
[09:28:21.241]                           ns <- base::getNamespace("future")
[09:28:21.241]                           version <- ns[[".package"]][["version"]]
[09:28:21.241]                           if (is.null(version)) 
[09:28:21.241]                             version <- utils::packageVersion("future")
[09:28:21.241]                         }
[09:28:21.241]                         else {
[09:28:21.241]                           version <- NULL
[09:28:21.241]                         }
[09:28:21.241]                         if (!has_future || version < "1.8.0") {
[09:28:21.241]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.241]                             "", base::R.version$version.string), 
[09:28:21.241]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.241]                               "release", "version")], collapse = " "), 
[09:28:21.241]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.241]                             info)
[09:28:21.241]                           info <- base::paste(info, collapse = "; ")
[09:28:21.241]                           if (!has_future) {
[09:28:21.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.241]                               info)
[09:28:21.241]                           }
[09:28:21.241]                           else {
[09:28:21.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.241]                               info, version)
[09:28:21.241]                           }
[09:28:21.241]                           base::stop(msg)
[09:28:21.241]                         }
[09:28:21.241]                       })
[09:28:21.241]                     }
[09:28:21.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.241]                     base::options(mc.cores = 1L)
[09:28:21.241]                   }
[09:28:21.241]                   ...future.strategy.old <- future::plan("list")
[09:28:21.241]                   options(future.plan = NULL)
[09:28:21.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.241]                 }
[09:28:21.241]                 ...future.workdir <- getwd()
[09:28:21.241]             }
[09:28:21.241]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.241]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.241]         }
[09:28:21.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.241]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.241]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.241]             base::names(...future.oldOptions))
[09:28:21.241]     }
[09:28:21.241]     if (FALSE) {
[09:28:21.241]     }
[09:28:21.241]     else {
[09:28:21.241]         if (TRUE) {
[09:28:21.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.241]                 open = "w")
[09:28:21.241]         }
[09:28:21.241]         else {
[09:28:21.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.241]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.241]         }
[09:28:21.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.241]             base::sink(type = "output", split = FALSE)
[09:28:21.241]             base::close(...future.stdout)
[09:28:21.241]         }, add = TRUE)
[09:28:21.241]     }
[09:28:21.241]     ...future.frame <- base::sys.nframe()
[09:28:21.241]     ...future.conditions <- base::list()
[09:28:21.241]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.241]     if (FALSE) {
[09:28:21.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.241]     }
[09:28:21.241]     ...future.result <- base::tryCatch({
[09:28:21.241]         base::withCallingHandlers({
[09:28:21.241]             ...future.value <- base::withVisible(base::local({
[09:28:21.241]                 ...future.makeSendCondition <- base::local({
[09:28:21.241]                   sendCondition <- NULL
[09:28:21.241]                   function(frame = 1L) {
[09:28:21.241]                     if (is.function(sendCondition)) 
[09:28:21.241]                       return(sendCondition)
[09:28:21.241]                     ns <- getNamespace("parallel")
[09:28:21.241]                     if (exists("sendData", mode = "function", 
[09:28:21.241]                       envir = ns)) {
[09:28:21.241]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.241]                         envir = ns)
[09:28:21.241]                       envir <- sys.frame(frame)
[09:28:21.241]                       master <- NULL
[09:28:21.241]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.241]                         !identical(envir, emptyenv())) {
[09:28:21.241]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.241]                           inherits = FALSE)) {
[09:28:21.241]                           master <- get("master", mode = "list", 
[09:28:21.241]                             envir = envir, inherits = FALSE)
[09:28:21.241]                           if (inherits(master, c("SOCKnode", 
[09:28:21.241]                             "SOCK0node"))) {
[09:28:21.241]                             sendCondition <<- function(cond) {
[09:28:21.241]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.241]                                 success = TRUE)
[09:28:21.241]                               parallel_sendData(master, data)
[09:28:21.241]                             }
[09:28:21.241]                             return(sendCondition)
[09:28:21.241]                           }
[09:28:21.241]                         }
[09:28:21.241]                         frame <- frame + 1L
[09:28:21.241]                         envir <- sys.frame(frame)
[09:28:21.241]                       }
[09:28:21.241]                     }
[09:28:21.241]                     sendCondition <<- function(cond) NULL
[09:28:21.241]                   }
[09:28:21.241]                 })
[09:28:21.241]                 withCallingHandlers({
[09:28:21.241]                   {
[09:28:21.241]                     do.call(function(...) {
[09:28:21.241]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.241]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.241]                         ...future.globals.maxSize)) {
[09:28:21.241]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.241]                         on.exit(options(oopts), add = TRUE)
[09:28:21.241]                       }
[09:28:21.241]                       {
[09:28:21.241]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.241]                           FUN = function(jj) {
[09:28:21.241]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.241]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.241]                           })
[09:28:21.241]                       }
[09:28:21.241]                     }, args = future.call.arguments)
[09:28:21.241]                   }
[09:28:21.241]                 }, immediateCondition = function(cond) {
[09:28:21.241]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.241]                   sendCondition(cond)
[09:28:21.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.241]                   {
[09:28:21.241]                     inherits <- base::inherits
[09:28:21.241]                     invokeRestart <- base::invokeRestart
[09:28:21.241]                     is.null <- base::is.null
[09:28:21.241]                     muffled <- FALSE
[09:28:21.241]                     if (inherits(cond, "message")) {
[09:28:21.241]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.241]                       if (muffled) 
[09:28:21.241]                         invokeRestart("muffleMessage")
[09:28:21.241]                     }
[09:28:21.241]                     else if (inherits(cond, "warning")) {
[09:28:21.241]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.241]                       if (muffled) 
[09:28:21.241]                         invokeRestart("muffleWarning")
[09:28:21.241]                     }
[09:28:21.241]                     else if (inherits(cond, "condition")) {
[09:28:21.241]                       if (!is.null(pattern)) {
[09:28:21.241]                         computeRestarts <- base::computeRestarts
[09:28:21.241]                         grepl <- base::grepl
[09:28:21.241]                         restarts <- computeRestarts(cond)
[09:28:21.241]                         for (restart in restarts) {
[09:28:21.241]                           name <- restart$name
[09:28:21.241]                           if (is.null(name)) 
[09:28:21.241]                             next
[09:28:21.241]                           if (!grepl(pattern, name)) 
[09:28:21.241]                             next
[09:28:21.241]                           invokeRestart(restart)
[09:28:21.241]                           muffled <- TRUE
[09:28:21.241]                           break
[09:28:21.241]                         }
[09:28:21.241]                       }
[09:28:21.241]                     }
[09:28:21.241]                     invisible(muffled)
[09:28:21.241]                   }
[09:28:21.241]                   muffleCondition(cond)
[09:28:21.241]                 })
[09:28:21.241]             }))
[09:28:21.241]             future::FutureResult(value = ...future.value$value, 
[09:28:21.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.241]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.241]                     ...future.globalenv.names))
[09:28:21.241]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.241]         }, condition = base::local({
[09:28:21.241]             c <- base::c
[09:28:21.241]             inherits <- base::inherits
[09:28:21.241]             invokeRestart <- base::invokeRestart
[09:28:21.241]             length <- base::length
[09:28:21.241]             list <- base::list
[09:28:21.241]             seq.int <- base::seq.int
[09:28:21.241]             signalCondition <- base::signalCondition
[09:28:21.241]             sys.calls <- base::sys.calls
[09:28:21.241]             `[[` <- base::`[[`
[09:28:21.241]             `+` <- base::`+`
[09:28:21.241]             `<<-` <- base::`<<-`
[09:28:21.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.241]                   3L)]
[09:28:21.241]             }
[09:28:21.241]             function(cond) {
[09:28:21.241]                 is_error <- inherits(cond, "error")
[09:28:21.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.241]                   NULL)
[09:28:21.241]                 if (is_error) {
[09:28:21.241]                   sessionInformation <- function() {
[09:28:21.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.241]                       search = base::search(), system = base::Sys.info())
[09:28:21.241]                   }
[09:28:21.241]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.241]                     cond$call), session = sessionInformation(), 
[09:28:21.241]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.241]                   signalCondition(cond)
[09:28:21.241]                 }
[09:28:21.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.241]                 "immediateCondition"))) {
[09:28:21.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.241]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.241]                   if (TRUE && !signal) {
[09:28:21.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.241]                     {
[09:28:21.241]                       inherits <- base::inherits
[09:28:21.241]                       invokeRestart <- base::invokeRestart
[09:28:21.241]                       is.null <- base::is.null
[09:28:21.241]                       muffled <- FALSE
[09:28:21.241]                       if (inherits(cond, "message")) {
[09:28:21.241]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.241]                         if (muffled) 
[09:28:21.241]                           invokeRestart("muffleMessage")
[09:28:21.241]                       }
[09:28:21.241]                       else if (inherits(cond, "warning")) {
[09:28:21.241]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.241]                         if (muffled) 
[09:28:21.241]                           invokeRestart("muffleWarning")
[09:28:21.241]                       }
[09:28:21.241]                       else if (inherits(cond, "condition")) {
[09:28:21.241]                         if (!is.null(pattern)) {
[09:28:21.241]                           computeRestarts <- base::computeRestarts
[09:28:21.241]                           grepl <- base::grepl
[09:28:21.241]                           restarts <- computeRestarts(cond)
[09:28:21.241]                           for (restart in restarts) {
[09:28:21.241]                             name <- restart$name
[09:28:21.241]                             if (is.null(name)) 
[09:28:21.241]                               next
[09:28:21.241]                             if (!grepl(pattern, name)) 
[09:28:21.241]                               next
[09:28:21.241]                             invokeRestart(restart)
[09:28:21.241]                             muffled <- TRUE
[09:28:21.241]                             break
[09:28:21.241]                           }
[09:28:21.241]                         }
[09:28:21.241]                       }
[09:28:21.241]                       invisible(muffled)
[09:28:21.241]                     }
[09:28:21.241]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.241]                   }
[09:28:21.241]                 }
[09:28:21.241]                 else {
[09:28:21.241]                   if (TRUE) {
[09:28:21.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.241]                     {
[09:28:21.241]                       inherits <- base::inherits
[09:28:21.241]                       invokeRestart <- base::invokeRestart
[09:28:21.241]                       is.null <- base::is.null
[09:28:21.241]                       muffled <- FALSE
[09:28:21.241]                       if (inherits(cond, "message")) {
[09:28:21.241]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.241]                         if (muffled) 
[09:28:21.241]                           invokeRestart("muffleMessage")
[09:28:21.241]                       }
[09:28:21.241]                       else if (inherits(cond, "warning")) {
[09:28:21.241]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.241]                         if (muffled) 
[09:28:21.241]                           invokeRestart("muffleWarning")
[09:28:21.241]                       }
[09:28:21.241]                       else if (inherits(cond, "condition")) {
[09:28:21.241]                         if (!is.null(pattern)) {
[09:28:21.241]                           computeRestarts <- base::computeRestarts
[09:28:21.241]                           grepl <- base::grepl
[09:28:21.241]                           restarts <- computeRestarts(cond)
[09:28:21.241]                           for (restart in restarts) {
[09:28:21.241]                             name <- restart$name
[09:28:21.241]                             if (is.null(name)) 
[09:28:21.241]                               next
[09:28:21.241]                             if (!grepl(pattern, name)) 
[09:28:21.241]                               next
[09:28:21.241]                             invokeRestart(restart)
[09:28:21.241]                             muffled <- TRUE
[09:28:21.241]                             break
[09:28:21.241]                           }
[09:28:21.241]                         }
[09:28:21.241]                       }
[09:28:21.241]                       invisible(muffled)
[09:28:21.241]                     }
[09:28:21.241]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.241]                   }
[09:28:21.241]                 }
[09:28:21.241]             }
[09:28:21.241]         }))
[09:28:21.241]     }, error = function(ex) {
[09:28:21.241]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.241]                 ...future.rng), started = ...future.startTime, 
[09:28:21.241]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.241]             version = "1.8"), class = "FutureResult")
[09:28:21.241]     }, finally = {
[09:28:21.241]         if (!identical(...future.workdir, getwd())) 
[09:28:21.241]             setwd(...future.workdir)
[09:28:21.241]         {
[09:28:21.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.241]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.241]             }
[09:28:21.241]             base::options(...future.oldOptions)
[09:28:21.241]             if (.Platform$OS.type == "windows") {
[09:28:21.241]                 old_names <- names(...future.oldEnvVars)
[09:28:21.241]                 envs <- base::Sys.getenv()
[09:28:21.241]                 names <- names(envs)
[09:28:21.241]                 common <- intersect(names, old_names)
[09:28:21.241]                 added <- setdiff(names, old_names)
[09:28:21.241]                 removed <- setdiff(old_names, names)
[09:28:21.241]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.241]                   envs[common]]
[09:28:21.241]                 NAMES <- toupper(changed)
[09:28:21.241]                 args <- list()
[09:28:21.241]                 for (kk in seq_along(NAMES)) {
[09:28:21.241]                   name <- changed[[kk]]
[09:28:21.241]                   NAME <- NAMES[[kk]]
[09:28:21.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.241]                     next
[09:28:21.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.241]                 }
[09:28:21.241]                 NAMES <- toupper(added)
[09:28:21.241]                 for (kk in seq_along(NAMES)) {
[09:28:21.241]                   name <- added[[kk]]
[09:28:21.241]                   NAME <- NAMES[[kk]]
[09:28:21.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.241]                     next
[09:28:21.241]                   args[[name]] <- ""
[09:28:21.241]                 }
[09:28:21.241]                 NAMES <- toupper(removed)
[09:28:21.241]                 for (kk in seq_along(NAMES)) {
[09:28:21.241]                   name <- removed[[kk]]
[09:28:21.241]                   NAME <- NAMES[[kk]]
[09:28:21.241]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.241]                     next
[09:28:21.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.241]                 }
[09:28:21.241]                 if (length(args) > 0) 
[09:28:21.241]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.241]             }
[09:28:21.241]             else {
[09:28:21.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.241]             }
[09:28:21.241]             {
[09:28:21.241]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.241]                   0L) {
[09:28:21.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.241]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.241]                   base::options(opts)
[09:28:21.241]                 }
[09:28:21.241]                 {
[09:28:21.241]                   {
[09:28:21.241]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.241]                     NULL
[09:28:21.241]                   }
[09:28:21.241]                   options(future.plan = NULL)
[09:28:21.241]                   if (is.na(NA_character_)) 
[09:28:21.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.241]                     .init = FALSE)
[09:28:21.241]                 }
[09:28:21.241]             }
[09:28:21.241]         }
[09:28:21.241]     })
[09:28:21.241]     if (TRUE) {
[09:28:21.241]         base::sink(type = "output", split = FALSE)
[09:28:21.241]         if (TRUE) {
[09:28:21.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.241]         }
[09:28:21.241]         else {
[09:28:21.241]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.241]         }
[09:28:21.241]         base::close(...future.stdout)
[09:28:21.241]         ...future.stdout <- NULL
[09:28:21.241]     }
[09:28:21.241]     ...future.result$conditions <- ...future.conditions
[09:28:21.241]     ...future.result$finished <- base::Sys.time()
[09:28:21.241]     ...future.result
[09:28:21.241] }
[09:28:21.245] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[09:28:21.245] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:21.248] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:21.248] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[09:28:21.248] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[09:28:21.249] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:28:21.249] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:28:21.249] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:21.249] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:21.249] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:21.250] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:21.250] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[09:28:21.250] MultisessionFuture started
[09:28:21.250] - Launch lazy future ... done
[09:28:21.250] run() for ‘MultisessionFuture’ ... done
[09:28:21.251] Created future:
[09:28:21.251] MultisessionFuture:
[09:28:21.251] Label: ‘future_apply-2’
[09:28:21.251] Expression:
[09:28:21.251] {
[09:28:21.251]     do.call(function(...) {
[09:28:21.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.251]             on.exit(options(oopts), add = TRUE)
[09:28:21.251]         }
[09:28:21.251]         {
[09:28:21.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.251]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.251]             })
[09:28:21.251]         }
[09:28:21.251]     }, args = future.call.arguments)
[09:28:21.251] }
[09:28:21.251] Lazy evaluation: FALSE
[09:28:21.251] Asynchronous evaluation: TRUE
[09:28:21.251] Local evaluation: TRUE
[09:28:21.251] Environment: R_GlobalEnv
[09:28:21.251] Capture standard output: TRUE
[09:28:21.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.251] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.251] Packages: <none>
[09:28:21.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.251] Resolved: FALSE
[09:28:21.251] Value: <not collected>
[09:28:21.251] Conditions captured: <none>
[09:28:21.251] Early signaling: FALSE
[09:28:21.251] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.251] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.262] Chunk #2 of 2 ... DONE
[09:28:21.262] Launching 2 futures (chunks) ... DONE
[09:28:21.262] Resolving 2 futures (chunks) ...
[09:28:21.263] resolve() on list ...
[09:28:21.263]  recursive: 0
[09:28:21.263]  length: 2
[09:28:21.263] 
[09:28:21.263] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.263] - Validating connection of MultisessionFuture
[09:28:21.264] - received message: FutureResult
[09:28:21.264] - Received FutureResult
[09:28:21.264] - Erased future from FutureRegistry
[09:28:21.264] result() for ClusterFuture ...
[09:28:21.264] - result already collected: FutureResult
[09:28:21.264] result() for ClusterFuture ... done
[09:28:21.264] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.264] Future #1
[09:28:21.264] result() for ClusterFuture ...
[09:28:21.265] - result already collected: FutureResult
[09:28:21.265] result() for ClusterFuture ... done
[09:28:21.265] result() for ClusterFuture ...
[09:28:21.265] - result already collected: FutureResult
[09:28:21.265] result() for ClusterFuture ... done
[09:28:21.265] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:21.265] - nx: 2
[09:28:21.265] - relay: TRUE
[09:28:21.265] - stdout: TRUE
[09:28:21.265] - signal: TRUE
[09:28:21.265] - resignal: FALSE
[09:28:21.265] - force: TRUE
[09:28:21.266] - relayed: [n=2] FALSE, FALSE
[09:28:21.266] - queued futures: [n=2] FALSE, FALSE
[09:28:21.266]  - until=1
[09:28:21.266]  - relaying element #1
[09:28:21.266] result() for ClusterFuture ...
[09:28:21.266] - result already collected: FutureResult
[09:28:21.266] result() for ClusterFuture ... done
[09:28:21.266] result() for ClusterFuture ...
[09:28:21.266] - result already collected: FutureResult
[09:28:21.266] result() for ClusterFuture ... done
[09:28:21.266] result() for ClusterFuture ...
[09:28:21.267] - result already collected: FutureResult
[09:28:21.267] result() for ClusterFuture ... done
[09:28:21.267] result() for ClusterFuture ...
[09:28:21.267] - result already collected: FutureResult
[09:28:21.267] result() for ClusterFuture ... done
[09:28:21.267] - relayed: [n=2] TRUE, FALSE
[09:28:21.267] - queued futures: [n=2] TRUE, FALSE
[09:28:21.267] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:21.267]  length: 1 (resolved future 1)
[09:28:21.293] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.293] - Validating connection of MultisessionFuture
[09:28:21.294] - received message: FutureResult
[09:28:21.294] - Received FutureResult
[09:28:21.294] - Erased future from FutureRegistry
[09:28:21.294] result() for ClusterFuture ...
[09:28:21.294] - result already collected: FutureResult
[09:28:21.294] result() for ClusterFuture ... done
[09:28:21.294] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.294] Future #2
[09:28:21.294] result() for ClusterFuture ...
[09:28:21.294] - result already collected: FutureResult
[09:28:21.294] result() for ClusterFuture ... done
[09:28:21.295] result() for ClusterFuture ...
[09:28:21.295] - result already collected: FutureResult
[09:28:21.295] result() for ClusterFuture ... done
[09:28:21.295] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:21.295] - nx: 2
[09:28:21.295] - relay: TRUE
[09:28:21.295] - stdout: TRUE
[09:28:21.295] - signal: TRUE
[09:28:21.295] - resignal: FALSE
[09:28:21.295] - force: TRUE
[09:28:21.295] - relayed: [n=2] TRUE, FALSE
[09:28:21.295] - queued futures: [n=2] TRUE, FALSE
[09:28:21.296]  - until=2
[09:28:21.296]  - relaying element #2
[09:28:21.296] result() for ClusterFuture ...
[09:28:21.296] - result already collected: FutureResult
[09:28:21.296] result() for ClusterFuture ... done
[09:28:21.296] result() for ClusterFuture ...
[09:28:21.296] - result already collected: FutureResult
[09:28:21.296] result() for ClusterFuture ... done
[09:28:21.296] result() for ClusterFuture ...
[09:28:21.296] - result already collected: FutureResult
[09:28:21.297] result() for ClusterFuture ... done
[09:28:21.297] result() for ClusterFuture ...
[09:28:21.297] - result already collected: FutureResult
[09:28:21.297] result() for ClusterFuture ... done
[09:28:21.297] - relayed: [n=2] TRUE, TRUE
[09:28:21.297] - queued futures: [n=2] TRUE, TRUE
[09:28:21.297] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:21.297]  length: 0 (resolved future 2)
[09:28:21.297] Relaying remaining futures
[09:28:21.297] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.297] - nx: 2
[09:28:21.298] - relay: TRUE
[09:28:21.298] - stdout: TRUE
[09:28:21.298] - signal: TRUE
[09:28:21.298] - resignal: FALSE
[09:28:21.298] - force: TRUE
[09:28:21.298] - relayed: [n=2] TRUE, TRUE
[09:28:21.298] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:21.298] - relayed: [n=2] TRUE, TRUE
[09:28:21.298] - queued futures: [n=2] TRUE, TRUE
[09:28:21.298] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.298] resolve() on list ... DONE
[09:28:21.298] result() for ClusterFuture ...
[09:28:21.299] - result already collected: FutureResult
[09:28:21.299] result() for ClusterFuture ... done
[09:28:21.299] result() for ClusterFuture ...
[09:28:21.299] - result already collected: FutureResult
[09:28:21.299] result() for ClusterFuture ... done
[09:28:21.299] result() for ClusterFuture ...
[09:28:21.299] - result already collected: FutureResult
[09:28:21.299] result() for ClusterFuture ... done
[09:28:21.299] result() for ClusterFuture ...
[09:28:21.299] - result already collected: FutureResult
[09:28:21.299] result() for ClusterFuture ... done
[09:28:21.300]  - Number of value chunks collected: 2
[09:28:21.300] Resolving 2 futures (chunks) ... DONE
[09:28:21.300] Reducing values from 2 chunks ...
[09:28:21.300]  - Number of values collected after concatenation: 2
[09:28:21.300]  - Number of values expected: 2
[09:28:21.300] Reducing values from 2 chunks ... DONE
[09:28:21.300] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[09:28:21.300] getGlobalsAndPackagesXApply() ...
[09:28:21.300]  - future.globals: TRUE
[09:28:21.301] getGlobalsAndPackages() ...
[09:28:21.301] Searching for globals...
[09:28:21.303] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[09:28:21.303] Searching for globals ... DONE
[09:28:21.304] Resolving globals: FALSE
[09:28:21.304] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[09:28:21.305] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[09:28:21.305] - globals: [1] ‘FUN’
[09:28:21.305] 
[09:28:21.305] getGlobalsAndPackages() ... DONE
[09:28:21.305]  - globals found/used: [n=1] ‘FUN’
[09:28:21.305]  - needed namespaces: [n=0] 
[09:28:21.305] Finding globals ... DONE
[09:28:21.305]  - use_args: TRUE
[09:28:21.305]  - Getting '...' globals ...
[09:28:21.306] resolve() on list ...
[09:28:21.306]  recursive: 0
[09:28:21.306]  length: 1
[09:28:21.306]  elements: ‘...’
[09:28:21.306]  length: 0 (resolved future 1)
[09:28:21.306] resolve() on list ... DONE
[09:28:21.306]    - '...' content: [n=0] 
[09:28:21.306] List of 1
[09:28:21.306]  $ ...: list()
[09:28:21.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.306]  - attr(*, "where")=List of 1
[09:28:21.306]   ..$ ...:<environment: 0x559ba26bb0b8> 
[09:28:21.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.306]  - attr(*, "resolved")= logi TRUE
[09:28:21.306]  - attr(*, "total_size")= num NA
[09:28:21.309]  - Getting '...' globals ... DONE
[09:28:21.309] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:21.309] List of 2
[09:28:21.309]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:21.309]  $ ...          : list()
[09:28:21.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.309]  - attr(*, "where")=List of 2
[09:28:21.309]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:21.309]   ..$ ...          :<environment: 0x559ba26bb0b8> 
[09:28:21.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.309]  - attr(*, "resolved")= logi FALSE
[09:28:21.309]  - attr(*, "total_size")= num 36296
[09:28:21.312] Packages to be attached in all futures: [n=0] 
[09:28:21.312] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.315] future_lapply() ...
[09:28:21.317] Generating random seeds ...
[09:28:21.317] Generating random seed streams for 2 elements ...
[09:28:21.317] Generating random seed streams for 2 elements ... DONE
[09:28:21.318] Generating random seeds ... DONE
[09:28:21.318] Will set RNG state on exit: 10407, 749497079, -1406431271, 1452057781, -932324082, 468635508, -74358506
[09:28:21.321] Number of chunks: 2
[09:28:21.321] getGlobalsAndPackagesXApply() ...
[09:28:21.321]  - future.globals: <name-value list> with names ‘list()’
[09:28:21.321]  - use_args: TRUE
[09:28:21.322] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[09:28:21.322] List of 2
[09:28:21.322]  $ ...          : list()
[09:28:21.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.322]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[09:28:21.322]  - attr(*, "where")=List of 2
[09:28:21.322]   ..$ ...          :<environment: 0x559ba26bb0b8> 
[09:28:21.322]   ..$ ...future.FUN:<environment: namespace:base> 
[09:28:21.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.322]  - attr(*, "resolved")= logi FALSE
[09:28:21.322]  - attr(*, "total_size")= num NA
[09:28:21.325] Packages to be attached in all futures: [n=0] 
[09:28:21.325] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.325] Number of futures (= number of chunks): 2
[09:28:21.325] Launching 2 futures (chunks) ...
[09:28:21.325] Chunk #1 of 2 ...
[09:28:21.326]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.326]  - seeds: [1] <seeds>
[09:28:21.326]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.326] getGlobalsAndPackages() ...
[09:28:21.326] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.326] Resolving globals: FALSE
[09:28:21.326] Tweak future expression to call with '...' arguments ...
[09:28:21.326] {
[09:28:21.326]     do.call(function(...) {
[09:28:21.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.326]             on.exit(options(oopts), add = TRUE)
[09:28:21.326]         }
[09:28:21.326]         {
[09:28:21.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.326]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.326]                   envir = globalenv(), inherits = FALSE)
[09:28:21.326]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.326]             })
[09:28:21.326]         }
[09:28:21.326]     }, args = future.call.arguments)
[09:28:21.326] }
[09:28:21.327] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.327] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.327] 
[09:28:21.327] getGlobalsAndPackages() ... DONE
[09:28:21.327] run() for ‘Future’ ...
[09:28:21.327] - state: ‘created’
[09:28:21.328] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.341]   - Field: ‘node’
[09:28:21.341]   - Field: ‘label’
[09:28:21.341]   - Field: ‘local’
[09:28:21.341]   - Field: ‘owner’
[09:28:21.342]   - Field: ‘envir’
[09:28:21.342]   - Field: ‘workers’
[09:28:21.342]   - Field: ‘packages’
[09:28:21.342]   - Field: ‘gc’
[09:28:21.342]   - Field: ‘conditions’
[09:28:21.342]   - Field: ‘persistent’
[09:28:21.342]   - Field: ‘expr’
[09:28:21.342]   - Field: ‘uuid’
[09:28:21.342]   - Field: ‘seed’
[09:28:21.342]   - Field: ‘version’
[09:28:21.342]   - Field: ‘result’
[09:28:21.342]   - Field: ‘asynchronous’
[09:28:21.343]   - Field: ‘calls’
[09:28:21.343]   - Field: ‘globals’
[09:28:21.343]   - Field: ‘stdout’
[09:28:21.343]   - Field: ‘earlySignal’
[09:28:21.343]   - Field: ‘lazy’
[09:28:21.343]   - Field: ‘state’
[09:28:21.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.343] - Launch lazy future ...
[09:28:21.343] Packages needed by the future expression (n = 0): <none>
[09:28:21.344] Packages needed by future strategies (n = 0): <none>
[09:28:21.344] {
[09:28:21.344]     {
[09:28:21.344]         {
[09:28:21.344]             ...future.startTime <- base::Sys.time()
[09:28:21.344]             {
[09:28:21.344]                 {
[09:28:21.344]                   {
[09:28:21.344]                     {
[09:28:21.344]                       base::local({
[09:28:21.344]                         has_future <- base::requireNamespace("future", 
[09:28:21.344]                           quietly = TRUE)
[09:28:21.344]                         if (has_future) {
[09:28:21.344]                           ns <- base::getNamespace("future")
[09:28:21.344]                           version <- ns[[".package"]][["version"]]
[09:28:21.344]                           if (is.null(version)) 
[09:28:21.344]                             version <- utils::packageVersion("future")
[09:28:21.344]                         }
[09:28:21.344]                         else {
[09:28:21.344]                           version <- NULL
[09:28:21.344]                         }
[09:28:21.344]                         if (!has_future || version < "1.8.0") {
[09:28:21.344]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.344]                             "", base::R.version$version.string), 
[09:28:21.344]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.344]                               "release", "version")], collapse = " "), 
[09:28:21.344]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.344]                             info)
[09:28:21.344]                           info <- base::paste(info, collapse = "; ")
[09:28:21.344]                           if (!has_future) {
[09:28:21.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.344]                               info)
[09:28:21.344]                           }
[09:28:21.344]                           else {
[09:28:21.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.344]                               info, version)
[09:28:21.344]                           }
[09:28:21.344]                           base::stop(msg)
[09:28:21.344]                         }
[09:28:21.344]                       })
[09:28:21.344]                     }
[09:28:21.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.344]                     base::options(mc.cores = 1L)
[09:28:21.344]                   }
[09:28:21.344]                   ...future.strategy.old <- future::plan("list")
[09:28:21.344]                   options(future.plan = NULL)
[09:28:21.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.344]                 }
[09:28:21.344]                 ...future.workdir <- getwd()
[09:28:21.344]             }
[09:28:21.344]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.344]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.344]         }
[09:28:21.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.344]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.344]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.344]             base::names(...future.oldOptions))
[09:28:21.344]     }
[09:28:21.344]     if (FALSE) {
[09:28:21.344]     }
[09:28:21.344]     else {
[09:28:21.344]         if (TRUE) {
[09:28:21.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.344]                 open = "w")
[09:28:21.344]         }
[09:28:21.344]         else {
[09:28:21.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.344]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.344]         }
[09:28:21.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.344]             base::sink(type = "output", split = FALSE)
[09:28:21.344]             base::close(...future.stdout)
[09:28:21.344]         }, add = TRUE)
[09:28:21.344]     }
[09:28:21.344]     ...future.frame <- base::sys.nframe()
[09:28:21.344]     ...future.conditions <- base::list()
[09:28:21.344]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.344]     if (FALSE) {
[09:28:21.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.344]     }
[09:28:21.344]     ...future.result <- base::tryCatch({
[09:28:21.344]         base::withCallingHandlers({
[09:28:21.344]             ...future.value <- base::withVisible(base::local({
[09:28:21.344]                 ...future.makeSendCondition <- base::local({
[09:28:21.344]                   sendCondition <- NULL
[09:28:21.344]                   function(frame = 1L) {
[09:28:21.344]                     if (is.function(sendCondition)) 
[09:28:21.344]                       return(sendCondition)
[09:28:21.344]                     ns <- getNamespace("parallel")
[09:28:21.344]                     if (exists("sendData", mode = "function", 
[09:28:21.344]                       envir = ns)) {
[09:28:21.344]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.344]                         envir = ns)
[09:28:21.344]                       envir <- sys.frame(frame)
[09:28:21.344]                       master <- NULL
[09:28:21.344]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.344]                         !identical(envir, emptyenv())) {
[09:28:21.344]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.344]                           inherits = FALSE)) {
[09:28:21.344]                           master <- get("master", mode = "list", 
[09:28:21.344]                             envir = envir, inherits = FALSE)
[09:28:21.344]                           if (inherits(master, c("SOCKnode", 
[09:28:21.344]                             "SOCK0node"))) {
[09:28:21.344]                             sendCondition <<- function(cond) {
[09:28:21.344]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.344]                                 success = TRUE)
[09:28:21.344]                               parallel_sendData(master, data)
[09:28:21.344]                             }
[09:28:21.344]                             return(sendCondition)
[09:28:21.344]                           }
[09:28:21.344]                         }
[09:28:21.344]                         frame <- frame + 1L
[09:28:21.344]                         envir <- sys.frame(frame)
[09:28:21.344]                       }
[09:28:21.344]                     }
[09:28:21.344]                     sendCondition <<- function(cond) NULL
[09:28:21.344]                   }
[09:28:21.344]                 })
[09:28:21.344]                 withCallingHandlers({
[09:28:21.344]                   {
[09:28:21.344]                     do.call(function(...) {
[09:28:21.344]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.344]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.344]                         ...future.globals.maxSize)) {
[09:28:21.344]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.344]                         on.exit(options(oopts), add = TRUE)
[09:28:21.344]                       }
[09:28:21.344]                       {
[09:28:21.344]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.344]                           FUN = function(jj) {
[09:28:21.344]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.344]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.344]                               envir = globalenv(), inherits = FALSE)
[09:28:21.344]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.344]                           })
[09:28:21.344]                       }
[09:28:21.344]                     }, args = future.call.arguments)
[09:28:21.344]                   }
[09:28:21.344]                 }, immediateCondition = function(cond) {
[09:28:21.344]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.344]                   sendCondition(cond)
[09:28:21.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.344]                   {
[09:28:21.344]                     inherits <- base::inherits
[09:28:21.344]                     invokeRestart <- base::invokeRestart
[09:28:21.344]                     is.null <- base::is.null
[09:28:21.344]                     muffled <- FALSE
[09:28:21.344]                     if (inherits(cond, "message")) {
[09:28:21.344]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.344]                       if (muffled) 
[09:28:21.344]                         invokeRestart("muffleMessage")
[09:28:21.344]                     }
[09:28:21.344]                     else if (inherits(cond, "warning")) {
[09:28:21.344]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.344]                       if (muffled) 
[09:28:21.344]                         invokeRestart("muffleWarning")
[09:28:21.344]                     }
[09:28:21.344]                     else if (inherits(cond, "condition")) {
[09:28:21.344]                       if (!is.null(pattern)) {
[09:28:21.344]                         computeRestarts <- base::computeRestarts
[09:28:21.344]                         grepl <- base::grepl
[09:28:21.344]                         restarts <- computeRestarts(cond)
[09:28:21.344]                         for (restart in restarts) {
[09:28:21.344]                           name <- restart$name
[09:28:21.344]                           if (is.null(name)) 
[09:28:21.344]                             next
[09:28:21.344]                           if (!grepl(pattern, name)) 
[09:28:21.344]                             next
[09:28:21.344]                           invokeRestart(restart)
[09:28:21.344]                           muffled <- TRUE
[09:28:21.344]                           break
[09:28:21.344]                         }
[09:28:21.344]                       }
[09:28:21.344]                     }
[09:28:21.344]                     invisible(muffled)
[09:28:21.344]                   }
[09:28:21.344]                   muffleCondition(cond)
[09:28:21.344]                 })
[09:28:21.344]             }))
[09:28:21.344]             future::FutureResult(value = ...future.value$value, 
[09:28:21.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.344]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.344]                     ...future.globalenv.names))
[09:28:21.344]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.344]         }, condition = base::local({
[09:28:21.344]             c <- base::c
[09:28:21.344]             inherits <- base::inherits
[09:28:21.344]             invokeRestart <- base::invokeRestart
[09:28:21.344]             length <- base::length
[09:28:21.344]             list <- base::list
[09:28:21.344]             seq.int <- base::seq.int
[09:28:21.344]             signalCondition <- base::signalCondition
[09:28:21.344]             sys.calls <- base::sys.calls
[09:28:21.344]             `[[` <- base::`[[`
[09:28:21.344]             `+` <- base::`+`
[09:28:21.344]             `<<-` <- base::`<<-`
[09:28:21.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.344]                   3L)]
[09:28:21.344]             }
[09:28:21.344]             function(cond) {
[09:28:21.344]                 is_error <- inherits(cond, "error")
[09:28:21.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.344]                   NULL)
[09:28:21.344]                 if (is_error) {
[09:28:21.344]                   sessionInformation <- function() {
[09:28:21.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.344]                       search = base::search(), system = base::Sys.info())
[09:28:21.344]                   }
[09:28:21.344]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.344]                     cond$call), session = sessionInformation(), 
[09:28:21.344]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.344]                   signalCondition(cond)
[09:28:21.344]                 }
[09:28:21.344]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[09:28:21.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.344]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.344]                   if (TRUE && !signal) {
[09:28:21.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.344]                     {
[09:28:21.344]                       inherits <- base::inherits
[09:28:21.344]                       invokeRestart <- base::invokeRestart
[09:28:21.344]                       is.null <- base::is.null
[09:28:21.344]                       muffled <- FALSE
[09:28:21.344]                       if (inherits(cond, "message")) {
[09:28:21.344]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.344]                         if (muffled) 
[09:28:21.344]                           invokeRestart("muffleMessage")
[09:28:21.344]                       }
[09:28:21.344]                       else if (inherits(cond, "warning")) {
[09:28:21.344]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.344]                         if (muffled) 
[09:28:21.344]                           invokeRestart("muffleWarning")
[09:28:21.344]                       }
[09:28:21.344]                       else if (inherits(cond, "condition")) {
[09:28:21.344]                         if (!is.null(pattern)) {
[09:28:21.344]                           computeRestarts <- base::computeRestarts
[09:28:21.344]                           grepl <- base::grepl
[09:28:21.344]                           restarts <- computeRestarts(cond)
[09:28:21.344]                           for (restart in restarts) {
[09:28:21.344]                             name <- restart$name
[09:28:21.344]                             if (is.null(name)) 
[09:28:21.344]                               next
[09:28:21.344]                             if (!grepl(pattern, name)) 
[09:28:21.344]                               next
[09:28:21.344]                             invokeRestart(restart)
[09:28:21.344]                             muffled <- TRUE
[09:28:21.344]                             break
[09:28:21.344]                           }
[09:28:21.344]                         }
[09:28:21.344]                       }
[09:28:21.344]                       invisible(muffled)
[09:28:21.344]                     }
[09:28:21.344]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.344]                   }
[09:28:21.344]                 }
[09:28:21.344]                 else {
[09:28:21.344]                   if (TRUE) {
[09:28:21.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.344]                     {
[09:28:21.344]                       inherits <- base::inherits
[09:28:21.344]                       invokeRestart <- base::invokeRestart
[09:28:21.344]                       is.null <- base::is.null
[09:28:21.344]                       muffled <- FALSE
[09:28:21.344]                       if (inherits(cond, "message")) {
[09:28:21.344]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.344]                         if (muffled) 
[09:28:21.344]                           invokeRestart("muffleMessage")
[09:28:21.344]                       }
[09:28:21.344]                       else if (inherits(cond, "warning")) {
[09:28:21.344]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.344]                         if (muffled) 
[09:28:21.344]                           invokeRestart("muffleWarning")
[09:28:21.344]                       }
[09:28:21.344]                       else if (inherits(cond, "condition")) {
[09:28:21.344]                         if (!is.null(pattern)) {
[09:28:21.344]                           computeRestarts <- base::computeRestarts
[09:28:21.344]                           grepl <- base::grepl
[09:28:21.344]                           restarts <- computeRestarts(cond)
[09:28:21.344]                           for (restart in restarts) {
[09:28:21.344]                             name <- restart$name
[09:28:21.344]                             if (is.null(name)) 
[09:28:21.344]                               next
[09:28:21.344]                             if (!grepl(pattern, name)) 
[09:28:21.344]                               next
[09:28:21.344]                             invokeRestart(restart)
[09:28:21.344]                             muffled <- TRUE
[09:28:21.344]                             break
[09:28:21.344]                           }
[09:28:21.344]                         }
[09:28:21.344]                       }
[09:28:21.344]                       invisible(muffled)
[09:28:21.344]                     }
[09:28:21.344]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.344]                   }
[09:28:21.344]                 }
[09:28:21.344]             }
[09:28:21.344]         }))
[09:28:21.344]     }, error = function(ex) {
[09:28:21.344]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.344]                 ...future.rng), started = ...future.startTime, 
[09:28:21.344]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.344]             version = "1.8"), class = "FutureResult")
[09:28:21.344]     }, finally = {
[09:28:21.344]         if (!identical(...future.workdir, getwd())) 
[09:28:21.344]             setwd(...future.workdir)
[09:28:21.344]         {
[09:28:21.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.344]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.344]             }
[09:28:21.344]             base::options(...future.oldOptions)
[09:28:21.344]             if (.Platform$OS.type == "windows") {
[09:28:21.344]                 old_names <- names(...future.oldEnvVars)
[09:28:21.344]                 envs <- base::Sys.getenv()
[09:28:21.344]                 names <- names(envs)
[09:28:21.344]                 common <- intersect(names, old_names)
[09:28:21.344]                 added <- setdiff(names, old_names)
[09:28:21.344]                 removed <- setdiff(old_names, names)
[09:28:21.344]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.344]                   envs[common]]
[09:28:21.344]                 NAMES <- toupper(changed)
[09:28:21.344]                 args <- list()
[09:28:21.344]                 for (kk in seq_along(NAMES)) {
[09:28:21.344]                   name <- changed[[kk]]
[09:28:21.344]                   NAME <- NAMES[[kk]]
[09:28:21.344]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.344]                     next
[09:28:21.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.344]                 }
[09:28:21.344]                 NAMES <- toupper(added)
[09:28:21.344]                 for (kk in seq_along(NAMES)) {
[09:28:21.344]                   name <- added[[kk]]
[09:28:21.344]                   NAME <- NAMES[[kk]]
[09:28:21.344]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.344]                     next
[09:28:21.344]                   args[[name]] <- ""
[09:28:21.344]                 }
[09:28:21.344]                 NAMES <- toupper(removed)
[09:28:21.344]                 for (kk in seq_along(NAMES)) {
[09:28:21.344]                   name <- removed[[kk]]
[09:28:21.344]                   NAME <- NAMES[[kk]]
[09:28:21.344]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.344]                     next
[09:28:21.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.344]                 }
[09:28:21.344]                 if (length(args) > 0) 
[09:28:21.344]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.344]             }
[09:28:21.344]             else {
[09:28:21.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.344]             }
[09:28:21.344]             {
[09:28:21.344]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.344]                   0L) {
[09:28:21.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.344]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.344]                   base::options(opts)
[09:28:21.344]                 }
[09:28:21.344]                 {
[09:28:21.344]                   {
[09:28:21.344]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.344]                     NULL
[09:28:21.344]                   }
[09:28:21.344]                   options(future.plan = NULL)
[09:28:21.344]                   if (is.na(NA_character_)) 
[09:28:21.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.344]                     .init = FALSE)
[09:28:21.344]                 }
[09:28:21.344]             }
[09:28:21.344]         }
[09:28:21.344]     })
[09:28:21.344]     if (TRUE) {
[09:28:21.344]         base::sink(type = "output", split = FALSE)
[09:28:21.344]         if (TRUE) {
[09:28:21.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.344]         }
[09:28:21.344]         else {
[09:28:21.344]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.344]         }
[09:28:21.344]         base::close(...future.stdout)
[09:28:21.344]         ...future.stdout <- NULL
[09:28:21.344]     }
[09:28:21.344]     ...future.result$conditions <- ...future.conditions
[09:28:21.344]     ...future.result$finished <- base::Sys.time()
[09:28:21.344]     ...future.result
[09:28:21.344] }
[09:28:21.347] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[09:28:21.347] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:21.348] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:21.348] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[09:28:21.392] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[09:28:21.392] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:28:21.393] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:28:21.393] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[09:28:21.393] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[09:28:21.393] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[09:28:21.394] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[09:28:21.394] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[09:28:21.394] MultisessionFuture started
[09:28:21.395] - Launch lazy future ... done
[09:28:21.395] run() for ‘MultisessionFuture’ ... done
[09:28:21.395] Created future:
[09:28:21.395] MultisessionFuture:
[09:28:21.395] Label: ‘future_apply-1’
[09:28:21.395] Expression:
[09:28:21.395] {
[09:28:21.395]     do.call(function(...) {
[09:28:21.395]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.395]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.395]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.395]             on.exit(options(oopts), add = TRUE)
[09:28:21.395]         }
[09:28:21.395]         {
[09:28:21.395]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.395]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.395]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.395]                   envir = globalenv(), inherits = FALSE)
[09:28:21.395]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.395]             })
[09:28:21.395]         }
[09:28:21.395]     }, args = future.call.arguments)
[09:28:21.395] }
[09:28:21.395] Lazy evaluation: FALSE
[09:28:21.395] Asynchronous evaluation: TRUE
[09:28:21.395] Local evaluation: TRUE
[09:28:21.395] Environment: R_GlobalEnv
[09:28:21.395] Capture standard output: TRUE
[09:28:21.395] Capture condition classes: <none>
[09:28:21.395] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.395] Packages: <none>
[09:28:21.395] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:28:21.395] Resolved: FALSE
[09:28:21.395] Value: <not collected>
[09:28:21.395] Conditions captured: <none>
[09:28:21.395] Early signaling: FALSE
[09:28:21.395] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.395] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.406] Chunk #1 of 2 ... DONE
[09:28:21.406] Chunk #2 of 2 ...
[09:28:21.407]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[09:28:21.407]  - seeds: [1] <seeds>
[09:28:21.407]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.407] getGlobalsAndPackages() ...
[09:28:21.407] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.407] Resolving globals: FALSE
[09:28:21.407] Tweak future expression to call with '...' arguments ...
[09:28:21.408] {
[09:28:21.408]     do.call(function(...) {
[09:28:21.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.408]             on.exit(options(oopts), add = TRUE)
[09:28:21.408]         }
[09:28:21.408]         {
[09:28:21.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.408]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.408]                   envir = globalenv(), inherits = FALSE)
[09:28:21.408]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.408]             })
[09:28:21.408]         }
[09:28:21.408]     }, args = future.call.arguments)
[09:28:21.408] }
[09:28:21.408] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.408] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.408] 
[09:28:21.408] getGlobalsAndPackages() ... DONE
[09:28:21.409] run() for ‘Future’ ...
[09:28:21.409] - state: ‘created’
[09:28:21.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:21.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:21.422]   - Field: ‘node’
[09:28:21.422]   - Field: ‘label’
[09:28:21.422]   - Field: ‘local’
[09:28:21.423]   - Field: ‘owner’
[09:28:21.423]   - Field: ‘envir’
[09:28:21.423]   - Field: ‘workers’
[09:28:21.423]   - Field: ‘packages’
[09:28:21.423]   - Field: ‘gc’
[09:28:21.423]   - Field: ‘conditions’
[09:28:21.423]   - Field: ‘persistent’
[09:28:21.423]   - Field: ‘expr’
[09:28:21.423]   - Field: ‘uuid’
[09:28:21.423]   - Field: ‘seed’
[09:28:21.423]   - Field: ‘version’
[09:28:21.424]   - Field: ‘result’
[09:28:21.424]   - Field: ‘asynchronous’
[09:28:21.424]   - Field: ‘calls’
[09:28:21.424]   - Field: ‘globals’
[09:28:21.424]   - Field: ‘stdout’
[09:28:21.424]   - Field: ‘earlySignal’
[09:28:21.424]   - Field: ‘lazy’
[09:28:21.424]   - Field: ‘state’
[09:28:21.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:21.424] - Launch lazy future ...
[09:28:21.425] Packages needed by the future expression (n = 0): <none>
[09:28:21.425] Packages needed by future strategies (n = 0): <none>
[09:28:21.425] {
[09:28:21.425]     {
[09:28:21.425]         {
[09:28:21.425]             ...future.startTime <- base::Sys.time()
[09:28:21.425]             {
[09:28:21.425]                 {
[09:28:21.425]                   {
[09:28:21.425]                     {
[09:28:21.425]                       base::local({
[09:28:21.425]                         has_future <- base::requireNamespace("future", 
[09:28:21.425]                           quietly = TRUE)
[09:28:21.425]                         if (has_future) {
[09:28:21.425]                           ns <- base::getNamespace("future")
[09:28:21.425]                           version <- ns[[".package"]][["version"]]
[09:28:21.425]                           if (is.null(version)) 
[09:28:21.425]                             version <- utils::packageVersion("future")
[09:28:21.425]                         }
[09:28:21.425]                         else {
[09:28:21.425]                           version <- NULL
[09:28:21.425]                         }
[09:28:21.425]                         if (!has_future || version < "1.8.0") {
[09:28:21.425]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.425]                             "", base::R.version$version.string), 
[09:28:21.425]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:21.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.425]                               "release", "version")], collapse = " "), 
[09:28:21.425]                             hostname = base::Sys.info()[["nodename"]])
[09:28:21.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.425]                             info)
[09:28:21.425]                           info <- base::paste(info, collapse = "; ")
[09:28:21.425]                           if (!has_future) {
[09:28:21.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.425]                               info)
[09:28:21.425]                           }
[09:28:21.425]                           else {
[09:28:21.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.425]                               info, version)
[09:28:21.425]                           }
[09:28:21.425]                           base::stop(msg)
[09:28:21.425]                         }
[09:28:21.425]                       })
[09:28:21.425]                     }
[09:28:21.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:21.425]                     base::options(mc.cores = 1L)
[09:28:21.425]                   }
[09:28:21.425]                   ...future.strategy.old <- future::plan("list")
[09:28:21.425]                   options(future.plan = NULL)
[09:28:21.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.425]                 }
[09:28:21.425]                 ...future.workdir <- getwd()
[09:28:21.425]             }
[09:28:21.425]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.425]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.425]         }
[09:28:21.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.425]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[09:28:21.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.425]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.425]             base::names(...future.oldOptions))
[09:28:21.425]     }
[09:28:21.425]     if (FALSE) {
[09:28:21.425]     }
[09:28:21.425]     else {
[09:28:21.425]         if (TRUE) {
[09:28:21.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.425]                 open = "w")
[09:28:21.425]         }
[09:28:21.425]         else {
[09:28:21.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.425]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.425]         }
[09:28:21.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.425]             base::sink(type = "output", split = FALSE)
[09:28:21.425]             base::close(...future.stdout)
[09:28:21.425]         }, add = TRUE)
[09:28:21.425]     }
[09:28:21.425]     ...future.frame <- base::sys.nframe()
[09:28:21.425]     ...future.conditions <- base::list()
[09:28:21.425]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.425]     if (FALSE) {
[09:28:21.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.425]     }
[09:28:21.425]     ...future.result <- base::tryCatch({
[09:28:21.425]         base::withCallingHandlers({
[09:28:21.425]             ...future.value <- base::withVisible(base::local({
[09:28:21.425]                 ...future.makeSendCondition <- base::local({
[09:28:21.425]                   sendCondition <- NULL
[09:28:21.425]                   function(frame = 1L) {
[09:28:21.425]                     if (is.function(sendCondition)) 
[09:28:21.425]                       return(sendCondition)
[09:28:21.425]                     ns <- getNamespace("parallel")
[09:28:21.425]                     if (exists("sendData", mode = "function", 
[09:28:21.425]                       envir = ns)) {
[09:28:21.425]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:21.425]                         envir = ns)
[09:28:21.425]                       envir <- sys.frame(frame)
[09:28:21.425]                       master <- NULL
[09:28:21.425]                       while (!identical(envir, .GlobalEnv) && 
[09:28:21.425]                         !identical(envir, emptyenv())) {
[09:28:21.425]                         if (exists("master", mode = "list", envir = envir, 
[09:28:21.425]                           inherits = FALSE)) {
[09:28:21.425]                           master <- get("master", mode = "list", 
[09:28:21.425]                             envir = envir, inherits = FALSE)
[09:28:21.425]                           if (inherits(master, c("SOCKnode", 
[09:28:21.425]                             "SOCK0node"))) {
[09:28:21.425]                             sendCondition <<- function(cond) {
[09:28:21.425]                               data <- list(type = "VALUE", value = cond, 
[09:28:21.425]                                 success = TRUE)
[09:28:21.425]                               parallel_sendData(master, data)
[09:28:21.425]                             }
[09:28:21.425]                             return(sendCondition)
[09:28:21.425]                           }
[09:28:21.425]                         }
[09:28:21.425]                         frame <- frame + 1L
[09:28:21.425]                         envir <- sys.frame(frame)
[09:28:21.425]                       }
[09:28:21.425]                     }
[09:28:21.425]                     sendCondition <<- function(cond) NULL
[09:28:21.425]                   }
[09:28:21.425]                 })
[09:28:21.425]                 withCallingHandlers({
[09:28:21.425]                   {
[09:28:21.425]                     do.call(function(...) {
[09:28:21.425]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.425]                       if (!identical(...future.globals.maxSize.org, 
[09:28:21.425]                         ...future.globals.maxSize)) {
[09:28:21.425]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.425]                         on.exit(options(oopts), add = TRUE)
[09:28:21.425]                       }
[09:28:21.425]                       {
[09:28:21.425]                         lapply(seq_along(...future.elements_ii), 
[09:28:21.425]                           FUN = function(jj) {
[09:28:21.425]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.425]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.425]                               envir = globalenv(), inherits = FALSE)
[09:28:21.425]                             ...future.FUN(...future.X_jj, ...)
[09:28:21.425]                           })
[09:28:21.425]                       }
[09:28:21.425]                     }, args = future.call.arguments)
[09:28:21.425]                   }
[09:28:21.425]                 }, immediateCondition = function(cond) {
[09:28:21.425]                   sendCondition <- ...future.makeSendCondition()
[09:28:21.425]                   sendCondition(cond)
[09:28:21.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.425]                   {
[09:28:21.425]                     inherits <- base::inherits
[09:28:21.425]                     invokeRestart <- base::invokeRestart
[09:28:21.425]                     is.null <- base::is.null
[09:28:21.425]                     muffled <- FALSE
[09:28:21.425]                     if (inherits(cond, "message")) {
[09:28:21.425]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:21.425]                       if (muffled) 
[09:28:21.425]                         invokeRestart("muffleMessage")
[09:28:21.425]                     }
[09:28:21.425]                     else if (inherits(cond, "warning")) {
[09:28:21.425]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:21.425]                       if (muffled) 
[09:28:21.425]                         invokeRestart("muffleWarning")
[09:28:21.425]                     }
[09:28:21.425]                     else if (inherits(cond, "condition")) {
[09:28:21.425]                       if (!is.null(pattern)) {
[09:28:21.425]                         computeRestarts <- base::computeRestarts
[09:28:21.425]                         grepl <- base::grepl
[09:28:21.425]                         restarts <- computeRestarts(cond)
[09:28:21.425]                         for (restart in restarts) {
[09:28:21.425]                           name <- restart$name
[09:28:21.425]                           if (is.null(name)) 
[09:28:21.425]                             next
[09:28:21.425]                           if (!grepl(pattern, name)) 
[09:28:21.425]                             next
[09:28:21.425]                           invokeRestart(restart)
[09:28:21.425]                           muffled <- TRUE
[09:28:21.425]                           break
[09:28:21.425]                         }
[09:28:21.425]                       }
[09:28:21.425]                     }
[09:28:21.425]                     invisible(muffled)
[09:28:21.425]                   }
[09:28:21.425]                   muffleCondition(cond)
[09:28:21.425]                 })
[09:28:21.425]             }))
[09:28:21.425]             future::FutureResult(value = ...future.value$value, 
[09:28:21.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.425]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.425]                     ...future.globalenv.names))
[09:28:21.425]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.425]         }, condition = base::local({
[09:28:21.425]             c <- base::c
[09:28:21.425]             inherits <- base::inherits
[09:28:21.425]             invokeRestart <- base::invokeRestart
[09:28:21.425]             length <- base::length
[09:28:21.425]             list <- base::list
[09:28:21.425]             seq.int <- base::seq.int
[09:28:21.425]             signalCondition <- base::signalCondition
[09:28:21.425]             sys.calls <- base::sys.calls
[09:28:21.425]             `[[` <- base::`[[`
[09:28:21.425]             `+` <- base::`+`
[09:28:21.425]             `<<-` <- base::`<<-`
[09:28:21.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.425]                   3L)]
[09:28:21.425]             }
[09:28:21.425]             function(cond) {
[09:28:21.425]                 is_error <- inherits(cond, "error")
[09:28:21.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.425]                   NULL)
[09:28:21.425]                 if (is_error) {
[09:28:21.425]                   sessionInformation <- function() {
[09:28:21.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.425]                       search = base::search(), system = base::Sys.info())
[09:28:21.425]                   }
[09:28:21.425]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.425]                     cond$call), session = sessionInformation(), 
[09:28:21.425]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.425]                   signalCondition(cond)
[09:28:21.425]                 }
[09:28:21.425]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[09:28:21.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.425]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.425]                   if (TRUE && !signal) {
[09:28:21.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.425]                     {
[09:28:21.425]                       inherits <- base::inherits
[09:28:21.425]                       invokeRestart <- base::invokeRestart
[09:28:21.425]                       is.null <- base::is.null
[09:28:21.425]                       muffled <- FALSE
[09:28:21.425]                       if (inherits(cond, "message")) {
[09:28:21.425]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.425]                         if (muffled) 
[09:28:21.425]                           invokeRestart("muffleMessage")
[09:28:21.425]                       }
[09:28:21.425]                       else if (inherits(cond, "warning")) {
[09:28:21.425]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.425]                         if (muffled) 
[09:28:21.425]                           invokeRestart("muffleWarning")
[09:28:21.425]                       }
[09:28:21.425]                       else if (inherits(cond, "condition")) {
[09:28:21.425]                         if (!is.null(pattern)) {
[09:28:21.425]                           computeRestarts <- base::computeRestarts
[09:28:21.425]                           grepl <- base::grepl
[09:28:21.425]                           restarts <- computeRestarts(cond)
[09:28:21.425]                           for (restart in restarts) {
[09:28:21.425]                             name <- restart$name
[09:28:21.425]                             if (is.null(name)) 
[09:28:21.425]                               next
[09:28:21.425]                             if (!grepl(pattern, name)) 
[09:28:21.425]                               next
[09:28:21.425]                             invokeRestart(restart)
[09:28:21.425]                             muffled <- TRUE
[09:28:21.425]                             break
[09:28:21.425]                           }
[09:28:21.425]                         }
[09:28:21.425]                       }
[09:28:21.425]                       invisible(muffled)
[09:28:21.425]                     }
[09:28:21.425]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.425]                   }
[09:28:21.425]                 }
[09:28:21.425]                 else {
[09:28:21.425]                   if (TRUE) {
[09:28:21.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.425]                     {
[09:28:21.425]                       inherits <- base::inherits
[09:28:21.425]                       invokeRestart <- base::invokeRestart
[09:28:21.425]                       is.null <- base::is.null
[09:28:21.425]                       muffled <- FALSE
[09:28:21.425]                       if (inherits(cond, "message")) {
[09:28:21.425]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.425]                         if (muffled) 
[09:28:21.425]                           invokeRestart("muffleMessage")
[09:28:21.425]                       }
[09:28:21.425]                       else if (inherits(cond, "warning")) {
[09:28:21.425]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.425]                         if (muffled) 
[09:28:21.425]                           invokeRestart("muffleWarning")
[09:28:21.425]                       }
[09:28:21.425]                       else if (inherits(cond, "condition")) {
[09:28:21.425]                         if (!is.null(pattern)) {
[09:28:21.425]                           computeRestarts <- base::computeRestarts
[09:28:21.425]                           grepl <- base::grepl
[09:28:21.425]                           restarts <- computeRestarts(cond)
[09:28:21.425]                           for (restart in restarts) {
[09:28:21.425]                             name <- restart$name
[09:28:21.425]                             if (is.null(name)) 
[09:28:21.425]                               next
[09:28:21.425]                             if (!grepl(pattern, name)) 
[09:28:21.425]                               next
[09:28:21.425]                             invokeRestart(restart)
[09:28:21.425]                             muffled <- TRUE
[09:28:21.425]                             break
[09:28:21.425]                           }
[09:28:21.425]                         }
[09:28:21.425]                       }
[09:28:21.425]                       invisible(muffled)
[09:28:21.425]                     }
[09:28:21.425]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.425]                   }
[09:28:21.425]                 }
[09:28:21.425]             }
[09:28:21.425]         }))
[09:28:21.425]     }, error = function(ex) {
[09:28:21.425]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.425]                 ...future.rng), started = ...future.startTime, 
[09:28:21.425]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.425]             version = "1.8"), class = "FutureResult")
[09:28:21.425]     }, finally = {
[09:28:21.425]         if (!identical(...future.workdir, getwd())) 
[09:28:21.425]             setwd(...future.workdir)
[09:28:21.425]         {
[09:28:21.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.425]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.425]             }
[09:28:21.425]             base::options(...future.oldOptions)
[09:28:21.425]             if (.Platform$OS.type == "windows") {
[09:28:21.425]                 old_names <- names(...future.oldEnvVars)
[09:28:21.425]                 envs <- base::Sys.getenv()
[09:28:21.425]                 names <- names(envs)
[09:28:21.425]                 common <- intersect(names, old_names)
[09:28:21.425]                 added <- setdiff(names, old_names)
[09:28:21.425]                 removed <- setdiff(old_names, names)
[09:28:21.425]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.425]                   envs[common]]
[09:28:21.425]                 NAMES <- toupper(changed)
[09:28:21.425]                 args <- list()
[09:28:21.425]                 for (kk in seq_along(NAMES)) {
[09:28:21.425]                   name <- changed[[kk]]
[09:28:21.425]                   NAME <- NAMES[[kk]]
[09:28:21.425]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.425]                     next
[09:28:21.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.425]                 }
[09:28:21.425]                 NAMES <- toupper(added)
[09:28:21.425]                 for (kk in seq_along(NAMES)) {
[09:28:21.425]                   name <- added[[kk]]
[09:28:21.425]                   NAME <- NAMES[[kk]]
[09:28:21.425]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.425]                     next
[09:28:21.425]                   args[[name]] <- ""
[09:28:21.425]                 }
[09:28:21.425]                 NAMES <- toupper(removed)
[09:28:21.425]                 for (kk in seq_along(NAMES)) {
[09:28:21.425]                   name <- removed[[kk]]
[09:28:21.425]                   NAME <- NAMES[[kk]]
[09:28:21.425]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.425]                     next
[09:28:21.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.425]                 }
[09:28:21.425]                 if (length(args) > 0) 
[09:28:21.425]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.425]             }
[09:28:21.425]             else {
[09:28:21.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.425]             }
[09:28:21.425]             {
[09:28:21.425]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.425]                   0L) {
[09:28:21.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.425]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.425]                   base::options(opts)
[09:28:21.425]                 }
[09:28:21.425]                 {
[09:28:21.425]                   {
[09:28:21.425]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:21.425]                     NULL
[09:28:21.425]                   }
[09:28:21.425]                   options(future.plan = NULL)
[09:28:21.425]                   if (is.na(NA_character_)) 
[09:28:21.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.425]                     .init = FALSE)
[09:28:21.425]                 }
[09:28:21.425]             }
[09:28:21.425]         }
[09:28:21.425]     })
[09:28:21.425]     if (TRUE) {
[09:28:21.425]         base::sink(type = "output", split = FALSE)
[09:28:21.425]         if (TRUE) {
[09:28:21.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.425]         }
[09:28:21.425]         else {
[09:28:21.425]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.425]         }
[09:28:21.425]         base::close(...future.stdout)
[09:28:21.425]         ...future.stdout <- NULL
[09:28:21.425]     }
[09:28:21.425]     ...future.result$conditions <- ...future.conditions
[09:28:21.425]     ...future.result$finished <- base::Sys.time()
[09:28:21.425]     ...future.result
[09:28:21.425] }
[09:28:21.428] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[09:28:21.428] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:21.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:21.429] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[09:28:21.472] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[09:28:21.472] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[09:28:21.473] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[09:28:21.473] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[09:28:21.473] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[09:28:21.473] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[09:28:21.474] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[09:28:21.474] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[09:28:21.474] MultisessionFuture started
[09:28:21.474] - Launch lazy future ... done
[09:28:21.474] run() for ‘MultisessionFuture’ ... done
[09:28:21.474] Created future:
[09:28:21.475] MultisessionFuture:
[09:28:21.475] Label: ‘future_apply-2’
[09:28:21.475] Expression:
[09:28:21.475] {
[09:28:21.475]     do.call(function(...) {
[09:28:21.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.475]             on.exit(options(oopts), add = TRUE)
[09:28:21.475]         }
[09:28:21.475]         {
[09:28:21.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.475]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[09:28:21.475]                   envir = globalenv(), inherits = FALSE)
[09:28:21.475]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.475]             })
[09:28:21.475]         }
[09:28:21.475]     }, args = future.call.arguments)
[09:28:21.475] }
[09:28:21.475] Lazy evaluation: FALSE
[09:28:21.475] Asynchronous evaluation: TRUE
[09:28:21.475] Local evaluation: TRUE
[09:28:21.475] Environment: R_GlobalEnv
[09:28:21.475] Capture standard output: TRUE
[09:28:21.475] Capture condition classes: <none>
[09:28:21.475] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[09:28:21.475] Packages: <none>
[09:28:21.475] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[09:28:21.475] Resolved: FALSE
[09:28:21.475] Value: <not collected>
[09:28:21.475] Conditions captured: <none>
[09:28:21.475] Early signaling: FALSE
[09:28:21.475] Owner process: 0ccf861a-ab27-5bbc-e736-86fb831d4f7b
[09:28:21.475] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:21.486] Chunk #2 of 2 ... DONE
[09:28:21.486] Launching 2 futures (chunks) ... DONE
[09:28:21.486] Resolving 2 futures (chunks) ...
[09:28:21.486] resolve() on list ...
[09:28:21.486]  recursive: 0
[09:28:21.487]  length: 2
[09:28:21.487] 
[09:28:21.487] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.487] - Validating connection of MultisessionFuture
[09:28:21.487] - received message: FutureResult
[09:28:21.487] - Received FutureResult
[09:28:21.488] - Erased future from FutureRegistry
[09:28:21.488] result() for ClusterFuture ...
[09:28:21.488] - result already collected: FutureResult
[09:28:21.488] result() for ClusterFuture ... done
[09:28:21.488] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.488] Future #1
[09:28:21.488] result() for ClusterFuture ...
[09:28:21.488] - result already collected: FutureResult
[09:28:21.488] result() for ClusterFuture ... done
[09:28:21.488] result() for ClusterFuture ...
[09:28:21.488] - result already collected: FutureResult
[09:28:21.489] result() for ClusterFuture ... done
[09:28:21.489] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:21.489] - nx: 2
[09:28:21.489] - relay: TRUE
[09:28:21.489] - stdout: TRUE
[09:28:21.489] - signal: TRUE
[09:28:21.489] - resignal: FALSE
[09:28:21.489] - force: TRUE
[09:28:21.489] - relayed: [n=2] FALSE, FALSE
[09:28:21.489] - queued futures: [n=2] FALSE, FALSE
[09:28:21.489]  - until=1
[09:28:21.489]  - relaying element #1
[09:28:21.490] result() for ClusterFuture ...
[09:28:21.490] - result already collected: FutureResult
[09:28:21.490] result() for ClusterFuture ... done
[09:28:21.490] result() for ClusterFuture ...
[09:28:21.490] - result already collected: FutureResult
[09:28:21.490] result() for ClusterFuture ... done
[09:28:21.490] result() for ClusterFuture ...
[09:28:21.490] - result already collected: FutureResult
[09:28:21.490] result() for ClusterFuture ... done
[09:28:21.490] result() for ClusterFuture ...
[09:28:21.490] - result already collected: FutureResult
[09:28:21.491] result() for ClusterFuture ... done
[09:28:21.491] - relayed: [n=2] TRUE, FALSE
[09:28:21.491] - queued futures: [n=2] TRUE, FALSE
[09:28:21.491] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:21.491]  length: 1 (resolved future 1)
[09:28:21.517] receiveMessageFromWorker() for ClusterFuture ...
[09:28:21.517] - Validating connection of MultisessionFuture
[09:28:21.518] - received message: FutureResult
[09:28:21.518] - Received FutureResult
[09:28:21.518] - Erased future from FutureRegistry
[09:28:21.518] result() for ClusterFuture ...
[09:28:21.518] - result already collected: FutureResult
[09:28:21.518] result() for ClusterFuture ... done
[09:28:21.518] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:21.518] Future #2
[09:28:21.518] result() for ClusterFuture ...
[09:28:21.518] - result already collected: FutureResult
[09:28:21.519] result() for ClusterFuture ... done
[09:28:21.519] result() for ClusterFuture ...
[09:28:21.519] - result already collected: FutureResult
[09:28:21.519] result() for ClusterFuture ... done
[09:28:21.519] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:21.519] - nx: 2
[09:28:21.519] - relay: TRUE
[09:28:21.519] - stdout: TRUE
[09:28:21.519] - signal: TRUE
[09:28:21.520] - resignal: FALSE
[09:28:21.520] - force: TRUE
[09:28:21.520] - relayed: [n=2] TRUE, FALSE
[09:28:21.520] - queued futures: [n=2] TRUE, FALSE
[09:28:21.520]  - until=2
[09:28:21.520]  - relaying element #2
[09:28:21.520] result() for ClusterFuture ...
[09:28:21.520] - result already collected: FutureResult
[09:28:21.520] result() for ClusterFuture ... done
[09:28:21.521] result() for ClusterFuture ...
[09:28:21.521] - result already collected: FutureResult
[09:28:21.521] result() for ClusterFuture ... done
[09:28:21.521] result() for ClusterFuture ...
[09:28:21.521] - result already collected: FutureResult
[09:28:21.521] result() for ClusterFuture ... done
[09:28:21.522] result() for ClusterFuture ...
[09:28:21.522] - result already collected: FutureResult
[09:28:21.522] result() for ClusterFuture ... done
[09:28:21.522] - relayed: [n=2] TRUE, TRUE
[09:28:21.522] - queued futures: [n=2] TRUE, TRUE
[09:28:21.522] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:21.522]  length: 0 (resolved future 2)
[09:28:21.522] Relaying remaining futures
[09:28:21.523] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.523] - nx: 2
[09:28:21.523] - relay: TRUE
[09:28:21.523] - stdout: TRUE
[09:28:21.523] - signal: TRUE
[09:28:21.523] - resignal: FALSE
[09:28:21.523] - force: TRUE
[09:28:21.524] - relayed: [n=2] TRUE, TRUE
[09:28:21.524] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:21.524] - relayed: [n=2] TRUE, TRUE
[09:28:21.528] - queued futures: [n=2] TRUE, TRUE
[09:28:21.528] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.528] resolve() on list ... DONE
[09:28:21.528] result() for ClusterFuture ...
[09:28:21.529] - result already collected: FutureResult
[09:28:21.529] result() for ClusterFuture ... done
[09:28:21.529] result() for ClusterFuture ...
[09:28:21.529] - result already collected: FutureResult
[09:28:21.529] result() for ClusterFuture ... done
[09:28:21.529] result() for ClusterFuture ...
[09:28:21.529] - result already collected: FutureResult
[09:28:21.530] result() for ClusterFuture ... done
[09:28:21.530] result() for ClusterFuture ...
[09:28:21.530] - result already collected: FutureResult
[09:28:21.530] result() for ClusterFuture ... done
[09:28:21.530]  - Number of value chunks collected: 2
[09:28:21.530] Resolving 2 futures (chunks) ... DONE
[09:28:21.530] Reducing values from 2 chunks ...
[09:28:21.530]  - Number of values collected after concatenation: 2
[09:28:21.531]  - Number of values expected: 2
[09:28:21.531] Reducing values from 2 chunks ... DONE
[09:28:21.531] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[09:28:21.531] plan(): Setting new future strategy stack:
[09:28:21.531] List of future strategies:
[09:28:21.531] 1. sequential:
[09:28:21.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.531]    - tweaked: FALSE
[09:28:21.531]    - call: plan(sequential)
[09:28:21.533] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[09:28:21.535] plan(): Setting new future strategy stack:
[09:28:21.535] List of future strategies:
[09:28:21.535] 1. FutureStrategy:
[09:28:21.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.535]    - tweaked: FALSE
[09:28:21.535]    - call: future::plan(oplan)
[09:28:21.536] plan(): nbrOfWorkers() = 1
> 
