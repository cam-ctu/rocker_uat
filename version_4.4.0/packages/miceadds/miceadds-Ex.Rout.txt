
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "miceadds"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('miceadds')
Loading required package: mice

Attaching package: ‘mice’

The following object is masked from ‘package:stats’:

    filter

The following objects are masked from ‘package:base’:

    cbind, rbind

* miceadds 3.17-44 (2024-01-08 19:08:24)
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("GroupMean")
> ### * GroupMean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GroupMean
> ### Title: Calculation of Groupwise Descriptive Statistics for Matrices
> ### Aliases: GroupMean GroupSum GroupSD gm cwc
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 1: Group means and standard deviations for data.ma02
> ##D #############################################################################
> ##D 
> ##D data(data.ma02, package="miceadds" )
> ##D dat <- data.ma02[[1]] # select first dataset
> ##D 
> ##D #--- group means for read and math
> ##D GroupMean( dat[, c("read","math") ], group=dat$idschool )
> ##D # using rowsum
> ##D a1 <- base::rowsum( dat[, c("read","math") ], dat$idschool )
> ##D a2 <- base::rowsum( 1+0*dat[, c("read","math") ], dat$idschool )
> ##D (a1/a2)[1:10,]
> ##D # using aggregate
> ##D stats::aggregate(  dat[, c("read","math") ], list(dat$idschool), mean )[1:10,]
> ##D 
> ##D #--- extend group means to original dataset
> ##D GroupMean( dat[, c("read","math") ], group=dat$idschool, extend=TRUE )
> ##D # using ave
> ##D stats::ave( dat[, "read" ], dat$idschool  )
> ##D stats::ave( dat[, "read" ], dat$idschool, FUN=mean )
> ##D 
> ##D #--- group standard deviations
> ##D GroupSD( dat[, c("read","math") ], group=dat$idschool)[1:10,]
> ##D # using aggregate
> ##D stats::aggregate(  dat[, c("read","math") ], list(dat$idschool), sd )[1:10,]
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Calculating group means and group mean centering
> ##D #############################################################################
> ##D 
> ##D data(data.ma07, package="miceadds")
> ##D dat <- data.ma07
> ##D 
> ##D # compute group means
> ##D miceadds::gm( dat$x1, dat$id2 )
> ##D # centering within clusters
> ##D miceadds::cwc( dat$x1, dat$id2 )
> ##D 
> ##D # evaluate formula with model.matrix
> ##D X <- model.matrix( ~ I( miceadds::cwc(x1, id2) ) + I( miceadds::gm(x1,id2) ), data=dat )
> ##D head(X)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("NMIwaldtest")
> ### * NMIwaldtest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NMIwaldtest
> ### Title: Wald Test for Nested Multiply Imputed Datasets
> ### Aliases: NMIwaldtest create.designMatrices.waldtest summary.NMIwaldtest
> ###   MIwaldtest summary.MIwaldtest
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nested multiple imputation and Wald test | TIMSS data
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D }
> ##D 
> ##D #***************
> ##D # (1) nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
> ##D summary(imp1)
> ##D 
> ##D #**** Model 1: Linear regression with interaction effects
> ##D res1 <- with( imp1, stats::lm( likesc ~ female*migrant + female*books  ) )
> ##D pres1 <- miceadds::pool.mids.nmi( res1 )
> ##D summary(pres1)
> ##D 
> ##D # test whether both interaction effects equals zero
> ##D pars <- dimnames(pres1$qhat)[[3]]
> ##D des <- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
> ##D Cdes <- des$Cdes
> ##D rdes <- des$rdes
> ##D Cdes[1, "female:migrant"] <- 1
> ##D Cdes[2, "female:books"] <- 1
> ##D wres1 <- miceadds::NMIwaldtest( qhat=pres1$qhat, u=pres1$u, Cdes=Cdes, rdes=rdes )
> ##D summary(wres1)
> ##D 
> ##D # a simpler specification is the use of "testnull"
> ##D testnull <- c("female:migrant", "female:books")
> ##D wres1b <- miceadds::NMIwaldtest( qhat=qhat, u=u, testnull=testnull )
> ##D summary(wres1b)
> ##D 
> ##D #**** Model 2: Multivariate linear regression
> ##D res2 <- with( imp1, stats::lm( cbind( ASMMAT, ASSSCI ) ~
> ##D                            0 + I(1*(female==1)) + I(1*(female==0))   ) )
> ##D pres2 <- miceadds::pool.mids.nmi( res2 )
> ##D summary(pres2)
> ##D 
> ##D # test whether both gender differences equals -10 points
> ##D pars <- dimnames(pres2$qhat)[[3]]
> ##D   ##  > pars
> ##D   ##  [1] "ASMMAT:I(1 * (female==1))" "ASMMAT:I(1 * (female==0))"
> ##D   ##  [3] "ASSSCI:I(1 * (female==1))" "ASSSCI:I(1 * (female==0))"
> ##D 
> ##D des <- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
> ##D Cdes <- des$Cdes
> ##D rdes <- c(-10,-10)
> ##D Cdes[1, "ASMMAT:I(1*(female==1))"] <- 1
> ##D Cdes[1, "ASMMAT:I(1*(female==0))"] <- -1
> ##D Cdes[2, "ASSSCI:I(1*(female==1))"] <- 1
> ##D Cdes[2, "ASSSCI:I(1*(female==0))"] <- -1
> ##D 
> ##D wres2 <- miceadds::NMIwaldtest( qhat=pres2$qhat, u=pres2$u, Cdes=Cdes, rdes=rdes )
> ##D summary(wres2)
> ##D 
> ##D # test only first hypothesis
> ##D wres2b <- miceadds::NMIwaldtest( qhat=pres2$qhat, u=pres2$u, Cdes=Cdes[1,,drop=FALSE],
> ##D                          rdes=rdes[1] )
> ##D summary(wres2b)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Multiple imputation and Wald test | TIMSS data
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D dat <- data.timss2[[1]]
> ##D dat <- dat[, - c(1:4) ]
> ##D 
> ##D # perform multiple imputation
> ##D imp <- mice::mice( dat, m=6, maxit=3 )
> ##D 
> ##D # define analysis model
> ##D res1 <- with( imp, lm( likesc ~ female*migrant + female*books  ) )
> ##D pres1 <- mice::pool( res1 )
> ##D summary(pres1)
> ##D 
> ##D # Wald test for zero interaction effects
> ##D qhat <- mitools::MIextract(res1$analyses, fun=coef)
> ##D u <- mitools::MIextract(res1$analyses, fun=vcov)
> ##D pars <- names(qhat[[1]])
> ##D des <- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
> ##D Cdes <- des$Cdes
> ##D rdes <- des$rdes
> ##D Cdes[1, "female:migrant"] <- 1
> ##D Cdes[2, "female:books"] <- 1
> ##D 
> ##D # apply MIwaldtest function
> ##D wres1 <- miceadds::MIwaldtest( qhat, u, Cdes, rdes )
> ##D summary(wres1)
> ##D 
> ##D # use again "testnull"
> ##D testnull <- c("female:migrant", "female:books")
> ##D wres1b <- miceadds::MIwaldtest( qhat=qhat, u=u, testnull=testnull )
> ##D summary(wres1b)
> ##D 
> ##D #***** linear regression with cluster robust standard errors
> ##D 
> ##D # convert object of class mids into a list object
> ##D datlist_imp <- miceadds::mids2datlist( imp )
> ##D # define cluster
> ##D idschool <- as.numeric( substring( data.timss2[[1]]$IDSTUD, 1, 5 ) )
> ##D # linear regression
> ##D res2 <- lapply( datlist_imp, FUN=function(data){
> ##D            miceadds::lm.cluster( data=data, formula=likesc ~ female*migrant + female*books,
> ##D                             cluster=idschool ) } )
> ##D # extract parameters and covariance matrix
> ##D qhat <- lapply( res2, FUN=function(rr){ coef(rr) } )
> ##D u <- lapply( res2, FUN=function(rr){ vcov(rr) } )
> ##D # perform Wald test
> ##D wres2 <- miceadds::MIwaldtest( qhat, u, Cdes, rdes )
> ##D summary(wres2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("NestedImputationList")
> ### * NestedImputationList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NestedImputationList
> ### Title: Functions for Analysis of Nested Multiply Imputed Datasets
> ### Aliases: NestedImputationList MIcombine.NestedImputationResultList
> ###   print.NestedImputationList
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nested multiple imputation and conversion into an object of class
> ##D #            NestedImputationList
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D 
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D                 }
> ##D 
> ##D # nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
> ##D summary(imp1)
> ##D 
> ##D # create object of class NestedImputationList
> ##D datlist1 <- miceadds::mids2datlist( imp1 )
> ##D datlist1 <- miceadds::NestedImputationList( datlist1 )
> ##D 
> ##D # estimate linear model using with
> ##D res1 <- with( datlist1, stats::lm( ASMMAT ~ female + migrant ) )
> ##D # pool results
> ##D mres1 <- mitools::MIcombine( res1 )
> ##D summary(mres1)
> ##D coef(mres1)
> ##D vcov(mres1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Reval")
> ### * Reval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Reval
> ### Title: R Utilities: Evaluates a String as an Expression in R
> ### Aliases: Reval Revalpr Revalprstr Revalpr_round Revalpr_maxabs
> 
> ### ** Examples
> 
> # This function is simply a shortage function
> # See the definition of this function:
> Reval <- function( Rstring, print.string=TRUE){
+     if (print.string){ cat( paste( Rstring ), "\n"  ) }
+         eval.parent( parse( text=paste( Rstring )), n=1 )
+             }
> 
> Reval( "a <- 2^3" )
a <- 2^3 
>   ## a <- 2^3
> a
[1] 8
>   ## [1] 8
> 
> 
> 
> cleanEx()
> nameEx("Rfunction_include_argument_values")
> ### * Rfunction_include_argument_values
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rfunction_include_argument_values
> ### Title: Utility Functions for Writing R Functions
> ### Aliases: Rfunction_include_argument_values
> ###   Rfunction_output_list_result_function Rfunction
> ###   Rcppfunction_remove_classes Rcppfunction
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Toy examples
> #############################################################################
> 
> ##**** extend missing arguments
> 
> string <- "
+           mice.impute.2l.pls2(y, ry, x, type, pls.facs=pls.facs  ))
+           "
> cat( miceadds::Rfunction_include_argument_values(string) )

         mice.impute.2l.pls2( y=y, ry=ry, x=x, type=type, pls.facs=pls.facs) ) 
>   ##    mice.impute.2l.pls2( y=y, ry=ry, x=x, type=type, pls.facs=pls.facs )
> 
> ##**** assignment to objects as entries in a list
> 
> string <- "
+           list( vname=vname, p, type=type, data=data, levels_id )
+           "
> cat( miceadds::Rfunction_output_list_result_function( string ) )

vname <- res$vname
p <- res$p
type <- res$type
data <- res$data
levels_id <- res$levels_id
>   ##
>   ##  vname <- res$vname
>   ##  p <- res$p
>   ##  type <- res$type
>   ##  data <- res$data
>   ##  levels_id <- res$levels_id
> 
> 
> string <- "
+ arma::colvec miceadds_rcpp_rtnorm2( arma::colvec mu,
+             double sigma0, arma::colvec lower, arma::colvec upper,
+             double minval, double maxval)
+     "
> 
> cat( miceadds::Rcppfunction_remove_classes(string, maxlen=70) )
miceadds_rcpp_rtnorm2( mu, sigma0, lower, upper, minval, maxval )
> cat( miceadds::Rcppfunction_remove_classes(string, maxlen=70, remove=FALSE) )
arma::colvec miceadds_rcpp_rtnorm2( arma::colvec mu, double sigma0, 
arma::colvec lower, arma::colvec upper, double minval, double maxval )
> 
> 
> 
> cleanEx()
> nameEx("Rhat.mice")
> ### * Rhat.mice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rhat.mice
> ### Title: Rhat Convergence Statistic of a 'mice' Imputation
> ### Aliases: Rhat.mice
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Rhat statistic for nhanes data
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes 3 parallel chains
> ##D imp1 <- mice::mice( nhanes, m=3, maxit=10, method=rep("norm", 4 ))
> ##D miceadds::Rhat.mice( imp1 )
> ##D   ##     variable MissProp Rhat.M.imp Rhat.Var.imp
> ##D   ##   1      bmi       36  1.0181998     1.155807
> ##D   ##   2      hyp       32  1.0717677     1.061174
> ##D   ##   3      chl       40  0.9717109     1.318721
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Rsessinfo")
> ### * Rsessinfo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rsessinfo
> ### Title: R Utilities: R Session Information
> ### Aliases: Rsessinfo
> 
> ### ** Examples
> 
> Rsessinfo()
[1] "R version 4.4.0 (2024-04-24) x86_64, linux-gnu | nodename=3fe59e189152 | login=unknown"
>   ##   > miceadds::Rsessinfo()
>   ##   [1] "R version 2.15.2 (2012-10-26) x86_64, mingw32 | nodename=SD70 | login=robitzsch"
> 
> 
> 
> cleanEx()
> nameEx("VariableNames2String")
> ### * VariableNames2String
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: VariableNames2String
> ### Title: Stringing Variable Names with Line Breaks
> ### Aliases: VariableNames2String
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Toy example
> #############################################################################
> 
> data(data.ma01)
> # extract variable names
> vars <- colnames(data.ma01)
> # convert into a long string with line breaks at column 25
> vars2 <- miceadds::VariableNames2String(vars, breaks=25)
> vars
 [1] "idstud"   "idschool" "studwgt"  "math"     "read"     "migrant" 
 [7] "books"    "hisei"    "paredu"   "female"   "urban"   
>   ##   [1] "idstud"   "idschool" "studwgt"  "math"     "read"     "migrant"
>   ##   [7] "books"    "hisei"    "paredu"   "female"   "urban"
> vars2
[1] "idstud idschool studwgt \nmath read migrant books \nhisei paredu female \nurban "
>   ##  idstud idschool studwgt
>   ##  math read migrant books
>   ##  hisei paredu female
>   ##  urban
> 
> 
> 
> cleanEx()
> nameEx("complete.miceadds")
> ### * complete.miceadds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complete.miceadds
> ### Title: Creates Imputed Dataset from a 'mids.nmi' or 'mids.1chain'
> ###   Object
> ### Aliases: complete.mids.nmi complete.mids.1chain
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nested multiple imputation and dataset extraction for TIMSS data
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D 
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D }
> ##D 
> ##D #***************
> ##D # (1) nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
> ##D summary(imp1)
> ##D 
> ##D #***************
> ##D # (2) nested multiple imputation using mice.1chain
> ##D imp2 <- miceadds::mice.nmi( datlist, Nimp=4, burnin=10,iter=22, type="mice.1chain")
> ##D summary(imp2)
> ##D 
> ##D #**************
> ##D # extract dataset for third orginal dataset the second within imputation
> ##D dat32a <- miceadds::complete.mids.nmi( imp1, action=c(3,2) )
> ##D dat32b <- miceadds::complete.mids.nmi( imp2, action=c(3,2) )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Imputation from one chain and extracting dataset for nhanes data
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D 
> ##D # nhanes data in one chain
> ##D imp1 <- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4,
> ##D             method=rep("norm", 4 ) )
> ##D 
> ##D # extract first imputed dataset
> ##D dati1 <- miceadds::complete.mids.1chain( imp1, action=1 )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("crlrem")
> ### * crlrem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crlrem
> ### Title: R Utilities: Removing CF Line Endings
> ### Aliases: crlrem
> 
> ### ** Examples
> 
> ## Not run: 
> ##D filename1 <- "rm.arraymult__0.02.cpp"
> ##D filename2 <- "rm.arraymult__0.03.cpp"
> ##D crlrem( filename1, filename2 )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cxxfunction.copy")
> ### * cxxfunction.copy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cxxfunction.copy
> ### Title: R Utilities: Copy of an 'Rcpp' File
> ### Aliases: cxxfunction.copy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Rcpp code logistic distribution
> ##D #############################################################################
> ##D 
> ##D library(Rcpp)
> ##D library(inline)
> ##D 
> ##D # define Rcpp file
> ##D code1 <- "
> ##D     // input array A
> ##D     Rcpp::NumericMatrix AA(A);
> ##D     // Rcpp::IntegerVector dimAA(dimA);
> ##D     int nrows=AA.nrow();
> ##D     int ncolumns=AA.ncol();
> ##D     Rcpp::NumericMatrix Alogis(nrows,ncolumns)  ;
> ##D     // compute logistic distribution
> ##D     for (int ii=0; ii<nrows; ii++){
> ##D         Rcpp::NumericVector h1=AA.row(ii) ;
> ##D         Rcpp::NumericVector res=plogis( h1 ) ;
> ##D         for (int jj=0;jj<ncolumns;jj++){
> ##D             Alogis(ii,jj)=res[jj] ;
> ##D                         }
> ##D                     }
> ##D     return( wrap(Alogis) );
> ##D     "
> ##D # compile Rcpp code
> ##D fct_rcpp <- inline::cxxfunction( signature( A="matrix"), code1,
> ##D               plugin="Rcpp", verbose=TRUE )
> ##D # copy function and save it as object 'calclogis'
> ##D name <- "calclogis"  # name of the function
> ##D cxxfunction.copy( cppfct=fct_rcpp, name=name )
> ##D # function is available as object named as name
> ##D Reval( paste0( name, " <- fct_rcpp " ) )
> ##D # test function
> ##D m1 <- outer( seq( -2, 2, len=10 ), seq(-1.5,1.5,len=4) )
> ##D calclogis(m1)
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("data.allison")
> ### * data.allison
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.allison
> ### Title: Datasets from Allison's _Missing Data_ Book
> ### Aliases: data.allison data.allison.gssexp data.allison.hip
> ###   data.allison.usnews
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Hip dataset | Imputation using a wide format
> ##D #############################################################################
> ##D 
> ##D # at first, the hip dataset is 'melted' for imputation
> ##D 
> ##D data(data.allison.hip)
> ##D   ##   head(data.allison.hip)
> ##D   ##     SID WAVE ADL PAIN SRH WALK   CESD
> ##D   ##   1   1    1   3    0   2    1  9.000
> ##D   ##   2   1    2   2    5   4    0 28.000
> ##D   ##   3   1    3   3    0   2    0 31.000
> ##D   ##   4   1    4   3    0   2    0 11.579
> ##D   ##   5   2    1   3    0   4    0     NA
> ##D   ##   6   2    2   1    1   1    0  2.222
> ##D 
> ##D library(reshape)
> ##D hip.wide <- reshape::reshape(data.allison.hip, idvar="SID", timevar="WAVE",
> ##D                 direction="wide")
> ##D   ##   > head(hip.wide, 2)
> ##D   ##     SID ADL.1 PAIN.1 SRH.1 WALK.1 CESD.1 ADL.2 PAIN.2 SRH.2 WALK.2 CESD.2 ADL.3
> ##D   ##   1   1     3      0     2      1      9     2      5     4      0 28.000     3
> ##D   ##   5   2     3      0     4      0     NA     1      1     1      0  2.222     2
> ##D   ##     PAIN.3 SRH.3 WALK.3 CESD.3 ADL.4 PAIN.4 SRH.4 WALK.4 CESD.4
> ##D   ##   1      0     2      0     31     3      0     2      0 11.579
> ##D   ##   5      5     1      0     12     1     NA     2      0     NA
> ##D 
> ##D # imputation of the hip wide dataset
> ##D imp <- mice::mice( as.matrix( hip.wide[,-1] ), m=5, maxit=3 )
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("data.graham")
> ### * data.graham
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.graham
> ### Title: Datasets from Grahams _Missing Data_ Book
> ### Aliases: data.graham data.graham.ex3 data.graham.ex6 data.graham.ex8a
> ###   data.graham.ex8b data.graham.ex8c
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(mitools)
> ##D library(mice)
> ##D library(Amelia)
> ##D library(jomo)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 1: data.graham.8a | Imputation under multivariate normal model
> ##D #############################################################################
> ##D 
> ##D data(data.graham.ex8a)
> ##D dat <- data.graham.ex8a
> ##D dat <- dat[,1:10]
> ##D vars <- colnames(dat)
> ##D V <- length(vars)
> ##D # remove persons with completely missing data
> ##D dat <- dat[ rowMeans( is.na(dat) ) < 1, ]
> ##D summary(dat)
> ##D 
> ##D # some descriptive statistics
> ##D psych::describe(dat)
> ##D 
> ##D #**************
> ##D # imputation under a multivariate normal model
> ##D M <- 7  # number of imputations
> ##D 
> ##D #--------- mice package
> ##D # define imputation method
> ##D impM <- rep("norm", V)
> ##D names(impM) <- vars
> ##D # mice imputation
> ##D imp1a <- mice::mice( dat, method=impM, m=M, maxit=4 )
> ##D summary(imp1a)
> ##D # convert into a list of datasets
> ##D datlist1a <- miceadds::mids2datlist(imp1a)
> ##D 
> ##D #--------- Amelia package
> ##D imp1b <- Amelia::amelia( dat, m=M )
> ##D summary(imp1b)
> ##D datlist1b <- imp1b$imputations
> ##D 
> ##D #--------- jomo package
> ##D imp1c <- jomo::jomo1con(Y=dat, nburn=100, nbetween=10, nimp=M)
> ##D str(imp1c)
> ##D # convert into a list of datasets
> ##D datlist1c <- miceadds::jomo2datlist(imp1c)
> ##D 
> ##D # alternatively one can use the jomo wrapper function
> ##D imp1c1 <- jomo::jomo(Y=dat, nburn=100, nbetween=10, nimp=M)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: data.graham.8b | Imputation with categorical variables
> ##D #############################################################################
> ##D 
> ##D data(data.graham.ex8b)
> ##D dat <- data.graham.ex8b
> ##D vars <- colnames(dat)
> ##D V <- length(vars)
> ##D 
> ##D # descriptive statistics
> ##D psych::describe(dat)
> ##D 
> ##D #*******************************
> ##D # imputation in mice using predictive mean matching
> ##D imp1a <- mice::mice( dat, m=5, maxit=10)
> ##D datlist1a <- mitools::imputationList( miceadds::mids2datlist(imp1a) )
> ##D print(datlist1a)
> ##D 
> ##D #*******************************
> ##D # imputation in jomo treating all variables as categorical
> ##D 
> ##D # Note that variables must have values from 1 to N
> ##D # use categorize function from sirt package here
> ##D dat.categ <- sirt::categorize( dat, categorical=colnames(dat), lowest=1 )
> ##D dat0 <- dat.categ$data
> ##D 
> ##D # imputation in jomo treating all variables as categorical
> ##D Y_numcat <- apply( dat0, 2, max, na.rm=TRUE )
> ##D imp1b <- jomo::jomo1cat(Y.cat=dat0, Y.numcat=Y_numcat, nburn=100,
> ##D                  nbetween=10, nimp=5)
> ##D 
> ##D # recode original categories
> ##D datlist1b <- sirt::decategorize( imp1b, categ_design=dat.categ$categ_design )
> ##D # convert into a list of datasets
> ##D datlist1b <- miceadds::jomo2datlist(datlist1b)
> ##D datlist1b <- mitools::imputationList( datlist1b )
> ##D 
> ##D # Alternatively, jomo can be used but categorical variables must be
> ##D # declared as factors
> ##D dat <- dat0
> ##D # define two variables as factors
> ##D vars <- miceadds::scan.vec(" rskreb71 rskreb72")
> ##D for (vv in vars){
> ##D     dat[, vv] <- as.factor( dat[,vv] )
> ##D           }
> ##D # use jomo
> ##D imp1b1 <- jomo::jomo(Y=dat, nburn=30, nbetween=10, nimp=5)
> ##D 
> ##D #****************************
> ##D # compare frequency tables for both imputation packages
> ##D fun_prop <- function( variable ){
> ##D             t1 <- table(variable)
> ##D             t1 / sum(t1)
> ##D                 }
> ##D 
> ##D # variable rskreb71
> ##D res1a <-  with( datlist1a, fun_prop(rskreb71) )
> ##D res1b <-  with( datlist1b, fun_prop(rskreb71) )
> ##D summary( miceadds::NMIcombine(qhat=res1a, NMI=FALSE ) )
> ##D summary( miceadds::NMIcombine(qhat=res1b, NMI=FALSE ) )
> ##D 
> ##D # variable posatt
> ##D res2a <-  with( datlist1a, fun_prop(posatt) )
> ##D res2b <-  with( datlist1b, fun_prop(posatt) )
> ##D summary( miceadds::NMIcombine(qhat=res2a, NMI=FALSE ) )
> ##D summary( miceadds::NMIcombine(qhat=res2b, NMI=FALSE ) )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("data.internet")
> ### * data.internet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data.internet
> ### Title: Dataset Internet
> ### Aliases: data.internet
> 
> ### ** Examples
> 
> data(data.internet)
> # missing proportions
> colMeans( is.na(data.internet) )
        IN1         IN2         IN3         IN4         IN5         IN6 
0.120996441 0.000000000 0.035587189 0.021352313 0.000000000 0.007117438 
        IN7         IN8         IN9        IN10        IN11        IN12 
0.003558719 0.014234875 0.064056940 0.181494662 0.092526690 0.153024911 
       IN13        IN14        IN15        IN16        IN17        IN18 
0.010676157 0.145907473 0.032028470 0.000000000 0.000000000 0.000000000 
       IN19        IN20        IN21        IN22 
0.000000000 0.000000000 0.003558719 0.003558719 
> 
> 
> 
> cleanEx()
> nameEx("datalist2mids")
> ### * datalist2mids
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datlist2mids
> ### Title: Converting a List of Multiply Imputed Data Sets into a 'mids'
> ###   Object
> ### Aliases: datalist2mids datlist2mids
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of NHANES data using Amelia package
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(Amelia)
> ##D 
> ##D data(nhanes,package="mice")
> ##D set.seed(566)  # fix random seed
> ##D 
> ##D # impute 10 datasets using Amelia
> ##D a.out <- Amelia::amelia(x=nhanes, m=10)
> ##D # plot of observed and imputed data
> ##D plot(a.out)
> ##D 
> ##D # convert list of multiply imputed datasets into a mids object
> ##D a.mids <- miceadds::datlist2mids( a.out$imputations )
> ##D 
> ##D # linear regression: apply mice functionality lm.mids
> ##D mod <- with( a.mids, stats::lm( bmi ~ age ) )
> ##D summary( mice::pool( mod ) )
> ##D   ##                    est       se         t       df     Pr(>|t|)     lo 95
> ##D   ##  (Intercept) 30.624652 2.626886 11.658158 8.406608 1.767631e-06 24.617664
> ##D   ##  age         -2.280607 1.323355 -1.723352 8.917910 1.192288e-01 -5.278451
> ##D   ##                   hi 95 nmis       fmi    lambda
> ##D   ##  (Intercept) 36.6316392   NA 0.5791956 0.4897257
> ##D   ##  age          0.7172368    0 0.5549945 0.4652567
> ##D 
> ##D # fit linear regression model in Zelig
> ##D library(Zelig)
> ##D mod2 <- Zelig::zelig( bmi ~ age, model="ls", data=a.out, cite=FALSE)
> ##D summary(mod2)
> ##D   ##  Model: Combined Imputations
> ##D   ##              Estimate Std.Error z value Pr(>|z|)
> ##D   ##  (Intercept)   30.625     2.627  11.658  0.00000 ***
> ##D   ##  age           -2.281     1.323  -1.723  0.08482
> ##D   ##  ---
> ##D   ##  Signif. codes:  '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> ##D 
> ##D # fit linear regression using mitools package
> ##D library(mitools)
> ##D datimp <- mitools::imputationList(a.out$imputations)
> ##D mod3 <- with( datimp, stats::lm( bmi ~ age ) )
> ##D summary( mitools::MIcombine( mod3 ) )
> ##D   ##  Multiple imputation results:
> ##D   ##        with(datimp, stats::lm(bmi ~ age))
> ##D   ##        MIcombine.default(mod3)
> ##D   ##                results       se    (lower     upper) missInfo
> ##D   ##  (Intercept) 30.624652 2.626886 25.304594 35.9447092     51 ##D 
> ##D   ##  age         -2.280607 1.323355 -4.952051  0.3908368     49 ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("datlist2Amelia")
> ### * datlist2Amelia
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datlist2Amelia
> ### Title: Converting an Object of class 'amelia'
> ### Aliases: datlist2Amelia
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of NHANES data using mice package
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(Amelia)
> ##D 
> ##D data(nhanes,package="mice")
> ##D set.seed(566)  # fix random seed
> ##D 
> ##D # imputation with mice
> ##D imp <- mice::mice(nhanes, m=7)
> ##D 
> ##D # conversion to amelia object
> ##D amp <- miceadds::datlist2Amelia(datlist=imp)
> ##D str(amp)
> ##D plot(amp)
> ##D print(amp)
> ##D summary(amp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("datlist_create")
> ### * datlist_create
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datlist_create
> ### Title: Creates Objects of Class 'datlist' or 'nested.datlist'
> ### Aliases: datlist_create nested.datlist_create print.datlist
> ###   print.nested.datlist nested.datlist2datlist datlist2nested.datlist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## The function datlist_create is currently defined as
> ##D function (datasets)
> ##D {
> ##D     class(datasets) <- "datlist"
> ##D     return(datasets)
> ##D   }
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 1: Create object of class datlist
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D 
> ##D # class datlist
> ##D obj1 <- miceadds::datlist_create(data.timss2)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Multiply imputed datasets: Different object classes
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes2, package="mice")
> ##D set.seed(990)
> ##D 
> ##D # nhanes2 data imputation
> ##D imp1 <- miceadds::mice.1chain( nhanes2, burnin=5, iter=25, Nimp=5 )
> ##D # object of class datlist
> ##D imp2 <- miceadds::mids2datlist(imp1)
> ##D # alternatively, one can use datlist_create
> ##D imp2b <- miceadds::datlist_create(imp1)
> ##D # object of class imputationList
> ##D imp3 <- mitools::imputationList(imp2)
> ##D # retransform object in class datlist
> ##D imp2c <- miceadds::datlist_create(imp3)
> ##D str(imp2c)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Nested multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D    # list of 5 datasets containing 5 plausible values
> ##D 
> ##D #** define imputation method and predictor matrix
> ##D data <- datlist[[1]]
> ##D V <- ncol(data)
> ##D # variables
> ##D vars <- colnames(data)
> ##D # variables not used for imputation
> ##D vars_unused <- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )
> ##D 
> ##D #- define imputation method
> ##D impMethod <- rep("norm", V )
> ##D names(impMethod) <- vars
> ##D impMethod[ vars_unused ] <- ""
> ##D 
> ##D #- define predictor matrix
> ##D predM <- matrix( 1, V, V )
> ##D colnames(predM) <- rownames(predM) <- vars
> ##D diag(predM) <- 0
> ##D predM[, vars_unused ] <- 0
> ##D 
> ##D # object of class nmi
> ##D imp1 <- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
> ##D                 m=4, maxit=3 )
> ##D # object of class nested.datlist
> ##D imp2 <- miceadds::mids2datlist(imp1)
> ##D # object of class NestedImputationList
> ##D imp3 <- miceadds::NestedImputationList(imp2)
> ##D # redefine class nested.datlist
> ##D imp4 <- miceadds::nested.datlist_create(imp3)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 4: Conversions between nested lists of datasets and lists of datasets
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss4, package="BIFIEsurvey" )
> ##D datlist <- data.timss4
> ##D 
> ##D # object of class nested.datlist
> ##D datlist1a <- miceadds::nested.datlist_create(datlist)
> ##D # object of class NestedImputationList
> ##D datlist1b <- miceadds::NestedImputationList(datlist)
> ##D 
> ##D # conversion to datlist
> ##D datlist2a <- miceadds::nested.datlist2datlist(datlist1a)  # class datlist
> ##D datlist2b <- miceadds::nested.datlist2datlist(datlist1b)  # class imputationList
> ##D 
> ##D # convert into a nested list with 2 between nests and 10 within nests
> ##D datlist3a <- miceadds::datlist2nested.datlist(datlist2a, Nimp=c(2,10) )
> ##D datlist3b <- miceadds::datlist2nested.datlist(datlist2b, Nimp=c(4,5) )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("draw.pv.ctt")
> ### * draw.pv.ctt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.pv.ctt
> ### Title: Plausible Value Imputation Using a Known Measurement Error
> ###   Variance (Based on Classical Test Theory)
> ### Aliases: draw.pv.ctt
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D #############################################################################
> ##D # SIMULATED EXAMPLE 1: Scale scores
> ##D #############################################################################
> ##D 
> ##D set.seed(899)
> ##D n <- 5000       # number of students
> ##D x <- round( stats::runif( n, 0,1 ) )
> ##D y <- stats::rnorm(n)
> ##D # simulate true score theta
> ##D theta <- .6 + .4*x + .5 * y + stats::rnorm(n)
> ##D # simulate observed score by adding measurement error
> ##D sig.e <- rep( sqrt(.40), n )
> ##D theta_obs <- theta + stats::rnorm( n, sd=sig.e)
> ##D 
> ##D # calculate alpha
> ##D ( alpha <- stats::var( theta ) / stats::var( theta_obs ) )
> ##D # [1] 0.7424108
> ##D #=> Ordinarily, sig.e or alpha will be known, assumed or estimated by using items,
> ##D #    replications or an appropriate measurement model.
> ##D 
> ##D # create matrix of predictors
> ##D X <- as.matrix( cbind(x, y ) )
> ##D 
> ##D # plausible value imputation with scale score
> ##D imp1 <- miceadds::draw.pv.ctt( y=theta_obs, x=X, sig.e=sig.e )
> ##D # check results
> ##D stats::lm( imp1 ~ x + y )
> ##D 
> ##D # imputation with alpha as an input
> ##D imp2 <- miceadds::draw.pv.ctt( y=theta_obs, x=X, alpha=.74 )
> ##D stats::lm( imp2 ~ x + y )
> ##D 
> ##D #--- plausible value imputation in Amelia package
> ##D library(Amelia)
> ##D 
> ##D # define data frame
> ##D dat <- data.frame( "x"=x, "y"=y, "theta"=theta_obs )
> ##D # generate observation-level priors for theta
> ##D priors <- cbind( 1:n, 3, theta_obs, sig.e )
> ##D              # 3 indicates column index for theta
> ##D overimp <- priors[,1:2]
> ##D # run Amelia
> ##D imp <- Amelia::amelia( dat, priors=priors, overimp=overimp, m=10)
> ##D # create object of class datlist and evaluate results
> ##D datlist <- miceadds::datlist_create( imp$imputations )
> ##D withPool_MI( with( datlist, stats::var(theta) ) )
> ##D stats::var(theta)       # compare with true variance
> ##D mod <- with( datlist,  stats::lm( theta ~ x + y ) )
> ##D mitools::MIcombine(mod)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("filename_split")
> ### * filename_split
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: filename_split
> ### Title: Some Functionality for Strings and File Names
> ### Aliases: filename_split string_extract_part string_to_matrix
> ###   filename_split_vec
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Demonstration example for filename_split
> #############################################################################
> 
> # file name
> file_name <- "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES__2016-10-12_1000.csv"
> 
> # apply function
> miceadds::filename_split( file_name )
$file_name
[1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES__2016-10-12_1000.csv"

$stem
[1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES"

$suffix
[1] "2016-10-12_1000"

$ext
[1] "csv"

$main
[1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES.csv"

>   ##  $file_name
>   ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES__2016-10-12_1000.csv"
>   ##  $stem
>   ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES"
>   ##  $suffix
>   ##  [1] "2016-10-12_1000"
>   ##  $ext
>   ##  [1] "csv"
>   ##  $main
>   ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES.csv"
> 
> #############################################################################
> # EXAMPLE 2: Example string_extract_part
> #############################################################################
> 
> vec <- c("ertu__DES", "ztu__DATA", "guzeuue745_ghshgk34__INFO", "zzu78347834_ghghwuz")
> 
> miceadds::string_extract_part( vec=vec, part=1, sep="__" )
[1] "ertu"                "ztu"                 "guzeuue745_ghshgk34"
[4] "zzu78347834_ghghwuz"
> miceadds::string_extract_part( vec=vec, part=2, sep="__" )
[1] "DES"  "DATA" "INFO" NA    
>   ##  > miceadds::string_extract_part( vec=vec, part=1, sep="__" )
>   ##  [1] "ertu"                "ztu"                 "guzeuue745_ghshgk34"
>   ##  [4] "zzu78347834_ghghwuz"
>   ##  > miceadds::string_extract_part( vec=vec, part=2, sep="__" )
>   ##  [1] "DES"  "DATA" "INFO" NA
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 3: Reading descriptive information from published articles
> ##D #############################################################################
> ##D data(data.ma08)
> ##D library(stringr)
> ##D 
> ##D #**** reading correlations (I)
> ##D dat <- data.ma08$mat1
> ##D miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2))
> ##D 
> ##D #**** reading correlations including some processing (II)
> ##D dat0 <- data.ma08$mat2
> ##D dat <- dat0[1:14]
> ##D 
> ##D # substitute "*"
> ##D dat <- gsub("*", "", dat, fixed=TRUE )
> ##D 
> ##D # replace blanks in variable names
> ##D s1 <- stringr::str_locate(dat, "[A-z] [A-z]")
> ##D start <- s1[,"start"] + 1
> ##D for (ss in 1:length(start) ){
> ##D     if ( ! is.na( start[ss] ) ){
> ##D         substring( dat[ss], start[ss], start[ss] ) <- "_"
> ##D     }
> ##D }
> ##D 
> ##D # character matrix
> ##D miceadds::string_to_matrix(dat)
> ##D # numeric matrix containing correlations
> ##D miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
> ##D            extend=TRUE )
> ##D #** reading means and SDs
> ##D miceadds::string_to_matrix(dat0[ c(15,16)], rownames=1, col_elim=c(1), as_numeric=TRUE )
> ##D 
> ##D #**** reading correlations (III)
> ##D dat <- data.ma08$mat3
> ##D dat <- gsub(" age ", "_age_", dat, fixed=TRUE )
> ##D miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
> ##D        extend=TRUE )
> ##D 
> ##D #**** reading correlations (IV)
> ##D dat <- data.ma08$mat4 <- dat0
> ##D 
> ##D # remove spaces in variable names
> ##D dat <- gsub(" age ", "_age_", dat, fixed=TRUE )
> ##D s1 <- stringr::str_locate_all(dat, "[A-z,.] [A-z]")
> ##D NL <- length(dat)
> ##D for (ss in 1:NL ){
> ##D     NR <- nrow(s1[[ss]])
> ##D     if (NR>1){
> ##D         start <- s1[[ss]][2,1]+1
> ##D         if ( ! is.na( start ) ){
> ##D             substring( dat[ss], start, start ) <- "_"
> ##D         }
> ##D     }
> ##D }
> ##D 
> ##D miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
> ##D      extend=TRUE )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 4: Input string of length one
> ##D #############################################################################
> ##D 
> ##D 
> ##D pm0 <- "
> ##D 0.828
> ##D 0.567 0.658
> ##D 0.664 0.560 0.772
> ##D 0.532 0.428 0.501 0.606
> ##D 0.718 0.567 0.672 0.526 0.843"
> ##D 
> ##D miceadds::string_to_matrix(x=pm0, as_numeric=TRUE, extend=TRUE)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 5: String with variable names and blanks
> ##D #############################################################################
> ##D 
> ##D tab1 <- "
> ##D Geometric Shapes .629 .021 (.483) -.049 (.472)
> ##D Plates .473 .017 (.370) .105 (.405)
> ##D Two Characteristics .601 .013 (.452) -.033 (.444)
> ##D Crossing Out Boxes .597 -.062 (.425) -.036 (.445)
> ##D Numbers/Letters .731 .004 (.564) .003 (.513)
> ##D Numbers/Letters mixed .682 .085 (.555) .082 (.514)"
> ##D 
> ##D miceadds::string_to_matrix(x=tab1, col1_numeric=TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("files_move")
> ### * files_move
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: files_move
> ### Title: Moves Files from One Directory to Another Directory
> ### Aliases: files_move
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Move older files in '__ARCHIVE' directory
> ##D #############################################################################
> ##D 
> ##D # specify path
> ##D path1 <- "p:/IPN/Projects/PISA/Trend_2015/2__Data/All_Waves/"
> ##D # specify target directory which is an archive
> ##D path2 <- file.path( path1, "__ARCHIVE" )
> ##D # move files
> ##D files_move( path1, path2 )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fleishman_sim")
> ### * fleishman_sim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fleishman_sim
> ### Title: Simulating Univariate Data from Fleishman Power Normal
> ###   Transformations
> ### Aliases: fleishman_sim fleishman_coef
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Simulating values with Fleishman polynomial
> ##D #############################################################################
> ##D 
> ##D #* define mean, standard deviation, skewness and kurtosis
> ##D mean <- .75
> ##D sd <- 2
> ##D skew <- 1
> ##D kurt <- 3
> ##D 
> ##D #* compute coefficients of Fleishman polynomial
> ##D coeff <- miceadds::fleishman_coef(mean=mean, sd=sd, skew=skew, kurt=kurt)
> ##D print(coeff)
> ##D 
> ##D # sample size
> ##D N <- 1000
> ##D set.seed(2018)
> ##D #* simulate values based on estimated coefficients
> ##D X <- miceadds::fleishman_sim(N=N, coef=coeff)
> ##D #* simulate values based on input of moments
> ##D X <- miceadds::fleishman_sim(N=N, mean=mean, sd=sd, skew=skew, kurt=kurt)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("grep.vec")
> ### * grep.vec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grep.vec
> ### Title: R Utilities: Vector Based Versions of 'grep'
> ### Aliases: grep.vec grep_leading grepvec_leading grepvec
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Toy example
> #############################################################################
> 
> vec <- c("abcd", "bcde", "aedf", "cdf" )
> # search for entries in vec with contain 'a' and 'f'
> #  -> operator="AND"
> grep.vec( pattern.vec=c("a","f"), x=vec )
$x
[1] "aedf"

$index.x
[1] 3

>   ##   $x
>   ##   [1] "aedf"
>   ##   $index.x
>   ##   [1] 3
> 
> grepvec( pattern.vec=c("a","f"), x=vec, value=TRUE)
[1] "aedf"
> grepvec( pattern.vec=c("a","f"), x=vec, value=FALSE)
[1] 3
> 
> # search for entries in vec which contain 'a' or 'f'
> grep.vec( pattern.vec=c("a","f"), x=vec, operator="OR")
$x
[1] "abcd" "aedf" "cdf" 

$index.x
[1] 1 3 4

>   ##   $x
>   ##   [1] "abcd" "aedf" "cdf"
>   ##   $index.x
>   ##   [1] 1 3 4
> 
> 
> 
> cleanEx()
> nameEx("in_CI")
> ### * in_CI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: in_CI
> ### Title: Indicator Function for Analyzing Coverage
> ### Aliases: in_CI
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Toy example
> #############################################################################
> 
> #-- simulate estimates and standard errors
> set.seed(987)
> n <- 10
> est <- stats::rnorm( n, sd=1)
> se <- stats::runif( n, 0, .7 )
> level <- .95
> true <- 0
> 
> #-- apply coverage function
> in_ci <- miceadds::in_CI( est, se, true)
> #-- check correctness
> cbind( est, se, true, in_ci )
              est          se true in_ci
 [1,] -0.05701369 0.542978044    0     1
 [2,]  0.26999481 0.352582683    0     1
 [3,]  0.87447166 0.133317844    0     0
 [4,] -0.19034659 0.525903923    0     1
 [5,]  1.10069779 0.672465703    0     1
 [6,] -0.89375895 0.007281376    0     0
 [7,] -0.95496792 0.347295505    0     0
 [8,] -0.85585769 0.349923336    0     0
 [9,] -1.11302005 0.228856774    0     0
[10,] -1.28872649 0.124689794    0     0
> 
> 
> 
> cleanEx()
> nameEx("index.dataframe")
> ### * index.dataframe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: index.dataframe
> ### Title: R Utilities: Include an Index to a Data Frame
> ### Aliases: index.dataframe
> 
> ### ** Examples
> 
> dfr <- matrix( 2*1:12-3, 4,3 )
> colnames(dfr) <- paste0("X",1:ncol(dfr))
> index.dataframe( dfr)
  index X1 X2 X3
1     1 -1  7 15
2     2  1  9 17
3     3  3 11 19
4     4  5 13 21
>   ##     index X1 X2 X3
>   ##   1     1 -1  7 15
>   ##   2     2  1  9 17
>   ##   3     3  3 11 19
>   ##   4     4  5 13 21
> index.dataframe( dfr, systime=TRUE)
  index          file_created X1 X2 X3
1     1  2024-12-19 17:57:13. -1  7 15
2     2  2024-12-19 17:57:13.  1  9 17
3     3  2024-12-19 17:57:13.  3 11 19
4     4  2024-12-19 17:57:13.  5 13 21
>   ##     index         file_created X1 X2 X3
>   ##   1     1  2013-08-22 10:26:28 -1  7 15
>   ##   2     2  2013-08-22 10:26:28  1  9 17
>   ##   3     3  2013-08-22 10:26:28  3 11 19
>   ##   4     4  2013-08-22 10:26:28  5 13 21
> 
> 
> 
> cleanEx()
> nameEx("jomo2datlist")
> ### * jomo2datlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jomo2datlist
> ### Title: Converts a 'jomo' Data Frame in Long Format into a List of
> ###   Datasets or an Object of Class 'mids'
> ### Aliases: jomo2datlist jomo2mids
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Dataset nhanes | jomo imputation and conversion into a data list
> ##D #############################################################################
> ##D 
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D 
> ##D # impute under multivariate normal model in jomo
> ##D imp1 <- jomo::jomo1con(Y=dat, nburn=100, nbetween=10, nimp=5)
> ##D # convert into a list of datasets
> ##D datlist1 <- miceadds::jomo2datlist(imp1)
> ##D # convert into mids object
> ##D datlist2 <- miceadds::jomo2datlist(imp1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("kernelpls.fit2")
> ### * kernelpls.fit2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kernelpls.fit2
> ### Title: Kernel PLS Regression
> ### Aliases: kernelpls.fit2 predict.kernelpls.fit2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # SIMULATED EXAMPLE 1: 300 cases on 100 variables
> ##D #############################################################################
> ##D set.seed(789)
> ##D library(mvtnorm)
> ##D 
> ##D N <- 300        # number of cases
> ##D p <- 100        # number of predictors
> ##D rho1 <- .6      # correlations between predictors
> ##D 
> ##D # simulate data
> ##D Sigma <- base::diag(1-rho1,p) + rho1
> ##D X <- mvtnorm::rmvnorm( N, sigma=Sigma )
> ##D beta <- base::seq( 0, 1, len=p )
> ##D y <- ( X %*% beta )[,1] + stats::rnorm( N, sd=.6 )
> ##D Y <- base::matrix(y,nrow=N, ncol=1 )
> ##D 
> ##D # PLS regression
> ##D res <- miceadds::kernelpls.fit2( X=X, Y=Y, ncomp=20 )
> ##D 
> ##D # predict new scores
> ##D Xpred <- predict( res, X=X[1:10,] )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Dataset yarn from pls package
> ##D #############################################################################
> ##D 
> ##D # use kernelpls.fit from pls package
> ##D library(pls)
> ##D data(yarn,package="pls")
> ##D mod1 <- pls::kernelpls.fit( X=yarn$NIR, Y=yarn$density, ncomp=10 )
> ##D # use kernelpls.fit2 from miceadds package
> ##D Y <- base::matrix( yarn$density, ncol=1 )
> ##D mod2 <- miceadds::kernelpls.fit2( X=yarn$NIR, Y=Y, ncomp=10 )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("library_install")
> ### * library_install
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: library_install
> ### Title: R Utilities: Loading a Package or Installation of a Package if
> ###   Necessary
> ### Aliases: library_install
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # try to load packages PP and MCMCglmm
> ##D library_install( pkg=c("PP", "MCMCglmm") )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lm.cluster")
> ### * lm.cluster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lm.cluster
> ### Title: Cluster Robust Standard Errors for Linear Models and General
> ###   Linear Models
> ### Aliases: lm.cluster glm.cluster coef.lm.cluster coef.glm.cluster
> ###   vcov.lm.cluster vcov.glm.cluster summary.lm.cluster
> ###   summary.glm.cluster
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 1: Cluster robust standard errors data.ma01
> ##D #############################################################################
> ##D 
> ##D data(data.ma01)
> ##D dat <- data.ma01
> ##D 
> ##D #*** Model 1: Linear regression
> ##D mod1 <- miceadds::lm.cluster( data=dat, formula=read ~ hisei + female,
> ##D                cluster="idschool" )
> ##D coef(mod1)
> ##D vcov(mod1)
> ##D summary(mod1)
> ##D 
> ##D # estimate Model 1, but cluster is provided as a vector
> ##D mod1b <- miceadds::lm.cluster( data=dat, formula=read ~ hisei + female,
> ##D                  cluster=dat$idschool)
> ##D summary(mod1b)
> ##D 
> ##D #*** Model 2: Logistic regression
> ##D dat$highmath <- 1 * ( dat$math > 600 )   # create dummy variable
> ##D mod2 <- miceadds::glm.cluster( data=dat, formula=highmath ~ hisei + female,
> ##D                 cluster="idschool", family="binomial")
> ##D coef(mod2)
> ##D vcov(mod2)
> ##D summary(mod2)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Cluster robust standard errors for multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D library(mitools)
> ##D data(data.ma05)
> ##D dat <- data.ma05
> ##D 
> ##D # imputation of the dataset: use six imputations
> ##D resp <- dat[, - c(1:2) ]
> ##D imp <- mice::mice( resp, method="norm", maxit=3, m=6 )
> ##D datlist <- miceadds::mids2datlist( imp )
> ##D 
> ##D # linear regression with cluster robust standard errors
> ##D mod <- lapply(  datlist, FUN=function(data){
> ##D             miceadds::lm.cluster( data=data, formula=denote ~ migrant+ misei,
> ##D                     cluster=dat$idclass )
> ##D             }  )
> ##D # extract parameters and covariance matrix
> ##D betas <- lapply( mod, FUN=function(rr){ coef(rr) } )
> ##D vars <- lapply( mod, FUN=function(rr){ vcov(rr) } )
> ##D # conduct statistical inference
> ##D summary( miceadds::pool_mi( qhat=betas, u=vars ) )
> ##D 
> ##D #------ compute global F-test for hypothesis that all predictors have zero coefficient values
> ##D library(mitml)
> ##D Nimp <- 6 # number of imputations
> ##D np <- length(betas[[1]])   # number of parameters
> ##D beta_names <- names(betas[[1]])
> ##D # define vector of parameters for which constraints should be tested
> ##D constraints <- beta_names[-1]
> ##D # create input for mitml::testConstraints function
> ##D qhat <- matrix( unlist(betas), ncol=Nimp)
> ##D rownames(qhat) <- beta_names
> ##D uhat <- array( unlist(vars), dim=c(np,np,Nimp))
> ##D dimnames(uhat) <- list( beta_names, beta_names, NULL )
> ##D # compute global F-test
> ##D Ftest <- mitml::testConstraints( qhat=betas, uhat=vars, constraints=constraints )
> ##D print(Ftest)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Comparing miceadds::lm.cluster() and lme4::lmer()
> ##D #############################################################################
> ##D 
> ##D data(data.ma01, package="miceadds")
> ##D dat <- na.omit(data.ma01)
> ##D 
> ##D # center hisei variable
> ##D dat$hisei <- dat$hisei - mean(dat$hisei)
> ##D 
> ##D # define school mean hisei
> ##D dat$hisei_gm <- miceadds::GroupMean(dat$hisei, dat$idschool, extend=TRUE)[,2]
> ##D dat$cluster_size <- miceadds::GroupSum(1+0*dat$hisei, dat$idschool, extend=TRUE)[,2]
> ##D dat$hisei_wc <- dat$hisei - dat$hisei_gm
> ##D 
> ##D 
> ##D 
> ##D #*** Model 1a: lm, hisei with clustering
> ##D mod1a <- miceadds::lm.cluster( data=dat, formula=read~hisei, cluster="idschool" )
> ##D 
> ##D #*** Model 1b: lmer, hisei
> ##D mod1b <- lme4::lmer( data=dat, formula=read~hisei+(1|idschool) )
> ##D 
> ##D cbind( coef(mod1a), fixef(mod1b))
> ##D  ##  > cbind( coef(mod1a), fixef(mod1b))
> ##D  ##                    [,1]        [,2]
> ##D  ##  (Intercept) 509.181691 507.8684752
> ##D  ##  hisei         1.524776   0.8161745
> ##D 
> ##D # variance explanation
> ##D vmod1b <- r2mlm::r2mlm(mod1b)
> ##D vmod1b$Decompositions
> ##D 
> ##D #*** Model 2a: lm, hisei and hisei_gm with clustering
> ##D mod2a <- miceadds::lm.cluster( data=dat, formula=read~hisei_wc+hisei_gm,
> ##D                                    cluster="idschool" )
> ##D 
> ##D #*** Model 2b: lmer, multilevel model
> ##D mod2b <- lme4::lmer( data=dat, formula=read~hisei_wc+hisei_gm + (1|idschool) )
> ##D 
> ##D # variance explanation
> ##D vmod2b <- r2mlm::r2mlm(mod2b)
> ##D vmod2b$Decompositions
> ##D 
> ##D cbind( coef(mod2a), fixef(mod2b))
> ##D  ##  > cbind( coef(mod2a), fixef(mod2b))
> ##D  ##                     [,1]        [,2]
> ##D  ##  (Intercept) 509.1816911 508.0478629
> ##D  ##  hisei_wc      0.7503773   0.7503773
> ##D  ##  hisei_gm      5.8424012   5.5681941
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lmer_vcov")
> ### * lmer_vcov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lmer_vcov
> ### Title: Statistical Inference for Fixed and Random Structure for Fitted
> ###   Models in 'lme4'
> ### Aliases: lmer_vcov summary.lmer_vcov coef.lmer_vcov vcov.lmer_vcov
> ###   lmer_vcov2 lmer_pool summary.lmer_pool lmer_pool2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Single model fitted in lme4
> ##D #############################################################################
> ##D 
> ##D library(lme4)
> ##D data(data.ma01, package="miceadds")
> ##D dat <- na.omit(data.ma01)
> ##D 
> ##D #* fit multilevel model
> ##D formula <- math ~ hisei + miceadds::gm( books, idschool ) + ( 1 + books | idschool )
> ##D mod1 <- lme4::lmer( formula, data=dat, REML=FALSE)
> ##D summary(mod1)
> ##D 
> ##D #* statistical inference
> ##D res1 <- miceadds::lmer_vcov( mod1 )
> ##D summary(res1)
> ##D coef(res1)
> ##D vcov(res1)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: lme4 model for multiply imputed dataset
> ##D #############################################################################
> ##D 
> ##D library(lme4)
> ##D data(data.ma02, package="miceadds")
> ##D datlist <- miceadds::datlist_create(data.ma02)
> ##D 
> ##D #** fit lme4 model for all imputed datasets
> ##D formula <- math ~ hisei + miceadds::gm( books, idschool ) + ( 1 | idschool )
> ##D models <- list()
> ##D M <- length(datlist)
> ##D for (mm in 1:M){
> ##D     models[[mm]] <- lme4::lmer( formula, data=datlist[[mm]], REML=FALSE)
> ##D }
> ##D 
> ##D #** statistical inference
> ##D res1 <- miceadds::lmer_pool(models)
> ##D summary(res1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("load.Rdata")
> ### * load.Rdata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load.Rdata
> ### Title: R Utilities: Loading 'Rdata' Files in a Convenient Way
> ### Aliases: load.Rdata load.Rdata2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # load a data frame in the file "data_s3.Rdata" and save this
> ##D # as the object "dat.s3"
> ##D load.Rdata( filename="data_s3.Rdata", "dat.s3" )
> ##D head(dat.s3)
> ##D 
> ##D # Alternatively one can use the function
> ##D dat.s3 <- miceadds::load.Rdata2( filename="data_s3.Rdata")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("load.data")
> ### * load.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load.data
> ### Title: R Utilities: Loading/Reading Data Files using 'miceadds'
> ### Aliases: load.data load.files
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Toy example
> ##D #############################################################################
> ##D 
> ##D # load a data frame in the file "data_s3.Rdata" and save this
> ##D # as the object "dat.s3"
> ##D dat.s3 <- miceadds::load.data( filename="data_s3.Rdata", type="Rdata" )
> ##D print(str(dat.s3))
> ##D 
> ##D # load text input with base::readLines() function using the 'load_fun' argument
> ##D dat <- miceadds::load.data( "my_output_", type="Rout", load_fun=readLines, path=path)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ma.scale2")
> ### * ma.scale2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ma.scale2
> ### Title: Standardization of a Matrix
> ### Aliases: ma.scale2
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: z-standardization data.internet
> #############################################################################
> 
> data(data.internet)
> dat <- data.internet
> 
> # z-standardize all variables in this dataset
> zdat <- miceadds::ma.scale2( dat, missings=TRUE )
> 
> ## Not run: 
> ##D #############################################################################
> ##D # SIMULATED EXAMPLE 2: Speed comparison for many cases and many variables
> ##D #############################################################################
> ##D 
> ##D set.seed(9786)
> ##D # 3000 cases, 200 variables
> ##D N <- 3000
> ##D p <- 200
> ##D # simulate some data
> ##D x <- matrix( stats::rnorm( N*p ), N, p )
> ##D x <- round( x, 2 )
> ##D 
> ##D # compare computation times for 10 replications
> ##D B <- 10
> ##D     s1 <- Sys.time()        # scale in R
> ##D for (bb in 1:B){
> ##D     res <- scale(x)
> ##D } ; s2 <- Sys.time() ; d1 <- s2-s1
> ##D 
> ##D     s1 <- Sys.time()        # scale in miceadds
> ##D for (bb in 1:B){
> ##D     res1 <- miceadds::ma.scale2(x)
> ##D } ; s2 <- Sys.time() ; d2 <- s2-s1
> ##D 
> ##D # scale in miceadds with missing handling
> ##D     s1 <- Sys.time()
> ##D for (bb in 1:B){
> ##D     res1 <- miceadds::ma.scale2(x,missings=TRUE)
> ##D } ; s2 <- Sys.time() ; d3 <- s2-s1
> ##D d1      # scale in R
> ##D d2      # scale in miceadds (no missing handling)
> ##D d3      # scale in miceadds (with missing handling)
> ##D   ##   > d1      # scale in R
> ##D   ##   Time difference of 1.622431 secs
> ##D   ##   > d2      # scale in miceadds (no missing handling)
> ##D   ##   Time difference of 0.156003 secs
> ##D   ##   > d3      # scale in miceadds (with missing handling)
> ##D   ##   Time difference of 0.2028039 secs
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ma.wtd.statNA")
> ### * ma.wtd.statNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ma.wtd.statNA
> ### Title: Some Multivariate Descriptive Statistics for Weighted Data in
> ###   'miceadds'
> ### Aliases: ma.wtd.statNA ma.wtd.covNA ma.wtd.corNA ma.wtd.meanNA
> ###   ma.wtd.sdNA ma.wtd.skewnessNA ma.wtd.kurtosisNA ma.wtd.quantileNA
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Weighted statistics for a single dataset data.ma01
> #############################################################################
> 
> data(data.ma01)
> dat <- as.matrix(data.ma01[,-c(1:3)])
> 
> # weighted mean
> ma.wtd.meanNA( dat, weights=data.ma01$studwgt )
        math         read      migrant        books        hisei       paredu 
506.86146130 500.43762737   0.18432784   3.61250574  45.00529600   3.30965534 
      female        urban 
  0.49112332   0.04544215 
> 
> # weighted SD
> ma.wtd.sdNA( dat, weights=data.ma01$studwgt )
       math        read     migrant       books       hisei      paredu 
100.0819097  80.7705744   0.3878106   1.4803289  15.6426222   1.8831952 
     female       urban 
  0.4999901   0.2083005 
> 
> # weighted covariance for selected variables
> ma.wtd.covNA( dat, weights=data.ma01$studwgt, vars=c("books","hisei") )
         books      hisei
books 2.191374   6.914589
hisei 6.914589 244.691628
> 
> # weighted correlation
> ma.wtd.corNA( dat, weights=data.ma01$studwgt )
               math        read      migrant       books        hisei
math     1.00000000  0.68011825 -0.189985751  0.33930096  0.221906963
read     0.68011825  1.00000000 -0.185449266  0.36100033  0.283020223
migrant -0.18998575 -0.18544927  1.000000000 -0.15914637 -0.107969883
books    0.33930096  0.36100033 -0.159146366  1.00000000  0.298606030
hisei    0.22190696  0.28302022 -0.107969883  0.29860603  1.000000000
paredu   0.19391574  0.21258699  0.002914095  0.31536577  0.429511350
female  -0.03772783  0.24775461  0.002869070  0.05424052 -0.006677162
urban    0.02101034  0.06482299  0.071132192  0.02765669  0.066006789
              paredu       female       urban
math     0.193915745 -0.037727827  0.02101034
read     0.212586987  0.247754610  0.06482299
migrant  0.002914095  0.002869070  0.07113219
books    0.315365774  0.054240516  0.02765669
hisei    0.429511350 -0.006677162  0.06600679
paredu   1.000000000 -0.047091492  0.04958162
female  -0.047091492  1.000000000 -0.01885873
urban    0.049581625 -0.018858731  1.00000000
> 
> ## Not run: 
> ##D # weighted skewness
> ##D ma.wtd.skewnessNA( dat[,"books"], weights=data.ma01$studwgt )
> ##D # compare with result in TAM
> ##D TAM::weighted_skewness( x=dat[,"books"], w=data.ma01$studwgt )
> ##D 
> ##D # weighted kurtosis
> ##D ma.wtd.kurtosisNA( dat, weights=data.ma01$studwgt, vars=c("books","hisei") )
> ##D # compare with TAM
> ##D TAM::weighted_kurtosis( dat[,"books"], w=data.ma01$studwgt )
> ##D TAM::weighted_kurtosis( dat[,"hisei"], w=data.ma01$studwgt )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Weighted statistics multiply imputed dataset
> ##D #############################################################################
> ##D 
> ##D library(mitools)
> ##D data(data.ma05)
> ##D dat <- data.ma05
> ##D 
> ##D # do imputations
> ##D resp <- dat[, - c(1:2) ]
> ##D # object of class mids
> ##D imp <- mice::mice( resp, method="norm", maxit=3, m=5 )
> ##D # object of class datlist
> ##D datlist <- miceadds::mids2datlist( imp )
> ##D # object of class imputationList
> ##D implist <- mitools::imputationList(datlist)
> ##D 
> ##D # weighted means
> ##D ma.wtd.meanNA(datlist)
> ##D ma.wtd.meanNA(implist)
> ##D ma.wtd.meanNA(imp)
> ##D 
> ##D # weighted quantiles
> ##D ma.wtd.quantileNA( implist, weights=data.ma05$studwgt, vars=c("manote","Dscore"))
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Weighted statistics nested multiply imputed dataset
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2   # list of 5 datasets containing 5 plausible values
> ##D 
> ##D #** define imputation method and predictor matrix
> ##D data <- datlist[[1]]
> ##D V <- ncol(data)
> ##D # variables
> ##D vars <- colnames(data)
> ##D # variables not used for imputation
> ##D vars_unused <- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )
> ##D #- define imputation method
> ##D impMethod <- rep("norm", V )
> ##D names(impMethod) <- vars
> ##D impMethod[ vars_unused ] <- ""
> ##D #- define predictor matrix
> ##D predM <- matrix( 1, V, V )
> ##D colnames(predM) <- rownames(predM) <- vars
> ##D diag(predM) <- 0
> ##D predM[, vars_unused ] <- 0
> ##D 
> ##D # object of class mids.nmi
> ##D imp1 <- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
> ##D                 m=4, maxit=3 )
> ##D # object of class nested.datlist
> ##D datlist <- miceadds::mids2datlist(imp1)
> ##D # object of class NestedImputationList
> ##D imp2 <- miceadds::NestedImputationList(datlist)
> ##D 
> ##D # weighted correlations
> ##D vars <- c("books","ASMMAT","likesc")
> ##D ma.wtd.corNA( datlist,  vars=vars )
> ##D ma.wtd.corNA( imp2,  vars=vars )
> ##D ma.wtd.corNA( imp1,  vars=vars )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 4: Multiply imputed datasets in BIFIEdata format
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss1, package="BIFIEsurvey")
> ##D data(data.timssrep, package="BIFIEsurvey")
> ##D 
> ##D # create BIFIEdata object
> ##D bdat <- BIFIEsurvey::BIFIE.data( data.list=data.timss1, wgt=data.timss1[[1]]$TOTWGT,
> ##D             wgtrep=data.timssrep[, -1 ] )
> ##D summary(bdat)
> ##D # create BIFIEdata object in a compact way
> ##D bdat2 <- BIFIEsurvey::BIFIE.data( data.list=data.timss1, wgt=data.timss1[[1]]$TOTWGT,
> ##D             wgtrep=data.timssrep[, -1 ], cdata=TRUE)
> ##D summary(bdat2)
> ##D 
> ##D # compute skewness
> ##D ma.wtd.skewnessNA( bdat, vars=c("ASMMAT", "books" ) )
> ##D ma.wtd.skewnessNA( bdat2, vars=c("ASMMAT", "books" ) )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 5: Nested multiply imputed datasets in BIFIEdata format
> ##D #############################################################################
> ##D 
> ##D data(data.timss4, package="BIFIEsurvey")
> ##D data(data.timssrep, package="BIFIEsurvey")
> ##D 
> ##D # nested imputed dataset, save it in compact format
> ##D bdat <- BIFIE.data( data.list=data.timss4, wgt=data.timss4[[1]][[1]]$TOTWGT,
> ##D             wgtrep=data.timssrep[, -1 ], NMI=TRUE, cdata=TRUE )
> ##D summary(bdat)
> ##D # skewness
> ##D ma.wtd.skewnessNA( bdat, vars=c("ASMMAT", "books" ) )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ma_lme4_formula_terms")
> ### * ma_lme4_formula_terms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ma_lme4_formula
> ### Title: Utility Functions for Working with 'lme4' Formula Objects
> ### Aliases: ma_lme4_formula ma_lme4_formula_terms
> ###   ma_lme4_formula_design_matrices
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Splitting a lme4 formula
> ##D #############################################################################
> ##D 
> ##D #*** formula for a multilevel model
> ##D formula <- y ~ I( miceadds::cwc(x, idcluster)) + z + I(z^2) + I( miceadds::gm(x, idcluster) ) + w +
> ##D                         ( x + I(x^2) | idcluster)  + (0 +  w | idcluster ) +
> ##D                         ( 0 + I(as.factor(f)) | idcluster)
> ##D miceadds::ma_lme4_formula_terms(formula)
> ##D 
> ##D #*** formula for a single level model
> ##D formula2 <- y ~ I( miceadds::cwc(x, idcluster)) + z + I(z^2) + I( miceadds::gm(x, idcluster) ) + w
> ##D miceadds::ma_lme4_formula_terms(formula2)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Design matrices for multilevel model
> ##D #############################################################################
> ##D 
> ##D data(data.ma07, package="miceadds")
> ##D dat <- data.ma07
> ##D 
> ##D formula <- x1 ~ x2 + I( miceadds::gm( x2, id2)) + I( miceadds::gm( x2, id3)) + y1 + z1 +
> ##D                     ( x2 | id2:id3 ) + ( 1 | id3 ) + ( 0 + x2 | id3 )
> ##D res <- miceadds::ma_lme4_formula_design_matrices(formula, data=dat)
> ##D str(res)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ma_rmvnorm")
> ### * ma_rmvnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ma_rmvnorm
> ### Title: Simulating Normally Distributed Data
> ### Aliases: ma_rmvnorm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Two-dimensional simulation with zero variance at dimension 1
> ##D #############################################################################
> ##D 
> ##D sigma <- matrix( c(0,0,0,1), nrow=2, ncol=2)
> ##D miceadds::ma_rmvnorm( n=10, sigma=sigma )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mi.anova")
> ### * mi.anova
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mi.anova
> ### Title: Analysis of Variance for Multiply Imputed Data Sets (Using the
> ###   D_2 Statistic)
> ### Aliases: mi.anova
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: nhanes2 data | two-way ANOVA
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(car)
> ##D data(nhanes2, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes data in one chain and 8 imputed datasets
> ##D mi.res <- miceadds::mice.1chain( nhanes2, burnin=4, iter=20, Nimp=8 )
> ##D # 2-way analysis of variance (type 2)
> ##D an2a <- miceadds::mi.anova(mi.res=mi.res, formula="bmi ~ age * chl" )
> ##D 
> ##D # test of interaction effects using mitml::testModels()
> ##D mod1 <- with( mi.res, stats::lm( bmi ~ age*chl ) )
> ##D mod0 <- with( mi.res, stats::lm( bmi ~ age+chl ) )
> ##D 
> ##D mitml::testModels(model=mod1$analyses, null.model=mod0$analyses, method="D1")
> ##D mitml::testModels(model=mod1$analyses, null.model=mod0$analyses, method="D2")
> ##D 
> ##D # 2-way analysis of variance (type 3)
> ##D an2b <- miceadds::mi.anova(mi.res=mi.res, formula="bmi ~ age * chl", type=3)
> ##D 
> ##D #****** analysis based on first imputed dataset
> ##D 
> ##D # extract first dataset
> ##D dat1 <- mice::complete( mi.res$mids )
> ##D 
> ##D # type 2 ANOVA
> ##D lm1 <- stats::lm( bmi ~ age * chl, data=dat1 )
> ##D summary( stats::aov( lm1 ) )
> ##D # type 3 ANOVA
> ##D lm2 <- stats::lm( bmi ~ age * chl, data=dat1, contrasts=list(age=contr.sum))
> ##D car::Anova(mod=lm2, type=3)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mi_dstat")
> ### * mi_dstat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mi_dstat
> ### Title: Cohen's d Effect Size for Missingness Indicators
> ### Aliases: mi_dstat
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: d effect size for missingness indicators data.ma01
> #############################################################################
> 
> data(data.ma01)
> dat <- data.ma01
> 
> # compute d effect sizes
> md <- miceadds::mi_dstat(dat)
> round( md, 3 )
        idstud idschool studwgt   math   read migrant books  hisei paredu
math     0.116    0.117  -0.004    NaN -0.179   0.682 0.135 -0.464 -0.292
read     0.129    0.130   0.309 -0.276    NaN   0.076 0.003 -0.085 -0.028
migrant  0.038    0.038  -0.103 -0.135 -0.186     NaN 0.090 -0.142  0.158
books   -0.056   -0.056  -0.138 -0.107 -0.145   0.268   NaN  0.098  0.226
hisei    0.010    0.010  -0.079 -0.221 -0.268   0.309 0.022    NaN  0.064
paredu  -0.023   -0.023  -0.116 -0.143 -0.190   0.340 0.017 -0.310    NaN
        female  urban
math     0.065  0.169
read    -0.006 -0.058
migrant -0.094  0.093
books   -0.093  0.036
hisei   -0.164  0.064
paredu  -0.085  0.045
> 
> 
> 
> cleanEx()
> nameEx("mice.1chain")
> ### * mice.1chain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.1chain
> ### Title: Multiple Imputation by Chained Equations using One Chain
> ### Aliases: mice.1chain summary.mids.1chain plot.mids.1chain
> ###   print.mids.1chain
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 1: One chain nhanes data
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes data in one chain
> ##D imp.mi1 <- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4,
> ##D                  method=rep("norm", 4 ) )
> ##D summary(imp.mi1)       # summary of mids.1chain
> ##D plot( imp.mi1 ) # trace plot excluding burnin iterations
> ##D plot( imp.mi1, plot.burnin=TRUE ) # trace plot including burnin iterations
> ##D 
> ##D # select mids object
> ##D imp.mi2 <- imp.mi1$midsobj
> ##D summary(imp.mi2)    # summary of mids
> ##D 
> ##D # apply mice functionality lm.mids
> ##D mod <- with( imp.mi2, stats::lm( bmi ~ age ) )
> ##D summary( mice::pool( mod ) )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: One chain (mixed data: numeric and factor)
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes2, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes2 data in one chain
> ##D imp.mi1 <- miceadds::mice.1chain( nhanes2, burnin=5, iter=25, Nimp=5 )
> ##D # summary
> ##D summary( imp.mi1$midsobj )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Multiple imputation with counterfactuals for estimating
> ##D #            causal effects (average treatment effects)
> ##D # Schafer, J. L., & Kang, J. (2008). Average causal effects from nonrandomized
> ##D #    studies: a practical guide and simulated example.
> ##D #    Psychological Methods, 13, 279-313.
> ##D #############################################################################
> ##D 
> ##D data(data.ma01)
> ##D dat <- data.ma01[, 4:11]
> ##D 
> ##D # define counterfactuals for reading score for students with and
> ##D # without migrational background
> ##D dat$read.migrant1 <- ifelse( paste(dat$migrant)==1, dat$read, NA )
> ##D dat$read.migrant0 <- ifelse( paste(dat$migrant)==0, dat$read, NA )
> ##D 
> ##D # define imputation method
> ##D impmethod <- rep("pls", ncol(dat) )
> ##D names(impmethod) <- colnames(dat)
> ##D 
> ##D # define predictor matrix
> ##D pm <- 4*(1 - diag( ncol(dat) ) )    # 4 - use all interactions
> ##D rownames(pm) <- colnames(pm) <- colnames(dat)
> ##D pm[ c( "read.migrant0", "read.migrant1"), ] <- 0
> ##D # do not use counterfactuals for 'read' as a predictor
> ##D pm[, "read.migrant0"] <- 0
> ##D pm[, "read.migrant1"] <- 0
> ##D # define control variables for creation of counterfactuals
> ##D pm[ c( "read.migrant0", "read.migrant1"), c("hisei","paredu","female","books") ] <- 4
> ##D   ##   > pm
> ##D   ##                 math read migrant books hisei paredu female urban read.migrant1 read.migrant0
> ##D   ##   math             0    4       4     4     4      4      4     4             0             0
> ##D   ##   read             4    0       4     4     4      4      4     4             0             0
> ##D   ##   migrant          4    4       0     4     4      4      4     4             0             0
> ##D   ##   books            4    4       4     0     4      4      4     4             0             0
> ##D   ##   hisei            4    4       4     4     0      4      4     4             0             0
> ##D   ##   paredu           4    4       4     4     4      0      4     4             0             0
> ##D   ##   female           4    4       4     4     4      4      0     4             0             0
> ##D   ##   urban            4    4       4     4     4      4      4     0             0             0
> ##D   ##   read.migrant1    0    0       0     4     4      4      4     0             0             0
> ##D   ##   read.migrant0    0    0       0     4     4      4      4     0             0             0
> ##D 
> ##D # imputation using mice function and PLS imputation with
> ##D # predictive mean matching method 'pmm6'
> ##D imp <- mice::mice( dat, method=impmethod, predictorMatrix=pm,
> ##D             maxit=4, m=5, pls.impMethod="pmm5" )
> ##D 
> ##D #*** Model 1: Raw score difference
> ##D mod1 <- with( imp, stats::lm( read ~ migrant ) )
> ##D smod1 <- summary( mice::pool(mod1) )
> ##D   ##   > smod1
> ##D   ##                  est    se      t     df Pr(>|t|)  lo 95  hi 95 nmis    fmi lambda
> ##D   ##   (Intercept) 510.21 1.460 349.37 358.26        0 507.34 513.09   NA 0.1053 0.1004
> ##D   ##   migrant     -43.38 3.757 -11.55  62.78        0 -50.89 -35.87  404 0.2726 0.2498
> ##D 
> ##D #*** Model 2: ANCOVA - regression adjustment
> ##D mod2 <- with( imp, stats::lm( read ~ migrant + hisei + paredu + female + books) )
> ##D smod2 <- summary( mice::pool(mod2) )
> ##D   ##   > smod2
> ##D   ##                    est      se      t      df  Pr(>|t|)    lo 95   hi 95 nmis      fmi   lambda
> ##D   ##   (Intercept) 385.1506 4.12027 93.477 3778.66 0.000e+00 377.0725 393.229   NA 0.008678 0.008153
> ##D   ##   migrant     -29.1899 3.30263 -8.838   87.46 9.237e-14 -35.7537 -22.626  404 0.228363 0.210917
> ##D   ##   hisei         0.9401 0.08749 10.745  160.51 0.000e+00   0.7673   1.113  733 0.164478 0.154132
> ##D   ##   paredu        2.9305 0.79081  3.706   41.34 6.190e-04   1.3338   4.527  672 0.339961 0.308780
> ##D   ##   female       38.1719 2.26499 16.853 1531.31 0.000e+00  33.7291  42.615    0 0.041093 0.039841
> ##D   ##   books        14.0113 0.88953 15.751  154.71 0.000e+00  12.2541  15.768  423 0.167812 0.157123
> ##D 
> ##D #*** Model 3a: Estimation using counterfactuals
> ##D mod3a <- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 1 ) )
> ##D smod3a <- summary( mice::pool(mod3a) )
> ##D   ##   > smod3a
> ##D   ##                  est    se      t    df Pr(>|t|)  lo 95  hi 95 nmis    fmi lambda
> ##D   ##   (Intercept) -22.54 7.498 -3.007 4.315  0.03602 -42.77 -2.311   NA 0.9652 0.9521
> ##D 
> ##D #*** Model 3b: Like Model 3a but using student weights
> ##D mod3b <- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 1,
> ##D                         weights=data.ma01$studwgt ) )
> ##D smod3b <- summary( mice::pool(mod3b) )
> ##D   ##   > smod3b
> ##D   ##                  est    se      t  df Pr(>|t|)  lo 95  hi 95 nmis    fmi lambda
> ##D   ##   (Intercept) -21.88 7.605 -2.877 4.3  0.04142 -42.43 -1.336   NA 0.9662 0.9535
> ##D 
> ##D #*** Model 4: Average treatment effect on the treated (ATT, migrants)
> ##D #             and non-treated (ATN, non-migrants)
> ##D mod4 <- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 0 + as.factor( migrant) )   )
> ##D smod4 <- summary( mice::pool(mod4) )
> ##D   ##   > smod4
> ##D   ##                          est    se      t    df Pr(>|t|)  lo 95   hi 95 nmis    fmi lambda
> ##D   ##   as.factor(migrant)0 -23.13 8.664 -2.669  4.27 0.052182 -46.59  0.3416   NA 0.9682 0.9562
> ##D   ##   as.factor(migrant)1 -19.95 5.198 -3.837 19.57 0.001063 -30.81 -9.0884   NA 0.4988 0.4501
> ##D # ATN=-23.13 and ATT=-19.95
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.2l.contextual.pmm")
> ### * mice.impute.2l.contextual.pmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.2l.contextual.pmm
> ### Title: Imputation by Predictive Mean Matching or Normal Linear
> ###   Regression with Contextual Variables
> ### Aliases: mice.impute.2l.contextual.pmm mice.impute.2l.contextual.norm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Sequential hierarchical imputation for data.ma05 dataset
> ##D #############################################################################
> ##D 
> ##D data(data.ma05)
> ##D dat <- data.ma05
> ##D 
> ##D # define predictor matrix
> ##D predM <- mice::make.predictorMatrix(data=dat)
> ##D # exclude student IDs
> ##D predM[, "idstud"] <- 0
> ##D # define idclass as the cluster variable (type=-2)
> ##D predM[, "idclass" ] <- -2
> ##D 
> ##D # initialize with norm method
> ##D impMethod <- mice::make.method(data=dat)
> ##D names(impMethod) <- names( imp0$method )
> ##D impMethod[ c("idstud","idclass")] <- ""
> ##D 
> ##D #*****
> ##D # STUDENT LEVEL (Level 1)
> ##D 
> ##D # Use a random slope model for Dscore and Mscore as the imputation method.
> ##D # Here, variance homogeneity of residuals is assumed (contrary to
> ##D # the 2l.norm imputation method in the mice package).
> ##D impMethod[ c("Dscore", "Mscore") ] <- "2l.pan"
> ##D predM[ c("Dscore","Mscore"), "misei" ] <- 2    # random slopes on 'misei'
> ##D predM[, "idclass" ] <- -2
> ##D 
> ##D # For imputing 'manote' and 'denote' use contextual effects (i.e. cluszer means)
> ##D # of variables 'misei' and 'migrant'
> ##D impMethod[ c("denote", "manote") ] <- "2l.contextual.pmm"
> ##D predM[ c("denote", "manote"), c("misei","migrant")] <- 2
> ##D 
> ##D # Use no cluster variable 'idclass' for imputation of 'misei'
> ##D impMethod[ "misei"] <- "norm"
> ##D predM[ "misei", "idclass"] <- 0 # use no multilevel imputation model
> ##D 
> ##D # Variable migrant: contextual effects of Dscore and misei
> ##D impMethod[ "migrant"] <- "2l.contextual.pmm"
> ##D predM[ "migrant", c("Dscore",  "misei" ) ] <- 2
> ##D predM[ "migrant", "idclass" ] <- -2
> ##D 
> ##D #****
> ##D # CLASS LEVEL (Level 2)
> ##D # impute 'sprengel' and 'groesse' at the level of classes
> ##D impMethod[ "sprengel"] <- "2lonly.pmm"
> ##D impMethod[ "groesse"] <- "2lonly.norm"
> ##D predM[ c("sprengel","groesse"), "idclass" ] <- -2
> ##D 
> ##D # do imputation
> ##D imp <- mice::mice( dat, predictorMatrix=predM, m=3,  maxit=4,
> ##D            method=impMethod, paniter=100)
> ##D summary(imp)
> ##D 
> ##D #**** imputation model 2 with PLS dimension reduction
> ##D 
> ##D # define some interaction effects
> ##D interactions <- list( manote=c("migrant", "misei") )
> ##D # number of PLS factors (5 factors)
> ##D pls.facs <- list( manote=5 )
> ##D 
> ##D # do imputation
> ##D imp2 <- mice::mice( dat, predictorMatrix=predM, interactions=interactions,
> ##D             pls.facs=pls.facs, method=impMethod, paniter=100)
> ##D summary(imp2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.2l.latentgroupmean.ml")
> ### * mice.impute.2l.latentgroupmean.ml
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.2l.latentgroupmean.ml
> ### Title: Imputation of Latent and Manifest Group Means for Multilevel
> ###   Data
> ### Aliases: mice.impute.2l.latentgroupmean.ml
> ###   mice.impute.2l.latentgroupmean.mcmc mice.impute.2l.groupmean
> ###   mice.impute.2l.groupmean.elim
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Two-level imputation data.ma05 dataset with imputation
> ##D #            of a latent group mean
> ##D #############################################################################
> ##D 
> ##D data(data.ma05)
> ##D dat <- data.ma05
> ##D 
> ##D # include manifest group mean for 'Mscore'
> ##D dat$M.Mscore <- NA
> ##D # include latent group group for 'Mscore'
> ##D dat$LM.Mscore <- NA    #=> LM: latent group mean
> ##D 
> ##D # define predictor matrix
> ##D predM <- mice::make.predictorMatrix(data=dat)
> ##D # exclude student ISs
> ##D predM[, "idstud"] <- 0
> ##D # idclass is the cluster identifier
> ##D predM[, "idclass" ] <- -2
> ##D 
> ##D # define imputation methods
> ##D impMethod <- mice::make.method(data=dat)
> ##D # initialize with norm
> ##D impMethod <- rep( "norm", length(impMethod) )
> ##D names(impMethod) <- names( imp$method )
> ##D impMethod[ c("idstud","idclass")] <- ""
> ##D 
> ##D #*****
> ##D # STUDENT LEVEL (Level 1)
> ##D 
> ##D # Use a random slope model for Dscore and Mscore as the imputation method.
> ##D # Here, variance homogeneity of residuals is assumed (contrary to
> ##D # the 2l.norm imputation method in the mice package).
> ##D impMethod[ c("Dscore", "Mscore") ] <- "2l.pan"
> ##D predM[ c("Dscore","Mscore"), "misei" ] <- 2    # random slopes on 'misei'
> ##D predM[, "idclass" ] <- -2
> ##D 
> ##D # For imputing 'manote' and 'denote' use contextual effects (i.e. cluster means)
> ##D # of variables 'misei' and 'migrant'
> ##D impMethod[ c("denote", "manote") ] <- "2l.contextual.pmm"
> ##D predM[ c("denote", "manote"), c("misei","migrant")] <- 2
> ##D 
> ##D # Use no cluster variable 'idclass' for imputation of 'misei'
> ##D impMethod[ "misei"] <- "norm"
> ##D predM[ "misei", "idclass"] <- 0 # use no multilevel imputation model
> ##D 
> ##D # Variable migrant: contextual effects of Dscore and misei
> ##D impMethod[ "migrant"] <- "2l.contextual.pmm"
> ##D predM[ "migrant", c("Dscore",  "misei" ) ] <- 2
> ##D predM[ "migrant", "idclass" ] <- -2
> ##D 
> ##D #****
> ##D # CLASS LEVEL (Level 2)
> ##D # impute 'sprengel' and 'groesse' at the level of classes
> ##D impMethod[ "sprengel"] <- "2lonly.pmm2"
> ##D impMethod[ "groesse"] <- "2lonly.norm2"
> ##D predM[ c("sprengel","groesse"), "idclass" ] <- -2
> ##D 
> ##D # manifest group mean for Mscore
> ##D impMethod[ "M.Mscore" ] <- "2l.groupmean"
> ##D # latent group mean for Mscore
> ##D impMethod[ "LM.Mscore" ] <- "2l.latentgroupmean.ml"
> ##D predM[ "M.Mscore", "Mscore" ] <- 2
> ##D 
> ##D # covariates for latent group mean of 'Mscore'
> ##D predM[ "LM.Mscore", "Mscore" ] <- 2
> ##D predM[ "LM.Mscore", c( "Dscore", "sprengel" ) ] <- 1
> ##D 
> ##D # do imputations
> ##D imp <- mice::mice( dat, predictorMatrix=predM, m=3,  maxit=4,
> ##D          method=impMethod, allow.na=TRUE, pan.iter=100)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.2lonly.function")
> ### * mice.impute.2lonly.function
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.2lonly.function
> ### Title: Imputation at Level 2 (in 'miceadds')
> ### Aliases: mice.impute.2lonly.function
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of level 2 variables
> ##D #############################################################################
> ##D 
> ##D #**** Simulate some data
> ##D # x,y ... level 1 variables
> ##D # v,w ... level 2 variables
> ##D 
> ##D set.seed(987)
> ##D G <- 250            # number of groups
> ##D n <- 20             # number of persons
> ##D beta <- .3          # regression coefficient
> ##D rho <- .30          # residual intraclass correlation
> ##D rho.miss <- .10     # correlation with missing response
> ##D missrate <- .50     # missing proportion
> ##D y1 <- rep( stats::rnorm( G, sd=sqrt(rho)), each=n ) + stats::rnorm(G*n, sd=sqrt(1-rho))
> ##D w <- rep( round( stats::rnorm(G ), 2 ), each=n )
> ##D v <- rep( round( stats::runif( G, 0, 3 ) ), each=n )
> ##D x <-  stats::rnorm( G*n )
> ##D y <- y1 + beta  * x + .2 * w + .1 * v
> ##D dfr0 <- dfr <- data.frame( "group"=rep(1:G, each=n ), "x"=x, "y"=y,
> ##D         "w"=w, "v"=v )
> ##D dfr[ rho.miss * x + stats::rnorm( G*n, sd=sqrt( 1 - rho.miss ) ) <
> ##D                 stats::qnorm(missrate), "y" ] <- NA
> ##D dfr[ rep( stats::rnorm(G), each=n ) < stats::qnorm(missrate), "w" ] <- NA
> ##D dfr[ rep( stats::rnorm(G), each=n ) < stats::qnorm(missrate), "v" ] <- NA
> ##D 
> ##D #* initial predictor matrix and imputation methods
> ##D predM <- mice::make.predictorMatrix(data=dfr)
> ##D impM <- mice::make.method(data=dfr)
> ##D 
> ##D #...
> ##D # multilevel imputation
> ##D predM1 <- predM
> ##D predM1[c("w","v","y"),"group"] <- c(0,0,-2)
> ##D predM1["y","x"] <- 1        # fixed x effects imputation
> ##D impM1 <- impM
> ##D impM1[c("y","w","v")] <- c("2l.continuous", "2lonly.function", "2lonly.function" )
> ##D # define imputation functions
> ##D imputationFunction <- list( "w"="sample", "v"="pmm5" )
> ##D # define cluster variable
> ##D cluster_var <- list( "w"="group", "v"="group" )
> ##D 
> ##D # impute
> ##D imp1 <- mice::mice( as.matrix(dfr), m=1, predictorMatrix=predM1, method=impM1, maxit=5,
> ##D             imputationFunction=imputationFunction, cluster_var=cluster_var )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.bygroup")
> ### * mice.impute.bygroup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.bygroup
> ### Title: Groupwise Imputation Function
> ### Aliases: mice.impute.bygroup
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Cluster-specific imputation for some variables
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data( data.ma01, package="miceadds")
> ##D dat <- data.ma01
> ##D 
> ##D # use sub-dataset
> ##D dat <- dat[ dat$idschool <=1006, ]
> ##D V <- ncol(dat)
> ##D # create initial predictor matrix and imputation methods
> ##D predictorMatrix <- matrix( 1, nrow=V, ncol=V)
> ##D diag(predictorMatrix) <- 0
> ##D rownames(predictorMatrix) <- colnames(predictorMatrix) <- colnames(dat)
> ##D predictorMatrix[, c("idstud", "studwgt","urban" ) ] <- 0
> ##D method <- rep("norm", V)
> ##D names(method) <- colnames(dat)
> ##D 
> ##D #** groupwise imputation of variable books
> ##D method["books"] <- "bygroup"
> ##D # specify name of the grouping variable ('idschool') and imputation method ('norm')
> ##D group <- list( "books"="idschool" )
> ##D imputationFunction <- list("books"="norm" )
> ##D 
> ##D #** conduct multiple imputation in mice
> ##D imp <- mice::mice( dat, method=method, predictorMatrix=predictorMatrix,
> ##D             m=1, maxit=1, group=group, imputationFunction=imputationFunction )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Group-wise multilevel imputation '2l.pan'
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data( data.ma01, package="miceadds" )
> ##D dat <- data.ma01
> ##D 
> ##D # select data
> ##D dat <- dat[, c("idschool","hisei","books","female") ]
> ##D V <- ncol(dat)
> ##D dat <- dat[ ! is.na( dat$books), ]
> ##D # define factor variable
> ##D 
> ##D dat$books <- as.factor(dat$books)
> ##D # create initial predictor matrix and imputation methods
> ##D predictorMatrix <- matrix( 0, nrow=V, ncol=V)
> ##D rownames(predictorMatrix) <- colnames(predictorMatrix) <- colnames(dat)
> ##D predictorMatrix["idschool", ] <- 0
> ##D predictorMatrix[ "hisei", "idschool" ] <- -2
> ##D predictorMatrix[ "hisei", c("books","female") ] <- 1
> ##D method <- rep("", V)
> ##D names(method) <- colnames(dat)
> ##D method["hisei"] <- "bygroup"
> ##D group <- list( "hisei"="female" )
> ##D imputationFunction <- list("hisei"="2l.pan" )
> ##D 
> ##D #** conduct multiple imputation in mice
> ##D imp <- mice::mice( dat, method=method, predictorMatrix=predictorMatrix,
> ##D             m=1, maxit=1, group=group, imputationFunction=imputationFunction )
> ##D str(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.catpmm")
> ### * mice.impute.catpmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.catpmm
> ### Title: Imputation of a Categorical Variable Using Multivariate
> ###   Predictive Mean Matching
> ### Aliases: mice.impute.catpmm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation internat data
> ##D #############################################################################
> ##D 
> ##D data(data.internet, package="miceadds")
> ##D dat <- data.internet
> ##D 
> ##D #** empty imputation
> ##D imp0 <- mice::mice(dat, m=1, maxit=0)
> ##D method <- imp0$method
> ##D predmat <- imp0$predictorMatrix
> ##D 
> ##D #** define factor variable
> ##D 
> ##D dat1 <- dat
> ##D dat1[,1] <- as.factor(dat1[,1])
> ##D method[1] <- "catpmm"
> ##D 
> ##D #** impute with 'catpmm''
> ##D imp <- mice::mice(dat1, method=method1, m=5)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.constant")
> ### * mice.impute.constant
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.constant
> ### Title: Imputation Using a Fixed Vector
> ### Aliases: mice.impute.constant
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Example with fixed imputed values
> ##D #############################################################################
> ##D 
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D 
> ##D #* define methods
> ##D method <- c(age="", bmi="constant", hyp="norm", chl="pmm")
> ##D fixed_values <- list( bmi=rep(27,9) )
> ##D 
> ##D #* impute
> ##D imp <- mice::mice(dat, method=method, m=1, maxit=3, fixed_values=fixed_values)
> ##D table(mice::complete(imp, action=1)$bmi)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.hotDeck")
> ### * mice.impute.hotDeck
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.hotDeck
> ### Title: Imputation of a Variable Using Probabilistic Hot Deck Imputation
> ### Aliases: mice.impute.hotDeck
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Hot deck imputation NHANES dataset
> ##D #############################################################################
> ##D 
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D 
> ##D #*** prepare imputation method
> ##D vars <- colnames(dat)
> ##D V <- length(vars)
> ##D impMethod <- rep("hotDeck", V)
> ##D method <- "cor"
> ##D 
> ##D #*** imputation in mice
> ##D imp <- mice::mice( data=as.matrix(dat), m=1, method=impMethod, method=method )
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.imputeR.lmFun")
> ### * mice.impute.imputeR.lmFun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.imputeR.lmFun
> ### Title: Wrapper Function to Imputation Methods in the 'imputeR' Package
> ### Aliases: mice.impute.imputeR.lmFun mice.impute.imputeR.cFun
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Example with binary and continuous variables
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(imputeR)
> ##D 
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D dat$hyp <- as.factor(dat$hyp)
> ##D 
> ##D #* define imputation methods
> ##D method <- c(age="",bmi="norm",hyp="imputeR.cFun",chl="imputeR.lmFun")
> ##D Fun <- list( hyp=imputeR::ridgeC, chl=imputeR::ridgeR)
> ##D 
> ##D #** do imputation
> ##D imp <- mice::mice(dat1, method=method, maxit=10, m=4, Fun=Fun)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.ml.lmer")
> ### * mice.impute.ml.lmer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.ml.lmer
> ### Title: Multilevel Imputation Using 'lme4'
> ### Aliases: mice.impute.ml.lmer
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of three-level data with normally distributed residuals
> ##D #############################################################################
> ##D 
> ##D data(data.ma07, package="miceadds")
> ##D dat <- data.ma07
> ##D 
> ##D # variables at level 1 (identifier id1): x1 (some missings), x2 (complete)
> ##D # variables at level 2 (identifier id2): y1 (some missings), y2 (complete)
> ##D # variables at level 3 (identifier id3): z1 (some missings), z2 (complete)
> ##D 
> ##D #****************************************************************************
> ##D # Imputation model 1
> ##D 
> ##D #----- specify levels of variables (only relevent for variables
> ##D #      with missing values)
> ##D variables_levels <- miceadds:::mice_imputation_create_type_vector( colnames(dat), value="")
> ##D  # leave variables at lowest level blank (i.e., "")
> ##D variables_levels[ c("y1","y2") ] <- "id2"
> ##D variables_levels[ c("z1","z2") ] <- "id3"
> ##D 
> ##D #----- specify predictor matrix
> ##D predmat <- mice::make.predictorMatrix(data=dat)
> ##D predmat[, c("id2", "id3") ] <- 0
> ##D # set -2 for cluster identifier for level 3 variable z1
> ##D # because "2lonly" function is used
> ##D predmat[ "z1", "id3" ] <- -2
> ##D 
> ##D #----- specify imputation methods
> ##D method <- mice::make.method(data=dat)
> ##D method[c("x1","y1")] <- "ml.lmer"
> ##D method[c("z1")] <- "2lonly.norm"
> ##D 
> ##D #----- specify hierarchical structure of imputation models
> ##D levels_id <- list()
> ##D #** hierarchical structure for variable x1
> ##D levels_id[["x1"]] <- c("id2", "id3")
> ##D #** hierarchical structure for variable y1
> ##D levels_id[["y1"]] <- c("id3")
> ##D 
> ##D #----- specify random slopes
> ##D random_slopes <- list()
> ##D #** random slopes for variable x1
> ##D random_slopes[["x1"]] <- list( "id2"=c("x2"), "id3"=c("y1") )
> ##D # if no random slopes should be specified, the corresponding entry can be left empty
> ##D # and only a random intercept is used in the imputation model
> ##D 
> ##D #----- imputation in mice
> ##D imp1 <- mice::mice( dat, maxit=10, m=5, method=method,
> ##D             predictorMatrix=predmat, levels_id=levels_id,  random_slopes=random_slopes,
> ##D             variables_levels=variables_levels )
> ##D summary(imp1)
> ##D 
> ##D #****************************************************************************
> ##D # Imputation model 2
> ##D 
> ##D #----- impute x1 with predictive mean matching and y1 with normally distributed residuals
> ##D model <- list(x1="pmm", y1="continuous")
> ##D 
> ##D #----- assume only random intercepts
> ##D random_slopes <- NULL
> ##D 
> ##D #---- create interactions with z2 for all predictors in imputation models for x1 and y1
> ##D interactions <- list("x1"="z2", "y1"="z2")
> ##D 
> ##D #----- imputation in mice
> ##D imp2 <- mice::mice( dat, method=method, predictorMatrix=predmat,
> ##D                 levels_id=levels_id, random_slopes=random_slopes,
> ##D                 variables_levels=variables_levels, model=model, interactions=interactions)
> ##D summary(imp2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.plausible.values")
> ### * mice.impute.plausible.values
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.plausible.values
> ### Title: Plausible Value Imputation using Classical Test Theory and Based
> ###   on Individual Likelihood
> ### Aliases: mice.impute.plausible.values
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Plausible value imputation for data.ma04 | 2 scales
> ##D #############################################################################
> ##D 
> ##D data(data.ma04, package="miceadds")
> ##D dat <- data.ma04
> ##D 
> ##D # Scale 1 consists of items A1,...,A4
> ##D # Scale 2 consists of items B1,...,B5
> ##D dat$scale1 <- NA
> ##D dat$scale2 <- NA
> ##D 
> ##D #** inits imputation method and predictor matrix
> ##D res <- miceadds::mice_inits(dat, ignore=c("group") )
> ##D predM <- res$predictorMatrix
> ##D impMethod <- res$method
> ##D impMethod <- gsub("pmm", "norm", impMethod )
> ##D 
> ##D # look at missing proportions
> ##D colSums( is.na(dat) )
> ##D 
> ##D # redefine imputation methods for plausible value imputation
> ##D impMethod[ "scale1" ] <- "plausible.values"
> ##D predM[ "scale1",  ] <- 1
> ##D predM[ "scale1", c("A1", "A2",  "A3", "A4" ) ] <- 3
> ##D     # items corresponding to a scale should be declared by a 3 in the predictor matrix
> ##D impMethod[ "scale2" ] <- "plausible.values"
> ##D predM[,"scale2"  ] <- 0
> ##D predM[ "scale2",  c("A2","A3","A4","V6","V7") ] <- 1
> ##D diag(predM) <- 0
> ##D 
> ##D # use imputed scale values as predictors for V5, V6 and V7
> ##D predM[ c("V5","V6","V7"), c("scale1","scale2" ) ] <- 1
> ##D # exclude for V5, V6 and V7 the items of scales A and B as predictors
> ##D predM[ c("V5","V6","V7"), c( paste0("A",2:4), paste0("B",1:5) ) ] <- 0
> ##D # exclude 'group' as a predictor
> ##D predM[,"group"] <- 0
> ##D 
> ##D # look at imputation method and predictor matrix
> ##D impMethod
> ##D predM
> ##D 
> ##D #-------------------------------
> ##D # Parameter for imputation
> ##D #***
> ##D # scale 1 (A1,...,A4)
> ##D # known Cronbach's Alpha
> ##D alpha <- NULL
> ##D alpha <- list( "scale1"=.8 )
> ##D alpha.se <- list( "scale1"=.05 )  # sample alpha with a standard deviation of .05
> ##D 
> ##D #***
> ##D # scale 2 (B1,...,B5)
> ##D # means and SE's of scale scores are assumed to be known
> ##D M.scale2 <- rowMeans( dat[, paste("B",1:5,sep="")  ] )
> ##D # M.scale2[ is.na( m1) ] <- mean( M.scale2, na.rm=TRUE )
> ##D SE.scale2 <- rep( sqrt( stats::var(M.scale2,na.rm=T)*(1-.8) ), nrow(dat) )
> ##D #=> heterogeneous measurement errors are allowed
> ##D scale.values <- list( "scale2"=list( "M"=M.scale2, "SE"=SE.scale2 ) )
> ##D 
> ##D #*** Imputation Model 1: Imputation four using parallel chains
> ##D imp1 <- mice::mice( dat, predictorMatrix=predM, m=4, maxit=5,
> ##D           alpha.se=alpha.se, method=impMethod,  allow.na=TRUE, alpha=alpha,
> ##D           scale.values=scale.values  )
> ##D summary(imp1)
> ##D 
> ##D # extract first imputed dataset
> ##D dat11 <- mice::complete( imp, 1 )
> ##D 
> ##D #*** Imputation Model 2: Imputation using one long chain
> ##D imp2 <- miceadds::mice.1chain( dat, predictorMatrix=predM, burnin=10, iter=20, Nimp=4,
> ##D           alpha.se=alpha.se, method=impMethod,  allow.na=TRUE, alpha=alpha,
> ##D           scale.values=scale.values )
> ##D summary(imp2)
> ##D 
> ##D #-------------
> ##D #*** Imputation Model 3: Imputation including  group level variables
> ##D 
> ##D # use group indicator for plausible value estimation
> ##D predM[ "scale1", "group" ] <- -2
> ##D # V7 and B1 should be aggregated at the group level
> ##D predM[ "scale1", c("V7","B1") ] <- 2
> ##D predM[ "scale2", "group" ] <- -2
> ##D predM[ "scale2", c("V7","A1") ] <- 2
> ##D 
> ##D # perform single imputation (m=1)
> ##D imp <- mice::mice( dat, predictorMatrix=predM, m=1, maxit=10,
> ##D             method=impMethod,  allow.na=TRUE, alpha=alpha,
> ##D             scale.values=scale.values )
> ##D dat10 <- mice::complete(imp)
> ##D 
> ##D # multilevel model
> ##D library(lme4)
> ##D mod <- lme4::lmer( scale1 ~ ( 1 | group), data=dat11 )
> ##D summary(mod)
> ##D 
> ##D mod <- lme4::lmer( scale1 ~ ( 1 | group), data=dat10)
> ##D summary(mod)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Plausible value imputation with chained equations
> ##D #############################################################################
> ##D 
> ##D # - simulate a latent variable theta and dichotomous item responses
> ##D # - two covariates X in which the second covariate has measurement error
> ##D 
> ##D library(sirt)
> ##D library(TAM)
> ##D library(lavaan)
> ##D 
> ##D set.seed(7756)
> ##D N <- 2000    # number of persons
> ##D I <- 10     # number of items
> ##D 
> ##D # simulate covariates
> ##D X <- MASS::mvrnorm( N, mu=c(0,0), Sigma=matrix( c(1,.5,.5,1),2,2 ) )
> ##D colnames(X) <- paste0("X",1:2)
> ##D # second covariate with measurement error with variance var.err
> ##D var.err <- .3
> ##D X.err <- X
> ##D X.err[,2] <- X[,2] + stats::rnorm(N, sd=sqrt(var.err) )
> ##D # simulate theta
> ##D theta <- .5*X[,1] + .4*X[,2] + stats::rnorm( N, sd=.5 )
> ##D # simulate item responses
> ##D itemdiff <- seq( -2, 2, length=I)  # item difficulties
> ##D dat <- sirt::sim.raschtype( theta, b=itemdiff )
> ##D 
> ##D #***********************
> ##D #*** Model 0: Regression model with true variables
> ##D mod0 <- stats::lm( theta ~ X )
> ##D summary(mod0)
> ##D 
> ##D #**********************
> ##D # plausible value imputation for abilities and error-prone
> ##D # covariates using the mice package
> ##D 
> ##D # creating the likelihood for plausible value for abilities
> ##D mod11 <- TAM::tam.mml( dat )
> ##D likePV <- IRT.likelihood(mod11)
> ##D # creating the likelihood for error-prone covariate X2
> ##D # The known measurement error variance is 0.3.
> ##D lavmodel <- "
> ##D   X2true=~ 1*X2
> ##D   X2 ~~ 0.3*X2
> ##D     "
> ##D mod12 <- lavaan::cfa( lavmodel, data=as.data.frame(X.err) )
> ##D summary(mod12)
> ##D likeX2 <- IRTLikelihood.cfa( data=X.err, cfaobj=mod12)
> ##D str(likeX2)
> ##D 
> ##D #-- create data input for mice package
> ##D data <- data.frame( "PVA"=NA, "X1"=X[,1], "X2"=NA  )
> ##D vars <- colnames(data)
> ##D V <- length(vars)
> ##D predictorMatrix <- 1 - diag(V)
> ##D rownames(predictorMatrix) <- colnames(predictorMatrix) <- vars
> ##D method <- rep("norm", V )
> ##D names(method) <- vars
> ##D method[c("PVA","X2")] <- "plausible.values"
> ##D 
> ##D #-- create argument lists for plausible value imputation
> ##D # likelihood and theta grid of plausible value derived from IRT model
> ##D like <- list( "PVA"=likePV, "X2"=likeX2 )
> ##D theta <- list( "PVA"=attr(likePV,"theta"),
> ##D                 "X2"=attr(likeX2, "theta") )
> ##D #-- initial imputations
> ##D data.init <- data
> ##D data.init$PVA <- mod11$person$EAP
> ##D data.init$X2 <- X.err[,"X2"]
> ##D 
> ##D #-- imputation using the mice and miceadds package
> ##D imp1 <- mice::mice( as.matrix(data), predictorMatrix=predictorMatrix, m=4,
> ##D             maxit=6, method=method,  allow.na=TRUE,
> ##D             theta=theta, like=like, data.init=data.init )
> ##D summary(imp1)
> ##D 
> ##D # compute linear regression
> ##D mod4a <- with( imp1, stats::lm( PVA ~ X1 + X2 ) )
> ##D summary( mice::pool(mod4a) )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Plausible value imputation with known error variance
> ##D #############################################################################
> ##D 
> ##D #---- simulate data
> ##D set.seed(987)
> ##D N <- 1000         # number of persons
> ##D var_err <- .4     # error variance
> ##D dat <- data.frame( x1=stats::rnorm(N), x2=stats::rnorm(N) )
> ##D dat$theta <- .3 * dat$x1 - .5*dat$x2 + stats::rnorm(N)
> ##D dat$y <- dat$theta + stats::rnorm( N, sd=sqrt(var_err) )
> ##D 
> ##D #-- linear regression for measurement-error-free data
> ##D mod0a <- stats::lm( theta ~ x1 + x2, data=dat )
> ##D summary(mod0a)
> ##D #-- linear regression for data with measurement error
> ##D mod0b <- stats::lm( y ~ x1 + x2, data=dat )
> ##D summary(mod0b)
> ##D 
> ##D #-- process data for imputation
> ##D 
> ##D dat1 <- dat
> ##D dat1$theta <- NA
> ##D scale.values <- list( "theta"=list( "M"=dat$y, "SE"=rep(sqrt(var_err),N )))
> ##D dat1$y <- NULL
> ##D 
> ##D cn <- colnames(dat1)
> ##D V <- length(cn)
> ##D method <- rep("", length(cn) )
> ##D names(method) <- cn
> ##D method["theta"] <- "plausible.values"
> ##D 
> ##D #-- imputation in mice
> ##D imp <- mice::mice( dat1, maxit=1, m=5, allow.na=TRUE, method=method,
> ##D             scale.values=scale.values )
> ##D summary(imp)
> ##D 
> ##D #-- inspect first dataset
> ##D summary( mice::complete(imp, action=1) )
> ##D 
> ##D #-- linear regression based on imputed datasets
> ##D mod1 <- with(imp, stats::lm( theta ~ x1 + x2 ) )
> ##D summary( mice::pool(mod1) )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.pls")
> ### * mice.impute.pls
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.pls
> ### Title: Imputation using Partial Least Squares for Dimension Reduction
> ### Aliases: mice.impute.pls mice.impute.2l.pls2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: PLS imputation method for internet data
> ##D #############################################################################
> ##D 
> ##D data(data.internet)
> ##D dat <- data.internet
> ##D 
> ##D # specify predictor matrix
> ##D predictorMatrix <- matrix( 1, ncol(dat), ncol(dat) )
> ##D rownames(predictorMatrix) <- colnames(predictorMatrix) <- colnames(dat)
> ##D diag( predictorMatrix) <- 0
> ##D 
> ##D # use PLS imputation method for all variables
> ##D impMethod <- rep( "pls", ncol(dat) )
> ##D names(impMethod) <- colnames(dat)
> ##D 
> ##D # define predictors for interactions (entries with type 4 in predictorMatrix)
> ##D predictorMatrix[c("IN1","IN15","IN16"),c("IN1","IN3","IN10","IN13")] <- 4
> ##D # define predictors which should appear as linear and quadratic terms (type 5)
> ##D predictorMatrix[c("IN1","IN8","IN9","IN10","IN11"),c("IN1","IN2","IN7","IN5")] <- 5
> ##D 
> ##D # use 9 PLS factors for all variables
> ##D pls.facs <- as.list( rep( 9, length(impMethod) ) )
> ##D names(pls.facs) <- names(impMethod)
> ##D pls.facs$IN1 <- 15   # use 15 PLS factors for variable IN1
> ##D 
> ##D # choose norm or pmm imputation method
> ##D pls.impMethod <- as.list( rep("norm", length(impMethod) ) )
> ##D names(pls.impMethod) <- names(impMethod)
> ##D pls.impMethod[ c("IN1","IN6")] <- "pmm"
> ##D 
> ##D # some arguments for imputation method
> ##D pls.impMethodArgs <- list( "IN1"=list( "donors"=10 ),
> ##D                            "IN2"=list( "ridge2"=1E-4 ) )
> ##D 
> ##D # Model 1: Three parallel chains
> ##D imp1 <- mice::mice(data=dat, method=impMethod,
> ##D      m=3, maxit=5, predictorMatrix=predictorMatrix,
> ##D      pls.facs=pls.facs, # number of PLS factors
> ##D      pls.impMethod=pls.impMethod,  # Imputation Method in PLS imputation
> ##D      pls.impMethodArgs=pls.impMethodArgs, # arguments for imputation method
> ##D      pls.print.progress=TRUE, ls.meth="ridge" )
> ##D summary(imp1)
> ##D 
> ##D # Model 2: One long chain
> ##D imp2 <- miceadds::mice.1chain(data=dat, method=impMethod,
> ##D      burnin=10, iter=21, Nimp=3, predictorMatrix=predictorMatrix,
> ##D      pls.facs=pls.facs, pls.impMethod=pls.impMethod,
> ##D      pls.impMethodArgs=pls.impMethodArgs, ls.meth="ridge" )
> ##D summary(imp2)
> ##D 
> ##D # Model 3: inclusion of additional derived variables
> ##D 
> ##D # define derived variables for IN1
> ##D derived_vars <- list( "IN1"=~I( ifelse( IN2>IN3, IN2, IN3 ) ) + I( sin(IN2) ) )
> ##D 
> ##D imp3 <- miceadds::mice.1chain(data=dat, method=impMethod, derived_vars=derived_vars,
> ##D      burnin=10, iter=21, Nimp=3, predictorMatrix=predictorMatrix,
> ##D      pls.facs=pls.facs, pls.impMethod=pls.impMethod,
> ##D      pls.impMethodArgs=pls.impMethodArgs, ls.meth="ridge" )
> ##D summary(imp3)
> ##D 
> ##D #*** example for using imputation function at the level of a variable
> ##D 
> ##D # extract first imputed dataset
> ##D imp1 <- mice::complete(imp1, action=1)
> ##D data_imp1[ is.na(dat$IN1), "IN1" ] <- NA
> ##D 
> ##D # define variables
> ##D y <- data_imp1$IN1
> ##D x <- data_imp1[, -1 ]
> ##D ry <- ! is.na(y)
> ##D cn <- colnames(dat)
> ##D p <- ncol(dat)
> ##D type <- rep(1,p)
> ##D names(type) <- cn
> ##D type["IN1"] <- 0
> ##D 
> ##D # imputation of variable 'IN1'
> ##D imp0 <- miceadds::mice.impute.pls(y=y, x=x, ry=ry, type=type, pls.facs=10, pls.impMethod="norm",
> ##D              ls.meth="ridge", extract_data=FALSE )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.pmm3")
> ### * mice.impute.pmm3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.pmm3
> ### Title: Imputation by Predictive Mean Matching (in 'miceadds')
> ### Aliases: mice.impute.pmm3 mice.impute.pmm4 mice.impute.pmm5
> ###   mice.impute.pmm6
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # SIMULATED EXAMPLE 1: Two variables x and y with missing y
> ##D #############################################################################
> ##D set.seed(1413)
> ##D 
> ##D rho <- .6   # correlation between x and y
> ##D N <- 6800    # number of cases
> ##D x <- stats::rnorm(N)
> ##D My <- .35   # mean of y
> ##D y.com <- y <- My + rho * x + stats::rnorm(N, sd=sqrt( 1 - rho^2 ) )
> ##D 
> ##D # create missingness on y depending on rho.MAR parameter
> ##D rho.mar <- .4    # correlation response tendency z and x
> ##D missrate <- .25  # missing response rate
> ##D # simulate response tendency z and missings on y
> ##D z <- rho.mar * x + stats::rnorm(N, sd=sqrt( 1 - rho.mar^2 ) )
> ##D y[ z < stats::qnorm( missrate ) ] <- NA
> ##D dat <- data.frame(x, y )
> ##D 
> ##D # mice imputation
> ##D impmethod <- rep("pmm", 2 )
> ##D names(impmethod) <- colnames(dat)
> ##D 
> ##D # pmm (in mice)
> ##D imp1 <- mice::mice( as.matrix(dat), m=1, maxit=1, method=impmethod)
> ##D # pmm3 (in miceadds)
> ##D imp3 <- mice::mice( as.matrix(dat), m=1, maxit=1,
> ##D            method=gsub("pmm","pmm3",impmethod)  )
> ##D # pmm4 (in miceadds)
> ##D imp4 <- mice::mice( as.matrix(dat), m=1, maxit=1,
> ##D            method=gsub("pmm","pmm4",impmethod)  )
> ##D # pmm5 (in miceadds)
> ##D imp5 <- mice::mice( as.matrix(dat), m=1, maxit=1,
> ##D            method=gsub("pmm","pmm5",impmethod)  )
> ##D # pmm6 (in miceadds)
> ##D imp6 <- mice::mice( as.matrix(dat), m=1, maxit=1,
> ##D            method=gsub("pmm","pmm6",impmethod)  )
> ##D 
> ##D dat.imp1 <- mice::complete( imp1, 1 )
> ##D dat.imp3 <- mice::complete( imp3, 1 )
> ##D dat.imp4 <- mice::complete( imp4, 1 )
> ##D dat.imp5 <- mice::complete( imp5, 1 )
> ##D dat.imp6 <- mice::complete( imp6, 1 )
> ##D 
> ##D dfr <- NULL
> ##D # means
> ##D dfr <- rbind( dfr, c( mean( y.com ), mean( y, na.rm=TRUE ), mean( dat.imp1$y),
> ##D     mean( dat.imp3$y), mean( dat.imp4$y), mean( dat.imp5$y),  mean( dat.imp6$y)  ) )
> ##D # SD
> ##D dfr <- rbind( dfr, c( stats::sd( y.com ), stats::sd( y, na.rm=TRUE ),
> ##D       stats::sd( dat.imp1$y), stats::sd( dat.imp3$y), stats::sd( dat.imp4$y),
> ##D       stats::sd( dat.imp5$y), stats::sd( dat.imp6$y) ) )
> ##D # correlations
> ##D dfr <- rbind( dfr, c( stats::cor( x,y.com ),
> ##D     stats::cor( x[ ! is.na(y) ], y[ ! is.na(y) ] ),
> ##D     stats::cor( dat.imp1$x, dat.imp1$y), stats::cor( dat.imp3$x, dat.imp3$y),
> ##D     stats::cor( dat.imp4$x, dat.imp4$y), stats::cor( dat.imp5$x, dat.imp5$y),
> ##D     stats::cor( dat.imp6$x, dat.imp6$y)
> ##D         ) )
> ##D rownames(dfr) <- c("M_y", "SD_y", "cor_xy" )
> ##D colnames(dfr) <- c("compl", "ld", "pmm", "pmm3", "pmm4", "pmm5","pmm6")
> ##D ##           compl     ld    pmm   pmm3   pmm4   pmm5   pmm6
> ##D ##   M_y    0.3306 0.4282 0.3314 0.3228 0.3223 0.3264 0.3310
> ##D ##   SD_y   0.9910 0.9801 0.9873 0.9887 0.9891 0.9882 0.9877
> ##D ##   cor_xy 0.6057 0.5950 0.6072 0.6021 0.6100 0.6057 0.6069
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.rlm")
> ### * mice.impute.rlm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.rlm
> ### Title: Imputation of a Linear Model by Bayesian Bootstrap
> ### Aliases: mice.impute.rlm mice.impute.lqs mice.impute.lm
> ###   mice.impute.lm_fun
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Some toy example illustrating the methods
> ##D #############################################################################
> ##D 
> ##D library(MASS)
> ##D library(mice)
> ##D 
> ##D #-- simulate data
> ##D set.seed(98)
> ##D N <- 1000
> ##D x <- stats::rnorm(N)
> ##D z <- 0.5*x + stats::rnorm(N, sd=.7)
> ##D y <- stats::rnorm(N, mean=.3*x - .2*z, sd=1 )
> ##D dat <- data.frame(x,z,y)
> ##D dat[ seq(1,N,3), c("x","y") ] <- NA
> ##D dat[ seq(1,N,4), "z" ] <- NA
> ##D 
> ##D #-- define imputation methods
> ##D imp <- mice::mice(dat, maxit=0)
> ##D method <- imp$method
> ##D method["x"] <- "rlm"
> ##D method["z"] <- "lm"
> ##D method["y"] <- "lqs"
> ##D 
> ##D #-- impute data
> ##D imp <- mice::mice(dat, method=method)
> ##D summary(imp)
> ##D 
> ##D #--- example using transformations
> ##D dat1$x <- exp(dat1$x)
> ##D dat1$z <- stats::plogis(dat1$z)
> ##D 
> ##D trafo <- list(x=log, z=stats::qlogis)
> ##D antitrafo <- list(x=exp, z=stats::plogis)
> ##D 
> ##D #- impute with transformations
> ##D imp2 <- mice::mice(dat1, method=method, m=1, maxit=3, trafo=trafo, antitrafo=antitrafo)
> ##D print(imp2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.simputation")
> ### * mice.impute.simputation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.simputation
> ### Title: Wrapper Function to Imputation Methods in the 'simputation'
> ###   Package
> ### Aliases: mice.impute.simputation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nhanes example
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(simputation)
> ##D 
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D 
> ##D #** imputation methods
> ##D method <- c(age="",bmi="norm", hyp="norm", chl="simputation")
> ##D Fun <- list( chl=simputation::impute_lm)
> ##D Fun_args <- list( chl=list(add_residual="observed") )
> ##D 
> ##D #** do imputations
> ##D imp <- mice::mice(dat, method=method, Fun=Fun, Fun_args=Fun_args)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.smcfcs")
> ### * mice.impute.smcfcs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.smcfcs
> ### Title: Substantive Model Compatible Multiple Imputation (Single Level)
> ### Aliases: mice.impute.smcfcs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Substantive model with interaction effects
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D library(mdmb)
> ##D 
> ##D #--- simulate data
> ##D set.seed(98)
> ##D N <- 1000
> ##D x <- stats::rnorm(N)
> ##D z <- 0.5*x + stats::rnorm(N, sd=.7)
> ##D y <- stats::rnorm(N, mean=.3*x - .2*z + .7*x*z, sd=1 )
> ##D dat <- data.frame(x,z,y)
> ##D dat[ seq(1,N,3), c("x","y") ] <- NA
> ##D 
> ##D 
> ##D #--- define imputation methods
> ##D imp <- mice::mice(dat, maxit=0)
> ##D method <- imp$method
> ##D method["x"] <- "smcfcs"
> ##D 
> ##D # define substantive model
> ##D sm <- y ~ x*z
> ##D # define formulas for imputation models
> ##D formulas <- as.list( rep("",ncol(dat)))
> ##D names(formulas) <- colnames(dat)
> ##D formulas[["x"]] <- x ~ z
> ##D formulas[["y"]] <- sm
> ##D formulas[["z"]] <- z ~ 1
> ##D 
> ##D #- Yeo-Johnson distribution for x
> ##D dep_type <- list()
> ##D dep_type$x <- "yj"
> ##D 
> ##D #-- do imputation
> ##D imp <- mice::mice(dat, method=method, sm=sm, formulas=formulas, m=1, maxit=10,
> ##D                    dep_type=dep_type)
> ##D summary(imp)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Substantive model with quadratic effects
> ##D #############################################################################
> ##D 
> ##D #** simulate data with missings
> ##D set.seed(50)
> ##D n <- 1000
> ##D x <- stats::rnorm(n)
> ##D z <- stats::rnorm(n)
> ##D y <- 0.5 * z + x + x^2 + stats::rnorm(n)
> ##D mm <- stats::runif(n)
> ##D x[sample(1:n, size=370, prob=mm)] <- NA
> ##D z[sample(1:n, size=480, prob=mm)] <- NA
> ##D y[sample(1:n, size=500, prob=mm)] <- NA
> ##D 
> ##D df <- data.frame(x=x,y=y,z=z)
> ##D 
> ##D #** imputation
> ##D imp <- mice::mice(df, method="smcfcs", sm=y ~ z + x + I(x^2), m=6, maxit=10)
> ##D summary(imp)
> ##D 
> ##D #** analysis
> ##D summary(mice::pool(with(imp, stats::lm(y ~ z + x + I(x^2)))))
> ##D 
> ##D #** imputation using the smcfcs package
> ##D df$x_sq <- df$x^2
> ##D nonmice <- smcfcs::smcfcs(df, smtype="lm", smformula=y ~ z + x + x_sq,
> ##D              method=c("norm", "", "norm", "x^2"))
> ##D mice::pool(lapply(nonmice$impDatasets, function(x) stats::lm(y ~ z + x + x_sq, data=x)))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.synthpop")
> ### * mice.impute.synthpop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.synthpop
> ### Title: Using a 'synthpop' Synthesizing Method in the 'mice' Package
> ### Aliases: mice.impute.synthpop
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of NHANES data using the 'syn.normrank' method
> ##D #############################################################################
> ##D 
> ##D library(synthpop)
> ##D data(nhanes, package="mice")
> ##D dat <- nhanes
> ##D 
> ##D #* empty imputation
> ##D imp0 <- mice::mice(dat, maxit=0)
> ##D method <- imp0$method
> ##D 
> ##D #* define synthpop method 'normrank' for variable 'chl'
> ##D method["chl"] <- "synthpop"
> ##D synthpop_fun <- list( chl="normrank" )
> ##D synthpop_args <- list( chl=list(smoothing="density") )
> ##D 
> ##D #* conduct imputation
> ##D imp <- mice::mice(dat, method=method, m=1, maxit=3, synthpop_fun=synthpop_fun,
> ##D             synthpop_args=synthpop_args)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.tricube.pmm")
> ### * mice.impute.tricube.pmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.tricube.pmm
> ### Title: Imputation by Tricube Predictive Mean Matching
> ### Aliases: mice.impute.tricube.pmm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Tricube predictive mean matching for nhanes data
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D #*** Model 1: Use default of tricube predictive mean matching
> ##D varnames <- colnames(nhanes)
> ##D VV <- length(varnames)
> ##D method <- rep("tricube.pmm", VV )
> ##D names(method) <- varnames
> ##D # imputation with mice
> ##D imp.mi1 <- mice::mice( nhanes, m=5, maxit=4, method=method )
> ##D 
> ##D #*** Model 2: use item-specific imputation methods
> ##D iM2 <- method
> ##D iM2["bmi"] <- "pmm6"
> ##D # use imputation method 'tricube.pmm' for hyp and chl
> ##D # select different scale parameters for these variables
> ##D tricube.pmm.scale1 <- list( "hyp"=.15, "chl"=.30 )
> ##D imp.mi2 <- miceadds::mice.1chain( nhanes, burnin=5, iter=20, Nimp=4,
> ##D                method=iM2, tricube.pmm.scale=tricube.pmm.scale1  )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.impute.weighted.pmm")
> ### * mice.impute.weighted.pmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.impute.weighted.pmm
> ### Title: Imputation by Weighted Predictive Mean Matching or Weighted
> ###   Normal Linear Regression
> ### Aliases: mice.impute.weighted.pmm mice.impute.weighted.norm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation using sample weights
> ##D #############################################################################
> ##D 
> ##D data( data.ma01)
> ##D set.seed(977)
> ##D 
> ##D # select subsample
> ##D dat <- as.matrix(data.ma01)
> ##D dat <- dat[ 1:1000, ]
> ##D 
> ##D # empty imputation
> ##D imp0 <- mice::mice( dat, maxit=0)
> ##D 
> ##D # redefine imputation methods
> ##D meth <- imp0$method
> ##D meth[ meth=="pmm"  ] <- "weighted.pmm"
> ##D meth[ c("paredu", "books", "migrant" ) ] <- "weighted.norm"
> ##D # redefine predictor matrix
> ##D pm <- imp0$predictorMatrix
> ##D pm[, 1:3 ] <- 0
> ##D # do imputation
> ##D imp <- mice::mice( dat, predictorMatrix=pm, method=meth,
> ##D            imputationWeights=dat[,"studwgt"], m=3, maxit=5)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice.nmi")
> ### * mice.nmi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice.nmi
> ### Title: Nested Multiple Imputation
> ### Aliases: mice.nmi summary.mids.nmi print.mids.nmi
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nested multiple imputation for TIMSS data
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D    # list of 5 datasets containing 5 plausible values
> ##D 
> ##D #** define imputation method and predictor matrix
> ##D data <- datlist[[1]]
> ##D V <- ncol(data)
> ##D # variables
> ##D vars <- colnames(data)
> ##D # variables not used for imputation
> ##D vars_unused <- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )
> ##D 
> ##D #- define imputation method
> ##D impMethod <- rep("norm", V )
> ##D names(impMethod) <- vars
> ##D impMethod[ vars_unused ] <- ""
> ##D 
> ##D #- define predictor matrix
> ##D predM <- matrix( 1, V, V )
> ##D colnames(predM) <- rownames(predM) <- vars
> ##D diag(predM) <- 0
> ##D predM[, vars_unused ] <- 0
> ##D 
> ##D #***************
> ##D # (1) nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
> ##D                 m=4, maxit=3 )
> ##D summary(imp1)
> ##D 
> ##D #***************
> ##D # (2) nested multiple imputation using mice.1chain
> ##D imp2 <- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
> ##D             Nimp=4, burnin=10,iter=22, type="mice.1chain")
> ##D summary(imp2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice_imputation_2l_lmer")
> ### * mice_imputation_2l_lmer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice_imputation_2l_lmer
> ### Title: Imputation of a Continuous or a Binary Variable From a Two-Level
> ###   Regression Model using 'lme4' or 'blme'
> ### Aliases: mice.impute.2l.binary mice.impute.2l.continuous
> ###   mice.impute.2l.pmm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of a binary variable
> ##D #############################################################################
> ##D 
> ##D #--- simulate missing values
> ##D set.seed(976)
> ##D G <- 30        # number of groups
> ##D n <- 8        # number of persons per group
> ##D iccx <- .2    # intra-class correlation X
> ##D iccy <- .3    # latent intra-class correlation binary outcome
> ##D bx <- .4    # regression coefficient
> ##D threshy <- stats::qnorm(.70)  # threshold for y
> ##D x <- rep( rnorm( G, sd=sqrt( iccx) ), each=n )  +
> ##D             rnorm(G*n, sd=sqrt( 1 - iccx) )
> ##D y <- bx * x + rep( rnorm( G, sd=sqrt( iccy) ), each=n )  +
> ##D                 rnorm(G*n, sd=sqrt( 1 - iccy) )
> ##D y <- 1 * ( y > threshy )
> ##D dat <- data.frame( group=100+rep(1:G, each=n), x=x, y=y )
> ##D 
> ##D #* create some missings
> ##D dat1 <- dat
> ##D dat1[ seq( 1, G*n, 3 ),"y" ]  <- NA
> ##D dat1[ dat1$group==2, "y" ] <- NA
> ##D 
> ##D #--- prepare imputation in mice
> ##D vars <- colnames(dat1)
> ##D V <- length(vars)
> ##D #* predictor matrix
> ##D predmat <- matrix( 0, nrow=V, ncol=V)
> ##D rownames(predmat) <- colnames(predmat) <- vars
> ##D predmat["y", ] <- c(-2,2,0)
> ##D #* imputation methods
> ##D impmeth <- rep("",V)
> ##D names(impmeth) <- vars
> ##D impmeth["y"] <- "2l.binary"
> ##D 
> ##D #** imputation with logistic regression ('2l.binary')
> ##D imp1 <- mice::mice( data=as.matrix(dat1), method=impmeth,
> ##D                 predictorMatrix=predmat, maxit=1, m=5 )
> ##D 
> ##D #** imputation with predictive mean matching ('2l.pmm')
> ##D impmeth["y"] <- "2l.pmm"
> ##D imp2 <- mice::mice( data=as.matrix(dat1), method=impmeth,
> ##D                 predictorMatrix=predmat, maxit=1, m=5 )
> ##D 
> ##D #** imputation with logistic regression using blme package
> ##D blme_args <- list( "cov.prior"="invwishart")
> ##D imp3 <- mice::mice( data=as.matrix(dat1), method=impmeth,
> ##D                 predictorMatrix=predmat, maxit=1, m=5,
> ##D                 blme_use=TRUE, blme_args=blme_args )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mice_inits")
> ### * mice_inits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mice_inits
> ### Title: Arguments for 'mice::mice' Function
> ### Aliases: mice_inits
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Inits for mice imputation
> ##D #############################################################################
> ##D 
> ##D data(data.ma04, package="miceadds")
> ##D dat <- data.ma04
> ##D 
> ##D res <- miceadds::mice_inits(dat, ignore=c("group") )
> ##D str(res)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("miceadds-package")
> ### * miceadds-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: miceadds-package
> ### Title: Some Additional Multiple Imputation Functions, Especially for
> ###   'mice'
> ### Aliases: miceadds-package miceadds
> ### Keywords: package
> 
> ### ** Examples
> 
> ##
> ##   ::'''''''''''''''''''''''''''''''''::
> ##   :: miceadds 0.11-69 (2013-12-01)   ::
> ##   ::'''''''''''''''''''''''''''''''''::
> ##
> ##  ----------------------- mice at work ---------------------------------
> ##
> ##                         (\-.
> ##                         / _`> .---------.
> ##                 _)     / _)=  |'-------'|
> ##                (      / _/    |O   O   o|
> ##                 `-.__(___)_   | o O . o |
> ##                               `---------'
> ##
> ##                                          oo__
> ##                                         <;___)------
> ##                                    oo__   " "
> ##                                   <;___)------     oo__
> ##                                     " "           <;___)------
> ##                                                     " "
> 
> 
> 
> cleanEx()
> nameEx("micombine.F")
> ### * micombine.F
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: micombine.F
> ### Title: Combination of F Statistics for Multiply Imputed Datasets Using
> ###   a Chi Square Approximation
> ### Aliases: micombine.F
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: F statistics for 5 imputed datasets
> #############################################################################
> 
> Fvalues <- c( 6.76, 4.54, 4.23, 5.45, 4.78 )
> micombine.F(Fvalues, df1=4 )
Combination of Chi Square Statistics for Multiply Imputed Data
Using 5 Imputed Data Sets
F(4, 52.94)=3.946     p=0.00709 
>   ##  Combination of Chi Square Statistics for Multiply Imputed Data
>   ##  Using 5 Imputed Data Sets
>   ##  F(4, 52.94)=3.946     p=0.00709
> 
> 
> 
> cleanEx()
> nameEx("micombine.chisquare")
> ### * micombine.chisquare
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: micombine.chisquare
> ### Title: Combination of Chi Square Statistics of Multiply Imputed
> ###   Datasets
> ### Aliases: micombine.chisquare
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Chi square values of analyses from 7 multiply imputed datasets
> #############################################################################
> 
> # Vector of 7 chi square statistics
> dk <- c(24.957, 18.051, 18.812, 17.362, 21.234, 18.615, 19.84)
> dk.comb <- miceadds::micombine.chisquare(dk=dk, df=4 )
Combination of Chi Square Statistics for Multiply Imputed Data
Using 7 Imputed Data Sets
F(4, 482.06)=4.438     p=0.00157 
>   ##  Combination of Chi Square Statistics for Multiply Imputed Data
>   ##  Using 7 Imputed Data Sets
>   ##  F(4, 482.06)=4.438     p=0.00157
> 
> 
> 
> cleanEx()
> nameEx("micombine.cor")
> ### * micombine.cor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: micombine.cor
> ### Title: Inference for Correlations and Covariances for Multiply Imputed
> ###   Datasets
> ### Aliases: micombine.cor micombine.cov
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: nhanes data | combination of correlation coefficients
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes data in one chain
> ##D imp.mi <- miceadds::mice.1chain( nhanes, burnin=5, iter=20, Nimp=4,
> ##D                   method=rep("norm", 4) )
> ##D 
> ##D # correlation coefficients of variables 4, 2 and 3 (indexed in nhanes data)
> ##D res <- miceadds::micombine.cor(mi.res=imp.mi, variables=c(4,2,3) )
> ##D   ##     variable1 variable2       r    rse fisher_r fisher_rse    fmi       t      p
> ##D   ##   1       chl       bmi  0.2458 0.2236   0.2510     0.2540 0.3246  0.9879 0.3232
> ##D   ##   2       chl       hyp  0.2286 0.2152   0.2327     0.2413 0.2377  0.9643 0.3349
> ##D   ##   3       bmi       hyp -0.0084 0.2198  -0.0084     0.2351 0.1904 -0.0358 0.9714
> ##D   ##     lower95 upper95
> ##D   ##   1 -0.2421  0.6345
> ##D   ##   2 -0.2358  0.6080
> ##D   ##   3 -0.4376  0.4239
> ##D 
> ##D # extract matrix with correlations and its standard errors
> ##D attr(res, "r_matrix")
> ##D attr(res, "rse_matrix")
> ##D 
> ##D # inference for covariance
> ##D res2 <- miceadds::micombine.cov(mi.res=imp.mi, variables=c(4,2,3) )
> ##D 
> ##D # inference can also be conducted for non-imputed data
> ##D res3 <- miceadds::micombine.cov(mi.res=nhanes, variables=c(4,2,3) )
> ##D 
> ##D # partial correlation residualizing bmi and chl
> ##D res4 <- miceadds::micombine.cor(mi.res=imp.mi, variables=c("age","hyp" ),
> ##D                   partial=~bmi+chl )
> ##D res4
> ##D # alternatively, 'partial' can also be defined as c('age','hyp')
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: nhanes data | comparing different correlation coefficients
> ##D #############################################################################
> ##D 
> ##D library(psych)
> ##D library(mitools)
> ##D 
> ##D # imputing data
> ##D imp1 <- mice::mice( nhanes,  method=rep("norm", 4 ) )
> ##D summary(imp1)
> ##D 
> ##D #*** Pearson correlation
> ##D res1 <- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2) )
> ##D 
> ##D #*** Spearman rank correlation
> ##D res2 <- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2),  method="spearman")
> ##D 
> ##D #*** Kendalls tau
> ##D # test of computation of tau for first imputed dataset
> ##D dat1 <- mice::complete(imp1, action=1)
> ##D tau1 <- psych::corr.test(x=dat1[,c(4,2)], method="kendall")
> ##D tau1$r[1,2]    # estimate
> ##D tau1$se     # standard error
> ##D 
> ##D # results of Kendalls tau for all imputed datasets
> ##D res3 <- with( data=imp1,
> ##D         expr=psych::corr.test( x=cbind( chl, bmi ), method="kendall") )
> ##D # extract estimates
> ##D betas <- lapply( res3$analyses, FUN=function(ll){ ll$r[1,2] } )
> ##D # extract variances
> ##D vars <- lapply( res3$analyses, FUN=function(ll){ (ll$se[1,2])^2 } )
> ##D # Rubin inference
> ##D tau_comb <- mitools::MIcombine( results=betas, variances=vars )
> ##D summary(tau_comb)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Inference for correlations for nested multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss4, package="BIFIEsurvey" )
> ##D datlist <- data.timss4
> ##D 
> ##D # object of class nested.datlist
> ##D datlist <- miceadds::nested.datlist_create(datlist)
> ##D # inference for correlations
> ##D res2 <- miceadds::micombine.cor(mi.res=datlist, variables=c("lang", "migrant", "ASMMAT"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mids2datlist")
> ### * mids2datlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mids2datlist
> ### Title: Converting a 'mids', 'mids.1chain' or 'mids.nmi' Object in a
> ###   Dataset List
> ### Aliases: mids2datlist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputing nhanes data and convert result into a dataset list
> ##D #############################################################################
> ##D 
> ##D data(nhanes,package="mice")
> ##D 
> ##D #**** imputation using mice
> ##D imp1 <- mice::mice( nhanes, m=3, maxit=5 )
> ##D # convert mids object into list
> ##D datlist1 <- miceadds::mids2datlist( imp1 )
> ##D 
> ##D #**** imputation using mice.1chain
> ##D imp2 <- miceadds::mice.1chain( nhanes, burnin=4, iter=20, Nimp=5 )
> ##D # convert mids.1chain object into list
> ##D datlist2 <- miceadds::mids2datlist( imp2 )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Nested multiple imputation and datalist conversion
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D    # list of 5 datasets containing 5 plausible values
> ##D 
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D                 }
> ##D 
> ##D #***************
> ##D # (1) nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
> ##D summary(imp1)
> ##D 
> ##D #***************
> ##D # (2) nested multiple imputation using mice.1chain
> ##D imp2 <- miceadds::mice.nmi( datlist, Nimp=4, burnin=10,iter=22, type="mice.1chain")
> ##D summary(imp2)
> ##D 
> ##D #**************
> ##D # conversion into a datalist
> ##D datlist.i1 <- miceadds::mids2datlist( imp1 )
> ##D datlist.i2 <- miceadds::mids2datlist( imp2 )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: mids object conversion and inclusion of further variables
> ##D #############################################################################
> ##D 
> ##D data(data.ma05)
> ##D dat <- data.ma05
> ##D 
> ##D # imputation
> ##D resp <- dat[, - c(1:2) ]
> ##D imp <- mice::mice( resp, method="norm", maxit=2, m=3 )
> ##D 
> ##D # convert mids object into datalist
> ##D datlist0 <- miceadds::mids2datlist( imp )
> ##D # convert mids object into datalist and include some id variables
> ##D datlist1 <- miceadds::mids2datlist( imp, X=dat[,c(1,2) ] )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mids2mlwin")
> ### * mids2mlwin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mids2mlwin
> ### Title: Export 'mids' object to MLwiN
> ### Aliases: mids2mlwin
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # imputation nhanes data
> ##D data(nhanes)
> ##D imp <- mice::mice(nhanes)
> ##D # write files to MLwiN
> ##D mids2mlwin(imp, file.prefix="nhanes" )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ml_mcmc")
> ### * ml_mcmc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ml_mcmc
> ### Title: MCMC Estimation for Mixed Effects Model
> ### Aliases: ml_mcmc ml_mcmc_fit plot.ml_mcmc summary.ml_mcmc coef.ml_mcmc
> ###   vcov.ml_mcmc miceadds_rcpp_ml_mcmc_sample_beta
> ###   miceadds_rcpp_ml_mcmc_sample_u miceadds_rcpp_ml_mcmc_sample_psi
> ###   miceadds_rcpp_ml_mcmc_sample_sigma2
> ###   miceadds_rcpp_ml_mcmc_sample_latent_probit
> ###   miceadds_rcpp_ml_mcmc_sample_thresholds
> ###   miceadds_rcpp_ml_mcmc_predict_fixed_random
> ###   miceadds_rcpp_ml_mcmc_predict_random_list
> ###   miceadds_rcpp_ml_mcmc_predict_random
> ###   miceadds_rcpp_ml_mcmc_predict_fixed
> ###   miceadds_rcpp_ml_mcmc_subtract_fixed
> ###   miceadds_rcpp_ml_mcmc_subtract_random
> ###   miceadds_rcpp_ml_mcmc_compute_ztz miceadds_rcpp_ml_mcmc_compute_xtx
> ###   miceadds_rcpp_ml_mcmc_probit_category_prob miceadds_rcpp_pnorm
> ###   miceadds_rcpp_qnorm miceadds_rcpp_rtnorm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Multilevel model continuous data
> ##D #############################################################################
> ##D 
> ##D library(lme4)
> ##D 
> ##D #*** simulate data
> ##D set.seed(9097)
> ##D 
> ##D # number of clusters and units within clusters
> ##D K <- 150
> ##D n <- 15
> ##D iccx <- .2
> ##D idcluster <- rep( 1:K, each=n )
> ##D w <- stats::rnorm( K )
> ##D x <- rep( stats::rnorm( K, sd=sqrt(iccx) ), each=n) +
> ##D                stats::rnorm( n*K, sd=sqrt( 1 - iccx ))
> ##D X <- data.frame(int=1, "x"=x, xaggr=miceadds::gm(x, idcluster),
> ##D         w=rep( w, each=n ) )
> ##D X <- as.matrix(X)
> ##D Sigma <- diag( c(2, .5 ) )
> ##D u <- MASS::mvrnorm( K, mu=c(0,0), Sigma=Sigma )
> ##D beta <- c( 0, .3, .7, 1 )
> ##D Z <- X[, c("int", "x") ]
> ##D ypred <- as.matrix(X) %*% beta + rowSums( Z * u[ idcluster, ] )
> ##D y <- ypred[,1] + stats::rnorm( n*K, sd=1 )
> ##D data <- as.data.frame(X)
> ##D data$idcluster <- idcluster
> ##D data$y <- y
> ##D 
> ##D #*** estimate mixed effects model with miceadds::ml_mcmc() function
> ##D formula <- y ~ x + miceadds::gm(x, idcluster) + w + ( 1 + x | idcluster)
> ##D mod1 <- miceadds::ml_mcmc( formula=formula, data=data)
> ##D plot(mod1)
> ##D summary(mod1)
> ##D 
> ##D #*** compare results with lme4 package
> ##D mod2 <- lme4::lmer(formula=formula, data=data)
> ##D summary(mod2)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Multilevel model for ordinal outcome
> ##D #############################################################################
> ##D 
> ##D #*** simulate data
> ##D set.seed(456)
> ##D # number of clusters and units within cluster
> ##D K <- 500
> ##D n <- 10
> ##D iccx <- .2
> ##D idcluster <- rep( 1:K, each=n )
> ##D w <- rnorm( K )
> ##D x <- rep( stats::rnorm( K, sd=sqrt(iccx)), each=n) +
> ##D                  stats::rnorm( n*K, sd=sqrt( 1 - iccx ))
> ##D X <- data.frame("int"=1, "x"=x, "xaggr"=miceadds::gm(x, idcluster),
> ##D         w=rep( w, each=n ) )
> ##D X <- as.matrix(X)
> ##D u <- matrix( stats::rnorm(K, sd=sqrt(.5) ), ncol=1)
> ##D beta <- c( 0, .3, .7, 1 )
> ##D Z <- X[, c("int") ]
> ##D ypred <- as.matrix(X) %*% beta + Z * u[ idcluster, ]
> ##D y <- ypred[,1] + stats::rnorm( n*K, sd=1 )
> ##D data <- as.data.frame(X)
> ##D data$idcluster <- idcluster
> ##D alpha <- c(-Inf, -.4, 0, 1.7,  Inf)
> ##D data$y <- cut( y, breaks=alpha, labels=FALSE ) - 1
> ##D 
> ##D #*** estimate model
> ##D formula <- y ~ miceadds::cwc(x, idcluster) + miceadds::gm(x,idcluster) + w + ( 1 | idcluster)
> ##D mod <- miceadds::ml_mcmc( formula=formula, data=data, iter=2000, burnin=500,
> ##D                 outcome="probit", inits_lme4=FALSE)
> ##D summary(mod)
> ##D plot(mod)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nestedList2List")
> ### * nestedList2List
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nestedList2List
> ### Title: Converting a Nested List into a List (and Vice Versa)
> ### Aliases: nestedList2List List2nestedList
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: List conversions using a small example
> ##D #############################################################################
> ##D 
> ##D # define a nestedList
> ##D nestedList <- as.list(1:3)
> ##D nestedList[[1]] <- as.list( 2:4 )
> ##D nestedList[[2]] <- as.list( 34 )
> ##D nestedList[[3]] <- as.list( 4:9 )
> ##D 
> ##D # convert a nested list into a list
> ##D v2 <- miceadds::nestedList2List( nestedList)
> ##D 
> ##D ## reconvert list v2 into a nested list, looping within first
> ##D v3 <- miceadds::List2nestedList(v2, N_between=5)
> ##D # looping between first
> ##D v4 <- miceadds::List2nestedList(v2, N_between=5, loop_within=FALSE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nnig_sim")
> ### * nnig_sim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnig_sim
> ### Title: Simulation of Multivariate Linearly Related Non-Normal Variables
> ### Aliases: nnig_coef nnig_sim
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Simulating data with nnig_sim function
> ##D #############################################################################
> ##D 
> ##D #* define input parameters
> ##D Sigma <- matrix( c(1,.5, .2,
> ##D                   .5, 1,.7,
> ##D                   .2, .7, 1), 3, 3 )
> ##D skew <- c(0,1,1)
> ##D kurt <- c(1,3,3)
> ##D 
> ##D #* determine coefficients
> ##D coeff <- miceadds::nnig_coef( Sigma=Sigma, skew=skew, kurt=kurt )
> ##D print(coeff)
> ##D 
> ##D #* simulate data
> ##D set.seed(2018)
> ##D Y <- miceadds::nnig_sim( N=2000, coef=coeff)
> ##D 
> ##D #* check descriptive statistics
> ##D apply(Y, 2, TAM::weighted_skewness )
> ##D apply(Y, 2, TAM::weighted_kurtosis )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("output.format1")
> ### * output.format1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: output.format1
> ### Title: R Utilities: Formatting R Output on the R Console
> ### Aliases: output.format1
> 
> ### ** Examples
> 
> output.format1(stringtype="*'", label="HELLO WORLD", stringlength=20)

*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'
HELLO WORLD

> ##   *'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'
> ##   HELLO WORLD
> 
> 
> 
> cleanEx()
> nameEx("pca.covridge")
> ### * pca.covridge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pca.covridge
> ### Title: Principal Component Analysis with Ridge Regularization
> ### Aliases: pca.covridge
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: PCA on imputed internet data
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(data.internet)
> ##D dat <- as.matrix( data.internet)
> ##D 
> ##D # single imputation in mice
> ##D imp <- mice::mice( dat, m=1, maxit=10 )
> ##D 
> ##D # apply PCA
> ##D pca.imp <- miceadds::pca.covridge( complete(imp) )
> ##D   ##   > pca.imp$sdev
> ##D   ##      Comp.1    Comp.2    Comp.3    Comp.4    Comp.5    Comp.6    Comp.7
> ##D   ##   3.0370905 2.3950176 2.2106816 2.0661971 1.8252900 1.7009921 1.6379599
> ##D 
> ##D # compare results with princomp
> ##D pca2.imp <- stats::princomp( complete(imp) )
> ##D   ##   > pca2.imp
> ##D   ##   Call:
> ##D   ##   stats::princomp(x=complete(imp))
> ##D   ##
> ##D   ##   Standard deviations:
> ##D   ##      Comp.1    Comp.2    Comp.3    Comp.4    Comp.5    Comp.6    Comp.7
> ##D   ##   3.0316816 2.3907523 2.2067445 2.0625173 1.8220392 1.6979627 1.6350428
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pool.mids.nmi")
> ### * pool.mids.nmi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool.mids.nmi
> ### Title: Pooling for Nested Multiple Imputation
> ### Aliases: pool.mids.nmi summary.mipo.nmi coef.mipo.nmi vcov.mipo.nmi
> ###   NMIcombine NMIextract pool_nmi
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Nested multiple imputation and statistical inference
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D                }
> ##D 
> ##D #***************
> ##D # (1) nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
> ##D summary(imp1)
> ##D 
> ##D #***************
> ##D # (2) first linear regression: ASMMAT ~ migrant + female
> ##D res1 <- with( imp1, stats::lm( ASMMAT ~ migrant + female ) ) # fit
> ##D pres1 <- miceadds::pool.mids.nmi( res1 )  # pooling
> ##D summary(pres1)  # summary
> ##D coef(pres1)
> ##D vcov(pres1)
> ##D 
> ##D #***************
> ##D # (3) second linear regression: likesc ~ migrant + books
> ##D res2 <- with( imp1, stats::lm( likesc ~ migrant + books  ) )
> ##D pres2 <- miceadds::pool.mids.nmi( res2 )
> ##D summary(pres2)
> ##D 
> ##D #***************
> ##D # (4) some descriptive statistics using the mids.nmi object
> ##D res3 <- with( imp1, c( "M_lsc"=mean(likesc), "SD_lsc"=stats::sd(likesc) ) )
> ##D pres3 <- miceadds::NMIcombine( qhat=res3$analyses )
> ##D summary(pres3)
> ##D 
> ##D #*************
> ##D # (5) apply linear regression based on imputation list
> ##D 
> ##D # convert mids object to datlist
> ##D datlist2 <- miceadds::mids2datlist( imp1 )
> ##D str(datlist2, max.level=1)
> ##D 
> ##D # double application of lapply to the list of list of nested imputed datasets
> ##D res4 <- lapply( datlist2, FUN=function(dl){
> ##D     lapply( dl, FUN=function(data){
> ##D             stats::lm( ASMMAT ~ migrant + books, data=data )
> ##D                                 } )
> ##D                 }  )
> ##D 
> ##D # extract coefficients
> ##D qhat <- lapply( res4, FUN=function(bb){
> ##D             lapply( bb, FUN=function(ww){
> ##D                     coef(ww)
> ##D                         } )
> ##D                 } )
> ##D # shorter function
> ##D NMIextract( results=res4, fun=coef )
> ##D 
> ##D # extract covariance matrices
> ##D u <- lapply( res4, FUN=function(bb){
> ##D             lapply( bb, FUN=function(ww){
> ##D                     vcov(ww)
> ##D                         } )
> ##D                 } )
> ##D # shorter function
> ##D NMIextract( results=res4, fun=vcov )
> ##D 
> ##D # apply statistical inference using the NMIcombine function
> ##D pres4 <- miceadds::NMIcombine( qhat=qhat, u=u )
> ##D summary(pres4)
> ##D 
> ##D #--- statistical inference if only standard errors are available
> ##D # extract standard errors
> ##D se <- lapply( res4, FUN=function(bb){
> ##D             lapply( bb, FUN=function(ww){
> ##D                 # ww <- res4[[1]][[1]]
> ##D                 sww <- summary(ww)
> ##D                 sww$coef[,"Std. Error"]
> ##D                         } )
> ##D                 } )
> ##D se
> ##D # apply NMIcombine function
> ##D pres4b <- miceadds::NMIcombine( qhat=qhat, se=se )
> ##D # compare results
> ##D summary(pres4b)
> ##D summary(pres4)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Some comparisons for a multiply imputed dataset
> ##D #############################################################################
> ##D 
> ##D library(mitools)
> ##D data(data.ma02)
> ##D 
> ##D # save dataset as imputation list
> ##D imp <- mitools::imputationList( data.ma02 )
> ##D print(imp)
> ##D # save dataset as an mids object
> ##D imp1 <- miceadds::datlist2mids( imp )
> ##D 
> ##D # apply linear model based on imputationList
> ##D mod <- with( imp, stats::lm( read ~ hisei + female ) )
> ##D # same linear model based on mids object
> ##D mod1 <- with( imp1, stats::lm( read ~ hisei + female ) )
> ##D 
> ##D # extract coefficients
> ##D cmod <- mitools::MIextract( mod, fun=coef)
> ##D # extract standard errors
> ##D semod <- lapply( mod, FUN=function(mm){
> ##D                 smm <- summary(mm)
> ##D                 smm$coef[,"Std. Error"]
> ##D                         } )
> ##D # extract covariance matrix
> ##D vmod <- mitools::MIextract( mod, fun=vcov)
> ##D 
> ##D #*** pooling with NMIcombine with se (1a) and vcov (1b) as input
> ##D pmod1a <- miceadds::NMIcombine( qhat=cmod, se=semod, NMI=FALSE )
> ##D pmod1b <- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE )
> ##D # use method 2 which should conform to MI inference of mice::pool
> ##D pmod1c <- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE, method=2)
> ##D 
> ##D #*** pooling with mitools::MIcombine function
> ##D pmod2 <- mitools::MIcombine( results=cmod, variances=vmod )
> ##D #*** pooling with mice::pool function
> ##D pmod3a <- mice::pool( mod1 )
> ##D pmod3b <- mice::pool( mod1, method="Rubin")
> ##D 
> ##D #--- compare results
> ##D summary(pmod1a)   # method=1  (the default)
> ##D summary(pmod1b)   # method=1  (the default)
> ##D summary(pmod1c)   # method=2
> ##D summary(pmod2)
> ##D summary(pmod3a)
> ##D summary(pmod3b)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pool_mi")
> ### * pool_mi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pool_mi
> ### Title: Statistical Inference for Multiply Imputed Datasets
> ### Aliases: pool_mi summary.pool_mi coef.pool_mi vcov.pool_mi
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Statistical inference for models based on imputationList
> ##D #############################################################################
> ##D 
> ##D library(mitools)
> ##D library(mice)
> ##D library(Zelig)
> ##D library(mitml)
> ##D library(lavaan)
> ##D library(semTools)
> ##D data(data.ma02)
> ##D 
> ##D # save dataset as imputation list
> ##D imp <- mitools::imputationList( data.ma02 )
> ##D # mids object
> ##D imp0 <- miceadds::datlist2mids( imp )
> ##D # datlist object
> ##D imp1 <- miceadds::datlist_create(data.ma02)
> ##D 
> ##D #--- apply linear model based on imputationList
> ##D mod <- with( imp, stats::lm( read ~ hisei + female ) )
> ##D #--- apply linear model for mids object
> ##D mod0 <- with( imp0, stats::lm( read ~ hisei + female ) )
> ##D # extract coefficients
> ##D cmod <- mitools::MIextract( mod, fun=coef)
> ##D # extract standard errors
> ##D semod <- lapply( mod, FUN=function(mm){
> ##D     smm <- summary(mm)
> ##D     smm$coef[,"Std. Error"]
> ##D } )
> ##D # extract covariance matrix
> ##D vmod <- mitools::MIextract( mod, fun=vcov)
> ##D 
> ##D #*** pooling based on covariance matrices
> ##D res1 <- miceadds::pool_mi( qhat=cmod, u=vmod )
> ##D summary(res1)
> ##D coef(res1)
> ##D vcov(res1)
> ##D 
> ##D #*** pooling based on standard errors
> ##D res2 <- miceadds::pool_mi( qhat=cmod, se=semod )
> ##D 
> ##D #*** pooling with MIcombine
> ##D res3 <- mitools::MIcombine( results=cmod, variances=vmod )
> ##D 
> ##D #*** pooling with pool function in mice
> ##D res4 <- mice::pool( mod0 )
> ##D 
> ##D #*** analysis in Zelig
> ##D # convert datalist into object of class amelia
> ##D mi02 <- list( "imputations"=data.ma02)
> ##D class(mi02) <- "amelia"
> ##D res5 <- Zelig::zelig( read ~ hisei + female, model="ls", data=mi02 )
> ##D 
> ##D #*** analysis in lavaan
> ##D lavmodel <- "
> ##D      read ~ hisei + female
> ##D      read ~~ a*read
> ##D      read ~ 1
> ##D      # residual standard deviation
> ##D      sde :=sqrt(a)
> ##D        "
> ##D # analysis for first imputed dataset
> ##D mod6a <- lavaan::sem( lavmodel, data=imp1[[1]] )
> ##D summary(mod6a)
> ##D # analysis based on all datasets using with
> ##D mod6b <- lapply( imp1, FUN=function(data){
> ##D            res <- lavaan::sem( lavmodel, data=data )
> ##D            return(res)
> ##D                 } )
> ##D # extract parameters and covariance matrices
> ##D qhat0 <- lapply( mod6b, FUN=function(ll){  coef(ll) } )
> ##D u0 <- lapply( mod6b, FUN=function(ll){  vcov(ll) } )
> ##D res6b <- mitools::MIcombine( results=qhat0, variances=u0 )
> ##D 
> ##D # extract informations for all parameters
> ##D qhat <- lapply( mod6b, FUN=function(ll){
> ##D         h1 <- lavaan::parameterEstimates(ll)
> ##D         parnames <- paste0( h1$lhs, h1$op, h1$rhs )
> ##D         v1 <- h1$est
> ##D         names(v1) <- parnames
> ##D         return(v1)
> ##D      } )
> ##D se <- lapply( mod6b, FUN=function(ll){
> ##D         h1 <- lavaan::parameterEstimates(ll)
> ##D         parnames <- paste0( h1$lhs, h1$op, h1$rhs )
> ##D         v1 <- h1$se
> ##D         names(v1) <- parnames
> ##D         return(v1)
> ##D      } )
> ##D res6c <- miceadds::pool_mi( qhat=qhat, se=se )
> ##D 
> ##D # function runMI in semTools package
> ##D res6d <- semTools::runMI(model=lavmodel, data=imp1, m=length(imp1) )
> ##D   # semTools version 0.4-9 provided an error message
> ##D # perform inference with mitml package
> ##D se2 <- lapply( se, FUN=function(ss){  ss^2  } )  # input variances
> ##D res6e <- mitml::testEstimates(qhat=qhat, uhat=se2)
> ##D 
> ##D #*** complete model estimation and inference in mitml
> ##D 
> ##D # convert into object of class mitml.list
> ##D ml02 <- mitml::as.mitml.list( data.ma02)
> ##D # estimate regression
> ##D mod7 <- with( ml02, stats::lm( read ~ hisei + female ) )
> ##D # inference
> ##D res7 <- mitml::testEstimates( mod7 )
> ##D 
> ##D #*** model comparison
> ##D summary(res1)
> ##D summary(res2)
> ##D summary(res3)
> ##D summary(res4)
> ##D summary(res5)
> ##D summary(res6b)
> ##D summary(res6c)
> ##D print(res6e)
> ##D print(res7)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("round2")
> ### * round2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: round2
> ### Title: R Utilities: Rounding DIN 1333 (Kaufmaennisches Runden)
> ### Aliases: round2
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1:
> #############################################################################
> 
> vec <- c( 1.5, 2.5, 3.5, 1.51,  1.49)
> vec
[1] 1.50 2.50 3.50 1.51 1.49
> round(vec)
[1] 2 2 4 2 1
> round2(vec)
[1] 2 3 4 2 1
>   ##   > vec
>   ##   [1] 1.50 2.50 3.50 1.51 1.49
>   ##   > round(vec)
>   ##   [1] 2 2 4 2 1
>   ##   > miceadds::round2(vec)
>   ##   [1] 2 3 4 2 1
> 
> #############################################################################
> # EXAMPLE 2:
> #############################################################################
> 
> vec <- - c( 1.5, 2.5, 3.5, 1.51,  1.49)
> vec
[1] -1.50 -2.50 -3.50 -1.51 -1.49
> round(vec)
[1] -2 -2 -4 -2 -1
> round2(vec)
[1] -2 -3 -4 -2 -1
>   ##   > vec
>   ##   [1] -1.50 -2.50 -3.50 -1.51 -1.49
>   ##   > round(vec)
>   ##   [1] -2 -2 -4 -2 -1
>   ##   > miceadds::round2(vec)
>   ##   [1] -2 -3 -4 -2 -1
> 
> #############################################################################
> # EXAMPLE 3:
> #############################################################################
> 
> vec <- c(8.4999999, 8.5, 8.501, 7.4999999, 7.5, 7.501 )
> round(vec)
[1] 8 8 9 7 8 8
> round2( vec )
[1] 8 9 9 7 8 8
> round2( vec, digits=1)
[1] 8.5 8.5 8.5 7.5 7.5 7.5
> round2( -vec )
[1] -8 -9 -9 -7 -8 -8
>   ##   > round(vec)
>   ##   [1] 8 8 9 7 8 8
>   ##   > miceadds::round2( vec )
>   ##   [1] 8 9 9 7 8 8
>   ##   > miceadds::round2( vec, digits=1)
>   ##   [1] 8.5 8.5 8.5 7.5 7.5 7.5
>   ##   > miceadds::round2( -vec )
>   ##   [1] -8 -9 -9 -7 -8 -8
> 
> 
> 
> cleanEx()
> nameEx("save.Rdata")
> ### * save.Rdata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: save.Rdata
> ### Title: R Utilities: Save a Data Frame in 'Rdata' Format
> ### Aliases: save.Rdata
> 
> ### ** Examples
> 
> ## Not run: 
> ##D dfr <- matrix( 2*1:12-3, 4,3 )
> ##D save.Rdata( dfr, "dataframe_test" )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("save.data")
> ### * save.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: save.data
> ### Title: R Utilities: Saving/Writing Data Files using 'miceadds'
> ### Aliases: save.data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Save dataset data.ma01
> ##D #############################################################################
> ##D 
> ##D #*** use data.ma01 as an example for writing data files using save.data
> ##D data(data.ma01)
> ##D dat <- data.ma01
> ##D 
> ##D # set a working directory
> ##D pf2 <- "P:/ARb/temp_miceadds"
> ##D 
> ##D # save data in Rdata format
> ##D miceadds::save.data( dat, filename="ma01data", type="Rdata", path=pf2)
> ##D 
> ##D # save data in table format without row and column names
> ##D miceadds::save.data( dat, filename="ma01data", type="table", path=pf2,
> ##D             row.names=FALSE, na=".", col.names=FALSE)
> ##D 
> ##D # save data in csv2 format, including time stamp in file name
> ##D # and row index and time stamp in saved data
> ##D miceadds::save.data( dat, filename="ma01data", type="csv2", path=pf2,
> ##D             row.names=FALSE, na="", suffix=systime()[5],
> ##D             index=TRUE, systime=TRUE )
> ##D 
> ##D # save data in sav format
> ##D miceadds::save.data( dat, filename="ma02data", type="sav",  path=pf2 )
> ##D 
> ##D # save data file in different formats
> ##D types <- c("Rdata", "csv2", "sav")
> ##D sapply( types, FUN=function(type){
> ##D     miceadds::save.data( dat, filename="ma02data", type=type,  path=pf2,
> ##D                suffix=miceadds::systime()[3], row.names=TRUE  )
> ##D                                     } )
> ##D 
> ##D # save data frame in multiple file formats (sav, table and csv2)
> ##D miceadds::save.data( dat, filename="ma03data", type=c("sav","table","csv2"),  path=pf2,
> ##D             suffix=miceadds::systime()[7]  )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("scale_datlist")
> ### * scale_datlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scale_datlist
> ### Title: Adding a Standardized Variable to a List of Multiply Imputed
> ###   Datasets or a Single Datasets
> ### Aliases: scale_datlist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Standardized variables in list of multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D data(data.ma02)
> ##D datlist <- data.ma02
> ##D 
> ##D #--- object of class 'datlist'
> ##D datlist <- miceadds::datlist_create( datlist )
> ##D 
> ##D # mean and SD of variable hisei
> ##D miceadds::ma.wtd.meanNA(data=datlist, weights=datlist[[1]]$studwgt, vars="hisei" )
> ##D mean( unlist( lapply( datlist, FUN=function(data){
> ##D         stats::weighted.mean( data$hisei, data$studwgt )  } ) ) )
> ##D miceadds::ma.wtd.sdNA(data=datlist, weights=datlist[[1]]$studwgt, vars="hisei" )
> ##D mean( unlist( lapply( datlist, FUN=function(data){
> ##D         sqrt( Hmisc::wtd.var( data$hisei, data$studwgt ) ) } ) ) )
> ##D 
> ##D # standardize variable hisei to M=100 and SD=15
> ##D datlist1a <- miceadds::scale_datlist( datlist=datlist, orig_var="hisei",
> ##D                trafo_var="hisei100", weights=datlist[[1]]$studwgt, M=100, SD=15 )
> ##D 
> ##D # check mean and SD
> ##D miceadds::ma.wtd.meanNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
> ##D miceadds::ma.wtd.sdNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
> ##D 
> ##D #--- do standardization for unweighted sample with books <=3
> ##D # -> define a weighting variable at first
> ##D datlist0 <- mitools::imputationList( datlist )
> ##D datlist2a <- miceadds::within.imputationList( datlist0, {
> ##D              # define weighting variable
> ##D                  wgt_books <- 1 * ( books <=3 )
> ##D                     } )
> ##D 
> ##D # standardize variable hisei to M=100 and SD=15 with respect to weighting variable
> ##D datlist2b <- miceadds::scale_datlist( datlist=datlist2a, orig_var="hisei", trafo_var="hisei100",
> ##D          weights="wgt_books", M=100, SD=15 )
> ##D 
> ##D # check mean and SD (groupwise)
> ##D miceadds::ma.wtd.meanNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
> ##D miceadds::ma.wtd.sdNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
> ##D 
> ##D #--- transformation for a single dataset
> ##D dat0 <- datlist[[1]]
> ##D dat0a <- miceadds::scale_datlist( datlist=dat0, orig_var="hisei", trafo_var="hisei100",
> ##D                     weights=dat0$studwgt, M=100, SD=15 )
> ##D stats::weighted.mean( dat0a[,"hisei"],  w=dat0a$studwgt )
> ##D stats::weighted.mean( dat0a[,"hisei100"],  w=dat0a$studwgt )
> ##D sqrt( Hmisc::wtd.var( dat0a[,"hisei100"],  weights=dat0a$studwgt ) )
> ##D 
> ##D #--- Standardizations for objects of class imputationList
> ##D datlist2 <- mitools::imputationList(datlist)   # object class conversion
> ##D datlist2a <- miceadds::scale_datlist( datlist=datlist2, orig_var="hisei",
> ##D                  trafo_var="hisei100", weights=datlist[[1]]$studwgt, M=100, SD=15 )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Standardized variables in list of nested multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D # nested multiply imputed dataset in BIFIEsurvey package
> ##D data(data.timss4, package="BIFIEsurvey")
> ##D datlist <- data.timss4
> ##D wgt <- datlist[[1]][[1]]$TOTWGT
> ##D 
> ##D # class nested.datlist
> ##D imp1 <- miceadds::nested.datlist_create( datlist )
> ##D # class NestedImputationList
> ##D imp2 <- miceadds::NestedImputationList( datlist )
> ##D 
> ##D # standardize variable scsci
> ##D imp1a <- miceadds::scale_datlist( datlist=imp1, orig_var="scsci", trafo_var="zscsci", weights=wgt)
> ##D # check descriptives
> ##D miceadds::ma.wtd.meanNA( imp1a, weights=wgt, vars=c("scsci", "zscsci" ) )
> ##D miceadds::ma.wtd.sdNA( imp1a, weights=wgt, vars=c("scsci", "zscsci" ) )
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 3: Standardization of variables for imputed data in mice package
> ##D #############################################################################
> ##D 
> ##D data(nhanes, package="mice")
> ##D set.seed(76)
> ##D 
> ##D #--- impute nhanes data
> ##D imp <- mice::mice(nhanes)
> ##D #--- convert into datlist
> ##D datlist <- miceadds::mids2datlist(imp)
> ##D #--- scale datlist (all variables)
> ##D vars <- colnames(nhanes)
> ##D sdatlist <- miceadds::scale_datlist(datlist, orig_var=vars, trafo_var=paste0("z",vars) )
> ##D #--- reconvert to mids object
> ##D imp2 <- miceadds::datlist2mids(sdatlist)
> ##D #*** compare descriptive statistics of objects
> ##D round( miceadds::mean0( mice::complete(imp, action=1) ), 2 )
> ##D round( miceadds::mean0( mice::complete(imp2, action=1) ), 2 )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("scan.vector")
> ### * scan.vector
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scan.vec
> ### Title: R Utilities: Scan a Character Vector
> ### Aliases: scan.vec scan.vector scan0
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Example scan.vec | reading a string
> #############################################################################
> 
> 
> vars <- miceadds::scan.vector( "urbgrad \n  groesse  \t  Nausg  grpgroesse   privat  ")
> vars
[1] "urbgrad"    "groesse"    "Nausg"      "grpgroesse" "privat"    
>   ## [1] "urbgrad"    "groesse"    "Nausg"      "grpgroesse"
>   ## [6] "privat"
> 
> ## the next lines are only commented out to fulfill CRAN checks
> ## vars2 <- miceadds::scan0()
> ##     female urbgrad  groesse  Nausg    grpgroesse   privat
> 
> 
> 
> cleanEx()
> nameEx("source.all")
> ### * source.all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: source.all
> ### Title: R Utilities: Source all R or 'Rcpp' Files within a Directory
> ### Aliases: source.all source.Rcpp.all rcpp_create_header_file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # define path
> ##D path <- "c:/myfiles/"
> ##D # source all files containing the string 'Rex'
> ##D source.all( path, "Rex" )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stats0")
> ### * stats0
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stats0
> ### Title: Descriptive Statistics for a Vector or a Data Frame
> ### Aliases: stats0 max0 min0 mean0 sd0 var0 quantile0 prop_miss
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Descriptive statistics toy datasets
> #############################################################################
> 
> #--- simulate vector y and data frame dat
> set.seed(765)
> N <- 25    # number of observations
> y <- stats::rnorm(N)
> V <- 4    # number of variables
> dat <- matrix( stats::rnorm( N*V ), ncol=V )
> colnames(dat) <- paste0("V",1:V)
> 
> #-- standard deviation
> apply( dat, 2, stats::sd )
       V1        V2        V3        V4 
0.9480664 1.1013884 0.9019879 0.7371857 
> sd0( dat )
       V1        V2        V3        V4 
0.9480664 1.1013884 0.9019879 0.7371857 
> #-- mean
> apply( dat, 2, base::mean )
          V1           V2           V3           V4 
-0.226196785  0.574153533  0.112860173 -0.004732666 
> mean0( dat )
          V1           V2           V3           V4 
-0.226196785  0.574153533  0.112860173 -0.004732666 
> #-- quantile
> apply( dat, 2, stats::quantile )
              V1         V2         V3          V4
0%   -2.24235286 -0.8546087 -1.4362801 -1.07327985
25%  -0.83641426 -0.3645960 -0.5983010 -0.52963615
50%  -0.06835345  0.4787022 -0.1094036  0.06631764
75%   0.54462543  0.9859189  0.8828221  0.32541820
100%  1.18778051  3.1118669  1.6148352  2.15683057
> quantile0( dat )
              V1         V2         V3          V4
0%   -2.24235286 -0.8546087 -1.4362801 -1.07327985
25%  -0.83641426 -0.3645960 -0.5983010 -0.52963615
50%  -0.06835345  0.4787022 -0.1094036  0.06631764
75%   0.54462543  0.9859189  0.8828221  0.32541820
100%  1.18778051  3.1118669  1.6148352  2.15683057
> #-- minimum and maximum
> min0(dat)
        V1         V2         V3         V4 
-2.2423529 -0.8546087 -1.4362801 -1.0732798 
> max0(dat)
      V1       V2       V3       V4 
1.187781 3.111867 1.614835 2.156831 
> 
> #*** apply functions to missing data
> dat1 <- dat
> dat1[ cbind( c(2,5),2) ] <- NA
> 
> #-- proportion of missing data
> prop_miss( dat1 )
  V1   V2   V3   V4 
0.00 0.08 0.00 0.00 
> #-- MAD statistic
> stats0( dat, FUN=stats::mad )
       V1        V2        V3        V4 
1.1070882 1.1221094 1.1156242 0.8516409 
> #-- SD
> sd0(y)
[1] 1.02124
> 
> 
> 
> cleanEx()
> nameEx("str_C.expand.grid")
> ### * str_C.expand.grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str_C.expand.grid
> ### Title: R Utilities: String Paste Combined with 'expand.grid'
> ### Aliases: str_C.expand.grid
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Some toy examples
> #############################################################################
> 
> x1 <- list( c("a","b" ), c("t", "r","v") )
> str_C.expand.grid( x1 )
[1] "at" "bt" "ar" "br" "av" "bv"
>   ##   [1] "at" "bt" "ar" "br" "av" "bv"
> 
> x1 <- list( c("a","b" ), paste0("_", 1:4 ), c("t", "r","v") )
> str_C.expand.grid( x1, indices=c(2,1,3) )
 [1] "_1at" "_1bt" "_2at" "_2bt" "_3at" "_3bt" "_4at" "_4bt" "_1ar" "_1br"
[11] "_2ar" "_2br" "_3ar" "_3br" "_4ar" "_4br" "_1av" "_1bv" "_2av" "_2bv"
[21] "_3av" "_3bv" "_4av" "_4bv"
>   ##    [1] "_1at" "_1bt" "_2at" "_2bt" "_3at" "_3bt" "_4at" "_4bt" "_1ar" "_1br"
>   ##   [11] "_2ar" "_2br" "_3ar" "_3br" "_4ar" "_4br" "_1av" "_1bv" "_2av" "_2bv"
>   ##   [21] "_3av" "_3bv" "_4av" "_4bv"
> 
> ## Not run: 
> ##D ##***************************************************************************
> ##D ## The function 'str_C.expand.grid' is currently defined as
> ##D function( xlist, indices=NULL )
> ##D {
> ##D      xeg <- expand.grid( xlist)
> ##D      if ( ! is.null(indices) ){    xeg <- xeg[, indices ]}
> ##D      apply( xeg, 1, FUN=function(vv){ paste0( vv, collapse="") } )
> ##D }
> ##D ##***************************************************************************
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("subset_datlist")
> ### * subset_datlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subset_datlist
> ### Title: Subsetting Multiply Imputed Datasets and Nested Multiply Imputed
> ###   Datasets
> ### Aliases: subset_datlist subset.datlist subset.imputationList
> ###   subset.mids subset.mids.1chain subset_nested.datlist
> ###   subset.nested.datlist subset.NestedImputationList
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Subsetting and selection of multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D data(data.ma02)
> ##D 
> ##D # define original list of datasets
> ##D datlist1a <- data.ma02
> ##D # object of class datlist
> ##D datlist1b <- miceadds::datlist_create(datlist1a)
> ##D datlist1b
> ##D # object of class imputationList
> ##D datlist1c <- mitools::imputationList(datlist1a)
> ##D datlist1c
> ##D # object of class mids
> ##D datlist1d <- miceadds::datlist2mids(datlist1a)
> ##D datlist1d
> ##D 
> ##D # select some imputed datasets
> ##D datlist2a <- miceadds::subset_datlist( datlist1a, index=c(5,3,7) )
> ##D datlist2a
> ##D # convert to class imputationList
> ##D datlist2b <- miceadds::subset_datlist( datlist1a, index=c(5,3,7),
> ##D                       toclass="imputationList")
> ##D datlist2b
> ##D # convert to class mids
> ##D datlist2c <- miceadds::subset_datlist( datlist1a, index=1:3, toclass="mids")
> ##D datlist2c
> ##D 
> ##D # select some variables
> ##D datlist3a <- miceadds::subset_datlist( datlist1a, select=c("idstud", "books")  )
> ##D datlist3a
> ##D # Because datlist1b is a datlist it is equivalent to
> ##D datlist3b <- subset( datlist1b, select=c("idstud", "books")  )
> ##D datlist3b
> ##D # operating on imputationList class
> ##D datlist3c <- miceadds::subset_datlist( datlist1c, select=c("idstud", "books")  )
> ##D datlist3c
> ##D # operating on mids class
> ##D datlist3d <- miceadds::subset_datlist( datlist1d, select=c("idstud", "books")  )
> ##D datlist3d
> ##D # selection of rows and columns in multiply imputed datasets
> ##D datlist4a <- miceadds::subset_datlist( datlist1a, index=1:5,
> ##D                   subset=datlist1a[[1]]$idschool < 1067,
> ##D                   select=c("idstud", "idschool","hisei") )
> ##D datlist4a
> ##D # convert to class mids
> ##D datlist4b <- miceadds::subset_datlist( datlist1a, index=1:5,
> ##D                   subset=datlist1a[[1]]$idschool < 1067,
> ##D                   select=c("idstud", "idschool","hisei"), toclass="mids" )
> ##D datlist4b
> ##D # The same functionality, but now applying to object of class mids datlist1d
> ##D datlist4c <- miceadds::subset_datlist( datlist1d, index=1:5,
> ##D                subset=datlist1a[[1]]$idschool < 1067,
> ##D                select=c("idstud", "idschool","hisei") )
> ##D datlist4c
> ##D 
> ##D # expression for selecting rows specific in each data frame
> ##D # which can result in differently sized datasets (because the variable
> ##D # migrant is imputed)
> ##D datlist5a <- miceadds::subset_datlist( datlist1a,  expr_subset=expression(migrant==1) )
> ##D datlist5a
> ##D 
> ##D # select the first 100 cases
> ##D datlist6a <- miceadds::subset_datlist( datlist1a, select=c("idstud", "books"),
> ##D                        subset=1:100 )
> ##D datlist6a
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Subsetting and selection of nested multiply imputed datasets
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss4, package="BIFIEsurvey")
> ##D dat <- data.timss4
> ##D 
> ##D # create object of class 'nested.datlist'
> ##D datlist1a <- miceadds::nested.datlist_create( dat )
> ##D # create object of class 'NestedImputationList'
> ##D datlist1b <- miceadds::NestedImputationList(dat)
> ##D 
> ##D # select some between datasets
> ##D datlist2a <- subset_nested.datlist( datlist1a, index_between=c(1,3,4) )
> ##D datlist2a
> ##D # shorter version
> ##D datlist2b <- subset( datlist1a, index_between=c(1,3,4) )
> ##D datlist2b
> ##D # conversion of a NestedImputationList
> ##D datlist2c <- subset( datlist1b, index_between=c(1,3,4))
> ##D datlist2c
> ##D # select rows and columns
> ##D sel_cases <- datlist1a[[1]][[1]]$JKZONE <=42
> ##D datlist3a <- subset( datlist1a, subset=sel_cases,
> ##D                  select=c("IDSTUD","books", "ASMMAT") )
> ##D datlist3a
> ##D # remove within nest
> ##D datlist4a <- subset( datlist1a, index_within=1 )
> ##D datlist4a
> ##D # remove within nest and simplify structure
> ##D datlist4b <- subset( datlist1a, index_within=1, simplify=TRUE)
> ##D datlist4b
> ##D datlist4c <- subset( datlist1b, index_within=1, simplify=TRUE)
> ##D datlist4c
> ##D # remove between nest
> ##D datlist5a <- subset( datlist1a, index_between=1, simplify=TRUE)
> ##D datlist5a
> ##D datlist5b <- subset( datlist1b, index_between=1, simplify=TRUE)
> ##D datlist5b
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sumpreserving.rounding")
> ### * sumpreserving.rounding
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sumpreserving.rounding
> ### Title: Sum Preserving Rounding
> ### Aliases: sumpreserving.rounding
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1:
> #############################################################################
> 
> # define example data
> data <- c( 1455, 1261, 1067, 970, 582, 97 )
> data <- 100 * data / sum(data)
> 
> ( x1 <- round( data ) )
[1] 27 23 20 18 11  2
> sum(x1)
[1] 101
> (x2 <- miceadds::sumpreserving.rounding( data ) )
[1] 27 23 20 18 10  2
> sum(x2)
[1] 100
> 
>   ##   > ( x1 <- round( data ) )
>   ##   [1] 27 23 20 18 11  2
>   ##   > sum(x1)
>   ##   [1] 101
>   ##   > (x2 <- miceadds::sumpreserving.rounding( data ) )
>   ##   [1] 27 23 20 18 10  2
>   ##   > sum(x2)
>   ##   [1] 100
> 
> #############################################################################
> # EXAMPLE 2:
> #############################################################################
> 
> # matrix input
> data <- rbind( data, data )
> ( x1 <- round( data ) )
     [,1] [,2] [,3] [,4] [,5] [,6]
data   27   23   20   18   11    2
data   27   23   20   18   11    2
> rowSums(x1)
data data 
 101  101 
> (x2 <- miceadds::sumpreserving.rounding( data ) )
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]   27   23   20   18   10    2
[2,]   27   23   20   18   10    2
> rowSums(x2)
[1] 100 100
> 
> #############################################################################
> # EXAMPLE 3:
> #############################################################################
> 
> x2 <- c( 1.4, 1.4, 1.2 )
> round(x2)
[1] 1 1 1
> sumpreserving.rounding(x2)
[1] 1 2 1
>   ##   > round(x2)
>   ##   [1] 1 1 1
>   ##   > miceadds::sumpreserving.rounding(x2)
>   ##   [1] 1 2 1
> 
> 
> 
> cleanEx()
> nameEx("syn.constant")
> ### * syn.constant
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: syn.constant
> ### Title: Synthesizing Method for Fixed Values by Design in 'synthpop'
> ### Aliases: syn.constant
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: SD2011 | Fixed values for variable sex
> ##D #############################################################################
> ##D 
> ##D library(synthpop)
> ##D 
> ##D #** selection of dataset
> ##D data(SD2011, package="synthpop")
> ##D vars <- c("sex","age","ls","smoke")
> ##D dat  <- SD2011[1:1000, vars]
> ##D dat$ls <- as.numeric(dat$ls)
> ##D 
> ##D #** default synthesis
> ##D imp0 <- synthpop::syn(dat)
> ##D pred <- imp0$predictor.matrix
> ##D method <- imp0$method
> ##D 
> ##D #** constant vector
> ##D method["sex"] <- "constant"
> ##D fixed_values <- data.frame( sex=rep(dat$sex[c(1,2)], each=1000) )
> ##D imp <- synthpop::syn( dat, method=method, k=2000, m=1,
> ##D                 rf.fixed_values=fixed_values)
> ##D table(imp$syn$sex)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("syn.formula")
> ### * syn.formula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: syn.formula
> ### Title: Synthesizing Method for 'synthpop' Using a Formula Interface
> ### Aliases: syn.formula
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: SD2011 | using a formula for defining the regression model
> ##D #############################################################################
> ##D 
> ##D library(synthpop)
> ##D 
> ##D #** selection of dataset
> ##D data(SD2011, package="synthpop")
> ##D vars <- c("sex","age","ls","smoke")
> ##D dat  <- SD2011[1:1000, vars]
> ##D dat$ls <- as.numeric(dat$ls)
> ##D 
> ##D #** default synthesis
> ##D imp0 <- synthpop::syn(dat)
> ##D pred <- imp0$predictor.matrix
> ##D method <- imp0$method
> ##D 
> ##D #** use synthesizing method 'formula'
> ##D method["ls"] <- "formula"
> ##D syn_fun <- list( ls="normrank" )
> ##D syn_args <- list( ls=list( smoothing="density" ) )
> ##D syn_formula <- list( ls=~ sex + age + I(age^2) + I(age>50) )
> ##D 
> ##D #* synthesize data
> ##D imp <- synthpop::syn( dat, method=method, predictor.matrix=pred, k=2000, m=1,
> ##D             rf.syn_fun=syn_fun, rf.syn_args=syn_args, rf.syn_formula=syn_formula)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("syn.mice")
> ### * syn.mice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: syn.mice
> ### Title: Using a 'mice' Imputation Method in the 'synthpop' Package
> ### Aliases: syn.mice
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: SD2011 | Minimal example for using a mice imputation method
> ##D #############################################################################
> ##D 
> ##D library(synthpop)
> ##D 
> ##D #** selection of dataset
> ##D data(SD2011, package="synthpop")
> ##D vars <- c("sex","age","ls","smoke")
> ##D dat  <- SD2011[1:1000, vars]
> ##D dat$ls <- as.numeric(dat$ls)
> ##D dat$smoke <- 1*(paste(dat$smoke)=="YES")
> ##D 
> ##D #** default synthesis
> ##D imp0 <- synthpop::syn(dat)
> ##D pred <- imp0$predictor.matrix
> ##D method <- imp0$method
> ##D 
> ##D #** use mice imputation method 'rlm' for variable 'ls'
> ##D method[c("ls","smoke")] <- c("mice","mice")
> ##D mice_fun <- list( ls="rlm", smoke="pmm")
> ##D mice_args <- list( ls=list( trafo=log, antitrafo=exp) )
> ##D 
> ##D #* synthesize data
> ##D imp <- synthpop::syn( dat, method=method, predictor.matrix=pred, k=2000, m=1,
> ##D             rf.mice_fun=mice_fun, rf.mice_args=mice_args)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("syn_da")
> ### * syn_da
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: syn_da
> ### Title: Generation of Synthetic Data Utilizing Data Augmentation
> ### Aliases: syn_da
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Generate synthetic data with item responses and covariates
> ##D #############################################################################
> ##D 
> ##D data(data.ma09, package="miceadds")
> ##D dat <- data.ma09
> ##D 
> ##D # fixed variables in synthesis
> ##D fix_vars <- c("PV1MATH", "SEX","AGE")
> ##D # ordinal variables in synthesis
> ##D ord_vars <- c("FISCED", "MISCED", items)
> ##D # variables that should be synthesized
> ##D syn_vars <- c("HISEI", "FISCED", "MISCED", items)
> ##D 
> ##D #-- synthesize data
> ##D mod <- miceadds::syn_da( dat=dat0, syn_vars=syn_vars, fix_vars=fix_vars,
> ##D             ord_vars=ord_vars, da_noise=0.5, imp_maxit=2, use_pls=TRUE, ncomp=20,
> ##D             exact_regression=TRUE, exact_marginal=TRUE)
> ##D #- extract synthetic dataset
> ##D mod$dat_syn
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("syn_mice")
> ### * syn_mice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: syn_mice
> ### Title: Constructs Synthetic Dataset with 'mice' Imputation Methods
> ### Aliases: syn_mice
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Synthesization of SD2011 using mice functionality
> ##D #############################################################################
> ##D 
> ##D library(synthpop)
> ##D 
> ##D #** selection of dataset
> ##D data(SD2011, package="synthpop")
> ##D vars <- c("sex","age","ls","smoke")
> ##D dat  <- SD2011[1:1000, vars]
> ##D dat$ls <- as.numeric(dat$ls)
> ##D 
> ##D #** default synthesis
> ##D imp0 <- synthpop::syn(dat)
> ##D pred0 <- imp0$predictor.matrix
> ##D method0 <- imp0$method
> ##D 
> ##D #* define imputation methods
> ##D method <- c(sex="synthpop", age="synthpop", ls="synthpop", smoke="logreg")
> ##D # only for smoke, an original mice imputation method is used
> ##D 
> ##D #- define synthpop functions
> ##D synthpop_fun <- list(sex="constant", age="constant", ls="cart")
> ##D 
> ##D #- arguments for 'syn.cart' method
> ##D synthpop_args <- list(ls=list(smoothing="density"))
> ##D 
> ##D #- fixed values for 'syn.constant' method
> ##D fixed_values <- dat[,1:2]
> ##D 
> ##D #- do synthesization
> ##D imp <- miceadds::syn_mice(dat, m=1, synthpop_fun=synthpop_fun, method=method,
> ##D             pedictorMatrix=pred0, rf.fixed_values=fixed_values, synthpop_args=synthpop_args)
> ##D summary(imp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("systime")
> ### * systime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: systime
> ### Title: R Utilities: Various Strings Representing System Time
> ### Aliases: systime
> 
> ### ** Examples
> 
> #############################################################################
> # EXAMPLE 1: Output of systime
> #############################################################################
> 
> systime()
[1] "2024-12-19 17:57:13"         "2024-12-19"                 
[3] "20241219"                    "2024-12-19_1757"            
[5] "2024-12-19_1700"             "20241219_175713"            
[7] "20241219175713"              "3fe59e189152_20241219175713"
>   ##
>   ##  > miceadds::systime()
>   ##  [1] "2016-02-29 10:25:44"
>   ##  [2] "2016-02-29"
>   ##  [3] "20160229"
>   ##  [4] "2016-02-29_1025"
>   ##  [5] "2016-02-29_1000"
>   ##  [6] "20160229_102544"
>   ##  [7] "20160229102544"
>   ##  [8] "IPNERZW-C014_20160229102544"
> 
> 
> 
> cleanEx()
> nameEx("tw.imputation")
> ### * tw.imputation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tw.imputation
> ### Title: Two-Way Imputation
> ### Aliases: tw.imputation tw.mcmc.imputation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Two-way imputation data.internet
> ##D #############################################################################
> ##D 
> ##D data(data.internet)
> ##D data <- data.internet
> ##D 
> ##D #***
> ##D # Model 1: Two-way imputation method of Sijtsma and van der Ark (2003)
> ##D set.seed(765)
> ##D dat.imp <- miceadds::tw.imputation( data )
> ##D dat.imp[ 278:281,]
> ##D   ##       IN9     IN10    IN11     IN12
> ##D   ##   278   5 4.829006 5.00000 4.941611
> ##D   ##   279   5 4.000000 4.78979 4.000000
> ##D   ##   280   7 4.000000 7.00000 7.000000
> ##D   ##   281   4 3.000000 5.00000 5.000000
> ##D 
> ##D #***
> ##D # Model 2: Two-way imputation method using MCMC
> ##D dat.imp <- miceadds::tw.mcmc.imputation( data, iter=3)
> ##D dat.imp[ 278:281,]
> ##D   ##       IN9     IN10     IN11     IN12
> ##D   ##   278   5 6.089222 5.000000 3.017244
> ##D   ##   279   5 4.000000 5.063547 4.000000
> ##D   ##   280   7 4.000000 7.000000 7.000000
> ##D   ##   281   4 3.000000 5.000000 5.000000
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("visitSequence.determine")
> ### * visitSequence.determine
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: visitSequence.determine
> ### Title: Automatic Determination of a Visit Sequence in 'mice'
> ### Aliases: visitSequence.determine
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Visit sequence for a small imputation model
> ##D #############################################################################
> ##D 
> ##D data( data.smallscale )
> ##D # select a small number of variables
> ##D dat <- data.smallscale[, paste0("v",1:4) ]
> ##D V <- ncol(dat)
> ##D 
> ##D # define initial vector of imputation methods
> ##D impMethod <- rep("norm", V)
> ##D names(impMethod) <- colnames(dat)
> ##D # define variable names and imputation method for passive variables in a data frame
> ##D dfr.impMeth <- data.frame( "variable"=NA,
> ##D                   "impMethod"=NA )
> ##D dfr.impMeth[1,] <- c("v1_v1", "~ I(v1^2)" )
> ##D dfr.impMeth[2,] <- c("v2_v4", "~ I(v2*v4)" )
> ##D dfr.impMeth[3,] <- c("v4log", "~ I( log(abs(v4)))" )
> ##D dfr.impMeth[4,] <- c("v12", "~ I( v1 + v2 + 3*v1_v1 - v2_v4 )" )
> ##D # add variables to dataset and imputation methods
> ##D VV <- nrow(dfr.impMeth)
> ##D for (vv in 1:VV){
> ##D     impMethod[ dfr.impMeth[vv,1] ] <- dfr.impMeth[vv,2]
> ##D     dat[, dfr.impMeth[vv,1] ] <- NA
> ##D }
> ##D 
> ##D # run empty imputation model to obtain initial vector of visit sequence
> ##D imp0 <- mice::mice( dat, m=1, method=impMethod, maxit=0 )
> ##D imp0$vis
> ##D 
> ##D # update visit sequence
> ##D vis1 <- miceadds::visitSequence.determine( impMethod=impMethod, vis=imp0$vis, data=dat)
> ##D 
> ##D # imputation with updated visit sequence
> ##D imp <- mice::mice( dat, m=1, method=impMethod, visitSequence=vis1, maxit=2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("with.miceadds")
> ### * with.miceadds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: with.miceadds
> ### Title: Evaluates an Expression for (Nested) Multiply Imputed Datasets
> ### Aliases: with.mids.1chain with.mids.nmi with.NestedImputationList
> ###   with.datlist with.nested.datlist within.imputationList
> ###   within.NestedImputationList within.datlist within.nested.datlist
> ###   summary.mira.nmi withPool_MI withPool_NMI
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: One chain nhanes data | application of 'with' and 'within'
> ##D #############################################################################
> ##D 
> ##D library(mice)
> ##D data(nhanes, package="mice")
> ##D set.seed(9090)
> ##D 
> ##D # nhanes data in one chain
> ##D imp <- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4 )
> ##D # apply linear regression
> ##D res <- with( imp, expr=stats::lm( hyp ~ age + bmi  ) )
> ##D summary(res)
> ##D # pool results
> ##D summary( mice::pool(res))
> ##D 
> ##D # calculate some descriptive statistics
> ##D res2 <- with( imp, expr=c("M1"=mean(hyp), "SD_age"=stats::sd(age) ) )
> ##D # pool estimates
> ##D withPool_MI(res2)
> ##D 
> ##D # with method for datlist
> ##D imp1 <- miceadds::datlist_create(imp)
> ##D res2b <- with( imp1, fun=function(data){
> ##D                     dfr <- data.frame("M"=colMeans(data),
> ##D                              "Q5"=apply( data, 2, stats::quantile, .05 ),
> ##D                              "Q95"=apply( data, 2, stats::quantile, .95 ) )
> ##D                     return(dfr)
> ##D                         } )
> ##D withPool_MI(res2b)
> ##D 
> ##D # convert mids object into an object of class imputationList
> ##D datlist <- miceadds::mids2datlist( imp )
> ##D datlist <- mitools::imputationList(datlist)
> ##D 
> ##D # define formulas for modification of the data frames in imputationList object
> ##D datlist2 <- within( datlist, {
> ##D                      age.D3 <- 1*(age==3)
> ##D                      hyp_chl <- hyp * chl
> ##D                         } )
> ##D # look at modified dataset
> ##D head( datlist2$imputations[[1]] )
> ##D 
> ##D # convert into a datlist
> ##D datlist2b <- miceadds::datlist_create( datlist2 )
> ##D 
> ##D # apply linear model using expression
> ##D mod1a <- with( datlist2, expr=stats::lm( hyp ~ age.D3 ) )
> ##D # do the same but now with a function argument
> ##D mod1b <- with( datlist2, fun=function(data){
> ##D                     stats::lm( data$hyp ~ data$age.D3 )
> ##D                         } )
> ##D # apply the same model for object datlist2b
> ##D mod2a <- with( datlist2b, expr=lm( hyp ~ age.D3 ) )
> ##D mod2b <- with( datlist2b, fun=function(data){
> ##D                     stats::lm( data$hyp ~ data$age.D3 )
> ##D                         } )
> ##D 
> ##D mitools::MIcombine(mod1a)
> ##D mitools::MIcombine(mod1b)
> ##D mitools::MIcombine(mod2a)
> ##D mitools::MIcombine(mod2b)
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Nested multiple imputation and application of with/within methods
> ##D #############################################################################
> ##D 
> ##D library(BIFIEsurvey)
> ##D data(data.timss2, package="BIFIEsurvey" )
> ##D datlist <- data.timss2
> ##D 
> ##D # remove first four variables
> ##D M <- length(datlist)
> ##D for (ll in 1:M){
> ##D     datlist[[ll]] <- datlist[[ll]][, -c(1:4) ]
> ##D                 }
> ##D 
> ##D # nested multiple imputation using mice
> ##D imp1 <- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
> ##D summary(imp1)
> ##D # apply linear model and use summary method for all analyses of imputed datasets
> ##D res1 <- with( imp1, stats::lm( ASMMAT ~ migrant + female ) )
> ##D summary(res1)
> ##D 
> ##D # convert mids.nmi object into an object of class NestedImputationList
> ##D datlist1 <- miceadds::mids2datlist( imp1 )
> ##D datlist1 <- miceadds::NestedImputationList( datlist1 )
> ##D # convert into nested.datlist object
> ##D datlist1b <- miceadds::nested.datlist_create(datlist1)
> ##D 
> ##D # use with function
> ##D res1b <- with( datlist1, stats::glm( ASMMAT ~ migrant + female ) )
> ##D # apply for nested.datlist
> ##D res1c <- with( datlist1b, stats::glm( ASMMAT ~ migrant + female ) )
> ##D 
> ##D # use within function for data transformations
> ##D datlist2 <- within( datlist1, {
> ##D                 highsc <- 1*(ASSSCI > 600)
> ##D                 books_dum <- 1*(books>=3)
> ##D                 rm(scsci)   # remove variable scsci
> ##D                     } )
> ##D 
> ##D # include random number in each dataset
> ##D N <- attr( datlist1b, "nobs")
> ##D datlist3 <- within( datlist1b, {
> ##D                 rn <- stats::runif( N, 0, .5 )
> ##D                     } )
> ##D 
> ##D #-- some applications of withPool_NMI
> ##D # mean and SD
> ##D res3a <- with( imp1, c( "m1"=mean(ASMMAT), "sd1"=stats::sd(ASMMAT) ) )
> ##D withPool_NMI(res3a)
> ##D # quantiles
> ##D vars <- c("ASMMAT", "lang", "scsci")
> ##D res3b <- with( datlist1b, fun=function(data){
> ##D                 dat <- data[,vars]
> ##D                 res0 <- sapply( vars, FUN=function(vv){
> ##D                     stats::quantile( dat[,vv], probs=c(.25, .50, .75) )
> ##D                                     } )
> ##D                 t(res0)
> ##D                     } )
> ##D withPool_NMI(res3b)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write.datlist")
> ### * write.datlist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.datlist
> ### Title: Write a List of Multiply Imputed Datasets
> ### Aliases: write.datlist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Write data list imputed in mice
> ##D #############################################################################
> ##D 
> ##D data(data.ma01)
> ##D dat <- as.matrix(data.ma01)
> ##D 
> ##D # start with empty imputation
> ##D imp0 <- mice::mice( dat, maxit=0)
> ##D 
> ##D # modify predictor matrix
> ##D predM <- imp0$predictorMatrix
> ##D predM[, c("idschool", "idstud" ) ] <- 0
> ##D # modify imputation method
> ##D impMeth <- imp0$method
> ##D impMeth[ impMeth=="pmm" ] <- "norm"
> ##D 
> ##D # do imputations in mice
> ##D imp <- mice::mice( dat, predictorMatrix=predM, method=impMeth, m=3, maxit=4 )
> ##D 
> ##D # write imputed data in format "csv2" and round after 4 digits
> ##D write.datlist( datlist=imp, name="mice_imp_csv2", round=4 )
> ##D # write imputed data in R binary format
> ##D write.datlist( datlist=imp, name="mice_imp_Rdata", type="Rdata")
> ##D # write data for Mplus usage
> ##D write.datlist( datlist=imp, name="mice_imp_Mplus", Mplus=TRUE, round=5)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write.fwf2")
> ### * write.fwf2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.fwf2
> ### Title: Reading and Writing Files in Fixed Width Format
> ### Aliases: write.fwf2 read.fwf2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Write and read a file in fixed width format
> ##D #############################################################################
> ##D 
> ##D # set working directory
> ##D path <- "P:/ARb/temp"
> ##D setwd(path)
> ##D 
> ##D # define a data frame
> ##D set.seed(9876)
> ##D dat <- data.frame( "x"=seq( 1, 21, len=5), "y"=stats::runif( 5 ),
> ##D             "z"=stats::rnorm( 5 ) )
> ##D 
> ##D # save data frame in fixed width format
> ##D format.full <- c(6, 6, 8 )
> ##D format.round <- c( 0, 2, 3 )
> ##D write.fwf2( dat, format.full=format.full, format.round=format.round,
> ##D                 file="testdata" )
> ##D 
> ##D # read the data
> ##D dat1 <- miceadds::read.fwf2( file="testdata.dat", format.full=c(6,6,8),
> ##D                variables=c("x","y","z") )
> ##D # check differences between data frames
> ##D dat - dat1
> ##D 
> ##D #############################################################################
> ##D # EXAMPLE 2: Write datasets containing some string variables in fwf format
> ##D #############################################################################
> ##D 
> ##D n <- 5
> ##D dat <- data.frame( "x"=stats::runif(n, 0, 9 ), "y"=LETTERS[1:n] )
> ##D write.fwf2(dat, format.full=c(4,2), format.round=c(2,0),  file="testdata")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write.mice.imputation")
> ### * write.mice.imputation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.mice.imputation
> ### Title: Export Multiply Imputed Datasets from a 'mids' Object
> ### Aliases: write.mice.imputation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Imputation of nhanes data and write imputed datasets on disk
> ##D #############################################################################
> ##D 
> ##D data(nhanes,package="mice")
> ##D 
> ##D #**********
> ##D # Model 1: Imputation using mice
> ##D imp1 <- mice::mice( nhanes, m=3, maxit=5 )
> ##D # write results
> ##D write.mice.imputation(mi.res=imp1, name="mice_imp1" )
> ##D 
> ##D #**********
> ##D # Model 2: Imputation using mice.1chain
> ##D imp2 <- miceadds::mice.1chain( nhanes, burnin=10, iter=20, Nimp=4 )
> ##D # write results
> ##D write.mice.imputation(mi.res=imp2, name="mice_imp2" )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write.pspp")
> ### * write.pspp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.pspp
> ### Title: Writing a Data Frame into SPSS Format Using PSPP Software
> ### Aliases: write.pspp
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #############################################################################
> ##D # EXAMPLE 1: Write a data frame into SPSS format
> ##D #############################################################################
> ##D 
> ##D #****
> ##D # (1) define data frame
> ##D data <- data.frame( "pid"=1000+1:5, "height"=round(rnorm( 5 ),4),
> ##D                 "y"=10*c(1,1,1,2,2), "r2"=round( rnorm(5),2),
> ##D                 "land"=as.factor( c( rep("A",1), rep("B", 4 ) ) ) )
> ##D #****
> ##D # (2) define variable labels
> ##D v1 <- rep( "", ncol(data) )
> ##D names(v1) <-  colnames(data)
> ##D attr( data, "variable.labels" ) <- v1
> ##D attr(data,"variable.labels")["pid"] <- "Person ID"
> ##D attr(data,"variable.labels")["height"] <- "Height of a person"
> ##D attr(data,"variable.labels")["y"] <- "Gender"
> ##D 
> ##D #****
> ##D # (3) define some value labels
> ##D v1 <- c(10,20)
> ##D names(v1) <- c("male", "female" )
> ##D attr( data$y, "value.labels" ) <- v1
> ##D 
> ##D #****
> ##D # (4a) run PSPP to produce a sav file
> ##D write.pspp( data, datafile="example_data1",
> ##D         pspp.path="C:/Program Files (x86)/PSPP/bin/" )
> ##D 
> ##D #****
> ##D # (4b) produce strings instead of factors
> ##D write.pspp( data, datafile="example_data2",
> ##D         pspp.path="C:/Program Files (x86)/PSPP/bin/", as.factors=FALSE )
> ##D 
> ##D #****
> ##D # write sav file using haven package
> ##D library(haven)
> ##D haven::write_sav( data, "example_data1a.sav" )
> ##D 
> ##D #****
> ##D # write sav file using sjlabelled package
> ##D library(sjlabelled)
> ##D data <- sjlabelled::set_label( data, attr(data, "variable.labels") )
> ##D sjlabelled::write_spss( data, "example_data1b.sav" )
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.396 0.153 1.548 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
