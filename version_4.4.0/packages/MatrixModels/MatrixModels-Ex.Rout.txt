
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "MatrixModels"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('MatrixModels')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Model-class")
> ### * Model-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Model-class
> ### Title: Mother Class "Model" of all S4 Models
> ### Aliases: Model-class formula,Model-method update,Model-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("Model")
Virtual Class "Model" [package "MatrixModels"]

Slots:
                        
Name:      call fitProps
Class:     call     list

Known Subclasses: "glpModel"
> 
> 
> 
> cleanEx()
> nameEx("glm4")
> ### * glm4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glm4
> ### Title: Fitting Generalized Linear Models (using S4)
> ### Aliases: glm4
> ### Keywords: models regression
> 
> ### ** Examples
> 
> ### All the following is very experimental -- and probably will change: -------
> 
> data(CO2, package="datasets")
> ## dense linear model
> str(glm4(uptake ~ 0 + Type*Treatment, data=CO2, doFit = FALSE), 4)
Formal class 'glpModel' [package "MatrixModels"] with 4 slots
  ..@ resp    :Formal class 'respModule' [package "MatrixModels"] with 7 slots
  .. .. ..@ mu     : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ offset : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ sqrtXwt: num [1:84, 1] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ sqrtrwt: num [1:84] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ weights: num [1:84] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ wtres  : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ y      : num [1:84] 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...
  ..@ pred    :Formal class 'dPredModule' [package "MatrixModels"] with 4 slots
  .. .. ..@ X   :Formal class 'ddenseModelMatrix' [package "MatrixModels"] with 6 slots
  .. .. ..@ fac :Formal class 'Cholesky' [package "Matrix"] with 5 slots
  .. .. ..@ coef: num [1:4] 0 0 0 0
  .. .. ..@ Vtr : num [1:4] 0 0 0 0
  ..@ call    : language glm4(formula = uptake ~ 0 + Type * Treatment, data = CO2, doFit = FALSE)
  ..@ fitProps: list()
> ## sparse linear model
> str(glm4(uptake ~ 0 + Type*Treatment, data=CO2, doFit = FALSE,
+                   sparse = TRUE), 4)
Formal class 'glpModel' [package "MatrixModels"] with 4 slots
  ..@ resp    :Formal class 'respModule' [package "MatrixModels"] with 7 slots
  .. .. ..@ mu     : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ offset : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ sqrtXwt: num [1:84, 1] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ sqrtrwt: num [1:84] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ weights: num [1:84] 1 1 1 1 1 1 1 1 1 1 ...
  .. .. ..@ wtres  : num [1:84] 0 0 0 0 0 0 0 0 0 0 ...
  .. .. ..@ y      : num [1:84] 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...
  ..@ pred    :Formal class 'sPredModule' [package "MatrixModels"] with 4 slots
  .. .. ..@ X   :Formal class 'dsparseModelMatrix' [package "MatrixModels"] with 8 slots
  .. .. ..@ fac :Formal class 'dCHMsimpl' [package "Matrix"] with 11 slots
  .. .. ..@ coef: num [1:4] 0 0 0 0
  .. .. ..@ Vtr : num [1:4] 0 0 0 0
  ..@ call    : language glm4(formula = uptake ~ 0 + Type * Treatment, data = CO2, sparse = TRUE,      doFit = FALSE)
  ..@ fitProps: list()
> 
> ## From example(glm): -----------------
> 
> ## Dobson (1990) Page 93: Randomized Controlled Trial :
> str(trial <- data.frame(counts=c(18,17,15,20,10,20,25,13,12),
+                         outcome=gl(3,1,9,labels=LETTERS[1:3]),
+                         treatment=gl(3,3,labels=letters[1:3])))
'data.frame':	9 obs. of  3 variables:
 $ counts   : num  18 17 15 20 10 20 25 13 12
 $ outcome  : Factor w/ 3 levels "A","B","C": 1 2 3 1 2 3 1 2 3
 $ treatment: Factor w/ 3 levels "a","b","c": 1 1 1 2 2 2 3 3 3
> glm.D93 <- glm(counts ~ outcome + treatment, family=poisson, data=trial)
> summary(glm.D93)

Call:
glm(formula = counts ~ outcome + treatment, family = poisson, 
    data = trial)

Coefficients:
              Estimate Std. Error z value Pr(>|z|)    
(Intercept)  3.045e+00  1.709e-01  17.815   <2e-16 ***
outcomeB    -4.543e-01  2.022e-01  -2.247   0.0246 *  
outcomeC    -2.930e-01  1.927e-01  -1.520   0.1285    
treatmentb   1.011e-15  2.000e-01   0.000   1.0000    
treatmentc   7.105e-16  2.000e-01   0.000   1.0000    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 10.5814  on 8  degrees of freedom
Residual deviance:  5.1291  on 4  degrees of freedom
AIC: 56.761

Number of Fisher Scoring iterations: 4

> c.glm <- unname(coef(glm.D93))
> glmM  <- glm4(counts ~ outcome + treatment, family = poisson, data=trial)
> glmM2 <- update(glmM, quick = FALSE) # slightly more accurate
> glmM3 <- update(glmM, quick = FALSE, finalUpdate = TRUE)
>                  # finalUpdate has no effect on 'coef'
> stopifnot( identical(glmM2@pred@coef, glmM3@pred@coef),
+            all.equal(glmM @pred@coef, c.glm, tolerance=1e-7),
+            all.equal(glmM2@pred@coef, c.glm, tolerance=1e-12))
> ## Don't show: 
> All.eq <- function(x,y, ...) all.equal(x,y, tolerance= 1e-12, ...)
> stopifnot( ## ensure typos are *caught* :
+   inherits(try(glm4(counts ~ outcome + treatment, family=poisson, data=trial,
+                        fooBar = FALSE)), "try-error"),
+   ## check formula(.): {environments differ - FIXME?}
+   formula(glmM) == formula(glm.D93),
+   identical(coef(glmM2), coefficients(glmM3)),
+   All.eq   (coef(glmM2), coefficients(glm.D93)),
+   identical(fitted.values(glmM2), fitted(glmM3)),
+   All.eq   (residuals(glmM2), resid(glm.D93), check.attributes=FALSE),# names()% FIXME ??
+   identical(residuals(glmM2), resid(glmM3))
+ )
Error : The following control arguments did not match any default's names:
   “fooBar”
> ## End(Don't show)
> 
> ## Watch the iterations --- and use no intercept --> more sparse X
> ## 1) dense generalized linear model
> glmM <- glm4(counts ~ 0+outcome + treatment, poisson, trial,
+                       verbose = TRUE)
_1_ convergence criterion: 0.0990093
step = 1.00000, new wrss = 5.0726703, Delta(wrss)= 0.0499074, coef =
[1] 3.044512e+00 2.590484e+00 2.751707e+00 1.163981e-04 6.095497e-05
_2_ convergence criterion: 0.00107995
step = 1.00000, new wrss = 5.1721149, Delta(wrss)= 5.94911e-06, coef =
[1] 3.044522e+00 2.590267e+00 2.751535e+00 1.923493e-08 8.383392e-09
_3_ convergence criterion: 1.4393e-07
> ## 2) sparse generalized linear model
> glmS <- glm4(counts ~ 0+outcome + treatment, poisson, trial,
+                       verbose = TRUE, sparse = TRUE)
_1_ convergence criterion: 0.0990093
step = 1.00000, new wrss = 5.0726703, Delta(wrss)= 0.0499074, coef =
[1] 3.044512e+00 2.590484e+00 2.751707e+00 1.163981e-04 6.095497e-05
_2_ convergence criterion: 0.00107995
step = 1.00000, new wrss = 5.1721149, Delta(wrss)= 5.94911e-06, coef =
[1] 3.044522e+00 2.590267e+00 2.751535e+00 1.923493e-08 8.383392e-09
_3_ convergence criterion: 1.43931e-07
> str(glmS, max.lev = 4)
Formal class 'glpModel' [package "MatrixModels"] with 4 slots
  ..@ resp    :Formal class 'glmRespMod' [package "MatrixModels"] with 10 slots
  .. .. ..@ family :List of 12
  .. .. .. ..- attr(*, "class")= chr "family"
  .. .. ..@ eta    : num [1:9] 3.04 2.59 2.75 3.04 2.59 ...
  .. .. ..@ n      : num [1:9] 1 1 1 1 1 1 1 1 1
  .. .. ..@ mu     : num [1:9] 21 13.3 15.7 21 13.3 ...
  .. .. ..@ offset : num [1:9] 0 0 0 0 0 0 0 0 0
  .. .. ..@ sqrtXwt: num [1:9, 1] 4.58 3.65 3.96 4.58 3.65 ...
  .. .. ..@ sqrtrwt: num [1:9] 0.218 0.274 0.253 0.218 0.274 ...
  .. .. ..@ weights: num [1:9] 1 1 1 1 1 1 1 1 1
  .. .. ..@ wtres  : num [1:9] -0.655 1.004 -0.168 -0.218 -0.913 ...
  .. .. ..@ y      : num [1:9] 18 17 15 20 10 20 25 13 12
  ..@ pred    :Formal class 'sPredModule' [package "MatrixModels"] with 4 slots
  .. .. ..@ X   :Formal class 'dsparseModelMatrix' [package "MatrixModels"] with 8 slots
  .. .. ..@ fac :Formal class 'dCHMsimpl' [package "Matrix"] with 11 slots
  .. .. ..@ coef: num [1:5] 3.04 2.59 2.75 1.92e-08 8.38e-09
  .. .. ..@ Vtr : num [1:5] -1.45e-07 -1.57e-06 -1.31e-06 -1.51e-06 -9.64e-07
  ..@ call    : language glm4(formula = counts ~ 0 + outcome + treatment, family = poisson, data = trial,      sparse = TRUE, verbose = TRUE)
  ..@ fitProps:List of 3
  .. ..$ convcrit : num 1.44e-07
  .. ..$ iter     : num 3
  .. ..$ nHalvings: num 0
> stopifnot( all.equal(glmM@pred@coef, glmS@pred@coef),
+            all.equal(glmM@pred@Vtr,  glmS@pred@Vtr) )
> 
> 
> ## A Gamma example, from McCullagh & Nelder (1989, pp. 300-2)
> clotting <- data.frame(u = c(5,10,15,20,30,40,60,80,100),
+                        lot1 = c(118,58,42,35,27,25,21,19,18),
+                        lot2 = c(69,35,26,21,18,16,13,12,12))
> str(gMN <- glm4(lot1 ~ log(u), data=clotting, family=Gamma, verbose=TRUE))
_1_ convergence criterion: 0.0455001
step = 1.00000, new wrss = 0.017051829, Delta(wrss)= 3.5175e-05, coef =
[1] -0.01655447  0.01534311
_2_ convergence criterion: 0.000110842
step = 1.00000, new wrss = 0.017122092, Delta(wrss)= 2.0547e-10, coef =
[1] -0.01655438  0.01534311
_3_ convergence criterion: 1.02e-09
Formal class 'glpModel' [package "MatrixModels"] with 4 slots
  ..@ resp    :Formal class 'glmRespMod' [package "MatrixModels"] with 10 slots
  .. .. ..@ family :List of 12
  .. .. .. ..$ family    : chr "Gamma"
  .. .. .. ..$ link      : chr "inverse"
  .. .. .. ..$ linkfun   :function (mu)  
  .. .. .. ..$ linkinv   :function (eta)  
  .. .. .. ..$ variance  :function (mu)  
  .. .. .. ..$ dev.resids:function (y, mu, wt)  
  .. .. .. ..$ aic       :function (y, n, mu, wt, dev)  
  .. .. .. ..$ mu.eta    :function (eta)  
  .. .. .. ..$ validmu   :function (mu)  
  .. .. .. ..$ valideta  :function (eta)  
  .. .. .. ..$ simulate  :function (object, nsim)  
  .. .. .. ..$ dispersion: num NA
  .. .. .. ..- attr(*, "class")= chr "family"
  .. .. ..@ eta    : num [1:9] 0.00814 0.01877 0.025 0.02941 0.03563 ...
  .. .. ..@ n      : num [1:9] 1 1 1 1 1 1 1 1 1
  .. .. ..@ mu     : num [1:9] 122.9 53.3 40 34 28.1 ...
  .. .. ..@ offset : num [1:9] 0 0 0 0 0 0 0 0 0
  .. .. ..@ sqrtXwt: num [1:9, 1] -122.9 -53.3 -40 -34 -28.1 ...
  .. .. ..@ sqrtrwt: num [1:9] 0.00814 0.01877 0.025 0.02941 0.03563 ...
  .. .. ..@ weights: num [1:9] 1 1 1 1 1 1 1 1 1
  .. .. ..@ wtres  : num [1:9] -0.0395 0.0889 0.0498 0.0293 -0.038 ...
  .. .. ..@ y      : num [1:9] 118 58 42 35 27 25 21 19 18
  ..@ pred    :Formal class 'dPredModule' [package "MatrixModels"] with 4 slots
  .. .. ..@ X   :Formal class 'ddenseModelMatrix' [package "MatrixModels"] with 6 slots
  .. .. .. .. ..@ Dim      : int [1:2] 9 2
  .. .. .. .. ..@ Dimnames :List of 2
  .. .. .. .. .. ..$ : chr [1:9] "1" "2" "3" "4" ...
  .. .. .. .. .. ..$ : chr [1:2] "(Intercept)" "log(u)"
  .. .. .. .. ..@ x        : num [1:18] 1 1 1 1 1 ...
  .. .. .. .. ..@ factors  : list()
  .. .. .. .. ..@ assign   : int [1:2] 0 1
  .. .. .. .. ..@ contrasts: list()
  .. .. ..@ fac :Formal class 'Cholesky' [package "Matrix"] with 5 slots
  .. .. .. .. ..@ uplo    : chr "U"
  .. .. .. .. ..@ x       : num [1:4] 153 0 320 119
  .. .. .. .. ..@ perm    : int(0) 
  .. .. .. .. ..@ Dim     : int [1:2] 2 2
  .. .. .. .. ..@ Dimnames:List of 2
  .. .. .. .. .. ..$ : chr [1:2] "(Intercept)" "log(u)"
  .. .. .. .. .. ..$ : chr [1:2] "(Intercept)" "log(u)"
  .. .. ..@ coef: num [1:2] -0.0166 0.0153
  .. .. ..@ Vtr : num [1:2] 1.91e-08 3.43e-08
  ..@ call    : language glm4(formula = lot1 ~ log(u), family = Gamma, data = clotting, verbose = TRUE)
  ..@ fitProps:List of 3
  .. ..$ convcrit : num 1.02e-09
  .. ..$ iter     : num 3
  .. ..$ nHalvings: num 0
> glm. <- glm(lot1 ~ log(u), data=clotting, family=Gamma)
> stopifnot( all.equal(gMN@pred@coef, unname(coef(glm.)), tolerance=1e-7) )
> 
> 
> 
> cleanEx()
> nameEx("glpModel-class")
> ### * glpModel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glpModel-class
> ### Title: Class "glpModel" of General Linear Prediction Models
> ### Aliases: glpModel-class coef,glpModel-method fitted,glpModel-method
> ###   residuals,glpModel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("glpModel")
Class "glpModel" [package "MatrixModels"]

Slots:
                                                  
Name:        resp       pred       call   fitProps
Class: respModule predModule       call       list

Extends: "Model"
> 
> ## Use   example(glm4)  or see  help(glm4) for many more examples.
> 
> 
> 
> cleanEx()
> nameEx("lm.fit.sparse")
> ### * lm.fit.sparse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lm.fit.sparse
> ### Title: Fitter Function for Sparse Linear Models
> ### Aliases: lm.fit.sparse
> ### Keywords: regression array
> 
> ### ** Examples
> 
> dd <- expand.grid(a = as.factor(1:3),
+                   b = as.factor(1:4),
+                   c = as.factor(1:2),
+                   d= as.factor(1:8))
> n <- nrow(dd <- dd[rep(seq_len(nrow(dd)), each = 10), ])
> set.seed(17)
> dM <- cbind(dd, x = round(rnorm(n), 1))
> ## randomly drop some
> n <- nrow(dM <- dM[- sample(n, 50),])
> dM <- within(dM, { A <- c(2,5,10)[a]
+                    B <- c(-10,-1, 3:4)[b]
+                    C <- c(-8,8)[c]
+                    D <- c(10*(-5:-2), 20*c(0, 3:5))[d]
+    Y <- A + B + A*B + C + D + A*D + C*x + rnorm(n)/10
+    wts <- sample(1:10, n, replace=TRUE)
+    rm(A,B,C,D)
+ })
> str(dM) # 1870 x 7
'data.frame':	1870 obs. of  7 variables:
 $ a  : Factor w/ 3 levels "1","2","3": 1 1 1 1 1 1 1 1 1 1 ...
 $ b  : Factor w/ 4 levels "1","2","3","4": 1 1 1 1 1 1 1 1 1 1 ...
 $ c  : Factor w/ 2 levels "1","2": 1 1 1 1 1 1 1 1 1 1 ...
 $ d  : Factor w/ 8 levels "1","2","3","4",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ x  : num  -1 -0.1 -0.2 -0.8 0.8 -0.2 1 1.7 0.3 0.4 ...
 $ wts: int  6 1 7 7 5 9 5 4 5 8 ...
 $ Y  : num  -178 -185 -184 -180 -192 ...
> 
> X <- Matrix::sparse.model.matrix( ~ (a+b+c+d)^2 + c*x, data = dM)
> dim(X) # 1870 x 69
[1] 1870   69
> X[1:10, 1:20]
10 x 20 sparse Matrix of class "dgCMatrix"
  [[ suppressing 20 column names ‘(Intercept)’, ‘a2’, ‘a3’ ... ]]
                                              
1   1 . . . . . . . . . . . . . -1.0 . . . . .
1.1 1 . . . . . . . . . . . . . -0.1 . . . . .
1.2 1 . . . . . . . . . . . . . -0.2 . . . . .
1.3 1 . . . . . . . . . . . . . -0.8 . . . . .
1.4 1 . . . . . . . . . . . . .  0.8 . . . . .
1.5 1 . . . . . . . . . . . . . -0.2 . . . . .
1.6 1 . . . . . . . . . . . . .  1.0 . . . . .
1.7 1 . . . . . . . . . . . . .  1.7 . . . . .
1.8 1 . . . . . . . . . . . . .  0.3 . . . . .
1.9 1 . . . . . . . . . . . . .  0.4 . . . . .
> 
> ## For now, use  'MatrixModels:::'  --- TODO : export once interface is clear!
> 
> Xd <- as(X,"matrix")
> system.time(fmDense <- lm.fit(Xd, y = dM[,"Y"])) # {base} functionality
   user  system elapsed 
  0.003   0.000   0.002 
> system.time( r1 <- MatrixModels:::lm.fit.sparse(X, y = dM[,"Y"]) ) # *is* faster
   user  system elapsed 
  0.003   0.000   0.003 
> stopifnot(all.equal(r1, unname(fmDense$coeff), tolerance = 1e-12))
> system.time(
+      r2 <- MatrixModels:::lm.fit.sparse(X, y = dM[,"Y"], method = "chol") )
   user  system elapsed 
  0.002   0.000   0.001 
> stopifnot(all.equal(r1, r2$coef, tolerance = 1e-12),
+           all.equal(fmDense$residuals, r2$residuals, tolerance=1e-9)
+          )
> ## with weights:
> system.time(fmD.w <- with(dM, lm.wfit(Xd, Y, w = wts)))
   user  system elapsed 
  0.003   0.000   0.003 
> system.time(fm.w1 <- with(dM, MatrixModels:::lm.fit.sparse(X, Y, w = wts)))
   user  system elapsed 
  0.003   0.000   0.003 
> system.time(fm.w2 <- with(dM, MatrixModels:::lm.fit.sparse(X, Y, w = wts,
+                                                      method = "chol") ))
   user  system elapsed 
  0.002   0.000   0.001 
> stopifnot(all.equal(fm.w1, unname(fmD.w$coeff), tolerance = 1e-12),
+           all.equal(fm.w2$coef, fm.w1, tolerance = 1e-12),
+           all.equal(fmD.w$residuals, fm.w2$residuals, tolerance=1e-9)
+           )
> 
> 
> 
> cleanEx()
> nameEx("mkRespMod")
> ### * mkRespMod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mkRespMod
> ### Title: Create a respModule object
> ### Aliases: mkRespMod
> ### Keywords: models
> 
> ### ** Examples
> 
>   ## see  help("glpModel-class")
> 
> 
> 
> cleanEx()
> nameEx("model.Matrix")
> ### * model.Matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model.Matrix
> ### Title: Construct Possibly Sparse Design or Model Matrices
> ### Aliases: model.Matrix
> ### Keywords: models
> 
> ### ** Examples
> 
> data(CO2, package="datasets")
> class(sm <- model.Matrix(~ 0+Type*Treatment, data=CO2, sparse=TRUE))
[1] "dsparseModelMatrix"
attr(,"package")
[1] "MatrixModels"
> class(dm <- model.Matrix(~ 0+Type*Treatment, data=CO2, sparse=FALSE))
[1] "ddenseModelMatrix"
attr(,"package")
[1] "MatrixModels"
> stopifnot(dim(sm) == c(84,4), dim(sm) == dim(dm), all(sm == dm))
> 
> 
> 
> cleanEx()
> nameEx("modelMatrix-class")
> ### * modelMatrix-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: modelMatrix-class
> ### Title: Class "modelMatrix" and SubClasses
> ### Aliases: modelMatrix-class denseModelMatrix-class
> ###   ddenseModelMatrix-class sparseModelMatrix-class
> ###   dsparseModelMatrix-class show,modelMatrix-method
> ###   print,modelMatrix-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("modelMatrix")
Virtual Class "modelMatrix" [package "MatrixModels"]

Slots:
                                              
Name:     assign contrasts       Dim  Dimnames
Class:   integer      list   integer      list

Extends: 
Class "Matrix", directly
Class "replValueSp", by class "Matrix", distance 2

Known Subclasses: 
Class "sparseModelMatrix", directly
Class "denseModelMatrix", directly
Class "ddenseModelMatrix", by class "denseModelMatrix", distance 2
Class "dsparseModelMatrix", by class "sparseModelMatrix", distance 2
> showClass("dsparseModelMatrix")
Class "dsparseModelMatrix" [package "MatrixModels"]

Slots:
                                                                            
Name:          i         p       Dim  Dimnames         x   factors    assign
Class:   integer   integer   integer      list   numeric      list   integer
                
Name:  contrasts
Class:      list

Extends: 
Class "dgCMatrix", directly
Class "sparseModelMatrix", directly
Class "CsparseMatrix", by class "dgCMatrix", distance 2
Class "dsparseMatrix", by class "dgCMatrix", distance 2
Class "generalMatrix", by class "dgCMatrix", distance 2
Class "modelMatrix", by class "sparseModelMatrix", distance 2
Class "dMatrix", by class "dgCMatrix", distance 3
Class "sparseMatrix", by class "dgCMatrix", distance 3
Class "compMatrix", by class "dgCMatrix", distance 3
Class "Matrix", by class "sparseModelMatrix", distance 3
Class "replValueSp", by class "sparseModelMatrix", distance 4
> 
> ## see   example(model.Matrix)
> 
> 
> 
> cleanEx()
> nameEx("predModule-class")
> ### * predModule-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predModule-class
> ### Title: Class "predModule" and SubClasses
> ### Aliases: predModule-class dPredModule-class sPredModule-class
> ###   coerce,ddenseModelMatrix,predModule-method
> ###   coerce,dsparseModelMatrix,predModule-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("dPredModule")
Class "dPredModule" [package "MatrixModels"]

Slots:
                                                                              
Name:                  X               fac              coef               Vtr
Class: ddenseModelMatrix          Cholesky           numeric           numeric

Extends: "predModule"
> showClass("sPredModule")
Class "sPredModule" [package "MatrixModels"]

Slots:
                                                               
Name:                   X                fac               coef
Class: dsparseModelMatrix          CHMfactor            numeric
                         
Name:                 Vtr
Class:            numeric

Extends: "predModule"
> 
> ## see   example(model.Matrix)
> 
> 
> 
> cleanEx()
> nameEx("respModule-class")
> ### * respModule-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: respModule-class
> ### Title: "respModule" and derived classes
> ### Aliases: respModule-class glmRespMod-class nlsRespMod-class
> ###   nglmRespMod-class fitted,respModule-method
> ###   residuals,respModule-method residuals,glmRespMod-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("respModule")
Class "respModule" [package "MatrixModels"]

Slots:
                                                              
Name:       mu  offset sqrtXwt sqrtrwt weights   wtres       y
Class: numeric numeric  matrix numeric numeric numeric numeric

Known Subclasses: 
Class "glmRespMod", directly
Class "nlsRespMod", directly
Class "nglmRespMod", by class "glmRespMod", distance 2
> showClass("glmRespMod")
Class "glmRespMod" [package "MatrixModels"]

Slots:
                                                                              
Name:   family     eta       n      mu  offset sqrtXwt sqrtrwt weights   wtres
Class:  family numeric numeric numeric numeric  matrix numeric numeric numeric
              
Name:        y
Class: numeric

Extends: "respModule"

Known Subclasses: "nglmRespMod"
> showClass("nlsRespMod")
Class "nlsRespMod" [package "MatrixModels"]

Slots:
                                                                              
Name:        nlenv       nlmod      pnames          mu      offset     sqrtXwt
Class: environment        call   character     numeric     numeric      matrix
                                                      
Name:      sqrtrwt     weights       wtres           y
Class:     numeric     numeric     numeric     numeric

Extends: "respModule"

Known Subclasses: "nglmRespMod"
> 
> 
> 
> cleanEx()
> nameEx("reweightPred")
> ### * reweightPred
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reweightPred
> ### Title: Reweight Prediction Module Structure Internals
> ### Aliases: reweightPred reweightPred-methods
> ###   reweightPred,dPredModule,matrix,numeric-method
> ###   reweightPred,sPredModule,matrix,numeric-method
> ### Keywords: regression methods
> 
> ### ** Examples
> 
> ## TODO
> 
> 
> 
> cleanEx()
> nameEx("solveCoef")
> ### * solveCoef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solveCoef
> ### Title: Solve for the Coefficients or Coefficient Increment
> ### Aliases: solveCoef solveCoef-methods solveCoef,dPredModule-method
> ###   solveCoef,sPredModule-method
> ### Keywords: regression methods
> 
> ### ** Examples
> 
> ## TODO
> 
> 
> 
> cleanEx()
> nameEx("updateMu")
> ### * updateMu
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: updateMu
> ### Title: Update 'mu', the Fitted Mean Response
> ### Aliases: updateMu updateMu-methods updateMu,glmRespMod,numeric-method
> ###   updateMu,nglmRespMod,numeric-method
> ###   updateMu,nlsRespMod,numeric-method updateMu,respModule,numeric-method
> ### Keywords: regression methods
> 
> ### ** Examples
> 
> ## TODO
> 
> 
> 
> cleanEx()
> nameEx("updateWts")
> ### * updateWts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: updateWts
> ### Title: Update the Residual and X Weights - Generic and Methods
> ### Aliases: updateWts updateWts-methods updateWts,glmRespMod-method
> ###   updateWts,respModule-method
> ### Keywords: regression methods
> 
> ### ** Examples
> 
> ## TODO
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.595 0.062 1.656 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
