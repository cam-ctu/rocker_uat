
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "matrixStats"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('matrixStats')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("anyMissing")
> ### * anyMissing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anyMissing
> ### Title: Checks if there are any missing values in an object or not
> ### Aliases: anyMissing colAnyMissings rowAnyMissings colAnyNAs rowAnyNAs
> ### Keywords: iteration logic
> 
> ### ** Examples
> 
>  x <- rnorm(n = 1000)
>  x[seq(300, length(x), by = 100)] <- NA
>  stopifnot(anyMissing(x) == any(is.na(x)))
> 
> 
> 
> 
> cleanEx()
> nameEx("binMeans")
> ### * binMeans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: binMeans
> ### Title: Fast mean calculations in non-overlapping bins
> ### Aliases: binMeans
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- 1:200
> mu <- double(length(x))
> mu[1:50] <- 5
> mu[101:150] <- -5
> y <- mu + rnorm(length(x))
> 
> # Binning
> bx <- c(0, 50, 100, 150, 200) + 0.5
> y_s <- binMeans(y, x = x, bx = bx)
> 
> plot(x, y)
> for (kk in seq_along(y_s)) {
+   lines(bx[c(kk, kk + 1)], y_s[c(kk, kk)], col = "blue", lwd = 2)
+ }
> 
> 
> 
> cleanEx()
> nameEx("diff2")
> ### * diff2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diff2
> ### Title: Fast lagged differences
> ### Aliases: diff2
> ### Keywords: internal univar
> 
> ### ** Examples
> 
> diff2(1:10)
[1] 1 1 1 1 1 1 1 1 1
> 
> 
> 
> 
> cleanEx()
> nameEx("indexByRow")
> ### * indexByRow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: indexByRow
> ### Title: Translates matrix indices by rows into indices by columns
> ### Aliases: indexByRow
> ### Keywords: iteration logic
> 
> ### ** Examples
> 
> dim <- c(5, 4)
> X <- matrix(NA_integer_, nrow = dim[1], ncol = dim[2])
> Y <- t(X)
> idxs <- seq_along(X)
> 
> # Assign by columns
> X[idxs] <- idxs
> print(X)
     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20
> 
> # Assign by rows
> Y[indexByRow(dim(Y), idxs)] <- idxs
> print(Y)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20
> 
> stopifnot(X == t(Y))
> 
> 
> 
> cleanEx()
> nameEx("logSumExp")
> ### * logSumExp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logSumExp
> ### Title: Accurately computes the logarithm of the sum of exponentials
> ### Aliases: logSumExp
> 
> ### ** Examples
> 
> ## EXAMPLE #1
> lx <- c(1000.01, 1000.02)
> y0 <- log(sum(exp(lx)))
> print(y0) ## Inf
[1] Inf
> 
> y1 <- logSumExp(lx)
> print(y1) ## 1000.708
[1] 1000.708
> 
> 
> ## EXAMPLE #2
> lx <- c(-1000.01, -1000.02)
> y0 <- log(sum(exp(lx)))
> print(y0) ## -Inf
[1] -Inf
> 
> y1 <- logSumExp(lx)
> print(y1) ## -999.3218
[1] -999.3218
> 
> 
> ## EXAMPLE #3
> ## R-help thread 'Beyond double-precision?' on May 9, 2009.
> 
> set.seed(1)
> x <- runif(50)
> 
> ## The logarithm of the harmonic mean
> y0 <- log(1 / mean(1 / x))
> print(y0)  ## -1.600885
[1] -1.600885
> 
> lx <- log(x)
> y1 <- log(length(x)) - logSumExp(-lx)
> print(y1)  ## [1] -1.600885
[1] -1.600885
> 
> # Sanity check
> stopifnot(all.equal(y1, y0))
> 
> 
> 
> cleanEx()
> nameEx("matrixStats.options")
> ### * matrixStats.options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrixStats.options
> ### Title: Options used for matrixStats
> ### Aliases: matrixStats.options matrixStats.useNames.NA
> ###   R_MATRIXSTATS_USENAMES_NA matrixStats.vars.formula.freq
> ###   R_MATRIXSTATS_VARS_FORMULA_FREQ matrixStats.vars.formula.onMistake
> ###   R_MATRIXSTATS_VARS_FORMULA_ONMISTAKE matrixStats.vars.center.onUse
> ###   R_MATRIXSTATS_VARS_CENTER_ONUSE matrixStats.center.onScalar
> ###   R_MATRIXSTATS_CENTER_ONSCALAR matrixStats.ties.method.missing
> ###   R_MATRIXSTATS_TIES_METHOD_MISSING matrixStats.ties.method.freq
> ###   R_MATRIXSTATS_TIES_METHOD_FREQ matrixStats.envs.min.version
> ###   R_MATRIXSTATS_ENVS_MIN_VERSION
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D options(matrixStats.useNames.NA = "defunct")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mean2")
> ### * mean2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mean2
> ### Title: Fast averaging over subset of vector elements
> ### Aliases: mean2
> ### Keywords: internal univar
> 
> ### ** Examples
> 
> x <- 1:10
> n <- length(x)
> 
> idxs <- seq(from = 1, to = n, by = 2)
> s1 <- mean(x[idxs])                     # 25
> s2 <- mean2(x, idxs = idxs)             # 25
> stopifnot(identical(s1, s2))
> 
> idxs <- seq(from = n, to = 1, by = -2)
> s1 <- mean(x[idxs])                     # 25
> s2 <- mean2(x, idxs = idxs)             # 25
> stopifnot(identical(s1, s2))
> 
> s1 <- mean(x)                           # 55
> s2 <- mean2(x)                          # 55
> stopifnot(identical(s1, s2))
> 
> 
> 
> cleanEx()
> nameEx("rowAlls")
> ### * rowAlls
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowAlls
> ### Title: Checks if a value exists / does not exist in each row (column)
> ###   of a matrix
> ### Aliases: rowAlls colAlls allValue rowAnys colAnys anyValue
> ### Keywords: array iteration logic univar
> 
> ### ** Examples
> 
> x <- matrix(FALSE, nrow = 10, ncol = 5)
> x[3:7, c(2, 4)] <- TRUE
> x[2:4, ] <- TRUE
> x[, 1] <- TRUE
> x[5, ] <- FALSE
> x[, 5] <- FALSE
> print(x)
       [,1]  [,2]  [,3]  [,4]  [,5]
 [1,]  TRUE FALSE FALSE FALSE FALSE
 [2,]  TRUE  TRUE  TRUE  TRUE FALSE
 [3,]  TRUE  TRUE  TRUE  TRUE FALSE
 [4,]  TRUE  TRUE  TRUE  TRUE FALSE
 [5,] FALSE FALSE FALSE FALSE FALSE
 [6,]  TRUE  TRUE FALSE  TRUE FALSE
 [7,]  TRUE  TRUE FALSE  TRUE FALSE
 [8,]  TRUE FALSE FALSE FALSE FALSE
 [9,]  TRUE FALSE FALSE FALSE FALSE
[10,]  TRUE FALSE FALSE FALSE FALSE
> 
> print(rowCounts(x))       # 1 4 4 4 0 3 3 1 1 1
 [1] 1 4 4 4 0 3 3 1 1 1
> print(colCounts(x))       # 9 5 3 5 0
[1] 9 5 3 5 0
> 
> print(rowAnys(x))
 [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
> print(which(rowAnys(x)))  # 1  2  3  4  6  7  8  9 10
[1]  1  2  3  4  6  7  8  9 10
> print(colAnys(x))
[1]  TRUE  TRUE  TRUE  TRUE FALSE
> print(which(colAnys(x)))  # 1 2 3 4
[1] 1 2 3 4
> 
> 
> 
> cleanEx()
> nameEx("rowAvgsPerColSet")
> ### * rowAvgsPerColSet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowAvgsPerColSet
> ### Title: Applies a row-by-row (column-by-column) averaging function to
> ###   equally-sized subsets of matrix columns (rows)
> ### Aliases: rowAvgsPerColSet colAvgsPerRowSet
> ### Keywords: internal utilities
> 
> ### ** Examples
> 
> X <- matrix(rnorm(20 * 6), nrow = 20, ncol = 6)
> rownames(X) <- LETTERS[1:nrow(X)]
> colnames(X) <- letters[1:ncol(X)]
> print(X)
            a           b          c            d          e           f
A -0.62645381  0.91897737 -0.1645236  2.401617761 -0.5686687 -0.62036668
B  0.18364332  0.78213630 -0.2533617 -0.039240003 -0.1351786  0.04211587
C -0.83562861  0.07456498  0.6969634  0.689739362  1.1780870 -0.91092165
D  1.59528080 -1.98935170  0.5566632  0.028002159 -1.5235668  0.15802877
E  0.32950777  0.61982575 -0.6887557 -0.743273209  0.5939462 -0.65458464
F -0.82046838 -0.05612874 -0.7074952  0.188792300  0.3329504  1.76728727
G  0.48742905 -0.15579551  0.3645820 -1.804958629  1.0630998  0.71670748
H  0.73832471 -1.47075238  0.7685329  1.465554862 -0.3041839  0.91017423
I  0.57578135 -0.47815006 -0.1123462  0.153253338  0.3700188  0.38418536
J -0.30538839  0.41794156  0.8811077  2.172611670  0.2670988  1.68217608
K  1.51178117  1.35867955  0.3981059  0.475509529 -0.5425200 -0.63573645
L  0.38984324 -0.10278773 -0.6120264 -0.709946431  1.2078678 -0.46164473
M -0.62124058  0.38767161  0.3411197  0.610726353  1.1604026  1.43228224
N -2.21469989 -0.05380504 -1.1293631 -0.934097632  0.7002136 -0.65069635
O  1.12493092 -1.37705956  1.4330237 -1.253633400  1.5868335 -0.20738074
P -0.04493361 -0.41499456  1.9803999  0.291446236  0.5584864 -0.39280793
Q -0.01619026 -0.39428995 -0.3672215 -0.443291873 -1.2765922 -0.31999287
R  0.94383621 -0.05931340 -1.0441346  0.001105352 -0.5732654 -0.27911330
S  0.82122120  1.10002537  0.5697196  0.074341324 -1.2246126  0.49418833
T  0.59390132  0.76317575 -0.1350546 -0.589520946 -0.4734006 -0.17733048
> 
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> # Apply rowMeans() for 3 sets of 2 columns
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> nbr_of_sets <- 3
> S <- matrix(1:ncol(X), ncol = nbr_of_sets)
> colnames(S) <- sprintf("s%d", 1:nbr_of_sets)
> print(S)
     s1 s2 s3
[1,]  1  3  5
[2,]  2  4  6
> 
> Z <- rowAvgsPerColSet(X, S = S)
> print(Z)
           s1          s2          s3
A  0.14626178  1.11854708 -0.59451771
B  0.48288981 -0.14630084 -0.04653137
C -0.38053181  0.69335137  0.13358267
D -0.19703545  0.29233268 -0.68276901
E  0.47466676 -0.71601445 -0.03031923
F -0.43829856 -0.25935143  1.05011882
G  0.16581677 -0.72018833  0.88990366
H -0.36621384  1.11704389  0.30299515
I  0.04881565  0.02045356  0.37710208
J  0.05627659  1.52685970  0.97463744
K  1.43523036  0.43680770 -0.58912824
L  0.14352775 -0.66098641  0.37311154
M -0.11678448  0.47592302  1.29634243
N -1.13425246 -1.03173036  0.02475865
O -0.12606432  0.08969515  0.68972636
P -0.22996409  1.13592307  0.08283925
Q -0.20524011 -0.40525667 -0.79829254
R  0.44226141 -0.52151464 -0.42618936
S  0.96062328  0.32203048 -0.36521214
T  0.67853853 -0.36228778 -0.32536556
> 
> # Validation
> Z0 <- cbind(s1 = rowMeans(X[, 1:2]),
+             s2 = rowMeans(X[, 3:4]),
+             s3 = rowMeans(X[, 5:6]))
> stopifnot(identical(drop(Z), Z0))
> 
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> # Apply colMeans() for 5 sets of 4 rows
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> nbr_of_sets <- 5
> S <- matrix(1:nrow(X), ncol = nbr_of_sets)
> colnames(S) <- sprintf("s%d", 1:nbr_of_sets)
> print(S)
     s1 s2 s3 s4 s5
[1,]  1  5  9 13 17
[2,]  2  6 10 14 18
[3,]  3  7 11 15 19
[4,]  4  8 12 16 20
> 
> Z <- colAvgsPerRowSet(X, S = S)
> print(Z)
             a           b           c          d          e           f
s1  0.07921043 -0.05341826  0.20893532  0.7700298 -0.2623318 -0.33278592
s2  0.18369829 -0.26571272 -0.06578399 -0.2234712  0.4214531  0.68489608
s3  0.54300434  0.29892083  0.13871025  0.5228570  0.3256163  0.24224506
s4 -0.43898579 -0.36454689  0.65629505 -0.3213896  1.0014840  0.04534930
s5  0.58569212  0.35239944 -0.24417277 -0.2393415 -0.8869677 -0.07056208
> 
> # Validation
> Z0 <- rbind(s1 = colMeans(X[  1:4, ]),
+             s2 = colMeans(X[  5:8, ]),
+             s3 = colMeans(X[ 9:12, ]),
+             s4 = colMeans(X[13:16, ]),
+             s5 = colMeans(X[17:20, ]))
> stopifnot(identical(drop(Z), Z0))
> 
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> # When there is only one "complete" set
> # - - - - - - - - - - - - - - - - - - - - - - - - - -
> nbr_of_sets <- 1
> S <- matrix(1:ncol(X), ncol = nbr_of_sets)
> colnames(S) <- sprintf("s%d", 1:nbr_of_sets)
> print(S)
     s1
[1,]  1
[2,]  2
[3,]  3
[4,]  4
[5,]  5
[6,]  6
> 
> Z <- rowAvgsPerColSet(X, S = S, FUN = rowMeans)
> print(Z)
            s1
A  0.223430386
B  0.096685867
C  0.148800743
D -0.195823927
E -0.090555640
F  0.117489610
G  0.111844032
H  0.351275069
I  0.148790432
J  0.852591240
K  0.427636607
L -0.048115707
M  0.551826988
N -0.713741393
O  0.217785729
P  0.329599410
Q -0.469596441
R -0.168480863
S  0.305813873
T -0.003038267
> 
> Z0 <- rowMeans(X)
> stopifnot(identical(drop(Z), Z0))
> 
> 
> nbr_of_sets <- 1
> S <- matrix(1:nrow(X), ncol = nbr_of_sets)
> colnames(S) <- sprintf("s%d", 1:nbr_of_sets)
> print(S)
      s1
 [1,]  1
 [2,]  2
 [3,]  3
 [4,]  4
 [5,]  5
 [6,]  6
 [7,]  7
 [8,]  8
 [9,]  9
[10,] 10
[11,] 11
[12,] 12
[13,] 13
[14,] 14
[15,] 15
[16,] 16
[17,] 17
[18,] 18
[19,] 19
[20,] 20
> 
> Z <- colAvgsPerRowSet(X, S = S, FUN = colMeans)
> print(Z)
           a            b         c         d         e         f
s1 0.1905239 -0.006471519 0.1387968 0.1017369 0.1198508 0.1138285
> 
> Z0 <- colMeans(X)
> stopifnot(identical(drop(Z), Z0))
> 
> 
> 
> cleanEx()
> nameEx("rowCollapse")
> ### * rowCollapse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCollapse
> ### Title: Extracts one cell per row (column) from a matrix
> ### Aliases: rowCollapse colCollapse
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- matrix(1:27, ncol = 3)
> 
> y <- rowCollapse(x, 1)
> stopifnot(identical(y, x[, 1]))
> 
> y <- rowCollapse(x, 2)
> stopifnot(identical(y, x[, 2]))
> 
> y <- rowCollapse(x, c(1, 1, 1, 1, 1, 3, 3, 3, 3))
> stopifnot(identical(y, c(x[1:5, 1], x[6:9, 3])))
> 
> y <- rowCollapse(x, 1:3)
> print(y)
[1]  1 11 21  4 14 24  7 17 27
> y_truth <- c(x[1, 1], x[2, 2], x[3, 3], x[4, 1], x[5, 2],
+              x[6, 3], x[7, 1], x[8, 2], x[9, 3])
> stopifnot(identical(y, y_truth))
> 
> 
> 
> cleanEx()
> nameEx("rowCounts")
> ### * rowCounts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCounts
> ### Title: Counts the number of occurrences of a specific value
> ### Aliases: rowCounts colCounts count
> ### Keywords: array iteration logic univar
> 
> ### ** Examples
> 
> x <- matrix(0:11, nrow = 4, ncol = 3)
> x[2:3, 2:3] <- 2:5
> x[3, 3] <- NA_integer_
> print(x)
     [,1] [,2] [,3]
[1,]    0    4    8
[2,]    1    2    4
[3,]    2    3   NA
[4,]    3    7   11
> 
> print(rowCounts(x, value = 2))
[1]  0  1 NA  0
> ## [1]  0  1 NA  0
> print(colCounts(x, value = 2))
[1]  1  1 NA
> ## [1]  1  1 NA
> print(colCounts(x, value = NA_integer_))
[1] 0 0 1
> ## [1] 0 0 1
> 
> print(rowCounts(x, value = 2, na.rm = TRUE))
[1] 0 1 1 0
> ## [1] 0 1 1 0
> print(colCounts(x, value = 2, na.rm = TRUE))
[1] 1 1 0
> ## [1] 1 1 0
> 
> print(rowAnys(x, value = 2))
[1] FALSE  TRUE  TRUE FALSE
> ## [1] FALSE  TRUE  TRUE FALSE
> print(rowAnys(x, value = NA_integer_))
[1] FALSE FALSE  TRUE FALSE
> ## [1] FALSE FALSE  TRUE FALSE
> 
> print(colAnys(x, value = 2))
[1] TRUE TRUE   NA
> ## [1] TRUE TRUE   NA
> print(colAnys(x, value = 2, na.rm = TRUE))
[1]  TRUE  TRUE FALSE
> ## [1]  TRUE  TRUE FALSE
> 
> print(colAlls(x, value = 2))
[1] FALSE FALSE FALSE
> ## [1] FALSE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("rowCumsums")
> ### * rowCumsums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCumsums
> ### Title: Cumulative sums, products, minima and maxima for each row
> ###   (column) in a matrix
> ### Aliases: rowCumsums colCumsums rowCumprods colCumprods rowCummins
> ###   colCummins rowCummaxs colCummaxs
> ### Keywords: array iteration univar
> 
> ### ** Examples
> 
> x <- matrix(1:12, nrow = 4, ncol = 3)
> print(x)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12
> 
> yr <- rowCumsums(x)
> print(yr)
     [,1] [,2] [,3]
[1,]    1    6   15
[2,]    2    8   18
[3,]    3   10   21
[4,]    4   12   24
> 
> yc <- colCumsums(x)
> print(yc)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    3   11   19
[3,]    6   18   30
[4,]   10   26   42
> 
> yr <- rowCumprods(x)
> print(yr)
     [,1] [,2] [,3]
[1,]    1    5   45
[2,]    2   12  120
[3,]    3   21  231
[4,]    4   32  384
> 
> yc <- colCumprods(x)
> print(yc)
     [,1] [,2]  [,3]
[1,]    1    5     9
[2,]    2   30    90
[3,]    6  210   990
[4,]   24 1680 11880
> 
> yr <- rowCummaxs(x)
> print(yr)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12
> 
> yc <- colCummaxs(x)
> print(yc)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12
> 
> yr <- rowCummins(x)
> print(yr)
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    2    2    2
[3,]    3    3    3
[4,]    4    4    4
> 
> yc <- colCummins(x)
> print(yc)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    1    5    9
[3,]    1    5    9
[4,]    1    5    9
> 
> 
> 
> cleanEx()
> nameEx("rowDiffs")
> ### * rowDiffs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowDiffs
> ### Title: Calculates difference for each row (column) in a matrix
> ### Aliases: rowDiffs colDiffs
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> x <- matrix(1:27, ncol = 3)
> 
> d1 <- rowDiffs(x)
> print(d1)
      [,1] [,2]
 [1,]    9    9
 [2,]    9    9
 [3,]    9    9
 [4,]    9    9
 [5,]    9    9
 [6,]    9    9
 [7,]    9    9
 [8,]    9    9
 [9,]    9    9
> 
> d2 <- t(colDiffs(t(x)))
> stopifnot(all.equal(d2, d1))
> 
> 
> 
> cleanEx()
> nameEx("rowIQRs")
> ### * rowIQRs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowIQRs
> ### Title: Estimates of the interquartile range for each row (column) in a
> ###   matrix
> ### Aliases: rowIQRs colIQRs iqr
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> set.seed(1)
> 
> x <- matrix(rnorm(50 * 40), nrow = 50, ncol = 40)
> str(x)
 num [1:50, 1:40] -0.626 0.184 -0.836 1.595 0.33 ...
> 
> # Row IQRs
> q <- rowIQRs(x)
> print(q)
 [1] 1.1731306 1.0107162 1.6654064 1.2539423 1.3705467 1.6404858 1.6995732
 [8] 1.3291742 1.6886054 1.2549506 0.9359126 1.0195589 1.4007595 1.2198987
[15] 1.0787055 1.4524548 1.2556678 1.6562935 0.9436753 1.5332922 1.0804972
[22] 1.3345150 1.3778290 1.2813150 1.1560162 1.2670159 1.6274822 1.0123151
[29] 1.3011232 0.9232206 1.3664274 1.6141894 1.3007675 1.3635105 1.1991735
[36] 1.1799147 1.5664136 1.1915430 1.3908429 1.2292913 1.3337325 1.1083987
[43] 1.1150356 1.3610511 1.9523920 1.1711522 1.8068631 1.4450980 1.7511271
[50] 1.1295912
> q0 <- apply(x, MARGIN = 1, FUN = IQR)
> stopifnot(all.equal(q0, q))
> 
> # Column IQRs
> q <- colIQRs(x)
> print(q)
 [1] 1.100049 1.178648 0.916382 1.523818 1.233231 1.177970 1.248359 1.281653
 [9] 1.305779 1.463096 1.121270 1.524690 1.262950 1.608730 1.937564 1.666534
[17] 1.370162 1.238580 1.341196 1.214581 1.610758 1.488645 1.361843 1.332965
[25] 1.244894 1.507090 1.172773 1.349565 1.511738 1.213386 1.241099 1.408363
[33] 1.050347 1.389932 1.806088 1.377805 1.241565 1.241594 1.234828 1.580717
> q0 <- apply(x, MARGIN = 2, FUN = IQR)
> stopifnot(all.equal(q0, q))
> 
> 
> 
> cleanEx()
> nameEx("rowQuantiles")
> ### * rowQuantiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowQuantiles
> ### Title: Estimates quantiles for each row (column) in a matrix
> ### Aliases: rowQuantiles colQuantiles
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> set.seed(1)
> 
> x <- matrix(rnorm(50 * 40), nrow = 50, ncol = 40)
> str(x)
 num [1:50, 1:40] -0.626 0.184 -0.836 1.595 0.33 ...
> 
> probs <- c(0.25, 0.5, 0.75)
> 
> # Row quantiles
> q <- rowQuantiles(x, probs = probs)
> print(q)
             25%          50%       75%
 [1,] -0.6218885  0.106762508 0.5512421
 [2,] -0.3049272  0.056473676 0.7057890
 [3,] -0.9231354 -0.118361292 0.7422711
 [4,] -0.9322740 -0.207686499 0.3216682
 [5,] -0.7084443 -0.035489532 0.6621024
 [6,] -0.9664491 -0.216591179 0.6740367
 [7,] -1.0384055  0.042690771 0.6611677
 [8,] -0.6330825 -0.126332443 0.6960917
 [9,] -1.0094086 -0.041113665 0.6791968
[10,] -0.6327419  0.054660577 0.6222087
[11,] -0.5645887 -0.041477859 0.3713240
[12,] -0.2766925  0.110955064 0.7428664
[13,] -0.8453155 -0.334769330 0.5554439
[14,] -0.8897809 -0.324080709 0.3301178
[15,] -0.7251620 -0.188349538 0.3535435
[16,] -0.4797823  0.091562203 0.9726725
[17,] -0.6200479 -0.262020284 0.6356199
[18,] -0.9034017 -0.140455912 0.7528919
[19,] -0.7707722 -0.152329236 0.1729031
[20,] -0.3200883  0.302574383 1.2132039
[21,] -0.5291880 -0.214782932 0.5513092
[22,] -0.5356002  0.284290389 0.7989148
[23,] -0.5700878  0.149494637 0.8077412
[24,] -0.7503936 -0.077770110 0.5309214
[25,] -0.4267110  0.263799916 0.7293052
[26,] -0.9591707 -0.137898692 0.3078452
[27,] -1.0171397 -0.150011032 0.6103426
[28,] -0.2687164  0.085033622 0.7435987
[29,] -0.7860127 -0.286445627 0.5151106
[30,] -0.3577578 -0.022684187 0.5654628
[31,] -0.9519151 -0.538929463 0.4145123
[32,] -0.6973686 -0.118983171 0.9168207
[33,] -0.8027962 -0.204718112 0.4979713
[34,] -0.9273236 -0.141973088 0.4361869
[35,] -0.4532102  0.365402869 0.7459632
[36,] -0.4184018  0.227594464 0.7615129
[37,] -0.6367977  0.088614257 0.9296158
[38,] -0.4039084 -0.010658183 0.7876346
[39,] -0.3561294  0.373172018 1.0347134
[40,] -0.7034831 -0.005856479 0.5258082
[41,] -0.6183522 -0.064312777 0.7153803
[42,] -0.4235112  0.125571403 0.6848875
[43,] -0.5556839  0.124678003 0.5593517
[44,] -0.5123758  0.439573098 0.8486753
[45,] -1.0042770 -0.060667550 0.9481150
[46,] -1.0340398 -0.310771412 0.1371124
[47,] -0.8865014  0.142643098 0.9203617
[48,] -0.7968222 -0.172298103 0.6482758
[49,] -1.2293839 -0.139233624 0.5217433
[50,] -0.6553804 -0.262142026 0.4742108
> q_0 <- apply(x, MARGIN = 1, FUN = quantile, probs = probs)
> stopifnot(all.equal(q_0, t(q)))
> 
> # Column IQRs
> q <- colQuantiles(x, probs = probs)
> print(q)
             25%          50%       75%
 [1,] -0.3720646  0.129104154 0.7279844
 [2,] -0.5721162  0.113797331 0.6065313
 [3,] -0.6469564 -0.246846356 0.2694256
 [4,] -0.7041278 -0.055939482 0.8196898
 [5,] -0.6089229 -0.029054330 0.6243079
 [6,] -0.4185202  0.146116784 0.7594495
 [7,] -0.4365107  0.091022110 0.8118479
 [8,] -0.6197929 -0.032415219 0.6618606
 [9,] -0.6727637 -0.273421020 0.6330157
[10,] -0.8825293 -0.011512761 0.5805665
[11,] -0.6381655  0.014950044 0.4831043
[12,] -0.7140804 -0.152388294 0.8106097
[13,] -0.7242296 -0.251628169 0.5387204
[14,] -1.0515879 -0.189977384 0.5571419
[15,] -0.9282411 -0.084192983 1.0093225
[16,] -0.8448598 -0.011103461 0.8216741
[17,] -0.5906504  0.161907795 0.7795111
[18,] -0.6499464 -0.059279451 0.5886333
[19,] -0.6094663  0.214748047 0.7317293
[20,] -0.7037132  0.022335956 0.5108679
[21,] -0.8504756  0.108484526 0.7602824
[22,] -0.7317770  0.007196516 0.7568682
[23,] -0.8515848 -0.319332762 0.5102586
[24,] -0.6366325 -0.249590203 0.6963329
[25,] -0.4791826  0.007958062 0.7657119
[26,] -0.4125492  0.291176656 1.0945407
[27,] -0.8272824 -0.267580711 0.3454911
[28,] -0.8544896 -0.197365516 0.4950755
[29,] -0.5364474  0.169648975 0.9752908
[30,] -0.6411633  0.057236706 0.5722226
[31,] -0.4458641 -0.018247105 0.7952345
[32,] -0.8358661  0.071609588 0.5724964
[33,] -0.5417449  0.124909830 0.5086025
[34,] -0.8415534 -0.215944585 0.5483784
[35,] -0.7080412 -0.017766239 1.0980467
[36,] -0.9491461 -0.256300105 0.4286593
[37,] -0.2463305  0.355645772 0.9952349
[38,] -0.5823101 -0.221579869 0.6592843
[39,] -0.8941790 -0.001721324 0.3406492
[40,] -0.6990172 -0.038793345 0.8817002
> q_0 <- apply(x, MARGIN = 2, FUN = quantile, probs = probs)
> stopifnot(all.equal(q_0, t(q)))
> 
> 
> 
> cleanEx()
> nameEx("rowTabulates")
> ### * rowTabulates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowTabulates
> ### Title: Tabulates the values in a matrix by row (column).
> ### Aliases: rowTabulates colTabulates
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- matrix(1:5, nrow = 10, ncol = 5)
> print(x)
      [,1] [,2] [,3] [,4] [,5]
 [1,]    1    1    1    1    1
 [2,]    2    2    2    2    2
 [3,]    3    3    3    3    3
 [4,]    4    4    4    4    4
 [5,]    5    5    5    5    5
 [6,]    1    1    1    1    1
 [7,]    2    2    2    2    2
 [8,]    3    3    3    3    3
 [9,]    4    4    4    4    4
[10,]    5    5    5    5    5
> print(rowTabulates(x))
      1 2 3 4 5
 [1,] 5 0 0 0 0
 [2,] 0 5 0 0 0
 [3,] 0 0 5 0 0
 [4,] 0 0 0 5 0
 [5,] 0 0 0 0 5
 [6,] 5 0 0 0 0
 [7,] 0 5 0 0 0
 [8,] 0 0 5 0 0
 [9,] 0 0 0 5 0
[10,] 0 0 0 0 5
> print(colTabulates(x))
     1 2 3 4 5
[1,] 2 2 2 2 2
[2,] 2 2 2 2 2
[3,] 2 2 2 2 2
[4,] 2 2 2 2 2
[5,] 2 2 2 2 2
> # Count only certain values
> print(rowTabulates(x, values = 1:3))
      1 2 3
 [1,] 5 0 0
 [2,] 0 5 0
 [3,] 0 0 5
 [4,] 0 0 0
 [5,] 0 0 0
 [6,] 5 0 0
 [7,] 0 5 0
 [8,] 0 0 5
 [9,] 0 0 0
[10,] 0 0 0
> 
> 
> y <- as.raw(x)
> dim(y) <- dim(x)
> print(y)
      [,1] [,2] [,3] [,4] [,5]
 [1,]   01   01   01   01   01
 [2,]   02   02   02   02   02
 [3,]   03   03   03   03   03
 [4,]   04   04   04   04   04
 [5,]   05   05   05   05   05
 [6,]   01   01   01   01   01
 [7,]   02   02   02   02   02
 [8,]   03   03   03   03   03
 [9,]   04   04   04   04   04
[10,]   05   05   05   05   05
> print(rowTabulates(y))
      0x1 0x2 0x3 0x4 0x5
 [1,]   5   0   0   0   0
 [2,]   0   5   0   0   0
 [3,]   0   0   5   0   0
 [4,]   0   0   0   5   0
 [5,]   0   0   0   0   5
 [6,]   5   0   0   0   0
 [7,]   0   5   0   0   0
 [8,]   0   0   5   0   0
 [9,]   0   0   0   5   0
[10,]   0   0   0   0   5
> print(colTabulates(y))
     0x1 0x2 0x3 0x4 0x5
[1,]   2   2   2   2   2
[2,]   2   2   2   2   2
[3,]   2   2   2   2   2
[4,]   2   2   2   2   2
[5,]   2   2   2   2   2
> 
> 
> 
> cleanEx()
> nameEx("rowVars")
> ### * rowVars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowVars
> ### Title: Variance estimates for each row (column) in a matrix
> ### Aliases: rowVars colVars
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> set.seed(1)
> 
> x <- matrix(rnorm(20), nrow = 5, ncol = 4)
> print(x)
           [,1]       [,2]       [,3]        [,4]
[1,] -0.6264538 -0.8204684  1.5117812 -0.04493361
[2,]  0.1836433  0.4874291  0.3898432 -0.01619026
[3,] -0.8356286  0.7383247 -0.6212406  0.94383621
[4,]  1.5952808  0.5757814 -2.2146999  0.82122120
[5,]  0.3295078 -0.3053884  1.1249309  0.59390132
> 
> # Row averages
> print(rowMeans(x))
[1] 0.004981341 0.261181337 0.056322931 0.194395865 0.435737906
> print(rowMedians(x))
[1] -0.33569371  0.28674328  0.05854206  0.69850127  0.46170455
> 
> # Column averages
> print(colMeans(x))
[1] 0.12926990 0.13513567 0.03812297 0.45956697
> print(colMedians(x))
[1] 0.1836433 0.4874291 0.3898432 0.5939013
> 
> 
> # Row variabilities
> print(rowVars(x))
[1] 1.11767161 0.05022969 0.83582537 2.76819528 0.35351857
> print(rowSds(x))
[1] 1.0571999 0.2241198 0.9142349 1.6637894 0.5945743
> print(rowMads(x))
[1] 0.5749039 0.2251964 1.1601914 0.7557549 0.5896472
> print(rowIQRs(x))
[1] 1.0192025 0.2805548 1.4645402 1.1365751 0.5558750
> 
> # Column variabilities
> print(rowVars(x))
[1] 1.11767161 0.05022969 0.83582537 2.76819528 0.35351857
> print(colSds(x))
[1] 0.9610394 0.6688342 1.4988744 0.4648177
> print(colMads(x))
[1] 1.2010500 0.3719779 1.4990329 0.5188135
> print(colIQRs(x))
[1] 0.9559616 0.8811697 1.7461715 0.8374115
> 
> # Row ranges
> print(rowRanges(x))
            [,1]      [,2]
[1,] -0.82046838 1.5117812
[2,] -0.01619026 0.4874291
[3,] -0.83562861 0.9438362
[4,] -2.21469989 1.5952808
[5,] -0.30538839 1.1249309
> print(cbind(rowMins(x), rowMaxs(x)))
            [,1]      [,2]
[1,] -0.82046838 1.5117812
[2,] -0.01619026 0.4874291
[3,] -0.83562861 0.9438362
[4,] -2.21469989 1.5952808
[5,] -0.30538839 1.1249309
> print(cbind(rowOrderStats(x, which = 1), rowOrderStats(x, which = ncol(x))))
            [,1]      [,2]
[1,] -0.82046838 1.5117812
[2,] -0.01619026 0.4874291
[3,] -0.83562861 0.9438362
[4,] -2.21469989 1.5952808
[5,] -0.30538839 1.1249309
> 
> # Column ranges
> print(colRanges(x))
            [,1]      [,2]
[1,] -0.83562861 1.5952808
[2,] -0.82046838 0.7383247
[3,] -2.21469989 1.5117812
[4,] -0.04493361 0.9438362
> print(cbind(colMins(x), colMaxs(x)))
            [,1]      [,2]
[1,] -0.83562861 1.5952808
[2,] -0.82046838 0.7383247
[3,] -2.21469989 1.5117812
[4,] -0.04493361 0.9438362
> print(cbind(colOrderStats(x, which = 1), colOrderStats(x, which = nrow(x))))
            [,1]      [,2]
[1,] -0.83562861 1.5952808
[2,] -0.82046838 0.7383247
[3,] -2.21469989 1.5117812
[4,] -0.04493361 0.9438362
> 
> 
> x <- matrix(rnorm(2000), nrow = 50, ncol = 40)
> 
> # Row standard deviations
> d <- rowDiffs(x)
> s1 <- rowSds(d) / sqrt(2)
> s2 <- rowSds(x)
> print(summary(s1 - s2))
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-0.19874 -0.04460  0.01411  0.01097  0.07339  0.27371 
> 
> # Column standard deviations
> d <- colDiffs(x)
> s1 <- colSds(d) / sqrt(2)
> s2 <- colSds(x)
> print(summary(s1 - s2))
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-0.13188 -0.02160  0.02329  0.01879  0.07141  0.15346 
> 
> 
> 
> cleanEx()
> nameEx("rowWeightedMeans")
> ### * rowWeightedMeans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowWeightedMeans
> ### Title: Calculates the weighted means for each row (column) in a matrix
> ### Aliases: rowWeightedMeans colWeightedMeans
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> x <- matrix(rnorm(20), nrow = 5, ncol = 4)
> print(x)
           [,1]       [,2]       [,3]        [,4]
[1,] -0.6264538 -0.8204684  1.5117812 -0.04493361
[2,]  0.1836433  0.4874291  0.3898432 -0.01619026
[3,] -0.8356286  0.7383247 -0.6212406  0.94383621
[4,]  1.5952808  0.5757814 -2.2146999  0.82122120
[5,]  0.3295078 -0.3053884  1.1249309  0.59390132
> 
> # Non-weighted row averages
> mu_0 <- rowMeans(x)
> mu <- rowWeightedMeans(x)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (uniform weights)
> w <- rep(2.5, times = ncol(x))
> mu <- rowWeightedMeans(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (excluding some columns)
> w <- c(1, 1, 0, 1)
> mu_0 <- rowMeans(x[, (w == 1), drop = FALSE])
> mu <- rowWeightedMeans(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (excluding some columns)
> w <- c(0, 1, 0, 0)
> mu_0 <- rowMeans(x[, (w == 1), drop = FALSE])
> mu <- rowWeightedMeans(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted averages by rows and columns
> w <- 1:4
> mu_1 <- rowWeightedMeans(x, w = w)
> mu_2 <- colWeightedMeans(t(x), w = w)
> stopifnot(all.equal(mu_2, mu_1))
> 
> 
> 
> cleanEx()
> nameEx("rowWeightedMedians")
> ### * rowWeightedMedians
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowWeightedMedians
> ### Title: Calculates the weighted medians for each row (column) in a
> ###   matrix
> ### Aliases: rowWeightedMedians colWeightedMedians
> ### Keywords: array iteration robust univar
> 
> ### ** Examples
> 
> x <- matrix(rnorm(20), nrow = 5, ncol = 4)
> print(x)
           [,1]       [,2]       [,3]        [,4]
[1,] -0.6264538 -0.8204684  1.5117812 -0.04493361
[2,]  0.1836433  0.4874291  0.3898432 -0.01619026
[3,] -0.8356286  0.7383247 -0.6212406  0.94383621
[4,]  1.5952808  0.5757814 -2.2146999  0.82122120
[5,]  0.3295078 -0.3053884  1.1249309  0.59390132
> 
> # Non-weighted row averages
> mu_0 <- rowMedians(x)
> mu <- rowWeightedMedians(x)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (uniform weights)
> w <- rep(2.5, times = ncol(x))
> mu <- rowWeightedMedians(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (excluding some columns)
> w <- c(1, 1, 0, 1)
> mu_0 <- rowMedians(x[, (w == 1), drop = FALSE])
> mu <- rowWeightedMedians(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted row averages (excluding some columns)
> w <- c(0, 1, 0, 0)
> mu_0 <- rowMedians(x[, (w == 1), drop = FALSE])
> mu <- rowWeightedMedians(x, w = w)
> stopifnot(all.equal(mu, mu_0))
> 
> # Weighted averages by rows and columns
> w <- 1:4
> mu_1 <- rowWeightedMedians(x, w = w)
> mu_2 <- colWeightedMedians(t(x), w = w)
> stopifnot(all.equal(mu_2, mu_1))
> 
> 
> 
> cleanEx()
> nameEx("sum2")
> ### * sum2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sum2
> ### Title: Fast sum over subset of vector elements
> ### Aliases: sum2
> ### Keywords: internal univar
> 
> ### ** Examples
> 
> x <- 1:10
> n <- length(x)
> 
> idxs <- seq(from = 1, to = n, by = 2)
> s1 <- sum(x[idxs])                     # 25
> s2 <- sum2(x, idxs = idxs)             # 25
> stopifnot(identical(s1, s2))
> 
> idxs <- seq(from = n, to = 1, by = -2)
> s1 <- sum(x[idxs])                     # 25
> s2 <- sum2(x, idxs = idxs)             # 25
> stopifnot(identical(s1, s2))
> 
> s1 <- sum(x)                           # 55
> s2 <- sum2(x)                          # 55
> stopifnot(identical(s1, s2))
> 
> 
> # Total gives integer overflow
> x <- c(.Machine$integer.max, 1L, -.Machine$integer.max)
> s1 <- sum(x[1:2])                      # NA_integer_ in R (< 3.5.0)
> s2 <- sum2(x[1:2])                     # NA_integer_
Warning in sum2(x[1:2]) :
  Integer overflow. Use sum2(..., mode = "double") to avoid this.
> 
> # Total gives integer overflow (coerce to numeric)
> s1 <- sum(as.numeric(x[1:2]))          # 2147483648
> s2 <- sum2(as.numeric(x[1:2]))         # 2147483648
> s3 <- sum2(x[1:2], mode = "double")    # 2147483648 w/out copy
> stopifnot(identical(s1, s2))
> stopifnot(identical(s1, s3))
> 
> # Cumulative sum would give integer overflow but not the total
> s1 <- sum(x)                           # 1L
> s2 <- sum2(x)                          # 1L
> stopifnot(identical(s1, s2))
> 
> 
> 
> cleanEx()
> nameEx("weightedMad")
> ### * weightedMad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weightedMad
> ### Title: Weighted Median Absolute Deviation (MAD)
> ### Aliases: weightedMad rowWeightedMads colWeightedMads
> ### Keywords: robust univar
> 
> ### ** Examples
> 
> x <- 1:10
> n <- length(x)
> 
> m1 <- mad(x)
> m2 <- weightedMad(x)
> stopifnot(identical(m1, m2))
> 
> w <- rep(1, times = n)
> m1 <- weightedMad(x, w)
> stopifnot(identical(m1, m2))
> 
> # All weight on the first value
> w[1] <- Inf
> m <- weightedMad(x, w)
> stopifnot(m  == 0)
> 
> # All weight on the first two values
> w[1:2] <- Inf
> m1 <- mad(x[1:2])
> m2 <- weightedMad(x, w)
> stopifnot(identical(m1, m2))
> 
> # All weights set to zero
> w <- rep(0, times = n)
> m <- weightedMad(x, w)
> stopifnot(is.na(m))
> 
> 
> 
> cleanEx()
> nameEx("weightedMean")
> ### * weightedMean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weightedMean
> ### Title: Weighted Arithmetic Mean
> ### Aliases: weightedMean
> ### Keywords: robust univar
> 
> ### ** Examples
> 
> x <- 1:10
> n <- length(x)
> 
> w <- rep(1, times = n)
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> # Pull the mean towards zero
> w[1] <- 5
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> # Put even more weight on the zero
> w[1] <- 8.5
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> # All weight on the first value
> w[1] <- Inf
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> # All weight on the last value
> w[1] <- 1
> w[n] <- Inf
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> # All weights set to zero
> w <- rep(0, times = n)
> m0 <- weighted.mean(x, w)
> m1 <- weightedMean(x, w)
> stopifnot(identical(m1, m0))
> 
> 
> 
> cleanEx()
> nameEx("weightedMedian")
> ### * weightedMedian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weightedMedian
> ### Title: Weighted Median Value
> ### Aliases: weightedMedian
> ### Keywords: robust univar
> 
> ### ** Examples
> 
> x <- 1:10
> n <- length(x)
> 
> m1 <- median(x)                             # 5.5
> m2 <- weightedMedian(x)                     # 5.5
> stopifnot(identical(m1, m2))
> 
> w <- rep(1, times = n)
> m1 <- weightedMedian(x, w)                  # 5.5 (default)
> m2 <- weightedMedian(x, ties = "weighted")  # 5.5 (default)
> m3 <- weightedMedian(x, ties = "min")       # 5
> m4 <- weightedMedian(x, ties = "max")       # 6
> stopifnot(identical(m1, m2))
> 
> # Pull the median towards zero
> w[1] <- 5
> m1 <- weightedMedian(x, w)                  # 3.5
> y <- c(rep(0, times = w[1]), x[-1])         # Only possible for integer weights
> m2 <- median(y)                             # 3.5
> stopifnot(identical(m1, m2))
> 
> # Put even more weight on the zero
> w[1] <- 8.5
> weightedMedian(x, w)                # 2
[1] 1.947368
> 
> # All weight on the first value
> w[1] <- Inf
> weightedMedian(x, w)                # 1
[1] 1
> 
> # All weight on the last value
> w[1] <- 1
> w[n] <- Inf
> weightedMedian(x, w)                # 10
[1] 10
> 
> # All weights set to zero
> w <- rep(0, times = n)
> weightedMedian(x, w)                # NA
[1] NA
> 
> # Simple benchmarking
> bench <- function(N = 1e5, K = 10) {
+   x <- rnorm(N)
+   gc()
+   t <- c()
+   t[1] <- system.time(for (k in 1:K) median(x))[3]
+   t[2] <- system.time(for (k in 1:K) weightedMedian(x))[3]
+   t <- t / t[1]
+   names(t) <- c("median", "weightedMedian")
+   t
+ }
> 
> print(bench(N =     5, K = 100))
        median weightedMedian 
             1              0 
> print(bench(N =    50, K = 100))
        median weightedMedian 
             1              0 
> print(bench(N =   200, K = 100))
        median weightedMedian 
           1.0            0.5 
> print(bench(N =  1000, K = 100))
        median weightedMedian 
     1.0000000      0.6666667 
> print(bench(N =  10e3, K =  20))
        median weightedMedian 
             1              7 
> print(bench(N = 100e3, K =  20))
        median weightedMedian 
      1.000000       3.454545 
> 
> 
> 
> cleanEx()
> nameEx("x_OP_y")
> ### * x_OP_y
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: x_OP_y
> ### Title: Fast calculation of 'z <- x OP y' and 'z <- t(t(x) OP y)'
> ### Aliases: x_OP_y t_tx_OP_y
> ### Keywords: internal
> 
> ### ** Examples
> 
> x <- matrix(c(1, 2, 3, NA, 5, 6), nrow = 3, ncol = 2)
> 
> # Add 'y' to each column
> y <- 1:2
> z0 <- x + y
> z1 <- x_OP_y(x, y, OP = "+")
> print(z1)
     [,1] [,2]
[1,]    2   NA
[2,]    4    6
[3,]    4    8
> stopifnot(all.equal(z1, z0))
> 
> 
> # Add 'y' to each row
> y <- 1:3
> z0 <- t(t(x) + y)
> z1 <- t_tx_OP_y(x, y, OP = "+")
> print(z1)
     [,1] [,2]
[1,]    2   NA
[2,]    5    6
[3,]    5    9
> stopifnot(all.equal(z1, z0))
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.661 0.038 0.698 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
