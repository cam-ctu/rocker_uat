
R version 4.5.0 (2025-04-11) -- "How About a Twenty-Six"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### Tests of iconv, especially 'sub'
> 
> ## Status:
> str(l10n_info()) # platform specific (-> help page)
List of 4
 $ MBCS   : logi TRUE
 $ UTF-8  : logi TRUE
 $ Latin-1: logi FALSE
 $ codeset: chr "UTF-8"
> 		 # also changes from Sys.setenv / Sys.setlocale
> Sys.getlocale()
[1] "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=C;LC_COLLATE=C;LC_MONETARY=en_US.UTF-8;LC_MESSAGES=en_US.UTF-8;LC_PAPER=en_US.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_US.UTF-8;LC_IDENTIFICATION=C"
> (iconv_version <- extSoftVersion()[["iconv"]])
[1] "glibc 2.39"
> known_iconv <- iconv_version != "unknown"  # musl's iconv is "unknown"
> 
> xU <- "a\xE7\xFAcar" # "aÃ§Ãºcar" (Portuguese)
> (x <- xU) # (..\xe7..)
[1] "a\xe7\xfacar"
> Encoding(x) <- "latin1"
> stopifnot(Encoding(x) == "latin1")
> x
[1] "aÃ§Ãºcar"
> xx <- iconv(x, "latin1", "UTF-8")
> xx
[1] "aÃ§Ãºcar"
> stopifnot(Encoding(xx) == "UTF-8") # iconv() uses mark = TRUE by default
> ## encoding does *not* matter, even though they differ internally:
> stopifnot(identical(xx, x), xx == x)
> 
> chkEQpr <- function(x, TR) stopifnot(print(x) == TR)
> chkEQpr(charToRaw(xx), as.raw(c(0x61, 0xc3, 0xa7, 0xc3, 0xba, 0x63, 0x61, 0x72)))
[1] 61 c3 a7 c3 ba 63 61 72
> 
> ## iconv() with substitution:
> iconv(c(x, xx), to = "ASCII", sub = NA) # default
[1] NA NA
> ## often both NA, but could still use substitution ("a**car" with musl's iconv)
> stopifnot(length(tools::showNonASCII(c(x, xx))) == 2L) # robust via string comparison
1: a<e7><fa>car
2: a<c3><a7><c3><ba>car
> ## output for most iconvs (at least GNU libiconv, glibc, win_iconv, macOS >= 14):
> ## 1: a<e7><fa>car
> ## 2: a<c3><a7><c3><ba>car
> ## musl:
> ## 1: a**car
> ## 2: a****car
> 
> if (known_iconv) withAutoprint({
+     chkEQpr(iconv(x, "latin1", "ASCII", "?"   ), "a??car")
+     chkEQpr(iconv(x, "latin1", "ASCII", ""    ), "acar")
+     chkEQpr(iconv(x, "latin1", "ASCII", "byte"), "a<e7><fa>car")
+     chkEQpr(iconv(xx, "UTF-8", "ASCII", "Unicode"), "a<U+00E7><U+00FA>car")
+     chkEQpr(iconv(xx, "UTF-8", "ASCII", "c99"    ), "a\\u00e7\\u00facar")
+     chkEQpr(charToRaw(iconv(xx, "UTF-8", "ASCII", "c99")),
+             sapply(c("a", "\\","u", "0","0","e","7",
+                      "\\","u", "0","0","f","a",  "c","a","r"), charToRaw))
+ })
> chkEQpr(iconv(x, "latin1", "ASCII", "?"), "a??car")
[1] "a??car"
> chkEQpr(iconv(x, "latin1", "ASCII", ""), "acar")
[1] "acar"
> chkEQpr(iconv(x, "latin1", "ASCII", "byte"), "a<e7><fa>car")
[1] "a<e7><fa>car"
> chkEQpr(iconv(xx, "UTF-8", "ASCII", "Unicode"), "a<U+00E7><U+00FA>car")
[1] "a<U+00E7><U+00FA>car"
> chkEQpr(iconv(xx, "UTF-8", "ASCII", "c99"), "a\\u00e7\\u00facar")
[1] "a\\u00e7\\u00facar"
> chkEQpr(charToRaw(iconv(xx, "UTF-8", "ASCII", "c99")), sapply(c("a", "\\", 
+     "u", "0", "0", "e", "7", "\\", "u", "0", "0", "f", "a", "c", "a", "r"), charToRaw))
 [1] 61 5c 75 30 30 65 37 5c 75 30 30 66 61 63 61 72
> 
> z <- "\U1f600"
> chkEQpr(charToRaw(z), as.raw(c(0xf0, 0x9f, 0x98, 0x80)))
[1] f0 9f 98 80
> if (known_iconv) withAutoprint({
+     chkEQpr(iconv(z, "UTF-8", "ASCII", "byte"), "<f0><9f><98><80>")
+     chkEQpr(iconv(z, "UTF-8", "ASCII", "Unicode"), "<U+1F600>")
+     chkEQpr(iconv(z, "UTF-8", "ASCII", "c99"    ), "\\U0001f600")
+ })
> chkEQpr(iconv(z, "UTF-8", "ASCII", "byte"), "<f0><9f><98><80>")
[1] "<f0><9f><98><80>"
> chkEQpr(iconv(z, "UTF-8", "ASCII", "Unicode"), "<U+1F600>")
[1] "<U+1F600>"
> chkEQpr(iconv(z, "UTF-8", "ASCII", "c99"), "\\U0001f600")
[1] "\\U0001f600"
> 
> ## write out to compare with GNU libiconv's iconv on e.g. macOS < 14
> ## The reading can only work in a UTF-8 locale
> if(startsWith(iconv_version, 'GNU libiconv') &&
+    l10n_info()[["UTF-8"]]) {
+     writeLines(c(xx, z), "test.txt")
+     zz <- system2("iconv", c("-f", "UTF-8", "-t", "c99", "test.txt"),
+                   stdout = TRUE)
+     unlink('test.txt')
+     stopifnot(zz == iconv(c(xx, z), "UTF-8", "ASCII", "c99"))
+     message('sub = "c99" agrees with GNU libiconv')
+ } else message('sub = "c99" agrees with GNU libiconv -- SKIPPED')
sub = "c99" agrees with GNU libiconv -- SKIPPED
> 
> ##------------- former  ./encodings.R  -----------------------------------
> 
> ## from iconv.Rd , things not above already:
> 
> # Extracts from R help files
> (x <- c("Ekstr\xf8m", "J\xf6reskog", "bi\xdfchen Z\xfcrcher"))
[1] "Ekstr\xf8m"            "J\xf6reskog"           "bi\xdfchen Z\xfcrcher"
> iconv(x, "latin1", "ASCII//TRANSLIT")
[1] "Ekstrom"          "Joreskog"         "bisschen Zurcher"
> iconv(x, "latin1", "ASCII", sub="byte")
[1] "Ekstr<f8>m"            "J<f6>reskog"           "bi<df>chen Z<fc>rcher"
> 
> ## tests of re-encoding in .C
> require("tools")
Loading required package: tools
> (x. <- "a\xE7\xFAcar")
[1] "a\xe7\xfacar"
> Renctest <- tools:::C_Renctest
> (x.en <- .C(Renctest, x.)[[1]])
'açúcar', nbytes = 6
[1] "a\xe7\xfacar"
> x <- x.; Encoding(x) <- "latin1"; x
[1] "aÃ§Ãºcar"
> (xen <- .C(Renctest, x)[[1]])
'aÃ§Ãºcar', nbytes = 8
[1] "aÃ§Ãºcar"
> (xx <- iconv(x, "latin1", "UTF-8"))
[1] "aÃ§Ãºcar"
> (xxen <- .C(Renctest, xx)[[1]])
'aÃ§Ãºcar', nbytes = 8
[1] "aÃ§Ãºcar"
> ## TODO: check these {all TRUE in UTF-8  but only 1st in "C" locale}
> identical(x., x.en)
[1] TRUE
> identical(x ,  xen)
[1] TRUE
> identical(xx, xxen)
[1] TRUE
> ##
> c(x.= Encoding(x.), x.en= Encoding(x.en),
+   x = Encoding(x),  xen = Encoding(xen),
+   xx= Encoding(xx), xxen= Encoding(xxen)) -> encs
> encs #  (unk unk  latin1 unk   UTF-8 unk)   in UTF-8  *and*  C locale (but not latin1)
       x.      x.en         x       xen        xx      xxen 
"unknown" "unknown"  "latin1" "unknown"   "UTF-8" "unknown" 
> ## TODO: s/all/stopifnot/  {here and below}
> all(encs == local({ u <- "unknown"; l <- "latin1"
+                     lu <- if(l10n_info()[["Latin-1"]]) l else u
+                     c(u, lu, l, u, "UTF-8", u) }))
[1] TRUE
> 
> ## tests of match length in  delimMatch(x, delim = c("{", "}"))
> (x <- c("a{bc}d", "{a\xE7b}"))
[1] "a{bc}d"   "{a\xe7b}"
> dM1 <- if(!l10n_info()[["MBCS"]]) { # not for multibyte locale
+             delimMatch(x) # fine w/ LC_ALL=C ; otherwise Error: "invalid multibyte string"
+  } else try(delimMatch(x))
Error in delimMatch(x) : invalid multibyte string at '<e7>b}'
> if(is.numeric(dM1)) all(print(dM1), structure(2:1, match.length = 4:5)) ## TODO stopifnot
> (xx <- iconv(x, "latin1", "UTF-8"))
[1] "a{bc}d" "{aÃ§b}" 
> str(dMx <- delimMatch(xx))
 int [1:2] 2 1
 - attr(*, "match.length")= int [1:2] 4 5
> ## 4 12 in "C" (4 5 in UTF-8, latin1, ?) -- was 5 6 in latin1, 5 5 in UTF-8
> (ok <- with(l10n_info(), `UTF-8` || `Latin-1`)) # when else?
[1] TRUE
> mlength <- if(ok) 4:5 else c(4L, 12L)
> all(identical(dMx, structure(2:1, match.length = mlength)))
[1] TRUE
> 
