
R version 4.5.0 (2025-04-11) -- "How About a Twenty-Six"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:49:44.521] plan(<NULL>, .skip = FALSE, .cleanup = NA, .init = TRUE) ...
[10:49:44.522] |  Getting current ("next") strategy: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:49:44.522] plan(<FutureStrategy>, .skip = FALSE, .cleanup = NA, .init = TRUE) ... done
[10:49:44.522] plan(<character>, .skip = FALSE, .cleanup = NA, .init = TRUE) ...
[10:49:44.561] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = TRUE) ...
[10:49:44.561] |  :  all.equal() for FutureStrategyList ...
[10:49:44.562] |  :  .  New stack:
[10:49:44.562] |  :  .  List of 1
[10:49:44.562] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:49:44.562] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:49:44.562] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:49:44.562] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.562] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.562] |  :  .    ..- attr(*, "call")= language future::plan("sequential")
[10:49:44.562] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:49:44.566] |  :  .  Old stack:
[10:49:44.566] |  :  .  List of 1
[10:49:44.566] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:49:44.566] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:49:44.566] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:49:44.566] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.566] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.566] |  :  .    ..- attr(*, "call")= language plan(sequential)
[10:49:44.566] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:49:44.568] |  :  .  Not identical
[10:49:44.568] |  :  .  all.equal() for future ...
[10:49:44.568] |  :  .  |  List of 2
[10:49:44.568] |  :  .  |   $ target :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:49:44.568] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:49:44.568] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:49:44.568] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.568] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.568] |  :  .  |    ..- attr(*, "call")= language future::plan("sequential")
[10:49:44.568] |  :  .  |   $ current:function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:49:44.568] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:49:44.568] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:49:44.568] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.568] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:49:44.568] |  :  .  |    ..- attr(*, "call")= language plan(sequential)
[10:49:44.572] |  :  .  all.equal() for future ... done
[10:49:44.572] |  :  all.equal() for FutureStrategyList ... done
[10:49:44.572] |  :  plan(): Skip setting new future strategy stack because it is the same as the current one:
[10:49:44.572] |  :  List of future strategies:
[10:49:44.572] |  :  1. sequential:
[10:49:44.572] |  :     - args: function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame(), workers = "<NULL>")
[10:49:44.572] |  :     - tweaked: FALSE
[10:49:44.572] |  :     - call: plan(sequential)
[10:49:44.573] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = TRUE) ... done
[10:49:44.573] plan(<sequential>, .skip = FALSE, .cleanup = NA, .init = TRUE) ... done
> library("tools") ## toTitleCase()
> 
> options(future.debug = FALSE)
> options(future.apply.debug = TRUE)
> 
> message("*** future_lapply() - globals ...")
*** future_lapply() - globals ...
> 
> plan(cluster, workers = "localhost")
> 
> a <- 1
> b <- 2
> 
> globals_set <- list(
+   A = FALSE,
+   B = TRUE,
+   C = c("a", "b"),
+   D = list(a = 2, b = 3)
+ )
> 
> x <- list(1)
> y_truth <- list(A = NULL, B = list(1), C = list(1), D = list(2))
> str(y_truth)
List of 4
 $ A: NULL
 $ B:List of 1
  ..$ : num 1
 $ C:List of 1
  ..$ : num 1
 $ D:List of 1
  ..$ : num 2
> 
> for (name in names(globals_set)) {
+   globals <- globals_set[[name]]
+   message("Globals set ", sQuote(name))
+   y <- tryCatch({
+     future_lapply(x, FUN = function(x) {
+       median(c(x, a, b))
+     }, future.globals = globals, future.packages = "utils")
+   }, error = identity)
+   print(y)
+   stopifnot((name == "A" && inherits(y, "error")) || 
+              identical(y, y_truth[[name]]))
+ }
Globals set ‘A’
[10:49:45.008] future_lapply() ...
[10:49:45.014] Number of chunks: 1
[10:49:45.015] getGlobalsAndPackagesXApply() ...
[10:49:45.015]  - future.globals: FALSE
[10:49:45.018]  - globals found/used: [n=2] ‘FUN’, ‘future.call.arguments’
[10:49:45.018]  - needed namespaces: [n=0] 
[10:49:45.018] Finding globals ... DONE
[10:49:45.018]  - use_args: TRUE
[10:49:45.018]  - Getting '...' globals ...
[10:49:45.019]    - '...' content: [n=0] 
[10:49:45.019] List of 1
[10:49:45.019]  $ ...: list()
[10:49:45.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.019]  - attr(*, "where")=List of 1
[10:49:45.019]   ..$ ...:<environment: 0x55d1ccc081c0> 
[10:49:45.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.019]  - attr(*, "resolved")= logi TRUE
[10:49:45.019]  - attr(*, "total_size")= num NA
[10:49:45.022]  - Getting '...' globals ... DONE
[10:49:45.022] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘future.call.arguments’, ‘...’
[10:49:45.022] List of 3
[10:49:45.022]  $ ...future.FUN        :function (x)  
[10:49:45.022]  $ future.call.arguments: list()
[10:49:45.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.022]  $ ...                  : list()
[10:49:45.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.022]  - attr(*, "where")=List of 3
[10:49:45.022]   ..$ ...future.FUN        :<environment: R_EmptyEnv> 
[10:49:45.022]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:49:45.022]   ..$ ...                  :<environment: 0x55d1ccc081c0> 
[10:49:45.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.022]  - attr(*, "resolved")= logi FALSE
[10:49:45.022]  - attr(*, "total_size")= num 5070
[10:49:45.026] Packages to be attached in all futures: [n=1] ‘utils’
[10:49:45.026] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.026] Number of futures (= number of chunks): 1
[10:49:45.026] Launching 1 futures (chunks) ...
[10:49:45.026] Chunk #1 of 1 ...
[10:49:45.027]  - seeds: <none>
[10:49:45.027]  - All globals exported: [n=6] ‘...future.FUN’, ‘future.call.arguments’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.088] Created future:
[10:49:45.088] ClusterFuture:
[10:49:45.088] Label: ‘future_lapply-1’
[10:49:45.088] Expression:
[10:49:45.088] {
[10:49:45.088]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.088]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.088]     "# as a global variable                                         "
[10:49:45.088]     do.call(function(...) {
[10:49:45.088]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.088]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.088]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.088]         "# anonymous function.                                          "
[10:49:45.088]         "#                                                              "
[10:49:45.088]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.088]         "# function environment of FUN() to the calling environment.    "
[10:49:45.088]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.088]         "# global environment, which is where globals are written.      "
[10:49:45.088]         penv <- env <- environment(...future.FUN)
[10:49:45.088]         repeat {
[10:49:45.088]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.088]                 emptyenv())) 
[10:49:45.088]                 break
[10:49:45.088]             penv <- env
[10:49:45.088]             env <- parent.env(env)
[10:49:45.088]         }
[10:49:45.088]         if (identical(penv, globalenv())) {
[10:49:45.088]             environment(...future.FUN) <- environment()
[10:49:45.088]         }
[10:49:45.088]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.088]             !isNamespace(penv)) {
[10:49:45.088]             parent.env(penv) <- environment()
[10:49:45.088]         }
[10:49:45.088]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.088]         {
[10:49:45.088]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.088]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.088]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.088]                 on.exit(options(oopts), add = TRUE)
[10:49:45.088]             }
[10:49:45.088]             {
[10:49:45.088]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.088]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.088]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.088]                 })
[10:49:45.088]             }
[10:49:45.088]         }
[10:49:45.088]     }, args = future.call.arguments)
[10:49:45.088] }
[10:49:45.088] Lazy evaluation: FALSE
[10:49:45.088] Asynchronous evaluation: TRUE
[10:49:45.088] Local evaluation: TRUE
[10:49:45.088] Environment: R_GlobalEnv
[10:49:45.088] Capture standard output: TRUE
[10:49:45.088] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.088] Immediate condition classes: ‘immediateCondition’
[10:49:45.088] Globals: 5 objects totaling 881 bytes (function ‘...future.FUN’ of 683 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.088] Packages: 1 packages (‘utils’)
[10:49:45.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.088] Resolved: FALSE
[10:49:45.088] Value: <not collected>
[10:49:45.088] Conditions captured: <none>
[10:49:45.088] Early signaling: FALSE
[10:49:45.088] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.088] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.101] Chunk #1 of 1 ... DONE
[10:49:45.101] Launching 1 futures (chunks) ... DONE
[10:49:45.101] Resolving 1 futures (chunks) ...
<simpleError in ...future.FUN(...future.X_jj, ...): object 'a' not found>
Globals set ‘B’
[10:49:45.192] future_lapply() ...
[10:49:45.193] Number of chunks: 1
[10:49:45.193] getGlobalsAndPackagesXApply() ...
[10:49:45.193]  - future.globals: TRUE
[10:49:45.197]  - globals found/used: [n=3] ‘FUN’, ‘a’, ‘b’
[10:49:45.197]  - needed namespaces: [n=1] ‘stats’
[10:49:45.197] Finding globals ... DONE
[10:49:45.197]  - use_args: TRUE
[10:49:45.197]  - Getting '...' globals ...
[10:49:45.198]    - '...' content: [n=0] 
[10:49:45.198] List of 1
[10:49:45.198]  $ ...: list()
[10:49:45.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.198]  - attr(*, "where")=List of 1
[10:49:45.198]   ..$ ...:<environment: 0x55d1ced4ae00> 
[10:49:45.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.198]  - attr(*, "resolved")= logi TRUE
[10:49:45.198]  - attr(*, "total_size")= num NA
[10:49:45.201]  - Getting '...' globals ... DONE
[10:49:45.201] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘a’, ‘b’, ‘...’
[10:49:45.201] List of 4
[10:49:45.201]  $ ...future.FUN:function (x)  
[10:49:45.201]  $ a            : num 1
[10:49:45.201]  $ b            : num 2
[10:49:45.201]  $ ...          : list()
[10:49:45.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.201]  - attr(*, "where")=List of 4
[10:49:45.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.201]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:45.201]   ..$ b            :<environment: R_EmptyEnv> 
[10:49:45.201]   ..$ ...          :<environment: 0x55d1ced4ae00> 
[10:49:45.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.201]  - attr(*, "resolved")= logi FALSE
[10:49:45.201]  - attr(*, "total_size")= num 5051
[10:49:45.209] Packages to be attached in all futures: [n=2] ‘stats’, ‘utils’
[10:49:45.210] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.210] Number of futures (= number of chunks): 1
[10:49:45.210] Launching 1 futures (chunks) ...
[10:49:45.210] Chunk #1 of 1 ...
[10:49:45.210]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.210]    + additional globals found: [n=0] 
[10:49:45.210]    + additional namespaces needed: [n=0] 
[10:49:45.211]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.211]  - seeds: <none>
[10:49:45.211]  - All globals exported: [n=7] ‘...future.FUN’, ‘a’, ‘b’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.236] Created future:
[10:49:45.236] ClusterFuture:
[10:49:45.236] Label: ‘future_lapply-1’
[10:49:45.236] Expression:
[10:49:45.236] {
[10:49:45.236]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.236]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.236]     "# as a global variable                                         "
[10:49:45.236]     do.call(function(...) {
[10:49:45.236]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.236]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.236]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.236]         "# anonymous function.                                          "
[10:49:45.236]         "#                                                              "
[10:49:45.236]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.236]         "# function environment of FUN() to the calling environment.    "
[10:49:45.236]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.236]         "# global environment, which is where globals are written.      "
[10:49:45.236]         penv <- env <- environment(...future.FUN)
[10:49:45.236]         repeat {
[10:49:45.236]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.236]                 emptyenv())) 
[10:49:45.236]                 break
[10:49:45.236]             penv <- env
[10:49:45.236]             env <- parent.env(env)
[10:49:45.236]         }
[10:49:45.236]         if (identical(penv, globalenv())) {
[10:49:45.236]             environment(...future.FUN) <- environment()
[10:49:45.236]         }
[10:49:45.236]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.236]             !isNamespace(penv)) {
[10:49:45.236]             parent.env(penv) <- environment()
[10:49:45.236]         }
[10:49:45.236]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.236]         {
[10:49:45.236]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.236]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.236]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.236]                 on.exit(options(oopts), add = TRUE)
[10:49:45.236]             }
[10:49:45.236]             {
[10:49:45.236]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.236]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.236]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.236]                 })
[10:49:45.236]             }
[10:49:45.236]         }
[10:49:45.236]     }, args = future.call.arguments)
[10:49:45.236] }
[10:49:45.236] Lazy evaluation: FALSE
[10:49:45.236] Asynchronous evaluation: TRUE
[10:49:45.236] Local evaluation: TRUE
[10:49:45.236] Environment: R_GlobalEnv
[10:49:45.236] Capture standard output: TRUE
[10:49:45.236] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.236] Immediate condition classes: ‘immediateCondition’
[10:49:45.236] Globals: 7 objects totaling 959 bytes (function ‘...future.FUN’ of 683 bytes, numeric ‘a’ of 39 bytes, numeric ‘b’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, ...)
[10:49:45.236] Packages: 2 packages (‘stats’, ‘utils’)
[10:49:45.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.236] Resolved: FALSE
[10:49:45.236] Value: <not collected>
[10:49:45.236] Conditions captured: <none>
[10:49:45.236] Early signaling: FALSE
[10:49:45.236] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.236] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.248] Chunk #1 of 1 ... DONE
[10:49:45.248] Launching 1 futures (chunks) ... DONE
[10:49:45.248] Resolving 1 futures (chunks) ...
[10:49:45.290]  - Number of value chunks collected: 1
[10:49:45.290] Resolving 1 futures (chunks) ... DONE
[10:49:45.290] Reducing values from 1 chunks ...
[10:49:45.290]  - Number of values collected after concatenation: 1
[10:49:45.290]  - Number of values expected: 1
[10:49:45.291] Reducing values from 1 chunks ... DONE
[10:49:45.291] future_lapply() ... DONE
[[1]]
[1] 1

Globals set ‘C’
[10:49:45.291] future_lapply() ...
[10:49:45.292] Number of chunks: 1
[10:49:45.292] getGlobalsAndPackagesXApply() ...
[10:49:45.292]  - future.globals: ‘a’, ‘b’
[10:49:45.292]  - use_args: TRUE
[10:49:45.292] Globals to be used in all futures (chunks): [n=4] ‘a’, ‘b’, ‘...future.FUN’, ‘...’
[10:49:45.292] List of 4
[10:49:45.292]  $ a            : num 1
[10:49:45.292]  $ b            : num 2
[10:49:45.292]  $ ...future.FUN:function (x)  
[10:49:45.292]  $ ...          : list()
[10:49:45.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.292]  - attr(*, "where")=List of 4
[10:49:45.292]   ..$ a            :<environment: R_GlobalEnv> 
[10:49:45.292]   ..$ b            :<environment: R_GlobalEnv> 
[10:49:45.292]   ..$ ...future.FUN:<environment: 0x55d1cd51c6a0> 
[10:49:45.292]   ..$ ...          :<environment: 0x55d1cd51c6a0> 
[10:49:45.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.292]  - attr(*, "resolved")= logi FALSE
[10:49:45.292]  - attr(*, "total_size")= num NA
[10:49:45.296] Packages to be attached in all futures: [n=1] ‘utils’
[10:49:45.297] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.297] Number of futures (= number of chunks): 1
[10:49:45.297] Launching 1 futures (chunks) ...
[10:49:45.297] Chunk #1 of 1 ...
[10:49:45.297]  - seeds: <none>
[10:49:45.297]  - All globals exported: [n=7] ‘a’, ‘b’, ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.362] Created future:
[10:49:45.362] ClusterFuture:
[10:49:45.362] Label: ‘future_lapply-1’
[10:49:45.362] Expression:
[10:49:45.362] {
[10:49:45.362]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.362]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.362]     "# as a global variable                                         "
[10:49:45.362]     do.call(function(...) {
[10:49:45.362]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.362]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.362]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.362]         "# anonymous function.                                          "
[10:49:45.362]         "#                                                              "
[10:49:45.362]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.362]         "# function environment of FUN() to the calling environment.    "
[10:49:45.362]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.362]         "# global environment, which is where globals are written.      "
[10:49:45.362]         penv <- env <- environment(...future.FUN)
[10:49:45.362]         repeat {
[10:49:45.362]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.362]                 emptyenv())) 
[10:49:45.362]                 break
[10:49:45.362]             penv <- env
[10:49:45.362]             env <- parent.env(env)
[10:49:45.362]         }
[10:49:45.362]         if (identical(penv, globalenv())) {
[10:49:45.362]             environment(...future.FUN) <- environment()
[10:49:45.362]         }
[10:49:45.362]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.362]             !isNamespace(penv)) {
[10:49:45.362]             parent.env(penv) <- environment()
[10:49:45.362]         }
[10:49:45.362]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.362]         {
[10:49:45.362]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.362]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.362]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.362]                 on.exit(options(oopts), add = TRUE)
[10:49:45.362]             }
[10:49:45.362]             {
[10:49:45.362]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.362]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.362]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.362]                 })
[10:49:45.362]             }
[10:49:45.362]         }
[10:49:45.362]     }, args = future.call.arguments)
[10:49:45.362] }
[10:49:45.362] Lazy evaluation: FALSE
[10:49:45.362] Asynchronous evaluation: TRUE
[10:49:45.362] Local evaluation: TRUE
[10:49:45.362] Environment: R_GlobalEnv
[10:49:45.362] Capture standard output: TRUE
[10:49:45.362] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.362] Immediate condition classes: ‘immediateCondition’
[10:49:45.362] Globals: 7 objects totaling 959 bytes (numeric ‘a’ of 39 bytes, numeric ‘b’ of 39 bytes, function ‘...future.FUN’ of 683 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, ...)
[10:49:45.362] Packages: 1 packages (‘utils’)
[10:49:45.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.362] Resolved: FALSE
[10:49:45.362] Value: <not collected>
[10:49:45.362] Conditions captured: <none>
[10:49:45.362] Early signaling: FALSE
[10:49:45.362] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.362] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.374] Chunk #1 of 1 ... DONE
[10:49:45.374] Launching 1 futures (chunks) ... DONE
[10:49:45.374] Resolving 1 futures (chunks) ...
[10:49:45.416]  - Number of value chunks collected: 1
[10:49:45.417] Resolving 1 futures (chunks) ... DONE
[10:49:45.417] Reducing values from 1 chunks ...
[10:49:45.417]  - Number of values collected after concatenation: 1
[10:49:45.417]  - Number of values expected: 1
[10:49:45.417] Reducing values from 1 chunks ... DONE
[10:49:45.417] future_lapply() ... DONE
[[1]]
[1] 1

Globals set ‘D’
[10:49:45.417] future_lapply() ...
[10:49:45.418] Number of chunks: 1
[10:49:45.418] getGlobalsAndPackagesXApply() ...
[10:49:45.418]  - future.globals: <name-value list> with names ‘2’, ‘3’
[10:49:45.418]  - use_args: TRUE
[10:49:45.418]  - Getting '...' globals ...
[10:49:45.419]    - '...' content: [n=0] 
[10:49:45.419] List of 1
[10:49:45.419]  $ ...: list()
[10:49:45.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.419]  - attr(*, "where")=List of 1
[10:49:45.419]   ..$ ...:<environment: 0x55d1cbd5b400> 
[10:49:45.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.419]  - attr(*, "resolved")= logi TRUE
[10:49:45.419]  - attr(*, "total_size")= num NA
[10:49:45.421]  - Getting '...' globals ... DONE
[10:49:45.422] Globals to be used in all futures (chunks): [n=4] ‘a’, ‘b’, ‘...future.FUN’, ‘...’
[10:49:45.422] List of 4
[10:49:45.422]  $ a            : num 2
[10:49:45.422]  $ b            : num 3
[10:49:45.422]  $ ...future.FUN:function (x)  
[10:49:45.422]  $ ...          : list()
[10:49:45.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.422]  - attr(*, "where")=List of 4
[10:49:45.422]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:45.422]   ..$ b            :<environment: R_EmptyEnv> 
[10:49:45.422]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:49:45.422]   ..$ ...          :<environment: 0x55d1cbd5b400> 
[10:49:45.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.422]  - attr(*, "resolved")= logi FALSE
[10:49:45.422]  - attr(*, "total_size")= num NA
[10:49:45.426] Packages to be attached in all futures: [n=1] ‘utils’
[10:49:45.426] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.426] Number of futures (= number of chunks): 1
[10:49:45.426] Launching 1 futures (chunks) ...
[10:49:45.426] Chunk #1 of 1 ...
[10:49:45.426]  - seeds: <none>
[10:49:45.426]  - All globals exported: [n=7] ‘a’, ‘b’, ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.490] Created future:
[10:49:45.490] ClusterFuture:
[10:49:45.490] Label: ‘future_lapply-1’
[10:49:45.490] Expression:
[10:49:45.490] {
[10:49:45.490]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.490]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.490]     "# as a global variable                                         "
[10:49:45.490]     do.call(function(...) {
[10:49:45.490]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.490]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.490]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.490]         "# anonymous function.                                          "
[10:49:45.490]         "#                                                              "
[10:49:45.490]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.490]         "# function environment of FUN() to the calling environment.    "
[10:49:45.490]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.490]         "# global environment, which is where globals are written.      "
[10:49:45.490]         penv <- env <- environment(...future.FUN)
[10:49:45.490]         repeat {
[10:49:45.490]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.490]                 emptyenv())) 
[10:49:45.490]                 break
[10:49:45.490]             penv <- env
[10:49:45.490]             env <- parent.env(env)
[10:49:45.490]         }
[10:49:45.490]         if (identical(penv, globalenv())) {
[10:49:45.490]             environment(...future.FUN) <- environment()
[10:49:45.490]         }
[10:49:45.490]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.490]             !isNamespace(penv)) {
[10:49:45.490]             parent.env(penv) <- environment()
[10:49:45.490]         }
[10:49:45.490]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.490]         {
[10:49:45.490]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.490]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.490]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.490]                 on.exit(options(oopts), add = TRUE)
[10:49:45.490]             }
[10:49:45.490]             {
[10:49:45.490]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.490]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.490]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.490]                 })
[10:49:45.490]             }
[10:49:45.490]         }
[10:49:45.490]     }, args = future.call.arguments)
[10:49:45.490] }
[10:49:45.490] Lazy evaluation: FALSE
[10:49:45.490] Asynchronous evaluation: TRUE
[10:49:45.490] Local evaluation: TRUE
[10:49:45.490] Environment: R_GlobalEnv
[10:49:45.490] Capture standard output: TRUE
[10:49:45.490] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.490] Immediate condition classes: ‘immediateCondition’
[10:49:45.490] Globals: 7 objects totaling 959 bytes (numeric ‘a’ of 39 bytes, numeric ‘b’ of 39 bytes, function ‘...future.FUN’ of 683 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, ...)
[10:49:45.490] Packages: 1 packages (‘utils’)
[10:49:45.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.490] Resolved: FALSE
[10:49:45.490] Value: <not collected>
[10:49:45.490] Conditions captured: <none>
[10:49:45.490] Early signaling: FALSE
[10:49:45.490] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.490] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.502] Chunk #1 of 1 ... DONE
[10:49:45.502] Launching 1 futures (chunks) ... DONE
[10:49:45.502] Resolving 1 futures (chunks) ...
[10:49:45.545]  - Number of value chunks collected: 1
[10:49:45.545] Resolving 1 futures (chunks) ... DONE
[10:49:45.545] Reducing values from 1 chunks ...
[10:49:45.545]  - Number of values collected after concatenation: 1
[10:49:45.545]  - Number of values expected: 1
[10:49:45.545] Reducing values from 1 chunks ... DONE
[10:49:45.545] future_lapply() ... DONE
[[1]]
[1] 2

> 
> message("*** future_lapply() - globals ... DONE")
*** future_lapply() - globals ... DONE
> 
> 
> message("*** future_lapply() - manual globals ...")
*** future_lapply() - manual globals ...
> 
> d <- 42
> y <- future_lapply(1:2, FUN = function(x) { x * d },
+                    future.globals = structure(FALSE, add = "d"))
[10:49:45.546] future_lapply() ...
[10:49:45.546] Number of chunks: 1
[10:49:45.547] getGlobalsAndPackagesXApply() ...
[10:49:45.547]  - future.globals: FALSE
[10:49:45.548]  - globals found/used: [n=3] ‘d’, ‘FUN’, ‘future.call.arguments’
[10:49:45.548]  - needed namespaces: [n=0] 
[10:49:45.548] Finding globals ... DONE
[10:49:45.548]  - use_args: TRUE
[10:49:45.548]  - Getting '...' globals ...
[10:49:45.548]    - '...' content: [n=0] 
[10:49:45.548] List of 1
[10:49:45.548]  $ ...: list()
[10:49:45.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.548]  - attr(*, "where")=List of 1
[10:49:45.548]   ..$ ...:<environment: 0x55d1cec10240> 
[10:49:45.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.548]  - attr(*, "resolved")= logi TRUE
[10:49:45.548]  - attr(*, "total_size")= num NA
[10:49:45.551]  - Getting '...' globals ... DONE
[10:49:45.551] Globals to be used in all futures (chunks): [n=4] ‘d’, ‘...future.FUN’, ‘future.call.arguments’, ‘...’
[10:49:45.551] List of 4
[10:49:45.551]  $ d                    : num 42
[10:49:45.551]  $ ...future.FUN        :function (x)  
[10:49:45.551]  $ future.call.arguments: list()
[10:49:45.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.551]  $ ...                  : list()
[10:49:45.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.551]  - attr(*, "where")=List of 4
[10:49:45.551]   ..$ d                    :<environment: R_EmptyEnv> 
[10:49:45.551]   ..$ ...future.FUN        :<environment: R_EmptyEnv> 
[10:49:45.551]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:49:45.551]   ..$ ...                  :<environment: 0x55d1cec10240> 
[10:49:45.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.551]  - attr(*, "resolved")= logi FALSE
[10:49:45.551]  - attr(*, "total_size")= num 3368
[10:49:45.555] Packages to be attached in all futures: [n=0] 
[10:49:45.555] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.555] Number of futures (= number of chunks): 1
[10:49:45.556] Launching 1 futures (chunks) ...
[10:49:45.556] Chunk #1 of 1 ...
[10:49:45.556]  - seeds: <none>
[10:49:45.556]  - All globals exported: [n=7] ‘d’, ‘...future.FUN’, ‘future.call.arguments’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.621] Created future:
[10:49:45.621] ClusterFuture:
[10:49:45.621] Label: ‘future_lapply-1’
[10:49:45.621] Expression:
[10:49:45.621] {
[10:49:45.621]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.621]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.621]     "# as a global variable                                         "
[10:49:45.621]     do.call(function(...) {
[10:49:45.621]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.621]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.621]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.621]         "# anonymous function.                                          "
[10:49:45.621]         "#                                                              "
[10:49:45.621]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.621]         "# function environment of FUN() to the calling environment.    "
[10:49:45.621]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.621]         "# global environment, which is where globals are written.      "
[10:49:45.621]         penv <- env <- environment(...future.FUN)
[10:49:45.621]         repeat {
[10:49:45.621]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.621]                 emptyenv())) 
[10:49:45.621]                 break
[10:49:45.621]             penv <- env
[10:49:45.621]             env <- parent.env(env)
[10:49:45.621]         }
[10:49:45.621]         if (identical(penv, globalenv())) {
[10:49:45.621]             environment(...future.FUN) <- environment()
[10:49:45.621]         }
[10:49:45.621]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.621]             !isNamespace(penv)) {
[10:49:45.621]             parent.env(penv) <- environment()
[10:49:45.621]         }
[10:49:45.621]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.621]         {
[10:49:45.621]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.621]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.621]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.621]                 on.exit(options(oopts), add = TRUE)
[10:49:45.621]             }
[10:49:45.621]             {
[10:49:45.621]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.621]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.621]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.621]                 })
[10:49:45.621]             }
[10:49:45.621]         }
[10:49:45.621]     }, args = future.call.arguments)
[10:49:45.621] }
[10:49:45.621] Lazy evaluation: FALSE
[10:49:45.621] Asynchronous evaluation: TRUE
[10:49:45.621] Local evaluation: TRUE
[10:49:45.621] Environment: R_GlobalEnv
[10:49:45.621] Capture standard output: TRUE
[10:49:45.621] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.621] Immediate condition classes: ‘immediateCondition’
[10:49:45.621] Globals: 6 objects totaling 372 bytes (numeric ‘d’ of 39 bytes, function ‘...future.FUN’ of 127 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:45.621] Packages: <none>
[10:49:45.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.621] Resolved: FALSE
[10:49:45.621] Value: <not collected>
[10:49:45.621] Conditions captured: <none>
[10:49:45.621] Early signaling: FALSE
[10:49:45.621] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.621] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.633] Chunk #1 of 1 ... DONE
[10:49:45.633] Launching 1 futures (chunks) ... DONE
[10:49:45.633] Resolving 1 futures (chunks) ...
[10:49:45.676]  - Number of value chunks collected: 1
[10:49:45.676] Resolving 1 futures (chunks) ... DONE
[10:49:45.676] Reducing values from 1 chunks ...
[10:49:45.676]  - Number of values collected after concatenation: 2
[10:49:45.676]  - Number of values expected: 2
[10:49:45.676] Reducing values from 1 chunks ... DONE
[10:49:45.676] future_lapply() ... DONE
> stopifnot(identical(y, list(42, 84)))
> 
> e <- 42
> res <- tryCatch({
+   future_lapply(1:2, FUN = function(x) { 2 * e },
+                 future.globals = structure(TRUE, ignore = "e"))
+ }, error = identity)
[10:49:45.676] future_lapply() ...
[10:49:45.677] Number of chunks: 1
[10:49:45.677] getGlobalsAndPackagesXApply() ...
[10:49:45.677]  - future.globals: TRUE
[10:49:45.679]  - globals found/used: [n=1] ‘FUN’
[10:49:45.679]  - needed namespaces: [n=0] 
[10:49:45.679] Finding globals ... DONE
[10:49:45.679]  - use_args: TRUE
[10:49:45.679]  - Getting '...' globals ...
[10:49:45.680]    - '...' content: [n=0] 
[10:49:45.680] List of 1
[10:49:45.680]  $ ...: list()
[10:49:45.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.680]  - attr(*, "where")=List of 1
[10:49:45.680]   ..$ ...:<environment: 0x55d1cd764060> 
[10:49:45.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.680]  - attr(*, "resolved")= logi TRUE
[10:49:45.680]  - attr(*, "total_size")= num NA
[10:49:45.682]  - Getting '...' globals ... DONE
[10:49:45.682] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:45.683] List of 2
[10:49:45.683]  $ ...future.FUN:function (x)  
[10:49:45.683]  $ ...          : list()
[10:49:45.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.683]  - attr(*, "where")=List of 2
[10:49:45.683]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.683]   ..$ ...          :<environment: 0x55d1cd764060> 
[10:49:45.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.683]  - attr(*, "resolved")= logi FALSE
[10:49:45.683]  - attr(*, "total_size")= num 3259
[10:49:45.685] Packages to be attached in all futures: [n=0] 
[10:49:45.685] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.686] Number of futures (= number of chunks): 1
[10:49:45.686] Launching 1 futures (chunks) ...
[10:49:45.686] Chunk #1 of 1 ...
[10:49:45.686]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.686]    + additional globals found: [n=0] 
[10:49:45.686]    + additional namespaces needed: [n=0] 
[10:49:45.686]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.686]  - seeds: <none>
[10:49:45.686]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.750] Created future:
[10:49:45.750] ClusterFuture:
[10:49:45.750] Label: ‘future_lapply-1’
[10:49:45.750] Expression:
[10:49:45.750] {
[10:49:45.750]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.750]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.750]     "# as a global variable                                         "
[10:49:45.750]     do.call(function(...) {
[10:49:45.750]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.750]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.750]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.750]         "# anonymous function.                                          "
[10:49:45.750]         "#                                                              "
[10:49:45.750]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.750]         "# function environment of FUN() to the calling environment.    "
[10:49:45.750]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.750]         "# global environment, which is where globals are written.      "
[10:49:45.750]         penv <- env <- environment(...future.FUN)
[10:49:45.750]         repeat {
[10:49:45.750]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.750]                 emptyenv())) 
[10:49:45.750]                 break
[10:49:45.750]             penv <- env
[10:49:45.750]             env <- parent.env(env)
[10:49:45.750]         }
[10:49:45.750]         if (identical(penv, globalenv())) {
[10:49:45.750]             environment(...future.FUN) <- environment()
[10:49:45.750]         }
[10:49:45.750]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.750]             !isNamespace(penv)) {
[10:49:45.750]             parent.env(penv) <- environment()
[10:49:45.750]         }
[10:49:45.750]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.750]         {
[10:49:45.750]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.750]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.750]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.750]                 on.exit(options(oopts), add = TRUE)
[10:49:45.750]             }
[10:49:45.750]             {
[10:49:45.750]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.750]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.750]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.750]                 })
[10:49:45.750]             }
[10:49:45.750]         }
[10:49:45.750]     }, args = future.call.arguments)
[10:49:45.750] }
[10:49:45.750] Lazy evaluation: FALSE
[10:49:45.750] Asynchronous evaluation: TRUE
[10:49:45.750] Local evaluation: TRUE
[10:49:45.750] Environment: R_GlobalEnv
[10:49:45.750] Capture standard output: TRUE
[10:49:45.750] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.750] Immediate condition classes: ‘immediateCondition’
[10:49:45.750] Globals: 5 objects totaling 345 bytes (function ‘...future.FUN’ of 139 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.750] Packages: <none>
[10:49:45.750] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.750] Resolved: FALSE
[10:49:45.750] Value: <not collected>
[10:49:45.750] Conditions captured: <none>
[10:49:45.750] Early signaling: FALSE
[10:49:45.750] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.750] Class: ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:45.762] Chunk #1 of 1 ... DONE
[10:49:45.762] Launching 1 futures (chunks) ... DONE
[10:49:45.762] Resolving 1 futures (chunks) ...
> stopifnot(inherits(res, "error"))
> 
> message("*** future_lapply() - manual globals ... DONE")
*** future_lapply() - manual globals ... DONE
> 
> 
> 
> ## Test adopted from http://stackoverflow.com/questions/42561088/nested-do-call-within-a-foreach-dopar-environment-cant-find-function-passed-w
> 
> message("*** future_lapply() - tricky globals ...")
*** future_lapply() - tricky globals ...
> 
> my_add <- function(a, b) a + b
> 
> call_my_add <- function(a, b) {
+   do.call(my_add, args = list(a = a, b = b))
+ }
> 
> call_my_add_caller <- function(a, b, FUN = call_my_add) {
+   do.call(FUN, args = list(a = a, b = b))
+ }
> 
> main <- function(x = 1:2, caller = call_my_add_caller,
+                  args = list(FUN = call_my_add)) {
+   results <- future_lapply(x, FUN = function(i) {
+     do.call(caller, args = c(list(a = i, b = i + 1L), args))
+   })
+   results
+ }
> 
> x <- list(list(1:2))
> z_length <- lapply(x, FUN = do.call, what = length)
> fun <- function(...) sum(...)
> z_fun <- lapply(x, FUN = do.call, what = fun)
> 
> y0 <- NULL
> for (strategy in supportedStrategies()) {
+   plan(strategy)
+ 
+   y <- main(1:3)
+   if (is.null(y0)) y0 <- y
+   stopifnot(identical(y, y0))
+ 
+   message("- future_lapply(x, FUN = do.call, ...) ...")
+   z <- future_lapply(x, FUN = do.call, what = length)
+   stopifnot(identical(z, z_length))
+   z <- future_lapply(x, FUN = do.call, what = fun)
+   stopifnot(identical(z, z_fun))
+ 
+   message("- future_lapply(x, ...) - passing arguments via '...' ...")
+   ## typeof() == "list"
+   obj <- data.frame(a = 1:2)
+   stopifnot(typeof(obj) == "list")
+   y <- future_lapply(1L, function(a, b) typeof(b), b = obj)
+   stopifnot(identical(y[[1]], typeof(obj)))
+ 
+   ## typeof() == "environment"
+   obj <- new.env()
+   stopifnot(typeof(obj) == "environment")
+   y <- future_lapply(1L, function(a, b) typeof(b), b = obj)
+   stopifnot(identical(y[[1]], typeof(obj)))
+ 
+   ## typeof() == "S4"
+   if (requireNamespace("methods")) {
+     obj <- methods::getClass("MethodDefinition")
+     stopifnot(typeof(obj) == "S4")
+     y <- future_lapply(1L, function(a, b) typeof(b), b = obj)
+     stopifnot(identical(y[[1]], typeof(obj)))
+   }
+ 
+   message("- future_lapply(X, ...) - 'X' containing globals ...")
+   ## From https://github.com/futureverse/future.apply/issues/12
+   a <- 42
+   b <- 21
+   X <- list(
+     function(b) 2 * a,
+     function() b / 2,
+     function() a + b,
+     function() nchar(toTitleCase("hello world"))
+   )
+   z0 <- lapply(X, FUN = function(f) f())
+   str(z0)
+   z1 <- future_lapply(X, FUN = function(f) f())
+   str(z1)
+   stopifnot(identical(z1, z0))
+ 
+   message("- future_lapply(x, ...) - passing '...' as a global ...")
+   ## https://github.com/HenrikBengtsson/future/issues/417
+   fcn0 <- function(...) { lapply(1, FUN = function(x) list(...)) }
+   z0 <- fcn0(a = 1)
+   str(list(z0 = z0))
+   stopifnot(identical(z0, list(list(a = 1))))
+   fcn <- function(...) { future_lapply(1, FUN = function(x) list(...)) }
+   z1 <- fcn(a = 1)
+   str(list(z1 = z1))
+   stopifnot(identical(z1, z0))
+ 
+   ## https://github.com/futureverse/future.apply/issues/47
+   message("- future_lapply(X, ...) - '{ a <- a + 1; a }' ...")
+   a <- 1
+   z0 <- lapply(1, function(ii) {
+     a <- a + 1
+     a
+   })
+   z1 <- future_lapply(1, function(ii) {
+     a <- a + 1
+     a
+   })
+   stopifnot(identical(z1, z0))
+ 
+   ## https://github.com/futureverse/future.apply/issues/47
+   message("- future_lapply(X, ...) - '{ a; a <- a + 1 }' ...")
+   z2 <- tryCatch(future_lapply(1, function(ii) {
+     a
+     a <- a + 1
+   }), error = identity)
+   stopifnot(identical(z2, z0))
+ 
+   ## https://github.com/futureverse/future.apply/issues/85
+   message("- future_lapply(..., future.globals = <list>) ...")
+   a <- 0
+   y <- future_lapply(1, FUN = function(x) a, future.globals = list(a = 42))
+   str(y)
+   stopifnot(y[[1]] == 42)
+ } ## for (strategy ...)
[10:49:45.867] future_lapply() ...
[10:49:45.869] Number of chunks: 1
[10:49:45.869] getGlobalsAndPackagesXApply() ...
[10:49:45.869]  - future.globals: TRUE
[10:49:45.874]  - globals found/used: [n=5] ‘FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’
[10:49:45.874]  - needed namespaces: [n=0] 
[10:49:45.874] Finding globals ... DONE
[10:49:45.874]  - use_args: TRUE
[10:49:45.874]  - Getting '...' globals ...
[10:49:45.875]    - '...' content: [n=0] 
[10:49:45.875] List of 1
[10:49:45.875]  $ ...: list()
[10:49:45.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.875]  - attr(*, "where")=List of 1
[10:49:45.875]   ..$ ...:<environment: 0x55d1ceaad608> 
[10:49:45.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.875]  - attr(*, "resolved")= logi TRUE
[10:49:45.875]  - attr(*, "total_size")= num NA
[10:49:45.877]  - Getting '...' globals ... DONE
[10:49:45.878] Globals to be used in all futures (chunks): [n=6] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’
[10:49:45.878] List of 6
[10:49:45.878]  $ ...future.FUN:function (i)  
[10:49:45.878]  $ caller       :function (a, b, FUN = call_my_add)  
[10:49:45.878]  $ args         :List of 1
[10:49:45.878]   ..$ FUN:function (a, b)  
[10:49:45.878]  $ call_my_add  :function (a, b)  
[10:49:45.878]  $ my_add       :function (a, b)  
[10:49:45.878]  $ ...          : list()
[10:49:45.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.878]  - attr(*, "where")=List of 6
[10:49:45.878]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.878]   ..$ caller       :<environment: R_EmptyEnv> 
[10:49:45.878]   ..$ args         :<environment: R_EmptyEnv> 
[10:49:45.878]   ..$ call_my_add  :<environment: R_EmptyEnv> 
[10:49:45.878]   ..$ my_add       :<environment: R_EmptyEnv> 
[10:49:45.878]   ..$ ...          :<environment: 0x55d1ceaad608> 
[10:49:45.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.878]  - attr(*, "resolved")= logi FALSE
[10:49:45.878]  - attr(*, "total_size")= num 6021
[10:49:45.884] Packages to be attached in all futures: [n=0] 
[10:49:45.884] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.885] Number of futures (= number of chunks): 1
[10:49:45.885] Launching 1 futures (chunks) ...
[10:49:45.885] Chunk #1 of 1 ...
[10:49:45.885]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.885]    + additional globals found: [n=0] 
[10:49:45.885]    + additional namespaces needed: [n=0] 
[10:49:45.885]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.886]  - seeds: <none>
[10:49:45.886]  - All globals exported: [n=9] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.895] Created future:
[10:49:45.895] SequentialFuture:
[10:49:45.895] Label: ‘future_lapply-1’
[10:49:45.895] Expression:
[10:49:45.895] {
[10:49:45.895]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.895]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.895]     "# as a global variable                                         "
[10:49:45.895]     do.call(function(...) {
[10:49:45.895]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.895]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.895]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.895]         "# anonymous function.                                          "
[10:49:45.895]         "#                                                              "
[10:49:45.895]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.895]         "# function environment of FUN() to the calling environment.    "
[10:49:45.895]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.895]         "# global environment, which is where globals are written.      "
[10:49:45.895]         penv <- env <- environment(...future.FUN)
[10:49:45.895]         repeat {
[10:49:45.895]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.895]                 emptyenv())) 
[10:49:45.895]                 break
[10:49:45.895]             penv <- env
[10:49:45.895]             env <- parent.env(env)
[10:49:45.895]         }
[10:49:45.895]         if (identical(penv, globalenv())) {
[10:49:45.895]             environment(...future.FUN) <- environment()
[10:49:45.895]         }
[10:49:45.895]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.895]             !isNamespace(penv)) {
[10:49:45.895]             parent.env(penv) <- environment()
[10:49:45.895]         }
[10:49:45.895]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.895]         {
[10:49:45.895]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.895]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.895]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.895]                 on.exit(options(oopts), add = TRUE)
[10:49:45.895]             }
[10:49:45.895]             {
[10:49:45.895]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.895]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.895]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.895]                 })
[10:49:45.895]             }
[10:49:45.895]         }
[10:49:45.895]     }, args = future.call.arguments)
[10:49:45.895] }
[10:49:45.895] Lazy evaluation: FALSE
[10:49:45.895] Asynchronous evaluation: TRUE
[10:49:45.895] Local evaluation: TRUE
[10:49:45.895] Environment: 0x55d1ceaa9c38
[10:49:45.895] Capture standard output: TRUE
[10:49:45.895] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.895] Immediate condition classes: ‘immediateCondition’
[10:49:45.895] Globals: 9 objects totaling 4.14 KiB (function ‘...future.FUN’ of 1.81 KiB, function ‘caller’ of 247 bytes, list ‘args’ of 928 bytes, function ‘call_my_add’ of 876 bytes, function ‘my_add’ of 114 bytes, ...)
[10:49:45.895] Packages: <none>
[10:49:45.895] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.895] Resolved: TRUE
[10:49:45.895] Value: 67 bytes of class ‘list’
[10:49:45.895] Early signaling: FALSE
[10:49:45.895] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.895] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:45.896] Chunk #1 of 1 ... DONE
[10:49:45.896] Launching 1 futures (chunks) ... DONE
[10:49:45.896] Resolving 1 futures (chunks) ...
[10:49:45.897]  - Number of value chunks collected: 1
[10:49:45.897] Resolving 1 futures (chunks) ... DONE
[10:49:45.897] Reducing values from 1 chunks ...
[10:49:45.897]  - Number of values collected after concatenation: 3
[10:49:45.897]  - Number of values expected: 3
[10:49:45.897] Reducing values from 1 chunks ... DONE
[10:49:45.897] future_lapply() ... DONE
- future_lapply(x, FUN = do.call, ...) ...
[10:49:45.898] future_lapply() ...
[10:49:45.899] Number of chunks: 1
[10:49:45.900] getGlobalsAndPackagesXApply() ...
[10:49:45.900]  - future.globals: TRUE
[10:49:45.902]  - globals found/used: [n=1] ‘FUN’
[10:49:45.903]  - needed namespaces: [n=0] 
[10:49:45.903] Finding globals ... DONE
[10:49:45.903]  - use_args: TRUE
[10:49:45.903]  - Getting '...' globals ...
[10:49:45.903]    - '...' content: [n=1] ‘what’
[10:49:45.903] List of 1
[10:49:45.903]  $ ...:List of 1
[10:49:45.903]   ..$ what:function (x)  
[10:49:45.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.903]  - attr(*, "where")=List of 1
[10:49:45.903]   ..$ ...:<environment: 0x55d1ccd8d5c8> 
[10:49:45.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.903]  - attr(*, "resolved")= logi TRUE
[10:49:45.903]  - attr(*, "total_size")= num NA
[10:49:45.906]  - Getting '...' globals ... DONE
[10:49:45.906] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:45.907] List of 2
[10:49:45.907]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:45.907]  $ ...          :List of 1
[10:49:45.907]   ..$ what:function (x)  
[10:49:45.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.907]  - attr(*, "where")=List of 2
[10:49:45.907]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.907]   ..$ ...          :<environment: 0x55d1ccd8d5c8> 
[10:49:45.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.907]  - attr(*, "resolved")= logi FALSE
[10:49:45.907]  - attr(*, "total_size")= num 6909
[10:49:45.910] Packages to be attached in all futures: [n=0] 
[10:49:45.910] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.910] Number of futures (= number of chunks): 1
[10:49:45.910] Launching 1 futures (chunks) ...
[10:49:45.910] Chunk #1 of 1 ...
[10:49:45.910]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.911]    + additional globals found: [n=0] 
[10:49:45.911]    + additional namespaces needed: [n=0] 
[10:49:45.911]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.911]  - seeds: <none>
[10:49:45.911]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.914] Created future:
[10:49:45.914] SequentialFuture:
[10:49:45.914] Label: ‘future_lapply-1’
[10:49:45.914] Expression:
[10:49:45.914] {
[10:49:45.914]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.914]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.914]     "# as a global variable                                         "
[10:49:45.914]     do.call(function(...) {
[10:49:45.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.914]             on.exit(options(oopts), add = TRUE)
[10:49:45.914]         }
[10:49:45.914]         {
[10:49:45.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.914]                 ...future.FUN(...future.X_jj, ...)
[10:49:45.914]             })
[10:49:45.914]         }
[10:49:45.914]     }, args = future.call.arguments)
[10:49:45.914] }
[10:49:45.914] Lazy evaluation: FALSE
[10:49:45.914] Asynchronous evaluation: TRUE
[10:49:45.914] Local evaluation: TRUE
[10:49:45.914] Environment: R_GlobalEnv
[10:49:45.914] Capture standard output: TRUE
[10:49:45.914] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.914] Immediate condition classes: ‘immediateCondition’
[10:49:45.914] Globals: 5 objects totaling 2.13 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.914] Packages: <none>
[10:49:45.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.914] Resolved: TRUE
[10:49:45.914] Value: 43 bytes of class ‘list’
[10:49:45.914] Early signaling: FALSE
[10:49:45.914] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.914] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:45.915] Chunk #1 of 1 ... DONE
[10:49:45.915] Launching 1 futures (chunks) ... DONE
[10:49:45.915] Resolving 1 futures (chunks) ...
[10:49:45.916]  - Number of value chunks collected: 1
[10:49:45.916] Resolving 1 futures (chunks) ... DONE
[10:49:45.916] Reducing values from 1 chunks ...
[10:49:45.916]  - Number of values collected after concatenation: 1
[10:49:45.916]  - Number of values expected: 1
[10:49:45.916] Reducing values from 1 chunks ... DONE
[10:49:45.916] future_lapply() ... DONE
[10:49:45.916] future_lapply() ...
[10:49:45.918] Number of chunks: 1
[10:49:45.918] getGlobalsAndPackagesXApply() ...
[10:49:45.918]  - future.globals: TRUE
[10:49:45.921]  - globals found/used: [n=1] ‘FUN’
[10:49:45.921]  - needed namespaces: [n=0] 
[10:49:45.921] Finding globals ... DONE
[10:49:45.921]  - use_args: TRUE
[10:49:45.921]  - Getting '...' globals ...
[10:49:45.922]    - '...' content: [n=1] ‘what’
[10:49:45.922] List of 1
[10:49:45.922]  $ ...:List of 1
[10:49:45.922]   ..$ what:function (...)  
[10:49:45.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.922]  - attr(*, "where")=List of 1
[10:49:45.922]   ..$ ...:<environment: 0x55d1ce8496a0> 
[10:49:45.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.922]  - attr(*, "resolved")= logi TRUE
[10:49:45.922]  - attr(*, "total_size")= num NA
[10:49:45.924]  - Getting '...' globals ... DONE
[10:49:45.925] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:45.925] List of 2
[10:49:45.925]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:45.925]  $ ...          :List of 1
[10:49:45.925]   ..$ what:function (...)  
[10:49:45.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.925]  - attr(*, "where")=List of 2
[10:49:45.925]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.925]   ..$ ...          :<environment: 0x55d1ce8496a0> 
[10:49:45.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.925]  - attr(*, "resolved")= logi FALSE
[10:49:45.925]  - attr(*, "total_size")= num 6977
[10:49:45.928] Packages to be attached in all futures: [n=0] 
[10:49:45.928] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.928] Number of futures (= number of chunks): 1
[10:49:45.928] Launching 1 futures (chunks) ...
[10:49:45.928] Chunk #1 of 1 ...
[10:49:45.928]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.929]    + additional globals found: [n=0] 
[10:49:45.929]    + additional namespaces needed: [n=0] 
[10:49:45.929]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.929]  - seeds: <none>
[10:49:45.929]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.935] Created future:
[10:49:45.935] SequentialFuture:
[10:49:45.935] Label: ‘future_lapply-1’
[10:49:45.935] Expression:
[10:49:45.935] {
[10:49:45.935]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.935]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.935]     "# as a global variable                                         "
[10:49:45.935]     do.call(function(...) {
[10:49:45.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.935]             on.exit(options(oopts), add = TRUE)
[10:49:45.935]         }
[10:49:45.935]         {
[10:49:45.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.935]                 ...future.FUN(...future.X_jj, ...)
[10:49:45.935]             })
[10:49:45.935]         }
[10:49:45.935]     }, args = future.call.arguments)
[10:49:45.935] }
[10:49:45.935] Lazy evaluation: FALSE
[10:49:45.935] Asynchronous evaluation: TRUE
[10:49:45.935] Local evaluation: TRUE
[10:49:45.935] Environment: R_GlobalEnv
[10:49:45.935] Capture standard output: TRUE
[10:49:45.935] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.935] Immediate condition classes: ‘immediateCondition’
[10:49:45.935] Globals: 5 objects totaling 2.36 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 388 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.935] Packages: <none>
[10:49:45.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.935] Resolved: TRUE
[10:49:45.935] Value: 43 bytes of class ‘list’
[10:49:45.935] Early signaling: FALSE
[10:49:45.935] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.935] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:45.936] Chunk #1 of 1 ... DONE
[10:49:45.936] Launching 1 futures (chunks) ... DONE
[10:49:45.936] Resolving 1 futures (chunks) ...
[10:49:45.936]  - Number of value chunks collected: 1
[10:49:45.936] Resolving 1 futures (chunks) ... DONE
[10:49:45.937] Reducing values from 1 chunks ...
[10:49:45.937]  - Number of values collected after concatenation: 1
[10:49:45.937]  - Number of values expected: 1
[10:49:45.937] Reducing values from 1 chunks ... DONE
[10:49:45.937] future_lapply() ... DONE
- future_lapply(x, ...) - passing arguments via '...' ...
[10:49:45.937] future_lapply() ...
[10:49:45.938] Number of chunks: 1
[10:49:45.938] getGlobalsAndPackagesXApply() ...
[10:49:45.938]  - future.globals: TRUE
[10:49:45.939]  - globals found/used: [n=1] ‘FUN’
[10:49:45.939]  - needed namespaces: [n=0] 
[10:49:45.940] Finding globals ... DONE
[10:49:45.940]  - use_args: TRUE
[10:49:45.940]  - Getting '...' globals ...
[10:49:45.940]    - '...' content: [n=1] ‘b’
[10:49:45.940] List of 1
[10:49:45.940]  $ ...:List of 1
[10:49:45.940]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:45.940]   .. ..$ a: int [1:2] 1 2
[10:49:45.940]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.940]  - attr(*, "where")=List of 1
[10:49:45.940]   ..$ ...:<environment: 0x55d1cd7f16b8> 
[10:49:45.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.940]  - attr(*, "resolved")= logi TRUE
[10:49:45.940]  - attr(*, "total_size")= num NA
[10:49:45.943]  - Getting '...' globals ... DONE
[10:49:45.944] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:45.944] List of 2
[10:49:45.944]  $ ...future.FUN:function (a, b)  
[10:49:45.944]  $ ...          :List of 1
[10:49:45.944]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:45.944]   .. ..$ a: int [1:2] 1 2
[10:49:45.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.944]  - attr(*, "where")=List of 2
[10:49:45.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.944]   ..$ ...          :<environment: 0x55d1cd7f16b8> 
[10:49:45.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.944]  - attr(*, "resolved")= logi FALSE
[10:49:45.944]  - attr(*, "total_size")= num 4163
[10:49:45.947] Packages to be attached in all futures: [n=0] 
[10:49:45.947] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.948] Number of futures (= number of chunks): 1
[10:49:45.948] Launching 1 futures (chunks) ...
[10:49:45.948] Chunk #1 of 1 ...
[10:49:45.948]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.948]    + additional globals found: [n=0] 
[10:49:45.948]    + additional namespaces needed: [n=0] 
[10:49:45.948]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.948]  - seeds: <none>
[10:49:45.948]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.952] Created future:
[10:49:45.952] SequentialFuture:
[10:49:45.952] Label: ‘future_lapply-1’
[10:49:45.952] Expression:
[10:49:45.952] {
[10:49:45.952]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.952]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.952]     "# as a global variable                                         "
[10:49:45.952]     do.call(function(...) {
[10:49:45.952]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.952]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.952]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.952]         "# anonymous function.                                          "
[10:49:45.952]         "#                                                              "
[10:49:45.952]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.952]         "# function environment of FUN() to the calling environment.    "
[10:49:45.952]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.952]         "# global environment, which is where globals are written.      "
[10:49:45.952]         penv <- env <- environment(...future.FUN)
[10:49:45.952]         repeat {
[10:49:45.952]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.952]                 emptyenv())) 
[10:49:45.952]                 break
[10:49:45.952]             penv <- env
[10:49:45.952]             env <- parent.env(env)
[10:49:45.952]         }
[10:49:45.952]         if (identical(penv, globalenv())) {
[10:49:45.952]             environment(...future.FUN) <- environment()
[10:49:45.952]         }
[10:49:45.952]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.952]             !isNamespace(penv)) {
[10:49:45.952]             parent.env(penv) <- environment()
[10:49:45.952]         }
[10:49:45.952]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.952]         {
[10:49:45.952]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.952]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.952]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.952]                 on.exit(options(oopts), add = TRUE)
[10:49:45.952]             }
[10:49:45.952]             {
[10:49:45.952]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.952]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.952]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.952]                 })
[10:49:45.952]             }
[10:49:45.952]         }
[10:49:45.952]     }, args = future.call.arguments)
[10:49:45.952] }
[10:49:45.952] Lazy evaluation: FALSE
[10:49:45.952] Asynchronous evaluation: TRUE
[10:49:45.952] Local evaluation: TRUE
[10:49:45.952] Environment: R_GlobalEnv
[10:49:45.952] Capture standard output: TRUE
[10:49:45.952] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.952] Immediate condition classes: ‘immediateCondition’
[10:49:45.952] Globals: 5 objects totaling 786 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 357 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.952] Packages: <none>
[10:49:45.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.952] Resolved: TRUE
[10:49:45.952] Value: 51 bytes of class ‘list’
[10:49:45.952] Early signaling: FALSE
[10:49:45.952] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.952] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:45.953] Chunk #1 of 1 ... DONE
[10:49:45.953] Launching 1 futures (chunks) ... DONE
[10:49:45.953] Resolving 1 futures (chunks) ...
[10:49:45.953]  - Number of value chunks collected: 1
[10:49:45.953] Resolving 1 futures (chunks) ... DONE
[10:49:45.954] Reducing values from 1 chunks ...
[10:49:45.954]  - Number of values collected after concatenation: 1
[10:49:45.954]  - Number of values expected: 1
[10:49:45.954] Reducing values from 1 chunks ... DONE
[10:49:45.954] future_lapply() ... DONE
[10:49:45.954] future_lapply() ...
[10:49:45.955] Number of chunks: 1
[10:49:45.955] getGlobalsAndPackagesXApply() ...
[10:49:45.955]  - future.globals: TRUE
[10:49:45.956]  - globals found/used: [n=1] ‘FUN’
[10:49:45.956]  - needed namespaces: [n=0] 
[10:49:45.957] Finding globals ... DONE
[10:49:45.957]  - use_args: TRUE
[10:49:45.957]  - Getting '...' globals ...
[10:49:45.957]    - '...' content: [n=1] ‘b’
[10:49:45.957] List of 1
[10:49:45.957]  $ ...:List of 1
[10:49:45.957]   ..$ b:<environment: 0x55d1cb7f6310> 
[10:49:45.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.957]  - attr(*, "where")=List of 1
[10:49:45.957]   ..$ ...:<environment: 0x55d1cb7f1c98> 
[10:49:45.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.957]  - attr(*, "resolved")= logi TRUE
[10:49:45.957]  - attr(*, "total_size")= num NA
[10:49:45.960]  - Getting '...' globals ... DONE
[10:49:45.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:45.960] List of 2
[10:49:45.960]  $ ...future.FUN:function (a, b)  
[10:49:45.960]  $ ...          :List of 1
[10:49:45.960]   ..$ b:<environment: 0x55d1cb7f6310> 
[10:49:45.960]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.960]  - attr(*, "where")=List of 2
[10:49:45.960]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:45.960]   ..$ ...          :<environment: 0x55d1cb7f1c98> 
[10:49:45.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.960]  - attr(*, "resolved")= logi FALSE
[10:49:45.960]  - attr(*, "total_size")= num 3918
[10:49:45.963] Packages to be attached in all futures: [n=0] 
[10:49:45.963] getGlobalsAndPackagesXApply() ... DONE
[10:49:45.964] Number of futures (= number of chunks): 1
[10:49:45.964] Launching 1 futures (chunks) ...
[10:49:45.964] Chunk #1 of 1 ...
[10:49:45.964]  - Finding globals in 'X' for chunk #1 ...
[10:49:45.964]    + additional globals found: [n=0] 
[10:49:45.964]    + additional namespaces needed: [n=0] 
[10:49:45.964]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:45.964]  - seeds: <none>
[10:49:45.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:45.968] Created future:
[10:49:45.968] SequentialFuture:
[10:49:45.968] Label: ‘future_lapply-1’
[10:49:45.968] Expression:
[10:49:45.968] {
[10:49:45.968]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:45.968]     "# expression in do.call(), because function called uses '...'  "
[10:49:45.968]     "# as a global variable                                         "
[10:49:45.968]     do.call(function(...) {
[10:49:45.968]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:45.968]         "# without having an '...' argument. This means '...' is treated"
[10:49:45.968]         "# as a global variable. This may happen when FUN() is an       "
[10:49:45.968]         "# anonymous function.                                          "
[10:49:45.968]         "#                                                              "
[10:49:45.968]         "# If an anonymous function, we will make sure to restore the   "
[10:49:45.968]         "# function environment of FUN() to the calling environment.    "
[10:49:45.968]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:45.968]         "# global environment, which is where globals are written.      "
[10:49:45.968]         penv <- env <- environment(...future.FUN)
[10:49:45.968]         repeat {
[10:49:45.968]             if (identical(env, globalenv()) || identical(env, 
[10:49:45.968]                 emptyenv())) 
[10:49:45.968]                 break
[10:49:45.968]             penv <- env
[10:49:45.968]             env <- parent.env(env)
[10:49:45.968]         }
[10:49:45.968]         if (identical(penv, globalenv())) {
[10:49:45.968]             environment(...future.FUN) <- environment()
[10:49:45.968]         }
[10:49:45.968]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:45.968]             !isNamespace(penv)) {
[10:49:45.968]             parent.env(penv) <- environment()
[10:49:45.968]         }
[10:49:45.968]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:45.968]         {
[10:49:45.968]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:45.968]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:45.968]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:45.968]                 on.exit(options(oopts), add = TRUE)
[10:49:45.968]             }
[10:49:45.968]             {
[10:49:45.968]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:45.968]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:45.968]                   ...future.FUN(...future.X_jj, ...)
[10:49:45.968]                 })
[10:49:45.968]             }
[10:49:45.968]         }
[10:49:45.968]     }, args = future.call.arguments)
[10:49:45.968] }
[10:49:45.968] Lazy evaluation: FALSE
[10:49:45.968] Asynchronous evaluation: TRUE
[10:49:45.968] Local evaluation: TRUE
[10:49:45.968] Environment: R_GlobalEnv
[10:49:45.968] Capture standard output: TRUE
[10:49:45.968] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:45.968] Immediate condition classes: ‘immediateCondition’
[10:49:45.968] Globals: 5 objects totaling 708 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 279 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:45.968] Packages: <none>
[10:49:45.968] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:45.968] Resolved: TRUE
[10:49:45.968] Value: 58 bytes of class ‘list’
[10:49:45.968] Early signaling: FALSE
[10:49:45.968] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:45.968] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:45.969] Chunk #1 of 1 ... DONE
[10:49:45.969] Launching 1 futures (chunks) ... DONE
[10:49:45.969] Resolving 1 futures (chunks) ...
[10:49:45.969]  - Number of value chunks collected: 1
[10:49:45.969] Resolving 1 futures (chunks) ... DONE
[10:49:45.970] Reducing values from 1 chunks ...
[10:49:45.970]  - Number of values collected after concatenation: 1
[10:49:45.970]  - Number of values expected: 1
[10:49:45.970] Reducing values from 1 chunks ... DONE
[10:49:45.970] future_lapply() ... DONE
[10:49:45.970] future_lapply() ...
[10:49:45.971] Number of chunks: 1
[10:49:45.971] getGlobalsAndPackagesXApply() ...
[10:49:45.971]  - future.globals: TRUE
[10:49:45.973]  - globals found/used: [n=1] ‘FUN’
[10:49:45.973]  - needed namespaces: [n=0] 
[10:49:45.973] Finding globals ... DONE
[10:49:45.973]  - use_args: TRUE
[10:49:45.973]  - Getting '...' globals ...
[10:49:45.974]    - '...' content: [n=1] ‘b’
[10:49:45.974] List of 1
[10:49:45.974]  $ ...:List of 1
[10:49:45.974]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:45.974]   .. .. ..@ slots     :List of 4
[10:49:45.974]   .. .. .. ..$ .Data  : chr "function"
[10:49:45.974]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. ..$ target : chr "signature"
[10:49:45.974]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. ..$ defined: chr "signature"
[10:49:45.974]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. ..$ generic: chr "character"
[10:49:45.974]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. ..@ contains  :List of 4
[10:49:45.974]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 1
[10:49:45.974]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 2
[10:49:45.974]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 2
[10:49:45.974]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 3
[10:49:45.974]   .. .. ..@ virtual   : logi FALSE
[10:49:45.974]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:45.974]  list()
[10:49:45.974]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:45.974]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:45.974]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:45.974]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:45.974]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:45.974]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:45.974]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:45.974]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:45.974]   .. .. .. .. ..$ generic: chr(0) 
[10:49:45.974]   .. .. ..@ validity  : NULL
[10:49:45.974]   .. .. ..@ access    : list()
[10:49:45.974]   .. .. ..@ className : chr "MethodDefinition"
[10:49:45.974]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. ..@ subclasses:List of 7
[10:49:45.974]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 1
[10:49:45.974]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 1
[10:49:45.974]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 1
[10:49:45.974]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 1
[10:49:45.974]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 2
[10:49:45.974]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 2
[10:49:45.974]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:45.974]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:45.974]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:45.974]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:45.974]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:45.974]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:45.974]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:45.974]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:45.974]   .. .. .. .. .. ..@ distance  : num 2
[10:49:45.974]   .. .. ..@ versionKey:<externalptr> 
[10:49:45.974]   .. .. ..@ sealed    : logi TRUE
[10:49:45.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:45.974]  - attr(*, "where")=List of 1
[10:49:45.974]   ..$ ...:<environment: 0x55d1ced5d8f0> 
[10:49:45.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:45.974]  - attr(*, "resolved")= logi TRUE
[10:49:45.974]  - attr(*, "total_size")= num NA
[10:49:46.030]  - Getting '...' globals ... DONE
[10:49:46.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.031] List of 2
[10:49:46.031]  $ ...future.FUN:function (a, b)  
[10:49:46.031]  $ ...          :List of 1
[10:49:46.031]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:46.031]   .. .. ..@ slots     :List of 4
[10:49:46.031]   .. .. .. ..$ .Data  : chr "function"
[10:49:46.031]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. ..$ target : chr "signature"
[10:49:46.031]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. ..$ defined: chr "signature"
[10:49:46.031]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. ..$ generic: chr "character"
[10:49:46.031]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. ..@ contains  :List of 4
[10:49:46.031]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.031]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.031]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.031]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 3
[10:49:46.031]   .. .. ..@ virtual   : logi FALSE
[10:49:46.031]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:46.031]  list()
[10:49:46.031]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.031]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.031]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.031]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.031]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.031]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.031]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.031]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.031]   .. .. .. .. ..$ generic: chr(0) 
[10:49:46.031]   .. .. ..@ validity  : NULL
[10:49:46.031]   .. .. ..@ access    : list()
[10:49:46.031]   .. .. ..@ className : chr "MethodDefinition"
[10:49:46.031]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. ..@ subclasses:List of 7
[10:49:46.031]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.031]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.031]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.031]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.031]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.031]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.031]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.031]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.031]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.031]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.031]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.031]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.031]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.031]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.031]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.031]   .. .. ..@ versionKey:<externalptr> 
[10:49:46.031]   .. .. ..@ sealed    : logi TRUE
[10:49:46.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.031]  - attr(*, "where")=List of 2
[10:49:46.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.031]   ..$ ...          :<environment: 0x55d1ced5d8f0> 
[10:49:46.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.031]  - attr(*, "resolved")= logi FALSE
[10:49:46.031]  - attr(*, "total_size")= num 105785
[10:49:46.085] Packages to be attached in all futures: [n=0] 
[10:49:46.085] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.085] Number of futures (= number of chunks): 1
[10:49:46.085] Launching 1 futures (chunks) ...
[10:49:46.085] Chunk #1 of 1 ...
[10:49:46.085]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.086]    + additional globals found: [n=0] 
[10:49:46.086]    + additional namespaces needed: [n=0] 
[10:49:46.086]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.086]  - seeds: <none>
[10:49:46.086]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.090] Created future:
[10:49:46.090] SequentialFuture:
[10:49:46.090] Label: ‘future_lapply-1’
[10:49:46.090] Expression:
[10:49:46.090] {
[10:49:46.090]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.090]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.090]     "# as a global variable                                         "
[10:49:46.090]     do.call(function(...) {
[10:49:46.090]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.090]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.090]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.090]         "# anonymous function.                                          "
[10:49:46.090]         "#                                                              "
[10:49:46.090]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.090]         "# function environment of FUN() to the calling environment.    "
[10:49:46.090]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.090]         "# global environment, which is where globals are written.      "
[10:49:46.090]         penv <- env <- environment(...future.FUN)
[10:49:46.090]         repeat {
[10:49:46.090]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.090]                 emptyenv())) 
[10:49:46.090]                 break
[10:49:46.090]             penv <- env
[10:49:46.090]             env <- parent.env(env)
[10:49:46.090]         }
[10:49:46.090]         if (identical(penv, globalenv())) {
[10:49:46.090]             environment(...future.FUN) <- environment()
[10:49:46.090]         }
[10:49:46.090]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.090]             !isNamespace(penv)) {
[10:49:46.090]             parent.env(penv) <- environment()
[10:49:46.090]         }
[10:49:46.090]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.090]         {
[10:49:46.090]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.090]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.090]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.090]                 on.exit(options(oopts), add = TRUE)
[10:49:46.090]             }
[10:49:46.090]             {
[10:49:46.090]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.090]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.090]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.090]                 })
[10:49:46.090]             }
[10:49:46.090]         }
[10:49:46.090]     }, args = future.call.arguments)
[10:49:46.090] }
[10:49:46.090] Lazy evaluation: FALSE
[10:49:46.090] Asynchronous evaluation: TRUE
[10:49:46.090] Local evaluation: TRUE
[10:49:46.090] Environment: R_GlobalEnv
[10:49:46.090] Capture standard output: TRUE
[10:49:46.090] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.090] Immediate condition classes: ‘immediateCondition’
[10:49:46.090] Globals: 5 objects totaling 50.72 KiB (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 50.30 KiB, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.090] Packages: <none>
[10:49:46.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.090] Resolved: TRUE
[10:49:46.090] Value: 49 bytes of class ‘list’
[10:49:46.090] Early signaling: FALSE
[10:49:46.090] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.090] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.091] Chunk #1 of 1 ... DONE
[10:49:46.091] Launching 1 futures (chunks) ... DONE
[10:49:46.091] Resolving 1 futures (chunks) ...
[10:49:46.092]  - Number of value chunks collected: 1
[10:49:46.092] Resolving 1 futures (chunks) ... DONE
[10:49:46.092] Reducing values from 1 chunks ...
[10:49:46.092]  - Number of values collected after concatenation: 1
[10:49:46.092]  - Number of values expected: 1
[10:49:46.092] Reducing values from 1 chunks ... DONE
[10:49:46.092] future_lapply() ... DONE
- future_lapply(X, ...) - 'X' containing globals ...
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
[10:49:46.094] future_lapply() ...
[10:49:46.095] Number of chunks: 1
[10:49:46.095] getGlobalsAndPackagesXApply() ...
[10:49:46.095]  - future.globals: TRUE
[10:49:46.096]  - globals found/used: [n=1] ‘FUN’
[10:49:46.097]  - needed namespaces: [n=0] 
[10:49:46.097] Finding globals ... DONE
[10:49:46.097]  - use_args: TRUE
[10:49:46.097]  - Getting '...' globals ...
[10:49:46.097]    - '...' content: [n=0] 
[10:49:46.097] List of 1
[10:49:46.097]  $ ...: list()
[10:49:46.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.097]  - attr(*, "where")=List of 1
[10:49:46.097]   ..$ ...:<environment: 0x55d1ceb17378> 
[10:49:46.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.097]  - attr(*, "resolved")= logi TRUE
[10:49:46.097]  - attr(*, "total_size")= num NA
[10:49:46.100]  - Getting '...' globals ... DONE
[10:49:46.100] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.100] List of 2
[10:49:46.100]  $ ...future.FUN:function (f)  
[10:49:46.100]  $ ...          : list()
[10:49:46.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.100]  - attr(*, "where")=List of 2
[10:49:46.100]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.100]   ..$ ...          :<environment: 0x55d1ceb17378> 
[10:49:46.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.100]  - attr(*, "resolved")= logi FALSE
[10:49:46.100]  - attr(*, "total_size")= num 4837
[10:49:46.103] Packages to be attached in all futures: [n=0] 
[10:49:46.103] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.103] Number of futures (= number of chunks): 1
[10:49:46.103] Launching 1 futures (chunks) ...
[10:49:46.103] Chunk #1 of 1 ...
[10:49:46.103]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.106]    + additional globals found: [n=2] ‘a’, ‘b’
[10:49:46.106]    + additional namespaces needed: [n=1] ‘tools’
[10:49:46.106]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.106]  - seeds: <none>
[10:49:46.106]  - All globals exported: [n=7] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’, ‘a’, ‘b’
[10:49:46.112] Created future:
[10:49:46.112] SequentialFuture:
[10:49:46.112] Label: ‘future_lapply-1’
[10:49:46.112] Expression:
[10:49:46.112] {
[10:49:46.112]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.112]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.112]     "# as a global variable                                         "
[10:49:46.112]     do.call(function(...) {
[10:49:46.112]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.112]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.112]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.112]         "# anonymous function.                                          "
[10:49:46.112]         "#                                                              "
[10:49:46.112]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.112]         "# function environment of FUN() to the calling environment.    "
[10:49:46.112]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.112]         "# global environment, which is where globals are written.      "
[10:49:46.112]         penv <- env <- environment(...future.FUN)
[10:49:46.112]         repeat {
[10:49:46.112]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.112]                 emptyenv())) 
[10:49:46.112]                 break
[10:49:46.112]             penv <- env
[10:49:46.112]             env <- parent.env(env)
[10:49:46.112]         }
[10:49:46.112]         if (identical(penv, globalenv())) {
[10:49:46.112]             environment(...future.FUN) <- environment()
[10:49:46.112]         }
[10:49:46.112]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.112]             !isNamespace(penv)) {
[10:49:46.112]             parent.env(penv) <- environment()
[10:49:46.112]         }
[10:49:46.112]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.112]         {
[10:49:46.112]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.112]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.112]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.112]                 on.exit(options(oopts), add = TRUE)
[10:49:46.112]             }
[10:49:46.112]             {
[10:49:46.112]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.112]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.112]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.112]                 })
[10:49:46.112]             }
[10:49:46.112]         }
[10:49:46.112]     }, args = future.call.arguments)
[10:49:46.112] }
[10:49:46.112] Lazy evaluation: FALSE
[10:49:46.112] Asynchronous evaluation: TRUE
[10:49:46.112] Local evaluation: TRUE
[10:49:46.112] Environment: R_GlobalEnv
[10:49:46.112] Capture standard output: TRUE
[10:49:46.112] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.112] Immediate condition classes: ‘immediateCondition’
[10:49:46.112] Globals: 7 objects totaling 1.84 KiB (function ‘...future.FUN’ of 225 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 1.40 KiB, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes, ...)
[10:49:46.112] Packages: 1 packages (‘tools’)
[10:49:46.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.112] Resolved: TRUE
[10:49:46.112] Value: 91 bytes of class ‘list’
[10:49:46.112] Early signaling: FALSE
[10:49:46.112] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.112] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.113] Chunk #1 of 1 ... DONE
[10:49:46.113] Launching 1 futures (chunks) ... DONE
[10:49:46.113] Resolving 1 futures (chunks) ...
[10:49:46.114]  - Number of value chunks collected: 1
[10:49:46.114] Resolving 1 futures (chunks) ... DONE
[10:49:46.114] Reducing values from 1 chunks ...
[10:49:46.114]  - Number of values collected after concatenation: 4
[10:49:46.114]  - Number of values expected: 4
[10:49:46.114] Reducing values from 1 chunks ... DONE
[10:49:46.114] future_lapply() ... DONE
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
- future_lapply(x, ...) - passing '...' as a global ...
List of 1
 $ z0:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
[10:49:46.117] future_lapply() ...
[10:49:46.118] Number of chunks: 1
[10:49:46.118] getGlobalsAndPackagesXApply() ...
[10:49:46.118]  - future.globals: TRUE
[10:49:46.120]  - globals found/used: [n=2] ‘FUN’, ‘future.call.arguments’
[10:49:46.120]  - needed namespaces: [n=0] 
[10:49:46.120] Finding globals ... DONE
[10:49:46.120]  - use_args: TRUE
[10:49:46.120]  - Getting '...' globals ...
[10:49:46.121]    - '...' content: [n=0] 
[10:49:46.121] List of 1
[10:49:46.121]  $ ...: list()
[10:49:46.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.121]  - attr(*, "where")=List of 1
[10:49:46.121]   ..$ ...:<environment: 0x55d1cd4cf608> 
[10:49:46.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.121]  - attr(*, "resolved")= logi TRUE
[10:49:46.121]  - attr(*, "total_size")= num NA
[10:49:46.123]  - Getting '...' globals ... DONE
[10:49:46.123] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘future.call.arguments’, ‘...’
[10:49:46.123] List of 3
[10:49:46.123]  $ ...future.FUN        :function (x)  
[10:49:46.123]  $ future.call.arguments:List of 1
[10:49:46.123]   ..$ a: num 1
[10:49:46.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.123]  $ ...                  : list()
[10:49:46.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.123]  - attr(*, "where")=List of 3
[10:49:46.123]   ..$ ...future.FUN        :<environment: R_EmptyEnv> 
[10:49:46.123]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:49:46.123]   ..$ ...                  :<environment: 0x55d1cd4cf608> 
[10:49:46.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.123]  - attr(*, "resolved")= logi FALSE
[10:49:46.123]  - attr(*, "total_size")= num 3563
[10:49:46.127] Packages to be attached in all futures: [n=0] 
[10:49:46.127] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.128] Number of futures (= number of chunks): 1
[10:49:46.128] Launching 1 futures (chunks) ...
[10:49:46.128] Chunk #1 of 1 ...
[10:49:46.128]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.128]    + additional globals found: [n=0] 
[10:49:46.128]    + additional namespaces needed: [n=0] 
[10:49:46.128]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.128]  - seeds: <none>
[10:49:46.128]  - All globals exported: [n=6] ‘...future.FUN’, ‘future.call.arguments’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.132] Created future:
[10:49:46.132] SequentialFuture:
[10:49:46.132] Label: ‘future_lapply-1’
[10:49:46.132] Expression:
[10:49:46.132] {
[10:49:46.132]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.132]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.132]     "# as a global variable                                         "
[10:49:46.132]     do.call(function(...) {
[10:49:46.132]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.132]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.132]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.132]         "# anonymous function.                                          "
[10:49:46.132]         "#                                                              "
[10:49:46.132]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.132]         "# function environment of FUN() to the calling environment.    "
[10:49:46.132]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.132]         "# global environment, which is where globals are written.      "
[10:49:46.132]         penv <- env <- environment(...future.FUN)
[10:49:46.132]         repeat {
[10:49:46.132]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.132]                 emptyenv())) 
[10:49:46.132]                 break
[10:49:46.132]             penv <- env
[10:49:46.132]             env <- parent.env(env)
[10:49:46.132]         }
[10:49:46.132]         if (identical(penv, globalenv())) {
[10:49:46.132]             environment(...future.FUN) <- environment()
[10:49:46.132]         }
[10:49:46.132]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.132]             !isNamespace(penv)) {
[10:49:46.132]             parent.env(penv) <- environment()
[10:49:46.132]         }
[10:49:46.132]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.132]         {
[10:49:46.132]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.132]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.132]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.132]                 on.exit(options(oopts), add = TRUE)
[10:49:46.132]             }
[10:49:46.132]             {
[10:49:46.132]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.132]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.132]                   ...future.FUN(...future.X_jj)
[10:49:46.132]                 })
[10:49:46.132]             }
[10:49:46.132]         }
[10:49:46.132]     }, args = future.call.arguments)
[10:49:46.132] }
[10:49:46.132] Lazy evaluation: FALSE
[10:49:46.132] Asynchronous evaluation: TRUE
[10:49:46.132] Local evaluation: TRUE
[10:49:46.132] Environment: 0x55d1cd4d30b8
[10:49:46.132] Capture standard output: TRUE
[10:49:46.132] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.132] Immediate condition classes: ‘immediateCondition’
[10:49:46.132] Globals: 5 objects totaling 613 bytes (function ‘...future.FUN’ of 361 bytes, DotDotDotList ‘future.call.arguments’ of 151 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.132] Packages: <none>
[10:49:46.132] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.132] Resolved: TRUE
[10:49:46.132] Value: 97 bytes of class ‘list’
[10:49:46.132] Early signaling: FALSE
[10:49:46.132] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.132] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.133] Chunk #1 of 1 ... DONE
[10:49:46.133] Launching 1 futures (chunks) ... DONE
[10:49:46.133] Resolving 1 futures (chunks) ...
[10:49:46.134]  - Number of value chunks collected: 1
[10:49:46.134] Resolving 1 futures (chunks) ... DONE
[10:49:46.134] Reducing values from 1 chunks ...
[10:49:46.134]  - Number of values collected after concatenation: 1
[10:49:46.134]  - Number of values expected: 1
[10:49:46.134] Reducing values from 1 chunks ... DONE
[10:49:46.134] future_lapply() ... DONE
List of 1
 $ z1:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
- future_lapply(X, ...) - '{ a <- a + 1; a }' ...
[10:49:46.135] future_lapply() ...
[10:49:46.136] Number of chunks: 1
[10:49:46.136] getGlobalsAndPackagesXApply() ...
[10:49:46.136]  - future.globals: TRUE
[10:49:46.139]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:46.139]  - needed namespaces: [n=0] 
[10:49:46.139] Finding globals ... DONE
[10:49:46.139]  - use_args: TRUE
[10:49:46.139]  - Getting '...' globals ...
[10:49:46.139]    - '...' content: [n=0] 
[10:49:46.139] List of 1
[10:49:46.139]  $ ...: list()
[10:49:46.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.139]  - attr(*, "where")=List of 1
[10:49:46.139]   ..$ ...:<environment: 0x55d1ce42b048> 
[10:49:46.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.139]  - attr(*, "resolved")= logi TRUE
[10:49:46.139]  - attr(*, "total_size")= num NA
[10:49:46.142]  - Getting '...' globals ... DONE
[10:49:46.142] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:46.142] List of 3
[10:49:46.142]  $ ...future.FUN:function (ii)  
[10:49:46.142]  $ a            : num 1
[10:49:46.142]  $ ...          : list()
[10:49:46.142]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.142]  - attr(*, "where")=List of 3
[10:49:46.142]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.142]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.142]   ..$ ...          :<environment: 0x55d1ce42b048> 
[10:49:46.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.142]  - attr(*, "resolved")= logi FALSE
[10:49:46.142]  - attr(*, "total_size")= num 3759
[10:49:46.145] Packages to be attached in all futures: [n=0] 
[10:49:46.145] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.146] Number of futures (= number of chunks): 1
[10:49:46.146] Launching 1 futures (chunks) ...
[10:49:46.146] Chunk #1 of 1 ...
[10:49:46.146]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.146]    + additional globals found: [n=0] 
[10:49:46.146]    + additional namespaces needed: [n=0] 
[10:49:46.146]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.146]  - seeds: <none>
[10:49:46.147]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.150] Created future:
[10:49:46.150] SequentialFuture:
[10:49:46.150] Label: ‘future_lapply-1’
[10:49:46.150] Expression:
[10:49:46.150] {
[10:49:46.150]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.150]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.150]     "# as a global variable                                         "
[10:49:46.150]     do.call(function(...) {
[10:49:46.150]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.150]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.150]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.150]         "# anonymous function.                                          "
[10:49:46.150]         "#                                                              "
[10:49:46.150]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.150]         "# function environment of FUN() to the calling environment.    "
[10:49:46.150]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.150]         "# global environment, which is where globals are written.      "
[10:49:46.150]         penv <- env <- environment(...future.FUN)
[10:49:46.150]         repeat {
[10:49:46.150]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.150]                 emptyenv())) 
[10:49:46.150]                 break
[10:49:46.150]             penv <- env
[10:49:46.150]             env <- parent.env(env)
[10:49:46.150]         }
[10:49:46.150]         if (identical(penv, globalenv())) {
[10:49:46.150]             environment(...future.FUN) <- environment()
[10:49:46.150]         }
[10:49:46.150]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.150]             !isNamespace(penv)) {
[10:49:46.150]             parent.env(penv) <- environment()
[10:49:46.150]         }
[10:49:46.150]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.150]         {
[10:49:46.150]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.150]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.150]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.150]                 on.exit(options(oopts), add = TRUE)
[10:49:46.150]             }
[10:49:46.150]             {
[10:49:46.150]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.150]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.150]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.150]                 })
[10:49:46.150]             }
[10:49:46.150]         }
[10:49:46.150]     }, args = future.call.arguments)
[10:49:46.150] }
[10:49:46.150] Lazy evaluation: FALSE
[10:49:46.150] Asynchronous evaluation: TRUE
[10:49:46.150] Local evaluation: TRUE
[10:49:46.150] Environment: R_GlobalEnv
[10:49:46.150] Capture standard output: TRUE
[10:49:46.150] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.150] Immediate condition classes: ‘immediateCondition’
[10:49:46.150] Globals: 6 objects totaling 748 bytes (function ‘...future.FUN’ of 511 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.150] Packages: <none>
[10:49:46.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.150] Resolved: TRUE
[10:49:46.150] Value: 47 bytes of class ‘list’
[10:49:46.150] Early signaling: FALSE
[10:49:46.150] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.150] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.151] Chunk #1 of 1 ... DONE
[10:49:46.151] Launching 1 futures (chunks) ... DONE
[10:49:46.151] Resolving 1 futures (chunks) ...
[10:49:46.152]  - Number of value chunks collected: 1
[10:49:46.152] Resolving 1 futures (chunks) ... DONE
[10:49:46.152] Reducing values from 1 chunks ...
[10:49:46.152]  - Number of values collected after concatenation: 1
[10:49:46.152]  - Number of values expected: 1
[10:49:46.152] Reducing values from 1 chunks ... DONE
[10:49:46.152] future_lapply() ... DONE
- future_lapply(X, ...) - '{ a; a <- a + 1 }' ...
[10:49:46.152] future_lapply() ...
[10:49:46.153] Number of chunks: 1
[10:49:46.153] getGlobalsAndPackagesXApply() ...
[10:49:46.153]  - future.globals: TRUE
[10:49:46.157]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:46.157]  - needed namespaces: [n=0] 
[10:49:46.157] Finding globals ... DONE
[10:49:46.157]  - use_args: TRUE
[10:49:46.158]  - Getting '...' globals ...
[10:49:46.158]    - '...' content: [n=0] 
[10:49:46.158] List of 1
[10:49:46.158]  $ ...: list()
[10:49:46.158]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.158]  - attr(*, "where")=List of 1
[10:49:46.158]   ..$ ...:<environment: 0x55d1cf0fd710> 
[10:49:46.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.158]  - attr(*, "resolved")= logi TRUE
[10:49:46.158]  - attr(*, "total_size")= num NA
[10:49:46.160]  - Getting '...' globals ... DONE
[10:49:46.161] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:46.161] List of 3
[10:49:46.161]  $ ...future.FUN:function (ii)  
[10:49:46.161]  $ a            : num 1
[10:49:46.161]  $ ...          : list()
[10:49:46.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.161]  - attr(*, "where")=List of 3
[10:49:46.161]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.161]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.161]   ..$ ...          :<environment: 0x55d1cf0fd710> 
[10:49:46.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.161]  - attr(*, "resolved")= logi FALSE
[10:49:46.161]  - attr(*, "total_size")= num 3775
[10:49:46.164] Packages to be attached in all futures: [n=0] 
[10:49:46.164] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.164] Number of futures (= number of chunks): 1
[10:49:46.164] Launching 1 futures (chunks) ...
[10:49:46.164] Chunk #1 of 1 ...
[10:49:46.165]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.165]    + additional globals found: [n=0] 
[10:49:46.165]    + additional namespaces needed: [n=0] 
[10:49:46.165]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.165]  - seeds: <none>
[10:49:46.165]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.168] Created future:
[10:49:46.169] SequentialFuture:
[10:49:46.169] Label: ‘future_lapply-1’
[10:49:46.169] Expression:
[10:49:46.169] {
[10:49:46.169]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.169]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.169]     "# as a global variable                                         "
[10:49:46.169]     do.call(function(...) {
[10:49:46.169]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.169]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.169]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.169]         "# anonymous function.                                          "
[10:49:46.169]         "#                                                              "
[10:49:46.169]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.169]         "# function environment of FUN() to the calling environment.    "
[10:49:46.169]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.169]         "# global environment, which is where globals are written.      "
[10:49:46.169]         penv <- env <- environment(...future.FUN)
[10:49:46.169]         repeat {
[10:49:46.169]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.169]                 emptyenv())) 
[10:49:46.169]                 break
[10:49:46.169]             penv <- env
[10:49:46.169]             env <- parent.env(env)
[10:49:46.169]         }
[10:49:46.169]         if (identical(penv, globalenv())) {
[10:49:46.169]             environment(...future.FUN) <- environment()
[10:49:46.169]         }
[10:49:46.169]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.169]             !isNamespace(penv)) {
[10:49:46.169]             parent.env(penv) <- environment()
[10:49:46.169]         }
[10:49:46.169]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.169]         {
[10:49:46.169]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.169]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.169]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.169]                 on.exit(options(oopts), add = TRUE)
[10:49:46.169]             }
[10:49:46.169]             {
[10:49:46.169]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.169]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.169]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.169]                 })
[10:49:46.169]             }
[10:49:46.169]         }
[10:49:46.169]     }, args = future.call.arguments)
[10:49:46.169] }
[10:49:46.169] Lazy evaluation: FALSE
[10:49:46.169] Asynchronous evaluation: TRUE
[10:49:46.169] Local evaluation: TRUE
[10:49:46.169] Environment: R_GlobalEnv
[10:49:46.169] Capture standard output: TRUE
[10:49:46.169] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.169] Immediate condition classes: ‘immediateCondition’
[10:49:46.169] Globals: 6 objects totaling 756 bytes (function ‘...future.FUN’ of 519 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.169] Packages: <none>
[10:49:46.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.169] Resolved: TRUE
[10:49:46.169] Value: 47 bytes of class ‘list’
[10:49:46.169] Early signaling: FALSE
[10:49:46.169] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.169] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.170] Chunk #1 of 1 ... DONE
[10:49:46.170] Launching 1 futures (chunks) ... DONE
[10:49:46.170] Resolving 1 futures (chunks) ...
[10:49:46.170]  - Number of value chunks collected: 1
[10:49:46.170] Resolving 1 futures (chunks) ... DONE
[10:49:46.170] Reducing values from 1 chunks ...
[10:49:46.170]  - Number of values collected after concatenation: 1
[10:49:46.170]  - Number of values expected: 1
[10:49:46.171] Reducing values from 1 chunks ... DONE
[10:49:46.171] future_lapply() ... DONE
- future_lapply(..., future.globals = <list>) ...
[10:49:46.171] future_lapply() ...
[10:49:46.171] Number of chunks: 1
[10:49:46.171] getGlobalsAndPackagesXApply() ...
[10:49:46.171]  - future.globals: <name-value list> with names ‘42’
[10:49:46.172]  - use_args: TRUE
[10:49:46.172]  - Getting '...' globals ...
[10:49:46.172]    - '...' content: [n=0] 
[10:49:46.172] List of 1
[10:49:46.172]  $ ...: list()
[10:49:46.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.172]  - attr(*, "where")=List of 1
[10:49:46.172]   ..$ ...:<environment: 0x55d1ccb4e280> 
[10:49:46.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.172]  - attr(*, "resolved")= logi TRUE
[10:49:46.172]  - attr(*, "total_size")= num NA
[10:49:46.175]  - Getting '...' globals ... DONE
[10:49:46.175] Globals to be used in all futures (chunks): [n=3] ‘a’, ‘...future.FUN’, ‘...’
[10:49:46.175] List of 3
[10:49:46.175]  $ a            : num 42
[10:49:46.175]  $ ...future.FUN:function (x)  
[10:49:46.175]  $ ...          : list()
[10:49:46.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.175]  - attr(*, "where")=List of 3
[10:49:46.175]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.175]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:49:46.175]   ..$ ...          :<environment: 0x55d1ccb4e280> 
[10:49:46.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.175]  - attr(*, "resolved")= logi FALSE
[10:49:46.175]  - attr(*, "total_size")= num NA
[10:49:46.178] Packages to be attached in all futures: [n=0] 
[10:49:46.178] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.178] Number of futures (= number of chunks): 1
[10:49:46.179] Launching 1 futures (chunks) ...
[10:49:46.179] Chunk #1 of 1 ...
[10:49:46.179]  - seeds: <none>
[10:49:46.179]  - All globals exported: [n=6] ‘a’, ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.182] Created future:
[10:49:46.182] SequentialFuture:
[10:49:46.182] Label: ‘future_lapply-1’
[10:49:46.182] Expression:
[10:49:46.182] {
[10:49:46.182]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.182]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.182]     "# as a global variable                                         "
[10:49:46.182]     do.call(function(...) {
[10:49:46.182]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.182]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.182]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.182]         "# anonymous function.                                          "
[10:49:46.182]         "#                                                              "
[10:49:46.182]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.182]         "# function environment of FUN() to the calling environment.    "
[10:49:46.182]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.182]         "# global environment, which is where globals are written.      "
[10:49:46.182]         penv <- env <- environment(...future.FUN)
[10:49:46.182]         repeat {
[10:49:46.182]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.182]                 emptyenv())) 
[10:49:46.182]                 break
[10:49:46.182]             penv <- env
[10:49:46.182]             env <- parent.env(env)
[10:49:46.182]         }
[10:49:46.182]         if (identical(penv, globalenv())) {
[10:49:46.182]             environment(...future.FUN) <- environment()
[10:49:46.182]         }
[10:49:46.182]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.182]             !isNamespace(penv)) {
[10:49:46.182]             parent.env(penv) <- environment()
[10:49:46.182]         }
[10:49:46.182]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.182]         {
[10:49:46.182]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.182]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.182]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.182]                 on.exit(options(oopts), add = TRUE)
[10:49:46.182]             }
[10:49:46.182]             {
[10:49:46.182]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.182]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.182]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.182]                 })
[10:49:46.182]             }
[10:49:46.182]         }
[10:49:46.182]     }, args = future.call.arguments)
[10:49:46.182] }
[10:49:46.182] Lazy evaluation: FALSE
[10:49:46.182] Asynchronous evaluation: TRUE
[10:49:46.182] Local evaluation: TRUE
[10:49:46.182] Environment: R_GlobalEnv
[10:49:46.182] Capture standard output: TRUE
[10:49:46.182] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.182] Immediate condition classes: ‘immediateCondition’
[10:49:46.182] Globals: 6 objects totaling 535 bytes (numeric ‘a’ of 39 bytes, function ‘...future.FUN’ of 298 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.182] Packages: <none>
[10:49:46.182] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.182] Resolved: TRUE
[10:49:46.182] Value: 47 bytes of class ‘list’
[10:49:46.182] Early signaling: FALSE
[10:49:46.182] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.182] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’
[10:49:46.183] Chunk #1 of 1 ... DONE
[10:49:46.183] Launching 1 futures (chunks) ... DONE
[10:49:46.183] Resolving 1 futures (chunks) ...
[10:49:46.184]  - Number of value chunks collected: 1
[10:49:46.184] Resolving 1 futures (chunks) ... DONE
[10:49:46.184] Reducing values from 1 chunks ...
[10:49:46.184]  - Number of values collected after concatenation: 1
[10:49:46.184]  - Number of values expected: 1
[10:49:46.184] Reducing values from 1 chunks ... DONE
[10:49:46.184] future_lapply() ... DONE
List of 1
 $ : num 42
[10:49:46.190] future_lapply() ...
[10:49:46.204] Number of chunks: 2
[10:49:46.204] getGlobalsAndPackagesXApply() ...
[10:49:46.204]  - future.globals: TRUE
[10:49:46.209]  - globals found/used: [n=5] ‘FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’
[10:49:46.209]  - needed namespaces: [n=0] 
[10:49:46.209] Finding globals ... DONE
[10:49:46.209]  - use_args: TRUE
[10:49:46.210]  - Getting '...' globals ...
[10:49:46.210]    - '...' content: [n=0] 
[10:49:46.210] List of 1
[10:49:46.210]  $ ...: list()
[10:49:46.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.210]  - attr(*, "where")=List of 1
[10:49:46.210]   ..$ ...:<environment: 0x55d1ceb9fe28> 
[10:49:46.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.210]  - attr(*, "resolved")= logi TRUE
[10:49:46.210]  - attr(*, "total_size")= num NA
[10:49:46.212]  - Getting '...' globals ... DONE
[10:49:46.213] Globals to be used in all futures (chunks): [n=6] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’
[10:49:46.213] List of 6
[10:49:46.213]  $ ...future.FUN:function (i)  
[10:49:46.213]  $ caller       :function (a, b, FUN = call_my_add)  
[10:49:46.213]  $ args         :List of 1
[10:49:46.213]   ..$ FUN:function (a, b)  
[10:49:46.213]  $ call_my_add  :function (a, b)  
[10:49:46.213]  $ my_add       :function (a, b)  
[10:49:46.213]  $ ...          : list()
[10:49:46.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.213]  - attr(*, "where")=List of 6
[10:49:46.213]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.213]   ..$ caller       :<environment: R_EmptyEnv> 
[10:49:46.213]   ..$ args         :<environment: R_EmptyEnv> 
[10:49:46.213]   ..$ call_my_add  :<environment: R_EmptyEnv> 
[10:49:46.213]   ..$ my_add       :<environment: R_EmptyEnv> 
[10:49:46.213]   ..$ ...          :<environment: 0x55d1ceb9fe28> 
[10:49:46.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.213]  - attr(*, "resolved")= logi FALSE
[10:49:46.213]  - attr(*, "total_size")= num 10892
[10:49:46.217] Packages to be attached in all futures: [n=0] 
[10:49:46.218] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.218] Number of futures (= number of chunks): 2
[10:49:46.218] Launching 2 futures (chunks) ...
[10:49:46.218] Chunk #1 of 2 ...
[10:49:46.218]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.218]    + additional globals found: [n=0] 
[10:49:46.218]    + additional namespaces needed: [n=0] 
[10:49:46.218]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:46.219]  - seeds: <none>
[10:49:46.219]  - All globals exported: [n=9] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.225] Created future:
[10:49:46.226] MulticoreFuture:
[10:49:46.226] Label: ‘future_lapply-1’
[10:49:46.226] Expression:
[10:49:46.226] {
[10:49:46.226]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.226]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.226]     "# as a global variable                                         "
[10:49:46.226]     do.call(function(...) {
[10:49:46.226]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.226]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.226]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.226]         "# anonymous function.                                          "
[10:49:46.226]         "#                                                              "
[10:49:46.226]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.226]         "# function environment of FUN() to the calling environment.    "
[10:49:46.226]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.226]         "# global environment, which is where globals are written.      "
[10:49:46.226]         penv <- env <- environment(...future.FUN)
[10:49:46.226]         repeat {
[10:49:46.226]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.226]                 emptyenv())) 
[10:49:46.226]                 break
[10:49:46.226]             penv <- env
[10:49:46.226]             env <- parent.env(env)
[10:49:46.226]         }
[10:49:46.226]         if (identical(penv, globalenv())) {
[10:49:46.226]             environment(...future.FUN) <- environment()
[10:49:46.226]         }
[10:49:46.226]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.226]             !isNamespace(penv)) {
[10:49:46.226]             parent.env(penv) <- environment()
[10:49:46.226]         }
[10:49:46.226]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.226]         {
[10:49:46.226]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.226]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.226]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.226]                 on.exit(options(oopts), add = TRUE)
[10:49:46.226]             }
[10:49:46.226]             {
[10:49:46.226]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.226]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.226]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.226]                 })
[10:49:46.226]             }
[10:49:46.226]         }
[10:49:46.226]     }, args = future.call.arguments)
[10:49:46.226] }
[10:49:46.226] Lazy evaluation: FALSE
[10:49:46.226] Asynchronous evaluation: TRUE
[10:49:46.226] Local evaluation: TRUE
[10:49:46.226] Environment: 0x55d1ce853c98
[10:49:46.226] Capture standard output: TRUE
[10:49:46.226] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.226] Immediate condition classes: ‘immediateCondition’
[10:49:46.226] Globals: 9 objects totaling 4.98 KiB (function ‘...future.FUN’ of 2.67 KiB, function ‘caller’ of 247 bytes, list ‘args’ of 928 bytes, function ‘call_my_add’ of 876 bytes, function ‘my_add’ of 114 bytes, ...)
[10:49:46.226] Packages: <none>
[10:49:46.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.226] Resolved: TRUE
[10:49:46.226] Value: <not collected>
[10:49:46.226] Conditions captured: <none>
[10:49:46.226] Early signaling: FALSE
[10:49:46.226] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.226] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.234] Chunk #1 of 2 ... DONE
[10:49:46.234] Chunk #2 of 2 ...
[10:49:46.235]  - Finding globals in 'X' for chunk #2 ...
[10:49:46.235]    + additional globals found: [n=0] 
[10:49:46.236]    + additional namespaces needed: [n=0] 
[10:49:46.236]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:46.236]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:46.236]  - seeds: <none>
[10:49:46.236]  - All globals exported: [n=9] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.242] Created future:
[10:49:46.243] MulticoreFuture:
[10:49:46.243] Label: ‘future_lapply-2’
[10:49:46.243] Expression:
[10:49:46.243] {
[10:49:46.243]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.243]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.243]     "# as a global variable                                         "
[10:49:46.243]     do.call(function(...) {
[10:49:46.243]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.243]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.243]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.243]         "# anonymous function.                                          "
[10:49:46.243]         "#                                                              "
[10:49:46.243]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.243]         "# function environment of FUN() to the calling environment.    "
[10:49:46.243]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.243]         "# global environment, which is where globals are written.      "
[10:49:46.243]         penv <- env <- environment(...future.FUN)
[10:49:46.243]         repeat {
[10:49:46.243]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.243]                 emptyenv())) 
[10:49:46.243]                 break
[10:49:46.243]             penv <- env
[10:49:46.243]             env <- parent.env(env)
[10:49:46.243]         }
[10:49:46.243]         if (identical(penv, globalenv())) {
[10:49:46.243]             environment(...future.FUN) <- environment()
[10:49:46.243]         }
[10:49:46.243]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.243]             !isNamespace(penv)) {
[10:49:46.243]             parent.env(penv) <- environment()
[10:49:46.243]         }
[10:49:46.243]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.243]         {
[10:49:46.243]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.243]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.243]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.243]                 on.exit(options(oopts), add = TRUE)
[10:49:46.243]             }
[10:49:46.243]             {
[10:49:46.243]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.243]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.243]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.243]                 })
[10:49:46.243]             }
[10:49:46.243]         }
[10:49:46.243]     }, args = future.call.arguments)
[10:49:46.243] }
[10:49:46.243] Lazy evaluation: FALSE
[10:49:46.243] Asynchronous evaluation: TRUE
[10:49:46.243] Local evaluation: TRUE
[10:49:46.243] Environment: 0x55d1ce853c98
[10:49:46.243] Capture standard output: TRUE
[10:49:46.243] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.243] Immediate condition classes: ‘immediateCondition’
[10:49:46.243] Globals: 9 objects totaling 4.99 KiB (function ‘...future.FUN’ of 2.67 KiB, function ‘caller’ of 247 bytes, list ‘args’ of 928 bytes, function ‘call_my_add’ of 876 bytes, function ‘my_add’ of 114 bytes, ...)
[10:49:46.243] Packages: <none>
[10:49:46.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.243] Resolved: TRUE
[10:49:46.243] Value: <not collected>
[10:49:46.243] Conditions captured: <none>
[10:49:46.243] Early signaling: FALSE
[10:49:46.243] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.243] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.251] Chunk #2 of 2 ... DONE
[10:49:46.251] Launching 2 futures (chunks) ... DONE
[10:49:46.251] Resolving 2 futures (chunks) ...
[10:49:46.257]  - Number of value chunks collected: 2
[10:49:46.257] Resolving 2 futures (chunks) ... DONE
[10:49:46.258] Reducing values from 2 chunks ...
[10:49:46.258]  - Number of values collected after concatenation: 3
[10:49:46.258]  - Number of values expected: 3
[10:49:46.258] Reducing values from 2 chunks ... DONE
[10:49:46.258] future_lapply() ... DONE
- future_lapply(x, FUN = do.call, ...) ...
[10:49:46.259] future_lapply() ...
[10:49:46.262] Number of chunks: 1
[10:49:46.262] getGlobalsAndPackagesXApply() ...
[10:49:46.262]  - future.globals: TRUE
[10:49:46.266]  - globals found/used: [n=1] ‘FUN’
[10:49:46.266]  - needed namespaces: [n=0] 
[10:49:46.266] Finding globals ... DONE
[10:49:46.266]  - use_args: TRUE
[10:49:46.266]  - Getting '...' globals ...
[10:49:46.267]    - '...' content: [n=1] ‘what’
[10:49:46.267] List of 1
[10:49:46.267]  $ ...:List of 1
[10:49:46.267]   ..$ what:function (x)  
[10:49:46.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.267]  - attr(*, "where")=List of 1
[10:49:46.267]   ..$ ...:<environment: 0x55d1ce4d6540> 
[10:49:46.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.267]  - attr(*, "resolved")= logi TRUE
[10:49:46.267]  - attr(*, "total_size")= num NA
[10:49:46.271]  - Getting '...' globals ... DONE
[10:49:46.271] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.271] List of 2
[10:49:46.271]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:46.271]  $ ...          :List of 1
[10:49:46.271]   ..$ what:function (x)  
[10:49:46.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.271]  - attr(*, "where")=List of 2
[10:49:46.271]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.271]   ..$ ...          :<environment: 0x55d1ce4d6540> 
[10:49:46.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.271]  - attr(*, "resolved")= logi FALSE
[10:49:46.271]  - attr(*, "total_size")= num 6909
[10:49:46.275] Packages to be attached in all futures: [n=0] 
[10:49:46.275] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.275] Number of futures (= number of chunks): 1
[10:49:46.275] Launching 1 futures (chunks) ...
[10:49:46.276] Chunk #1 of 1 ...
[10:49:46.276]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.276]    + additional globals found: [n=0] 
[10:49:46.276]    + additional namespaces needed: [n=0] 
[10:49:46.276]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.277]  - seeds: <none>
[10:49:46.277]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.280] Created future:
[10:49:46.280] MulticoreFuture:
[10:49:46.280] Label: ‘future_lapply-1’
[10:49:46.280] Expression:
[10:49:46.280] {
[10:49:46.280]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.280]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.280]     "# as a global variable                                         "
[10:49:46.280]     do.call(function(...) {
[10:49:46.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.280]             on.exit(options(oopts), add = TRUE)
[10:49:46.280]         }
[10:49:46.280]         {
[10:49:46.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.280]                 ...future.FUN(...future.X_jj, ...)
[10:49:46.280]             })
[10:49:46.280]         }
[10:49:46.280]     }, args = future.call.arguments)
[10:49:46.280] }
[10:49:46.280] Lazy evaluation: FALSE
[10:49:46.280] Asynchronous evaluation: TRUE
[10:49:46.280] Local evaluation: TRUE
[10:49:46.280] Environment: R_GlobalEnv
[10:49:46.280] Capture standard output: TRUE
[10:49:46.280] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.280] Immediate condition classes: ‘immediateCondition’
[10:49:46.280] Globals: 5 objects totaling 2.13 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.280] Packages: <none>
[10:49:46.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.280] Resolved: TRUE
[10:49:46.280] Value: <not collected>
[10:49:46.280] Conditions captured: <none>
[10:49:46.280] Early signaling: FALSE
[10:49:46.280] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.280] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.288] Chunk #1 of 1 ... DONE
[10:49:46.288] Launching 1 futures (chunks) ... DONE
[10:49:46.288] Resolving 1 futures (chunks) ...
[10:49:46.290]  - Number of value chunks collected: 1
[10:49:46.290] Resolving 1 futures (chunks) ... DONE
[10:49:46.290] Reducing values from 1 chunks ...
[10:49:46.290]  - Number of values collected after concatenation: 1
[10:49:46.290]  - Number of values expected: 1
[10:49:46.290] Reducing values from 1 chunks ... DONE
[10:49:46.290] future_lapply() ... DONE
[10:49:46.291] future_lapply() ...
[10:49:46.296] Number of chunks: 1
[10:49:46.296] getGlobalsAndPackagesXApply() ...
[10:49:46.296]  - future.globals: TRUE
[10:49:46.300]  - globals found/used: [n=1] ‘FUN’
[10:49:46.301]  - needed namespaces: [n=0] 
[10:49:46.301] Finding globals ... DONE
[10:49:46.301]  - use_args: TRUE
[10:49:46.301]  - Getting '...' globals ...
[10:49:46.301]    - '...' content: [n=1] ‘what’
[10:49:46.302] List of 1
[10:49:46.302]  $ ...:List of 1
[10:49:46.302]   ..$ what:function (...)  
[10:49:46.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.302]  - attr(*, "where")=List of 1
[10:49:46.302]   ..$ ...:<environment: 0x55d1cf154388> 
[10:49:46.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.302]  - attr(*, "resolved")= logi TRUE
[10:49:46.302]  - attr(*, "total_size")= num NA
[10:49:46.305]  - Getting '...' globals ... DONE
[10:49:46.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.306] List of 2
[10:49:46.306]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:46.306]  $ ...          :List of 1
[10:49:46.306]   ..$ what:function (...)  
[10:49:46.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.306]  - attr(*, "where")=List of 2
[10:49:46.306]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.306]   ..$ ...          :<environment: 0x55d1cf154388> 
[10:49:46.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.306]  - attr(*, "resolved")= logi FALSE
[10:49:46.306]  - attr(*, "total_size")= num 7345
[10:49:46.309] Packages to be attached in all futures: [n=0] 
[10:49:46.310] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.310] Number of futures (= number of chunks): 1
[10:49:46.310] Launching 1 futures (chunks) ...
[10:49:46.310] Chunk #1 of 1 ...
[10:49:46.310]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.311]    + additional globals found: [n=0] 
[10:49:46.311]    + additional namespaces needed: [n=0] 
[10:49:46.311]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.311]  - seeds: <none>
[10:49:46.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.314] Created future:
[10:49:46.315] MulticoreFuture:
[10:49:46.315] Label: ‘future_lapply-1’
[10:49:46.315] Expression:
[10:49:46.315] {
[10:49:46.315]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.315]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.315]     "# as a global variable                                         "
[10:49:46.315]     do.call(function(...) {
[10:49:46.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.315]             on.exit(options(oopts), add = TRUE)
[10:49:46.315]         }
[10:49:46.315]         {
[10:49:46.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.315]                 ...future.FUN(...future.X_jj, ...)
[10:49:46.315]             })
[10:49:46.315]         }
[10:49:46.315]     }, args = future.call.arguments)
[10:49:46.315] }
[10:49:46.315] Lazy evaluation: FALSE
[10:49:46.315] Asynchronous evaluation: TRUE
[10:49:46.315] Local evaluation: TRUE
[10:49:46.315] Environment: R_GlobalEnv
[10:49:46.315] Capture standard output: TRUE
[10:49:46.315] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.315] Immediate condition classes: ‘immediateCondition’
[10:49:46.315] Globals: 5 objects totaling 2.36 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 388 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.315] Packages: <none>
[10:49:46.315] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.315] Resolved: TRUE
[10:49:46.315] Value: <not collected>
[10:49:46.315] Conditions captured: <none>
[10:49:46.315] Early signaling: FALSE
[10:49:46.315] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.315] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.324] Chunk #1 of 1 ... DONE
[10:49:46.324] Launching 1 futures (chunks) ... DONE
[10:49:46.324] Resolving 1 futures (chunks) ...
[10:49:46.326]  - Number of value chunks collected: 1
[10:49:46.326] Resolving 1 futures (chunks) ... DONE
[10:49:46.326] Reducing values from 1 chunks ...
[10:49:46.326]  - Number of values collected after concatenation: 1
[10:49:46.326]  - Number of values expected: 1
[10:49:46.327] Reducing values from 1 chunks ... DONE
[10:49:46.327] future_lapply() ... DONE
- future_lapply(x, ...) - passing arguments via '...' ...
[10:49:46.327] future_lapply() ...
[10:49:46.328] Number of chunks: 1
[10:49:46.328] getGlobalsAndPackagesXApply() ...
[10:49:46.328]  - future.globals: TRUE
[10:49:46.331]  - globals found/used: [n=1] ‘FUN’
[10:49:46.331]  - needed namespaces: [n=0] 
[10:49:46.331] Finding globals ... DONE
[10:49:46.331]  - use_args: TRUE
[10:49:46.331]  - Getting '...' globals ...
[10:49:46.332]    - '...' content: [n=1] ‘b’
[10:49:46.332] List of 1
[10:49:46.332]  $ ...:List of 1
[10:49:46.332]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:46.332]   .. ..$ a: int [1:2] 1 2
[10:49:46.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.332]  - attr(*, "where")=List of 1
[10:49:46.332]   ..$ ...:<environment: 0x55d1cca20da8> 
[10:49:46.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.332]  - attr(*, "resolved")= logi TRUE
[10:49:46.332]  - attr(*, "total_size")= num NA
[10:49:46.336]  - Getting '...' globals ... DONE
[10:49:46.337] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.337] List of 2
[10:49:46.337]  $ ...future.FUN:function (a, b)  
[10:49:46.337]  $ ...          :List of 1
[10:49:46.337]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:46.337]   .. ..$ a: int [1:2] 1 2
[10:49:46.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.337]  - attr(*, "where")=List of 2
[10:49:46.337]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.337]   ..$ ...          :<environment: 0x55d1cca20da8> 
[10:49:46.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.337]  - attr(*, "resolved")= logi FALSE
[10:49:46.337]  - attr(*, "total_size")= num 4163
[10:49:46.341] Packages to be attached in all futures: [n=0] 
[10:49:46.341] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.342] Number of futures (= number of chunks): 1
[10:49:46.342] Launching 1 futures (chunks) ...
[10:49:46.342] Chunk #1 of 1 ...
[10:49:46.342]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.342]    + additional globals found: [n=0] 
[10:49:46.342]    + additional namespaces needed: [n=0] 
[10:49:46.343]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.343]  - seeds: <none>
[10:49:46.343]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.346] Created future:
[10:49:46.346] MulticoreFuture:
[10:49:46.346] Label: ‘future_lapply-1’
[10:49:46.346] Expression:
[10:49:46.346] {
[10:49:46.346]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.346]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.346]     "# as a global variable                                         "
[10:49:46.346]     do.call(function(...) {
[10:49:46.346]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.346]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.346]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.346]         "# anonymous function.                                          "
[10:49:46.346]         "#                                                              "
[10:49:46.346]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.346]         "# function environment of FUN() to the calling environment.    "
[10:49:46.346]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.346]         "# global environment, which is where globals are written.      "
[10:49:46.346]         penv <- env <- environment(...future.FUN)
[10:49:46.346]         repeat {
[10:49:46.346]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.346]                 emptyenv())) 
[10:49:46.346]                 break
[10:49:46.346]             penv <- env
[10:49:46.346]             env <- parent.env(env)
[10:49:46.346]         }
[10:49:46.346]         if (identical(penv, globalenv())) {
[10:49:46.346]             environment(...future.FUN) <- environment()
[10:49:46.346]         }
[10:49:46.346]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.346]             !isNamespace(penv)) {
[10:49:46.346]             parent.env(penv) <- environment()
[10:49:46.346]         }
[10:49:46.346]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.346]         {
[10:49:46.346]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.346]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.346]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.346]                 on.exit(options(oopts), add = TRUE)
[10:49:46.346]             }
[10:49:46.346]             {
[10:49:46.346]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.346]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.346]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.346]                 })
[10:49:46.346]             }
[10:49:46.346]         }
[10:49:46.346]     }, args = future.call.arguments)
[10:49:46.346] }
[10:49:46.346] Lazy evaluation: FALSE
[10:49:46.346] Asynchronous evaluation: TRUE
[10:49:46.346] Local evaluation: TRUE
[10:49:46.346] Environment: R_GlobalEnv
[10:49:46.346] Capture standard output: TRUE
[10:49:46.346] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.346] Immediate condition classes: ‘immediateCondition’
[10:49:46.346] Globals: 5 objects totaling 786 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 357 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.346] Packages: <none>
[10:49:46.346] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.346] Resolved: TRUE
[10:49:46.346] Value: <not collected>
[10:49:46.346] Conditions captured: <none>
[10:49:46.346] Early signaling: FALSE
[10:49:46.346] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.346] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.354] Chunk #1 of 1 ... DONE
[10:49:46.354] Launching 1 futures (chunks) ... DONE
[10:49:46.354] Resolving 1 futures (chunks) ...
[10:49:46.356]  - Number of value chunks collected: 1
[10:49:46.356] Resolving 1 futures (chunks) ... DONE
[10:49:46.356] Reducing values from 1 chunks ...
[10:49:46.356]  - Number of values collected after concatenation: 1
[10:49:46.356]  - Number of values expected: 1
[10:49:46.356] Reducing values from 1 chunks ... DONE
[10:49:46.356] future_lapply() ... DONE
[10:49:46.357] future_lapply() ...
[10:49:46.358] Number of chunks: 1
[10:49:46.358] getGlobalsAndPackagesXApply() ...
[10:49:46.358]  - future.globals: TRUE
[10:49:46.360]  - globals found/used: [n=1] ‘FUN’
[10:49:46.360]  - needed namespaces: [n=0] 
[10:49:46.360] Finding globals ... DONE
[10:49:46.361]  - use_args: TRUE
[10:49:46.361]  - Getting '...' globals ...
[10:49:46.361]    - '...' content: [n=1] ‘b’
[10:49:46.361] List of 1
[10:49:46.361]  $ ...:List of 1
[10:49:46.361]   ..$ b:<environment: 0x55d1ce98ff10> 
[10:49:46.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.361]  - attr(*, "where")=List of 1
[10:49:46.361]   ..$ ...:<environment: 0x55d1ce993218> 
[10:49:46.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.361]  - attr(*, "resolved")= logi TRUE
[10:49:46.361]  - attr(*, "total_size")= num NA
[10:49:46.365]  - Getting '...' globals ... DONE
[10:49:46.365] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.366] List of 2
[10:49:46.366]  $ ...future.FUN:function (a, b)  
[10:49:46.366]  $ ...          :List of 1
[10:49:46.366]   ..$ b:<environment: 0x55d1ce98ff10> 
[10:49:46.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.366]  - attr(*, "where")=List of 2
[10:49:46.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.366]   ..$ ...          :<environment: 0x55d1ce993218> 
[10:49:46.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.366]  - attr(*, "resolved")= logi FALSE
[10:49:46.366]  - attr(*, "total_size")= num 3918
[10:49:46.369] Packages to be attached in all futures: [n=0] 
[10:49:46.369] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.370] Number of futures (= number of chunks): 1
[10:49:46.370] Launching 1 futures (chunks) ...
[10:49:46.370] Chunk #1 of 1 ...
[10:49:46.370]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.370]    + additional globals found: [n=0] 
[10:49:46.371]    + additional namespaces needed: [n=0] 
[10:49:46.371]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.371]  - seeds: <none>
[10:49:46.371]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.375] Created future:
[10:49:46.375] MulticoreFuture:
[10:49:46.375] Label: ‘future_lapply-1’
[10:49:46.375] Expression:
[10:49:46.375] {
[10:49:46.375]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.375]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.375]     "# as a global variable                                         "
[10:49:46.375]     do.call(function(...) {
[10:49:46.375]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.375]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.375]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.375]         "# anonymous function.                                          "
[10:49:46.375]         "#                                                              "
[10:49:46.375]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.375]         "# function environment of FUN() to the calling environment.    "
[10:49:46.375]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.375]         "# global environment, which is where globals are written.      "
[10:49:46.375]         penv <- env <- environment(...future.FUN)
[10:49:46.375]         repeat {
[10:49:46.375]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.375]                 emptyenv())) 
[10:49:46.375]                 break
[10:49:46.375]             penv <- env
[10:49:46.375]             env <- parent.env(env)
[10:49:46.375]         }
[10:49:46.375]         if (identical(penv, globalenv())) {
[10:49:46.375]             environment(...future.FUN) <- environment()
[10:49:46.375]         }
[10:49:46.375]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.375]             !isNamespace(penv)) {
[10:49:46.375]             parent.env(penv) <- environment()
[10:49:46.375]         }
[10:49:46.375]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.375]         {
[10:49:46.375]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.375]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.375]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.375]                 on.exit(options(oopts), add = TRUE)
[10:49:46.375]             }
[10:49:46.375]             {
[10:49:46.375]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.375]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.375]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.375]                 })
[10:49:46.375]             }
[10:49:46.375]         }
[10:49:46.375]     }, args = future.call.arguments)
[10:49:46.375] }
[10:49:46.375] Lazy evaluation: FALSE
[10:49:46.375] Asynchronous evaluation: TRUE
[10:49:46.375] Local evaluation: TRUE
[10:49:46.375] Environment: R_GlobalEnv
[10:49:46.375] Capture standard output: TRUE
[10:49:46.375] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.375] Immediate condition classes: ‘immediateCondition’
[10:49:46.375] Globals: 5 objects totaling 708 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 279 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.375] Packages: <none>
[10:49:46.375] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.375] Resolved: TRUE
[10:49:46.375] Value: <not collected>
[10:49:46.375] Conditions captured: <none>
[10:49:46.375] Early signaling: FALSE
[10:49:46.375] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.375] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.387] Chunk #1 of 1 ... DONE
[10:49:46.387] Launching 1 futures (chunks) ... DONE
[10:49:46.387] Resolving 1 futures (chunks) ...
[10:49:46.391]  - Number of value chunks collected: 1
[10:49:46.391] Resolving 1 futures (chunks) ... DONE
[10:49:46.391] Reducing values from 1 chunks ...
[10:49:46.391]  - Number of values collected after concatenation: 1
[10:49:46.392]  - Number of values expected: 1
[10:49:46.392] Reducing values from 1 chunks ... DONE
[10:49:46.392] future_lapply() ... DONE
[10:49:46.392] future_lapply() ...
[10:49:46.393] Number of chunks: 1
[10:49:46.393] getGlobalsAndPackagesXApply() ...
[10:49:46.393]  - future.globals: TRUE
[10:49:46.396]  - globals found/used: [n=1] ‘FUN’
[10:49:46.396]  - needed namespaces: [n=0] 
[10:49:46.396] Finding globals ... DONE
[10:49:46.397]  - use_args: TRUE
[10:49:46.397]  - Getting '...' globals ...
[10:49:46.397]    - '...' content: [n=1] ‘b’
[10:49:46.397] List of 1
[10:49:46.397]  $ ...:List of 1
[10:49:46.397]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:46.397]   .. .. ..@ slots     :List of 4
[10:49:46.397]   .. .. .. ..$ .Data  : chr "function"
[10:49:46.397]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. ..$ target : chr "signature"
[10:49:46.397]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. ..$ defined: chr "signature"
[10:49:46.397]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. ..$ generic: chr "character"
[10:49:46.397]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. ..@ contains  :List of 4
[10:49:46.397]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.397]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.397]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.397]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 3
[10:49:46.397]   .. .. ..@ virtual   : logi FALSE
[10:49:46.397]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:46.397]  list()
[10:49:46.397]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.397]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.397]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.397]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.397]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.397]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.397]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.397]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.397]   .. .. .. .. ..$ generic: chr(0) 
[10:49:46.397]   .. .. ..@ validity  : NULL
[10:49:46.397]   .. .. ..@ access    : list()
[10:49:46.397]   .. .. ..@ className : chr "MethodDefinition"
[10:49:46.397]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. ..@ subclasses:List of 7
[10:49:46.397]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.397]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.397]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.397]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.397]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.397]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.397]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.397]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.397]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.397]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.397]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.397]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.397]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.397]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.397]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.397]   .. .. ..@ versionKey:<externalptr> 
[10:49:46.397]   .. .. ..@ sealed    : logi TRUE
[10:49:46.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.397]  - attr(*, "where")=List of 1
[10:49:46.397]   ..$ ...:<environment: 0x55d1cddb6728> 
[10:49:46.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.397]  - attr(*, "resolved")= logi TRUE
[10:49:46.397]  - attr(*, "total_size")= num NA
[10:49:46.460]  - Getting '...' globals ... DONE
[10:49:46.460] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.460] List of 2
[10:49:46.460]  $ ...future.FUN:function (a, b)  
[10:49:46.460]  $ ...          :List of 1
[10:49:46.460]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:46.460]   .. .. ..@ slots     :List of 4
[10:49:46.460]   .. .. .. ..$ .Data  : chr "function"
[10:49:46.460]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. ..$ target : chr "signature"
[10:49:46.460]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. ..$ defined: chr "signature"
[10:49:46.460]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. ..$ generic: chr "character"
[10:49:46.460]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. ..@ contains  :List of 4
[10:49:46.460]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.460]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.460]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.460]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 3
[10:49:46.460]   .. .. ..@ virtual   : logi FALSE
[10:49:46.460]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:46.460]  list()
[10:49:46.460]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.460]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.460]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.460]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.460]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:46.460]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:46.460]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:46.460]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:46.460]   .. .. .. .. ..$ generic: chr(0) 
[10:49:46.460]   .. .. ..@ validity  : NULL
[10:49:46.460]   .. .. ..@ access    : list()
[10:49:46.460]   .. .. ..@ className : chr "MethodDefinition"
[10:49:46.460]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. ..@ subclasses:List of 7
[10:49:46.460]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.460]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.460]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.460]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 1
[10:49:46.460]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.460]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.460]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:46.460]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:46.460]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:46.460]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:46.460]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:46.460]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:46.460]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:46.460]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:46.460]   .. .. .. .. .. ..@ distance  : num 2
[10:49:46.460]   .. .. ..@ versionKey:<externalptr> 
[10:49:46.460]   .. .. ..@ sealed    : logi TRUE
[10:49:46.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.460]  - attr(*, "where")=List of 2
[10:49:46.460]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.460]   ..$ ...          :<environment: 0x55d1cddb6728> 
[10:49:46.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.460]  - attr(*, "resolved")= logi FALSE
[10:49:46.460]  - attr(*, "total_size")= num 105785
[10:49:46.514] Packages to be attached in all futures: [n=0] 
[10:49:46.514] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.515] Number of futures (= number of chunks): 1
[10:49:46.515] Launching 1 futures (chunks) ...
[10:49:46.515] Chunk #1 of 1 ...
[10:49:46.515]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.515]    + additional globals found: [n=0] 
[10:49:46.516]    + additional namespaces needed: [n=0] 
[10:49:46.516]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.516]  - seeds: <none>
[10:49:46.516]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.520] Created future:
[10:49:46.520] MulticoreFuture:
[10:49:46.520] Label: ‘future_lapply-1’
[10:49:46.520] Expression:
[10:49:46.520] {
[10:49:46.520]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.520]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.520]     "# as a global variable                                         "
[10:49:46.520]     do.call(function(...) {
[10:49:46.520]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.520]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.520]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.520]         "# anonymous function.                                          "
[10:49:46.520]         "#                                                              "
[10:49:46.520]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.520]         "# function environment of FUN() to the calling environment.    "
[10:49:46.520]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.520]         "# global environment, which is where globals are written.      "
[10:49:46.520]         penv <- env <- environment(...future.FUN)
[10:49:46.520]         repeat {
[10:49:46.520]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.520]                 emptyenv())) 
[10:49:46.520]                 break
[10:49:46.520]             penv <- env
[10:49:46.520]             env <- parent.env(env)
[10:49:46.520]         }
[10:49:46.520]         if (identical(penv, globalenv())) {
[10:49:46.520]             environment(...future.FUN) <- environment()
[10:49:46.520]         }
[10:49:46.520]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.520]             !isNamespace(penv)) {
[10:49:46.520]             parent.env(penv) <- environment()
[10:49:46.520]         }
[10:49:46.520]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.520]         {
[10:49:46.520]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.520]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.520]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.520]                 on.exit(options(oopts), add = TRUE)
[10:49:46.520]             }
[10:49:46.520]             {
[10:49:46.520]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.520]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.520]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.520]                 })
[10:49:46.520]             }
[10:49:46.520]         }
[10:49:46.520]     }, args = future.call.arguments)
[10:49:46.520] }
[10:49:46.520] Lazy evaluation: FALSE
[10:49:46.520] Asynchronous evaluation: TRUE
[10:49:46.520] Local evaluation: TRUE
[10:49:46.520] Environment: R_GlobalEnv
[10:49:46.520] Capture standard output: TRUE
[10:49:46.520] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.520] Immediate condition classes: ‘immediateCondition’
[10:49:46.520] Globals: 5 objects totaling 50.72 KiB (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 50.30 KiB, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.520] Packages: <none>
[10:49:46.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.520] Resolved: TRUE
[10:49:46.520] Value: <not collected>
[10:49:46.520] Conditions captured: <none>
[10:49:46.520] Early signaling: FALSE
[10:49:46.520] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.520] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.530] Chunk #1 of 1 ... DONE
[10:49:46.531] Launching 1 futures (chunks) ... DONE
[10:49:46.531] Resolving 1 futures (chunks) ...
[10:49:46.532]  - Number of value chunks collected: 1
[10:49:46.532] Resolving 1 futures (chunks) ... DONE
[10:49:46.533] Reducing values from 1 chunks ...
[10:49:46.533]  - Number of values collected after concatenation: 1
[10:49:46.533]  - Number of values expected: 1
[10:49:46.533] Reducing values from 1 chunks ... DONE
[10:49:46.533] future_lapply() ... DONE
- future_lapply(X, ...) - 'X' containing globals ...
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
[10:49:46.536] future_lapply() ...
[10:49:46.537] Number of chunks: 2
[10:49:46.537] getGlobalsAndPackagesXApply() ...
[10:49:46.538]  - future.globals: TRUE
[10:49:46.540]  - globals found/used: [n=1] ‘FUN’
[10:49:46.540]  - needed namespaces: [n=0] 
[10:49:46.540] Finding globals ... DONE
[10:49:46.540]  - use_args: TRUE
[10:49:46.540]  - Getting '...' globals ...
[10:49:46.541]    - '...' content: [n=0] 
[10:49:46.541] List of 1
[10:49:46.541]  $ ...: list()
[10:49:46.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.541]  - attr(*, "where")=List of 1
[10:49:46.541]   ..$ ...:<environment: 0x55d1cd7e4b58> 
[10:49:46.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.541]  - attr(*, "resolved")= logi TRUE
[10:49:46.541]  - attr(*, "total_size")= num NA
[10:49:46.544]  - Getting '...' globals ... DONE
[10:49:46.544] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:46.544] List of 2
[10:49:46.544]  $ ...future.FUN:function (f)  
[10:49:46.544]  $ ...          : list()
[10:49:46.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.544]  - attr(*, "where")=List of 2
[10:49:46.544]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.544]   ..$ ...          :<environment: 0x55d1cd7e4b58> 
[10:49:46.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.544]  - attr(*, "resolved")= logi FALSE
[10:49:46.544]  - attr(*, "total_size")= num 4837
[10:49:46.548] Packages to be attached in all futures: [n=0] 
[10:49:46.548] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.548] Number of futures (= number of chunks): 2
[10:49:46.548] Launching 2 futures (chunks) ...
[10:49:46.548] Chunk #1 of 2 ...
[10:49:46.548]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.551]    + additional globals found: [n=2] ‘a’, ‘b’
[10:49:46.551]    + additional namespaces needed: [n=0] 
[10:49:46.551]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:46.551]  - seeds: <none>
[10:49:46.551]  - All globals exported: [n=7] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’, ‘a’, ‘b’
[10:49:46.554] Created future:
[10:49:46.555] MulticoreFuture:
[10:49:46.555] Label: ‘future_lapply-1’
[10:49:46.555] Expression:
[10:49:46.555] {
[10:49:46.555]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.555]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.555]     "# as a global variable                                         "
[10:49:46.555]     do.call(function(...) {
[10:49:46.555]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.555]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.555]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.555]         "# anonymous function.                                          "
[10:49:46.555]         "#                                                              "
[10:49:46.555]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.555]         "# function environment of FUN() to the calling environment.    "
[10:49:46.555]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.555]         "# global environment, which is where globals are written.      "
[10:49:46.555]         penv <- env <- environment(...future.FUN)
[10:49:46.555]         repeat {
[10:49:46.555]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.555]                 emptyenv())) 
[10:49:46.555]                 break
[10:49:46.555]             penv <- env
[10:49:46.555]             env <- parent.env(env)
[10:49:46.555]         }
[10:49:46.555]         if (identical(penv, globalenv())) {
[10:49:46.555]             environment(...future.FUN) <- environment()
[10:49:46.555]         }
[10:49:46.555]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.555]             !isNamespace(penv)) {
[10:49:46.555]             parent.env(penv) <- environment()
[10:49:46.555]         }
[10:49:46.555]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.555]         {
[10:49:46.555]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.555]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.555]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.555]                 on.exit(options(oopts), add = TRUE)
[10:49:46.555]             }
[10:49:46.555]             {
[10:49:46.555]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.555]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.555]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.555]                 })
[10:49:46.555]             }
[10:49:46.555]         }
[10:49:46.555]     }, args = future.call.arguments)
[10:49:46.555] }
[10:49:46.555] Lazy evaluation: FALSE
[10:49:46.555] Asynchronous evaluation: TRUE
[10:49:46.555] Local evaluation: TRUE
[10:49:46.555] Environment: R_GlobalEnv
[10:49:46.555] Capture standard output: TRUE
[10:49:46.555] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.555] Immediate condition classes: ‘immediateCondition’
[10:49:46.555] Globals: 7 objects totaling 1.02 KiB (function ‘...future.FUN’ of 225 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 588 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes, ...)
[10:49:46.555] Packages: <none>
[10:49:46.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.555] Resolved: TRUE
[10:49:46.555] Value: <not collected>
[10:49:46.555] Conditions captured: <none>
[10:49:46.555] Early signaling: FALSE
[10:49:46.555] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.563] Chunk #1 of 2 ... DONE
[10:49:46.563] Chunk #2 of 2 ...
[10:49:46.563]  - Finding globals in 'X' for chunk #2 ...
[10:49:46.567]    + additional globals found: [n=2] ‘a’, ‘b’
[10:49:46.567]    + additional namespaces needed: [n=1] ‘tools’
[10:49:46.568]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:46.568]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:46.568]  - seeds: <none>
[10:49:46.568]  - All globals exported: [n=7] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’, ‘a’, ‘b’
[10:49:46.572] Created future:
[10:49:46.573] MulticoreFuture:
[10:49:46.573] Label: ‘future_lapply-2’
[10:49:46.573] Expression:
[10:49:46.573] {
[10:49:46.573]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.573]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.573]     "# as a global variable                                         "
[10:49:46.573]     do.call(function(...) {
[10:49:46.573]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.573]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.573]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.573]         "# anonymous function.                                          "
[10:49:46.573]         "#                                                              "
[10:49:46.573]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.573]         "# function environment of FUN() to the calling environment.    "
[10:49:46.573]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.573]         "# global environment, which is where globals are written.      "
[10:49:46.573]         penv <- env <- environment(...future.FUN)
[10:49:46.573]         repeat {
[10:49:46.573]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.573]                 emptyenv())) 
[10:49:46.573]                 break
[10:49:46.573]             penv <- env
[10:49:46.573]             env <- parent.env(env)
[10:49:46.573]         }
[10:49:46.573]         if (identical(penv, globalenv())) {
[10:49:46.573]             environment(...future.FUN) <- environment()
[10:49:46.573]         }
[10:49:46.573]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.573]             !isNamespace(penv)) {
[10:49:46.573]             parent.env(penv) <- environment()
[10:49:46.573]         }
[10:49:46.573]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.573]         {
[10:49:46.573]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.573]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.573]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.573]                 on.exit(options(oopts), add = TRUE)
[10:49:46.573]             }
[10:49:46.573]             {
[10:49:46.573]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.573]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.573]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.573]                 })
[10:49:46.573]             }
[10:49:46.573]         }
[10:49:46.573]     }, args = future.call.arguments)
[10:49:46.573] }
[10:49:46.573] Lazy evaluation: FALSE
[10:49:46.573] Asynchronous evaluation: TRUE
[10:49:46.573] Local evaluation: TRUE
[10:49:46.573] Environment: R_GlobalEnv
[10:49:46.573] Capture standard output: TRUE
[10:49:46.573] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.573] Immediate condition classes: ‘immediateCondition’
[10:49:46.573] Globals: 7 objects totaling 1.33 KiB (function ‘...future.FUN’ of 225 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 903 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes, ...)
[10:49:46.573] Packages: 1 packages (‘tools’)
[10:49:46.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.573] Resolved: TRUE
[10:49:46.573] Value: <not collected>
[10:49:46.573] Conditions captured: <none>
[10:49:46.573] Early signaling: FALSE
[10:49:46.573] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.573] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.582] Chunk #2 of 2 ... DONE
[10:49:46.582] Launching 2 futures (chunks) ... DONE
[10:49:46.582] Resolving 2 futures (chunks) ...
[10:49:46.585]  - Number of value chunks collected: 2
[10:49:46.586] Resolving 2 futures (chunks) ... DONE
[10:49:46.586] Reducing values from 2 chunks ...
[10:49:46.586]  - Number of values collected after concatenation: 4
[10:49:46.586]  - Number of values expected: 4
[10:49:46.586] Reducing values from 2 chunks ... DONE
[10:49:46.586] future_lapply() ... DONE
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
- future_lapply(x, ...) - passing '...' as a global ...
List of 1
 $ z0:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
[10:49:46.591] future_lapply() ...
[10:49:46.592] Number of chunks: 1
[10:49:46.592] getGlobalsAndPackagesXApply() ...
[10:49:46.592]  - future.globals: TRUE
[10:49:46.595]  - globals found/used: [n=2] ‘FUN’, ‘future.call.arguments’
[10:49:46.595]  - needed namespaces: [n=0] 
[10:49:46.595] Finding globals ... DONE
[10:49:46.595]  - use_args: TRUE
[10:49:46.595]  - Getting '...' globals ...
[10:49:46.596]    - '...' content: [n=0] 
[10:49:46.596] List of 1
[10:49:46.596]  $ ...: list()
[10:49:46.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.596]  - attr(*, "where")=List of 1
[10:49:46.596]   ..$ ...:<environment: 0x55d1ce4e7f38> 
[10:49:46.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.596]  - attr(*, "resolved")= logi TRUE
[10:49:46.596]  - attr(*, "total_size")= num NA
[10:49:46.599]  - Getting '...' globals ... DONE
[10:49:46.599] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘future.call.arguments’, ‘...’
[10:49:46.599] List of 3
[10:49:46.599]  $ ...future.FUN        :function (x)  
[10:49:46.599]  $ future.call.arguments:List of 1
[10:49:46.599]   ..$ a: num 1
[10:49:46.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.599]  $ ...                  : list()
[10:49:46.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.599]  - attr(*, "where")=List of 3
[10:49:46.599]   ..$ ...future.FUN        :<environment: R_EmptyEnv> 
[10:49:46.599]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:49:46.599]   ..$ ...                  :<environment: 0x55d1ce4e7f38> 
[10:49:46.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.599]  - attr(*, "resolved")= logi FALSE
[10:49:46.599]  - attr(*, "total_size")= num 3563
[10:49:46.604] Packages to be attached in all futures: [n=0] 
[10:49:46.604] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.605] Number of futures (= number of chunks): 1
[10:49:46.605] Launching 1 futures (chunks) ...
[10:49:46.605] Chunk #1 of 1 ...
[10:49:46.605]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.605]    + additional globals found: [n=0] 
[10:49:46.605]    + additional namespaces needed: [n=0] 
[10:49:46.605]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.606]  - seeds: <none>
[10:49:46.606]  - All globals exported: [n=6] ‘...future.FUN’, ‘future.call.arguments’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.609] Created future:
[10:49:46.609] MulticoreFuture:
[10:49:46.609] Label: ‘future_lapply-1’
[10:49:46.609] Expression:
[10:49:46.609] {
[10:49:46.609]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.609]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.609]     "# as a global variable                                         "
[10:49:46.609]     do.call(function(...) {
[10:49:46.609]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.609]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.609]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.609]         "# anonymous function.                                          "
[10:49:46.609]         "#                                                              "
[10:49:46.609]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.609]         "# function environment of FUN() to the calling environment.    "
[10:49:46.609]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.609]         "# global environment, which is where globals are written.      "
[10:49:46.609]         penv <- env <- environment(...future.FUN)
[10:49:46.609]         repeat {
[10:49:46.609]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.609]                 emptyenv())) 
[10:49:46.609]                 break
[10:49:46.609]             penv <- env
[10:49:46.609]             env <- parent.env(env)
[10:49:46.609]         }
[10:49:46.609]         if (identical(penv, globalenv())) {
[10:49:46.609]             environment(...future.FUN) <- environment()
[10:49:46.609]         }
[10:49:46.609]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.609]             !isNamespace(penv)) {
[10:49:46.609]             parent.env(penv) <- environment()
[10:49:46.609]         }
[10:49:46.609]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.609]         {
[10:49:46.609]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.609]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.609]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.609]                 on.exit(options(oopts), add = TRUE)
[10:49:46.609]             }
[10:49:46.609]             {
[10:49:46.609]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.609]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.609]                   ...future.FUN(...future.X_jj)
[10:49:46.609]                 })
[10:49:46.609]             }
[10:49:46.609]         }
[10:49:46.609]     }, args = future.call.arguments)
[10:49:46.609] }
[10:49:46.609] Lazy evaluation: FALSE
[10:49:46.609] Asynchronous evaluation: TRUE
[10:49:46.609] Local evaluation: TRUE
[10:49:46.609] Environment: 0x55d1ce4e82b8
[10:49:46.609] Capture standard output: TRUE
[10:49:46.609] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.609] Immediate condition classes: ‘immediateCondition’
[10:49:46.609] Globals: 5 objects totaling 613 bytes (function ‘...future.FUN’ of 361 bytes, DotDotDotList ‘future.call.arguments’ of 151 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:46.609] Packages: <none>
[10:49:46.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.609] Resolved: TRUE
[10:49:46.609] Value: <not collected>
[10:49:46.609] Conditions captured: <none>
[10:49:46.609] Early signaling: FALSE
[10:49:46.609] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.609] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.617] Chunk #1 of 1 ... DONE
[10:49:46.617] Launching 1 futures (chunks) ... DONE
[10:49:46.617] Resolving 1 futures (chunks) ...
[10:49:46.618]  - Number of value chunks collected: 1
[10:49:46.619] Resolving 1 futures (chunks) ... DONE
[10:49:46.619] Reducing values from 1 chunks ...
[10:49:46.619]  - Number of values collected after concatenation: 1
[10:49:46.619]  - Number of values expected: 1
[10:49:46.619] Reducing values from 1 chunks ... DONE
[10:49:46.619] future_lapply() ... DONE
List of 1
 $ z1:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
- future_lapply(X, ...) - '{ a <- a + 1; a }' ...
[10:49:46.621] future_lapply() ...
[10:49:46.625] Number of chunks: 1
[10:49:46.625] getGlobalsAndPackagesXApply() ...
[10:49:46.625]  - future.globals: TRUE
[10:49:46.628]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:46.628]  - needed namespaces: [n=0] 
[10:49:46.628] Finding globals ... DONE
[10:49:46.628]  - use_args: TRUE
[10:49:46.628]  - Getting '...' globals ...
[10:49:46.629]    - '...' content: [n=0] 
[10:49:46.629] List of 1
[10:49:46.629]  $ ...: list()
[10:49:46.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.629]  - attr(*, "where")=List of 1
[10:49:46.629]   ..$ ...:<environment: 0x55d1cf153828> 
[10:49:46.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.629]  - attr(*, "resolved")= logi TRUE
[10:49:46.629]  - attr(*, "total_size")= num NA
[10:49:46.632]  - Getting '...' globals ... DONE
[10:49:46.632] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:46.632] List of 3
[10:49:46.632]  $ ...future.FUN:function (ii)  
[10:49:46.632]  $ a            : num 1
[10:49:46.632]  $ ...          : list()
[10:49:46.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.632]  - attr(*, "where")=List of 3
[10:49:46.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.632]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.632]   ..$ ...          :<environment: 0x55d1cf153828> 
[10:49:46.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.632]  - attr(*, "resolved")= logi FALSE
[10:49:46.632]  - attr(*, "total_size")= num 3759
[10:49:46.637] Packages to be attached in all futures: [n=0] 
[10:49:46.637] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.637] Number of futures (= number of chunks): 1
[10:49:46.637] Launching 1 futures (chunks) ...
[10:49:46.637] Chunk #1 of 1 ...
[10:49:46.637]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.638]    + additional globals found: [n=0] 
[10:49:46.638]    + additional namespaces needed: [n=0] 
[10:49:46.638]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.638]  - seeds: <none>
[10:49:46.638]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.641] Created future:
[10:49:46.641] MulticoreFuture:
[10:49:46.641] Label: ‘future_lapply-1’
[10:49:46.641] Expression:
[10:49:46.641] {
[10:49:46.641]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.641]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.641]     "# as a global variable                                         "
[10:49:46.641]     do.call(function(...) {
[10:49:46.641]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.641]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.641]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.641]         "# anonymous function.                                          "
[10:49:46.641]         "#                                                              "
[10:49:46.641]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.641]         "# function environment of FUN() to the calling environment.    "
[10:49:46.641]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.641]         "# global environment, which is where globals are written.      "
[10:49:46.641]         penv <- env <- environment(...future.FUN)
[10:49:46.641]         repeat {
[10:49:46.641]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.641]                 emptyenv())) 
[10:49:46.641]                 break
[10:49:46.641]             penv <- env
[10:49:46.641]             env <- parent.env(env)
[10:49:46.641]         }
[10:49:46.641]         if (identical(penv, globalenv())) {
[10:49:46.641]             environment(...future.FUN) <- environment()
[10:49:46.641]         }
[10:49:46.641]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.641]             !isNamespace(penv)) {
[10:49:46.641]             parent.env(penv) <- environment()
[10:49:46.641]         }
[10:49:46.641]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.641]         {
[10:49:46.641]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.641]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.641]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.641]                 on.exit(options(oopts), add = TRUE)
[10:49:46.641]             }
[10:49:46.641]             {
[10:49:46.641]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.641]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.641]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.641]                 })
[10:49:46.641]             }
[10:49:46.641]         }
[10:49:46.641]     }, args = future.call.arguments)
[10:49:46.641] }
[10:49:46.641] Lazy evaluation: FALSE
[10:49:46.641] Asynchronous evaluation: TRUE
[10:49:46.641] Local evaluation: TRUE
[10:49:46.641] Environment: R_GlobalEnv
[10:49:46.641] Capture standard output: TRUE
[10:49:46.641] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.641] Immediate condition classes: ‘immediateCondition’
[10:49:46.641] Globals: 6 objects totaling 748 bytes (function ‘...future.FUN’ of 511 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.641] Packages: <none>
[10:49:46.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.641] Resolved: TRUE
[10:49:46.641] Value: <not collected>
[10:49:46.641] Conditions captured: <none>
[10:49:46.641] Early signaling: FALSE
[10:49:46.641] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.641] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.650] Chunk #1 of 1 ... DONE
[10:49:46.650] Launching 1 futures (chunks) ... DONE
[10:49:46.650] Resolving 1 futures (chunks) ...
[10:49:46.652]  - Number of value chunks collected: 1
[10:49:46.652] Resolving 1 futures (chunks) ... DONE
[10:49:46.652] Reducing values from 1 chunks ...
[10:49:46.652]  - Number of values collected after concatenation: 1
[10:49:46.652]  - Number of values expected: 1
[10:49:46.652] Reducing values from 1 chunks ... DONE
[10:49:46.652] future_lapply() ... DONE
- future_lapply(X, ...) - '{ a; a <- a + 1 }' ...
[10:49:46.653] future_lapply() ...
[10:49:46.654] Number of chunks: 1
[10:49:46.654] getGlobalsAndPackagesXApply() ...
[10:49:46.654]  - future.globals: TRUE
[10:49:46.657]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:46.658]  - needed namespaces: [n=0] 
[10:49:46.658] Finding globals ... DONE
[10:49:46.658]  - use_args: TRUE
[10:49:46.658]  - Getting '...' globals ...
[10:49:46.658]    - '...' content: [n=0] 
[10:49:46.659] List of 1
[10:49:46.659]  $ ...: list()
[10:49:46.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.659]  - attr(*, "where")=List of 1
[10:49:46.659]   ..$ ...:<environment: 0x55d1ccb6ac58> 
[10:49:46.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.659]  - attr(*, "resolved")= logi TRUE
[10:49:46.659]  - attr(*, "total_size")= num NA
[10:49:46.662]  - Getting '...' globals ... DONE
[10:49:46.662] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:46.662] List of 3
[10:49:46.662]  $ ...future.FUN:function (ii)  
[10:49:46.662]  $ a            : num 1
[10:49:46.662]  $ ...          : list()
[10:49:46.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.662]  - attr(*, "where")=List of 3
[10:49:46.662]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:46.662]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.662]   ..$ ...          :<environment: 0x55d1ccb6ac58> 
[10:49:46.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.662]  - attr(*, "resolved")= logi FALSE
[10:49:46.662]  - attr(*, "total_size")= num 3775
[10:49:46.667] Packages to be attached in all futures: [n=0] 
[10:49:46.667] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.667] Number of futures (= number of chunks): 1
[10:49:46.667] Launching 1 futures (chunks) ...
[10:49:46.667] Chunk #1 of 1 ...
[10:49:46.667]  - Finding globals in 'X' for chunk #1 ...
[10:49:46.668]    + additional globals found: [n=0] 
[10:49:46.668]    + additional namespaces needed: [n=0] 
[10:49:46.668]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:46.668]  - seeds: <none>
[10:49:46.668]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.671] Created future:
[10:49:46.671] MulticoreFuture:
[10:49:46.671] Label: ‘future_lapply-1’
[10:49:46.671] Expression:
[10:49:46.671] {
[10:49:46.671]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.671]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.671]     "# as a global variable                                         "
[10:49:46.671]     do.call(function(...) {
[10:49:46.671]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.671]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.671]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.671]         "# anonymous function.                                          "
[10:49:46.671]         "#                                                              "
[10:49:46.671]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.671]         "# function environment of FUN() to the calling environment.    "
[10:49:46.671]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.671]         "# global environment, which is where globals are written.      "
[10:49:46.671]         penv <- env <- environment(...future.FUN)
[10:49:46.671]         repeat {
[10:49:46.671]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.671]                 emptyenv())) 
[10:49:46.671]                 break
[10:49:46.671]             penv <- env
[10:49:46.671]             env <- parent.env(env)
[10:49:46.671]         }
[10:49:46.671]         if (identical(penv, globalenv())) {
[10:49:46.671]             environment(...future.FUN) <- environment()
[10:49:46.671]         }
[10:49:46.671]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.671]             !isNamespace(penv)) {
[10:49:46.671]             parent.env(penv) <- environment()
[10:49:46.671]         }
[10:49:46.671]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.671]         {
[10:49:46.671]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.671]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.671]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.671]                 on.exit(options(oopts), add = TRUE)
[10:49:46.671]             }
[10:49:46.671]             {
[10:49:46.671]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.671]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.671]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.671]                 })
[10:49:46.671]             }
[10:49:46.671]         }
[10:49:46.671]     }, args = future.call.arguments)
[10:49:46.671] }
[10:49:46.671] Lazy evaluation: FALSE
[10:49:46.671] Asynchronous evaluation: TRUE
[10:49:46.671] Local evaluation: TRUE
[10:49:46.671] Environment: R_GlobalEnv
[10:49:46.671] Capture standard output: TRUE
[10:49:46.671] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.671] Immediate condition classes: ‘immediateCondition’
[10:49:46.671] Globals: 6 objects totaling 756 bytes (function ‘...future.FUN’ of 519 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.671] Packages: <none>
[10:49:46.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.671] Resolved: TRUE
[10:49:46.671] Value: <not collected>
[10:49:46.671] Conditions captured: <none>
[10:49:46.671] Early signaling: FALSE
[10:49:46.671] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.671] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.679] Chunk #1 of 1 ... DONE
[10:49:46.679] Launching 1 futures (chunks) ... DONE
[10:49:46.679] Resolving 1 futures (chunks) ...
[10:49:46.681]  - Number of value chunks collected: 1
[10:49:46.681] Resolving 1 futures (chunks) ... DONE
[10:49:46.681] Reducing values from 1 chunks ...
[10:49:46.681]  - Number of values collected after concatenation: 1
[10:49:46.681]  - Number of values expected: 1
[10:49:46.681] Reducing values from 1 chunks ... DONE
[10:49:46.681] future_lapply() ... DONE
- future_lapply(..., future.globals = <list>) ...
[10:49:46.682] future_lapply() ...
[10:49:46.682] Number of chunks: 1
[10:49:46.682] getGlobalsAndPackagesXApply() ...
[10:49:46.683]  - future.globals: <name-value list> with names ‘42’
[10:49:46.683]  - use_args: TRUE
[10:49:46.683]  - Getting '...' globals ...
[10:49:46.684]    - '...' content: [n=0] 
[10:49:46.684] List of 1
[10:49:46.684]  $ ...: list()
[10:49:46.684]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.684]  - attr(*, "where")=List of 1
[10:49:46.684]   ..$ ...:<environment: 0x55d1ce8b2618> 
[10:49:46.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.684]  - attr(*, "resolved")= logi TRUE
[10:49:46.684]  - attr(*, "total_size")= num NA
[10:49:46.687]  - Getting '...' globals ... DONE
[10:49:46.687] Globals to be used in all futures (chunks): [n=3] ‘a’, ‘...future.FUN’, ‘...’
[10:49:46.687] List of 3
[10:49:46.687]  $ a            : num 42
[10:49:46.687]  $ ...future.FUN:function (x)  
[10:49:46.687]  $ ...          : list()
[10:49:46.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:46.687]  - attr(*, "where")=List of 3
[10:49:46.687]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:46.687]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:49:46.687]   ..$ ...          :<environment: 0x55d1ce8b2618> 
[10:49:46.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:46.687]  - attr(*, "resolved")= logi FALSE
[10:49:46.687]  - attr(*, "total_size")= num NA
[10:49:46.691] Packages to be attached in all futures: [n=0] 
[10:49:46.691] getGlobalsAndPackagesXApply() ... DONE
[10:49:46.692] Number of futures (= number of chunks): 1
[10:49:46.692] Launching 1 futures (chunks) ...
[10:49:46.692] Chunk #1 of 1 ...
[10:49:46.692]  - seeds: <none>
[10:49:46.692]  - All globals exported: [n=6] ‘a’, ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:46.695] Created future:
[10:49:46.696] MulticoreFuture:
[10:49:46.696] Label: ‘future_lapply-1’
[10:49:46.696] Expression:
[10:49:46.696] {
[10:49:46.696]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:46.696]     "# expression in do.call(), because function called uses '...'  "
[10:49:46.696]     "# as a global variable                                         "
[10:49:46.696]     do.call(function(...) {
[10:49:46.696]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:46.696]         "# without having an '...' argument. This means '...' is treated"
[10:49:46.696]         "# as a global variable. This may happen when FUN() is an       "
[10:49:46.696]         "# anonymous function.                                          "
[10:49:46.696]         "#                                                              "
[10:49:46.696]         "# If an anonymous function, we will make sure to restore the   "
[10:49:46.696]         "# function environment of FUN() to the calling environment.    "
[10:49:46.696]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:46.696]         "# global environment, which is where globals are written.      "
[10:49:46.696]         penv <- env <- environment(...future.FUN)
[10:49:46.696]         repeat {
[10:49:46.696]             if (identical(env, globalenv()) || identical(env, 
[10:49:46.696]                 emptyenv())) 
[10:49:46.696]                 break
[10:49:46.696]             penv <- env
[10:49:46.696]             env <- parent.env(env)
[10:49:46.696]         }
[10:49:46.696]         if (identical(penv, globalenv())) {
[10:49:46.696]             environment(...future.FUN) <- environment()
[10:49:46.696]         }
[10:49:46.696]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:46.696]             !isNamespace(penv)) {
[10:49:46.696]             parent.env(penv) <- environment()
[10:49:46.696]         }
[10:49:46.696]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:46.696]         {
[10:49:46.696]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:46.696]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:46.696]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:46.696]                 on.exit(options(oopts), add = TRUE)
[10:49:46.696]             }
[10:49:46.696]             {
[10:49:46.696]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:46.696]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:46.696]                   ...future.FUN(...future.X_jj, ...)
[10:49:46.696]                 })
[10:49:46.696]             }
[10:49:46.696]         }
[10:49:46.696]     }, args = future.call.arguments)
[10:49:46.696] }
[10:49:46.696] Lazy evaluation: FALSE
[10:49:46.696] Asynchronous evaluation: TRUE
[10:49:46.696] Local evaluation: TRUE
[10:49:46.696] Environment: R_GlobalEnv
[10:49:46.696] Capture standard output: TRUE
[10:49:46.696] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:46.696] Immediate condition classes: ‘immediateCondition’
[10:49:46.696] Globals: 6 objects totaling 535 bytes (numeric ‘a’ of 39 bytes, function ‘...future.FUN’ of 298 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:46.696] Packages: <none>
[10:49:46.696] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:46.696] Resolved: TRUE
[10:49:46.696] Value: <not collected>
[10:49:46.696] Conditions captured: <none>
[10:49:46.696] Early signaling: FALSE
[10:49:46.696] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:46.696] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:46.703] Chunk #1 of 1 ... DONE
[10:49:46.703] Launching 1 futures (chunks) ... DONE
[10:49:46.703] Resolving 1 futures (chunks) ...
[10:49:46.705]  - Number of value chunks collected: 1
[10:49:46.705] Resolving 1 futures (chunks) ... DONE
[10:49:46.705] Reducing values from 1 chunks ...
[10:49:46.705]  - Number of values collected after concatenation: 1
[10:49:46.705]  - Number of values expected: 1
[10:49:46.705] Reducing values from 1 chunks ... DONE
[10:49:46.706] future_lapply() ... DONE
List of 1
 $ : num 42
[10:49:46.991] future_lapply() ...
[10:49:46.993] Number of chunks: 2
[10:49:46.993] getGlobalsAndPackagesXApply() ...
[10:49:46.993]  - future.globals: TRUE
[10:49:46.999]  - globals found/used: [n=5] ‘FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’
[10:49:46.999]  - needed namespaces: [n=0] 
[10:49:46.999] Finding globals ... DONE
[10:49:46.999]  - use_args: TRUE
[10:49:46.999]  - Getting '...' globals ...
[10:49:47.000]    - '...' content: [n=0] 
[10:49:47.000] List of 1
[10:49:47.000]  $ ...: list()
[10:49:47.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.000]  - attr(*, "where")=List of 1
[10:49:47.000]   ..$ ...:<environment: 0x55d1cd6aff68> 
[10:49:47.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.000]  - attr(*, "resolved")= logi TRUE
[10:49:47.000]  - attr(*, "total_size")= num NA
[10:49:47.003]  - Getting '...' globals ... DONE
[10:49:47.003] Globals to be used in all futures (chunks): [n=6] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’
[10:49:47.003] List of 6
[10:49:47.003]  $ ...future.FUN:function (i)  
[10:49:47.003]  $ caller       :function (a, b, FUN = call_my_add)  
[10:49:47.003]  $ args         :List of 1
[10:49:47.003]   ..$ FUN:function (a, b)  
[10:49:47.003]  $ call_my_add  :function (a, b)  
[10:49:47.003]  $ my_add       :function (a, b)  
[10:49:47.003]  $ ...          : list()
[10:49:47.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.003]  - attr(*, "where")=List of 6
[10:49:47.003]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.003]   ..$ caller       :<environment: R_EmptyEnv> 
[10:49:47.003]   ..$ args         :<environment: R_EmptyEnv> 
[10:49:47.003]   ..$ call_my_add  :<environment: R_EmptyEnv> 
[10:49:47.003]   ..$ my_add       :<environment: R_EmptyEnv> 
[10:49:47.003]   ..$ ...          :<environment: 0x55d1cd6aff68> 
[10:49:47.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.003]  - attr(*, "resolved")= logi FALSE
[10:49:47.003]  - attr(*, "total_size")= num 10892
[10:49:47.009] Packages to be attached in all futures: [n=0] 
[10:49:47.009] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.009] Number of futures (= number of chunks): 2
[10:49:47.009] Launching 2 futures (chunks) ...
[10:49:47.010] Chunk #1 of 2 ...
[10:49:47.010]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.010]    + additional globals found: [n=0] 
[10:49:47.010]    + additional namespaces needed: [n=0] 
[10:49:47.010]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.010]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:47.010]  - seeds: <none>
[10:49:47.011]  - All globals exported: [n=9] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.075] Created future:
[10:49:47.075] MultisessionFuture:
[10:49:47.075] Label: ‘future_lapply-1’
[10:49:47.075] Expression:
[10:49:47.075] {
[10:49:47.075]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.075]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.075]     "# as a global variable                                         "
[10:49:47.075]     do.call(function(...) {
[10:49:47.075]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:47.075]         "# without having an '...' argument. This means '...' is treated"
[10:49:47.075]         "# as a global variable. This may happen when FUN() is an       "
[10:49:47.075]         "# anonymous function.                                          "
[10:49:47.075]         "#                                                              "
[10:49:47.075]         "# If an anonymous function, we will make sure to restore the   "
[10:49:47.075]         "# function environment of FUN() to the calling environment.    "
[10:49:47.075]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:47.075]         "# global environment, which is where globals are written.      "
[10:49:47.075]         penv <- env <- environment(...future.FUN)
[10:49:47.075]         repeat {
[10:49:47.075]             if (identical(env, globalenv()) || identical(env, 
[10:49:47.075]                 emptyenv())) 
[10:49:47.075]                 break
[10:49:47.075]             penv <- env
[10:49:47.075]             env <- parent.env(env)
[10:49:47.075]         }
[10:49:47.075]         if (identical(penv, globalenv())) {
[10:49:47.075]             environment(...future.FUN) <- environment()
[10:49:47.075]         }
[10:49:47.075]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:47.075]             !isNamespace(penv)) {
[10:49:47.075]             parent.env(penv) <- environment()
[10:49:47.075]         }
[10:49:47.075]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:47.075]         {
[10:49:47.075]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.075]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.075]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.075]                 on.exit(options(oopts), add = TRUE)
[10:49:47.075]             }
[10:49:47.075]             {
[10:49:47.075]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.075]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.075]                   ...future.FUN(...future.X_jj, ...)
[10:49:47.075]                 })
[10:49:47.075]             }
[10:49:47.075]         }
[10:49:47.075]     }, args = future.call.arguments)
[10:49:47.075] }
[10:49:47.075] Lazy evaluation: FALSE
[10:49:47.075] Asynchronous evaluation: TRUE
[10:49:47.075] Local evaluation: TRUE
[10:49:47.075] Environment: 0x55d1cd6afb40
[10:49:47.075] Capture standard output: TRUE
[10:49:47.075] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.075] Immediate condition classes: ‘immediateCondition’
[10:49:47.075] Globals: 9 objects totaling 4.98 KiB (function ‘...future.FUN’ of 2.67 KiB, function ‘caller’ of 247 bytes, list ‘args’ of 928 bytes, function ‘call_my_add’ of 876 bytes, function ‘my_add’ of 114 bytes, ...)
[10:49:47.075] Packages: <none>
[10:49:47.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.075] Resolved: FALSE
[10:49:47.075] Value: <not collected>
[10:49:47.075] Conditions captured: <none>
[10:49:47.075] Early signaling: FALSE
[10:49:47.075] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.075] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.087] Chunk #1 of 2 ... DONE
[10:49:47.088] Chunk #2 of 2 ...
[10:49:47.088]  - Finding globals in 'X' for chunk #2 ...
[10:49:47.088]    + additional globals found: [n=0] 
[10:49:47.088]    + additional namespaces needed: [n=0] 
[10:49:47.088]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:47.089]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:47.089]  - seeds: <none>
[10:49:47.089]  - All globals exported: [n=9] ‘...future.FUN’, ‘caller’, ‘args’, ‘call_my_add’, ‘my_add’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.163] Created future:
[10:49:47.163] MultisessionFuture:
[10:49:47.163] Label: ‘future_lapply-2’
[10:49:47.163] Expression:
[10:49:47.163] {
[10:49:47.163]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.163]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.163]     "# as a global variable                                         "
[10:49:47.163]     do.call(function(...) {
[10:49:47.163]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:47.163]         "# without having an '...' argument. This means '...' is treated"
[10:49:47.163]         "# as a global variable. This may happen when FUN() is an       "
[10:49:47.163]         "# anonymous function.                                          "
[10:49:47.163]         "#                                                              "
[10:49:47.163]         "# If an anonymous function, we will make sure to restore the   "
[10:49:47.163]         "# function environment of FUN() to the calling environment.    "
[10:49:47.163]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:47.163]         "# global environment, which is where globals are written.      "
[10:49:47.163]         penv <- env <- environment(...future.FUN)
[10:49:47.163]         repeat {
[10:49:47.163]             if (identical(env, globalenv()) || identical(env, 
[10:49:47.163]                 emptyenv())) 
[10:49:47.163]                 break
[10:49:47.163]             penv <- env
[10:49:47.163]             env <- parent.env(env)
[10:49:47.163]         }
[10:49:47.163]         if (identical(penv, globalenv())) {
[10:49:47.163]             environment(...future.FUN) <- environment()
[10:49:47.163]         }
[10:49:47.163]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:47.163]             !isNamespace(penv)) {
[10:49:47.163]             parent.env(penv) <- environment()
[10:49:47.163]         }
[10:49:47.163]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:47.163]         {
[10:49:47.163]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.163]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.163]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.163]                 on.exit(options(oopts), add = TRUE)
[10:49:47.163]             }
[10:49:47.163]             {
[10:49:47.163]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.163]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.163]                   ...future.FUN(...future.X_jj, ...)
[10:49:47.163]                 })
[10:49:47.163]             }
[10:49:47.163]         }
[10:49:47.163]     }, args = future.call.arguments)
[10:49:47.163] }
[10:49:47.163] Lazy evaluation: FALSE
[10:49:47.163] Asynchronous evaluation: TRUE
[10:49:47.163] Local evaluation: TRUE
[10:49:47.163] Environment: 0x55d1cd6afb40
[10:49:47.163] Capture standard output: TRUE
[10:49:47.163] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.163] Immediate condition classes: ‘immediateCondition’
[10:49:47.163] Globals: 9 objects totaling 4.99 KiB (function ‘...future.FUN’ of 2.67 KiB, function ‘caller’ of 247 bytes, list ‘args’ of 928 bytes, function ‘call_my_add’ of 876 bytes, function ‘my_add’ of 114 bytes, ...)
[10:49:47.163] Packages: <none>
[10:49:47.163] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.163] Resolved: FALSE
[10:49:47.163] Value: <not collected>
[10:49:47.163] Conditions captured: <none>
[10:49:47.163] Early signaling: FALSE
[10:49:47.163] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.163] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.176] Chunk #2 of 2 ... DONE
[10:49:47.176] Launching 2 futures (chunks) ... DONE
[10:49:47.176] Resolving 2 futures (chunks) ...
[10:49:47.265]  - Number of value chunks collected: 2
[10:49:47.265] Resolving 2 futures (chunks) ... DONE
[10:49:47.265] Reducing values from 2 chunks ...
[10:49:47.265]  - Number of values collected after concatenation: 3
[10:49:47.265]  - Number of values expected: 3
[10:49:47.265] Reducing values from 2 chunks ... DONE
[10:49:47.265] future_lapply() ... DONE
- future_lapply(x, FUN = do.call, ...) ...
[10:49:47.265] future_lapply() ...
[10:49:47.267] Number of chunks: 1
[10:49:47.267] getGlobalsAndPackagesXApply() ...
[10:49:47.268]  - future.globals: TRUE
[10:49:47.271]  - globals found/used: [n=1] ‘FUN’
[10:49:47.271]  - needed namespaces: [n=0] 
[10:49:47.271] Finding globals ... DONE
[10:49:47.273]  - use_args: TRUE
[10:49:47.273]  - Getting '...' globals ...
[10:49:47.274]    - '...' content: [n=1] ‘what’
[10:49:47.274] List of 1
[10:49:47.274]  $ ...:List of 1
[10:49:47.274]   ..$ what:function (x)  
[10:49:47.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.274]  - attr(*, "where")=List of 1
[10:49:47.274]   ..$ ...:<environment: 0x55d1ce64f100> 
[10:49:47.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.274]  - attr(*, "resolved")= logi TRUE
[10:49:47.274]  - attr(*, "total_size")= num NA
[10:49:47.277]  - Getting '...' globals ... DONE
[10:49:47.277] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:47.278] List of 2
[10:49:47.278]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:47.278]  $ ...          :List of 1
[10:49:47.278]   ..$ what:function (x)  
[10:49:47.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.278]  - attr(*, "where")=List of 2
[10:49:47.278]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.278]   ..$ ...          :<environment: 0x55d1ce64f100> 
[10:49:47.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.278]  - attr(*, "resolved")= logi FALSE
[10:49:47.278]  - attr(*, "total_size")= num 6909
[10:49:47.281] Packages to be attached in all futures: [n=0] 
[10:49:47.281] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.281] Number of futures (= number of chunks): 1
[10:49:47.281] Launching 1 futures (chunks) ...
[10:49:47.281] Chunk #1 of 1 ...
[10:49:47.281]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.282]    + additional globals found: [n=0] 
[10:49:47.282]    + additional namespaces needed: [n=0] 
[10:49:47.282]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.282]  - seeds: <none>
[10:49:47.282]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.323] Created future:
[10:49:47.323] MultisessionFuture:
[10:49:47.323] Label: ‘future_lapply-1’
[10:49:47.323] Expression:
[10:49:47.323] {
[10:49:47.323]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.323]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.323]     "# as a global variable                                         "
[10:49:47.323]     do.call(function(...) {
[10:49:47.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.323]             on.exit(options(oopts), add = TRUE)
[10:49:47.323]         }
[10:49:47.323]         {
[10:49:47.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.323]                 ...future.FUN(...future.X_jj, ...)
[10:49:47.323]             })
[10:49:47.323]         }
[10:49:47.323]     }, args = future.call.arguments)
[10:49:47.323] }
[10:49:47.323] Lazy evaluation: FALSE
[10:49:47.323] Asynchronous evaluation: TRUE
[10:49:47.323] Local evaluation: TRUE
[10:49:47.323] Environment: R_GlobalEnv
[10:49:47.323] Capture standard output: TRUE
[10:49:47.323] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.323] Immediate condition classes: ‘immediateCondition’
[10:49:47.323] Globals: 5 objects totaling 2.13 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 152 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:47.323] Packages: <none>
[10:49:47.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.323] Resolved: FALSE
[10:49:47.323] Value: <not collected>
[10:49:47.323] Conditions captured: <none>
[10:49:47.323] Early signaling: FALSE
[10:49:47.323] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.323] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.334] Chunk #1 of 1 ... DONE
[10:49:47.334] Launching 1 futures (chunks) ... DONE
[10:49:47.334] Resolving 1 futures (chunks) ...
[10:49:47.377]  - Number of value chunks collected: 1
[10:49:47.377] Resolving 1 futures (chunks) ... DONE
[10:49:47.377] Reducing values from 1 chunks ...
[10:49:47.377]  - Number of values collected after concatenation: 1
[10:49:47.377]  - Number of values expected: 1
[10:49:47.377] Reducing values from 1 chunks ... DONE
[10:49:47.377] future_lapply() ... DONE
[10:49:47.378] future_lapply() ...
[10:49:47.379] Number of chunks: 1
[10:49:47.379] getGlobalsAndPackagesXApply() ...
[10:49:47.379]  - future.globals: TRUE
[10:49:47.382]  - globals found/used: [n=1] ‘FUN’
[10:49:47.383]  - needed namespaces: [n=0] 
[10:49:47.383] Finding globals ... DONE
[10:49:47.383]  - use_args: TRUE
[10:49:47.383]  - Getting '...' globals ...
[10:49:47.383]    - '...' content: [n=1] ‘what’
[10:49:47.383] List of 1
[10:49:47.383]  $ ...:List of 1
[10:49:47.383]   ..$ what:function (...)  
[10:49:47.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.383]  - attr(*, "where")=List of 1
[10:49:47.383]   ..$ ...:<environment: 0x55d1cb9d1e08> 
[10:49:47.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.383]  - attr(*, "resolved")= logi TRUE
[10:49:47.383]  - attr(*, "total_size")= num NA
[10:49:47.386]  - Getting '...' globals ... DONE
[10:49:47.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:47.387] List of 2
[10:49:47.387]  $ ...future.FUN:function (what, args, quote = FALSE, envir = parent.frame())  
[10:49:47.387]  $ ...          :List of 1
[10:49:47.387]   ..$ what:function (...)  
[10:49:47.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.387]  - attr(*, "where")=List of 2
[10:49:47.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.387]   ..$ ...          :<environment: 0x55d1cb9d1e08> 
[10:49:47.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.387]  - attr(*, "resolved")= logi FALSE
[10:49:47.387]  - attr(*, "total_size")= num 7345
[10:49:47.390] Packages to be attached in all futures: [n=0] 
[10:49:47.390] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.390] Number of futures (= number of chunks): 1
[10:49:47.390] Launching 1 futures (chunks) ...
[10:49:47.390] Chunk #1 of 1 ...
[10:49:47.390]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.391]    + additional globals found: [n=0] 
[10:49:47.391]    + additional namespaces needed: [n=0] 
[10:49:47.391]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.391]  - seeds: <none>
[10:49:47.391]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.471] Created future:
[10:49:47.471] MultisessionFuture:
[10:49:47.471] Label: ‘future_lapply-1’
[10:49:47.471] Expression:
[10:49:47.471] {
[10:49:47.471]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.471]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.471]     "# as a global variable                                         "
[10:49:47.471]     do.call(function(...) {
[10:49:47.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.471]             on.exit(options(oopts), add = TRUE)
[10:49:47.471]         }
[10:49:47.471]         {
[10:49:47.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.471]                 ...future.FUN(...future.X_jj, ...)
[10:49:47.471]             })
[10:49:47.471]         }
[10:49:47.471]     }, args = future.call.arguments)
[10:49:47.471] }
[10:49:47.471] Lazy evaluation: FALSE
[10:49:47.471] Asynchronous evaluation: TRUE
[10:49:47.471] Local evaluation: TRUE
[10:49:47.471] Environment: R_GlobalEnv
[10:49:47.471] Capture standard output: TRUE
[10:49:47.471] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.471] Immediate condition classes: ‘immediateCondition’
[10:49:47.471] Globals: 5 objects totaling 2.36 KiB (function ‘...future.FUN’ of 1.79 KiB, DotDotDotList ‘future.call.arguments’ of 388 bytes, list ‘...future.elements_ii’ of 149 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:47.471] Packages: <none>
[10:49:47.471] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.471] Resolved: FALSE
[10:49:47.471] Value: <not collected>
[10:49:47.471] Conditions captured: <none>
[10:49:47.471] Early signaling: FALSE
[10:49:47.471] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.471] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.483] Chunk #1 of 1 ... DONE
[10:49:47.483] Launching 1 futures (chunks) ... DONE
[10:49:47.483] Resolving 1 futures (chunks) ...
[10:49:47.526]  - Number of value chunks collected: 1
[10:49:47.526] Resolving 1 futures (chunks) ... DONE
[10:49:47.526] Reducing values from 1 chunks ...
[10:49:47.526]  - Number of values collected after concatenation: 1
[10:49:47.526]  - Number of values expected: 1
[10:49:47.526] Reducing values from 1 chunks ... DONE
[10:49:47.526] future_lapply() ... DONE
- future_lapply(x, ...) - passing arguments via '...' ...
[10:49:47.527] future_lapply() ...
[10:49:47.527] Number of chunks: 1
[10:49:47.528] getGlobalsAndPackagesXApply() ...
[10:49:47.528]  - future.globals: TRUE
[10:49:47.529]  - globals found/used: [n=1] ‘FUN’
[10:49:47.530]  - needed namespaces: [n=0] 
[10:49:47.530] Finding globals ... DONE
[10:49:47.530]  - use_args: TRUE
[10:49:47.530]  - Getting '...' globals ...
[10:49:47.530]    - '...' content: [n=1] ‘b’
[10:49:47.530] List of 1
[10:49:47.530]  $ ...:List of 1
[10:49:47.530]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:47.530]   .. ..$ a: int [1:2] 1 2
[10:49:47.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.530]  - attr(*, "where")=List of 1
[10:49:47.530]   ..$ ...:<environment: 0x55d1cf2988b0> 
[10:49:47.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.530]  - attr(*, "resolved")= logi TRUE
[10:49:47.530]  - attr(*, "total_size")= num NA
[10:49:47.536]  - Getting '...' globals ... DONE
[10:49:47.536] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:47.536] List of 2
[10:49:47.536]  $ ...future.FUN:function (a, b)  
[10:49:47.536]  $ ...          :List of 1
[10:49:47.536]   ..$ b:'data.frame':	2 obs. of  1 variable:
[10:49:47.536]   .. ..$ a: int [1:2] 1 2
[10:49:47.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.536]  - attr(*, "where")=List of 2
[10:49:47.536]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.536]   ..$ ...          :<environment: 0x55d1cf2988b0> 
[10:49:47.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.536]  - attr(*, "resolved")= logi FALSE
[10:49:47.536]  - attr(*, "total_size")= num 4163
[10:49:47.540] Packages to be attached in all futures: [n=0] 
[10:49:47.540] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.540] Number of futures (= number of chunks): 1
[10:49:47.540] Launching 1 futures (chunks) ...
[10:49:47.541] Chunk #1 of 1 ...
[10:49:47.541]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.541]    + additional globals found: [n=0] 
[10:49:47.541]    + additional namespaces needed: [n=0] 
[10:49:47.541]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.541]  - seeds: <none>
[10:49:47.541]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.622] Created future:
[10:49:47.622] MultisessionFuture:
[10:49:47.622] Label: ‘future_lapply-1’
[10:49:47.622] Expression:
[10:49:47.622] {
[10:49:47.622]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.622]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.622]     "# as a global variable                                         "
[10:49:47.622]     do.call(function(...) {
[10:49:47.622]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:47.622]         "# without having an '...' argument. This means '...' is treated"
[10:49:47.622]         "# as a global variable. This may happen when FUN() is an       "
[10:49:47.622]         "# anonymous function.                                          "
[10:49:47.622]         "#                                                              "
[10:49:47.622]         "# If an anonymous function, we will make sure to restore the   "
[10:49:47.622]         "# function environment of FUN() to the calling environment.    "
[10:49:47.622]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:47.622]         "# global environment, which is where globals are written.      "
[10:49:47.622]         penv <- env <- environment(...future.FUN)
[10:49:47.622]         repeat {
[10:49:47.622]             if (identical(env, globalenv()) || identical(env, 
[10:49:47.622]                 emptyenv())) 
[10:49:47.622]                 break
[10:49:47.622]             penv <- env
[10:49:47.622]             env <- parent.env(env)
[10:49:47.622]         }
[10:49:47.622]         if (identical(penv, globalenv())) {
[10:49:47.622]             environment(...future.FUN) <- environment()
[10:49:47.622]         }
[10:49:47.622]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:47.622]             !isNamespace(penv)) {
[10:49:47.622]             parent.env(penv) <- environment()
[10:49:47.622]         }
[10:49:47.622]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:47.622]         {
[10:49:47.622]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.622]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.622]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.622]                 on.exit(options(oopts), add = TRUE)
[10:49:47.622]             }
[10:49:47.622]             {
[10:49:47.622]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.622]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.622]                   ...future.FUN(...future.X_jj, ...)
[10:49:47.622]                 })
[10:49:47.622]             }
[10:49:47.622]         }
[10:49:47.622]     }, args = future.call.arguments)
[10:49:47.622] }
[10:49:47.622] Lazy evaluation: FALSE
[10:49:47.622] Asynchronous evaluation: TRUE
[10:49:47.622] Local evaluation: TRUE
[10:49:47.622] Environment: R_GlobalEnv
[10:49:47.622] Capture standard output: TRUE
[10:49:47.622] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.622] Immediate condition classes: ‘immediateCondition’
[10:49:47.622] Globals: 5 objects totaling 786 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 357 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:47.622] Packages: <none>
[10:49:47.622] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.622] Resolved: FALSE
[10:49:47.622] Value: <not collected>
[10:49:47.622] Conditions captured: <none>
[10:49:47.622] Early signaling: FALSE
[10:49:47.622] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.622] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.634] Chunk #1 of 1 ... DONE
[10:49:47.635] Launching 1 futures (chunks) ... DONE
[10:49:47.635] Resolving 1 futures (chunks) ...
[10:49:47.677]  - Number of value chunks collected: 1
[10:49:47.677] Resolving 1 futures (chunks) ... DONE
[10:49:47.677] Reducing values from 1 chunks ...
[10:49:47.678]  - Number of values collected after concatenation: 1
[10:49:47.678]  - Number of values expected: 1
[10:49:47.678] Reducing values from 1 chunks ... DONE
[10:49:47.678] future_lapply() ... DONE
[10:49:47.678] future_lapply() ...
[10:49:47.679] Number of chunks: 1
[10:49:47.679] getGlobalsAndPackagesXApply() ...
[10:49:47.679]  - future.globals: TRUE
[10:49:47.681]  - globals found/used: [n=1] ‘FUN’
[10:49:47.681]  - needed namespaces: [n=0] 
[10:49:47.681] Finding globals ... DONE
[10:49:47.681]  - use_args: TRUE
[10:49:47.681]  - Getting '...' globals ...
[10:49:47.681]    - '...' content: [n=1] ‘b’
[10:49:47.682] List of 1
[10:49:47.682]  $ ...:List of 1
[10:49:47.682]   ..$ b:<environment: 0x55d1ccafb700> 
[10:49:47.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.682]  - attr(*, "where")=List of 1
[10:49:47.682]   ..$ ...:<environment: 0x55d1ccaf6698> 
[10:49:47.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.682]  - attr(*, "resolved")= logi TRUE
[10:49:47.682]  - attr(*, "total_size")= num NA
[10:49:47.684]  - Getting '...' globals ... DONE
[10:49:47.685] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:47.685] List of 2
[10:49:47.685]  $ ...future.FUN:function (a, b)  
[10:49:47.685]  $ ...          :List of 1
[10:49:47.685]   ..$ b:<environment: 0x55d1ccafb700> 
[10:49:47.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.685]  - attr(*, "where")=List of 2
[10:49:47.685]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.685]   ..$ ...          :<environment: 0x55d1ccaf6698> 
[10:49:47.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.685]  - attr(*, "resolved")= logi FALSE
[10:49:47.685]  - attr(*, "total_size")= num 3918
[10:49:47.688] Packages to be attached in all futures: [n=0] 
[10:49:47.688] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.688] Number of futures (= number of chunks): 1
[10:49:47.688] Launching 1 futures (chunks) ...
[10:49:47.688] Chunk #1 of 1 ...
[10:49:47.688]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.689]    + additional globals found: [n=0] 
[10:49:47.689]    + additional namespaces needed: [n=0] 
[10:49:47.689]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.689]  - seeds: <none>
[10:49:47.689]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:47.769] Created future:
[10:49:47.769] MultisessionFuture:
[10:49:47.769] Label: ‘future_lapply-1’
[10:49:47.769] Expression:
[10:49:47.769] {
[10:49:47.769]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:47.769]     "# expression in do.call(), because function called uses '...'  "
[10:49:47.769]     "# as a global variable                                         "
[10:49:47.769]     do.call(function(...) {
[10:49:47.769]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:47.769]         "# without having an '...' argument. This means '...' is treated"
[10:49:47.769]         "# as a global variable. This may happen when FUN() is an       "
[10:49:47.769]         "# anonymous function.                                          "
[10:49:47.769]         "#                                                              "
[10:49:47.769]         "# If an anonymous function, we will make sure to restore the   "
[10:49:47.769]         "# function environment of FUN() to the calling environment.    "
[10:49:47.769]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:47.769]         "# global environment, which is where globals are written.      "
[10:49:47.769]         penv <- env <- environment(...future.FUN)
[10:49:47.769]         repeat {
[10:49:47.769]             if (identical(env, globalenv()) || identical(env, 
[10:49:47.769]                 emptyenv())) 
[10:49:47.769]                 break
[10:49:47.769]             penv <- env
[10:49:47.769]             env <- parent.env(env)
[10:49:47.769]         }
[10:49:47.769]         if (identical(penv, globalenv())) {
[10:49:47.769]             environment(...future.FUN) <- environment()
[10:49:47.769]         }
[10:49:47.769]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:47.769]             !isNamespace(penv)) {
[10:49:47.769]             parent.env(penv) <- environment()
[10:49:47.769]         }
[10:49:47.769]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:47.769]         {
[10:49:47.769]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:47.769]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:47.769]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:47.769]                 on.exit(options(oopts), add = TRUE)
[10:49:47.769]             }
[10:49:47.769]             {
[10:49:47.769]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:47.769]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:47.769]                   ...future.FUN(...future.X_jj, ...)
[10:49:47.769]                 })
[10:49:47.769]             }
[10:49:47.769]         }
[10:49:47.769]     }, args = future.call.arguments)
[10:49:47.769] }
[10:49:47.769] Lazy evaluation: FALSE
[10:49:47.769] Asynchronous evaluation: TRUE
[10:49:47.769] Local evaluation: TRUE
[10:49:47.769] Environment: R_GlobalEnv
[10:49:47.769] Capture standard output: TRUE
[10:49:47.769] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:47.769] Immediate condition classes: ‘immediateCondition’
[10:49:47.769] Globals: 5 objects totaling 708 bytes (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 279 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:47.769] Packages: <none>
[10:49:47.769] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:47.769] Resolved: FALSE
[10:49:47.769] Value: <not collected>
[10:49:47.769] Conditions captured: <none>
[10:49:47.769] Early signaling: FALSE
[10:49:47.769] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:47.769] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:47.781] Chunk #1 of 1 ... DONE
[10:49:47.781] Launching 1 futures (chunks) ... DONE
[10:49:47.781] Resolving 1 futures (chunks) ...
[10:49:47.824]  - Number of value chunks collected: 1
[10:49:47.824] Resolving 1 futures (chunks) ... DONE
[10:49:47.824] Reducing values from 1 chunks ...
[10:49:47.824]  - Number of values collected after concatenation: 1
[10:49:47.824]  - Number of values expected: 1
[10:49:47.824] Reducing values from 1 chunks ... DONE
[10:49:47.824] future_lapply() ... DONE
[10:49:47.824] future_lapply() ...
[10:49:47.825] Number of chunks: 1
[10:49:47.825] getGlobalsAndPackagesXApply() ...
[10:49:47.825]  - future.globals: TRUE
[10:49:47.827]  - globals found/used: [n=1] ‘FUN’
[10:49:47.828]  - needed namespaces: [n=0] 
[10:49:47.828] Finding globals ... DONE
[10:49:47.828]  - use_args: TRUE
[10:49:47.828]  - Getting '...' globals ...
[10:49:47.828]    - '...' content: [n=1] ‘b’
[10:49:47.828] List of 1
[10:49:47.828]  $ ...:List of 1
[10:49:47.828]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:47.828]   .. .. ..@ slots     :List of 4
[10:49:47.828]   .. .. .. ..$ .Data  : chr "function"
[10:49:47.828]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. ..$ target : chr "signature"
[10:49:47.828]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. ..$ defined: chr "signature"
[10:49:47.828]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. ..$ generic: chr "character"
[10:49:47.828]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. ..@ contains  :List of 4
[10:49:47.828]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.828]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.828]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.828]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 3
[10:49:47.828]   .. .. ..@ virtual   : logi FALSE
[10:49:47.828]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:47.828]  list()
[10:49:47.828]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:47.828]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:47.828]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:47.828]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:47.828]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:47.828]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:47.828]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:47.828]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:47.828]   .. .. .. .. ..$ generic: chr(0) 
[10:49:47.828]   .. .. ..@ validity  : NULL
[10:49:47.828]   .. .. ..@ access    : list()
[10:49:47.828]   .. .. ..@ className : chr "MethodDefinition"
[10:49:47.828]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. ..@ subclasses:List of 7
[10:49:47.828]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.828]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.828]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.828]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.828]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.828]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.828]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.828]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.828]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.828]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.828]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.828]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:47.828]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.828]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.828]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.828]   .. .. ..@ versionKey:<externalptr> 
[10:49:47.828]   .. .. ..@ sealed    : logi TRUE
[10:49:47.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.828]  - attr(*, "where")=List of 1
[10:49:47.828]   ..$ ...:<environment: 0x55d1ce49abf8> 
[10:49:47.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.828]  - attr(*, "resolved")= logi TRUE
[10:49:47.828]  - attr(*, "total_size")= num NA
[10:49:47.886]  - Getting '...' globals ... DONE
[10:49:47.886] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:47.886] List of 2
[10:49:47.886]  $ ...future.FUN:function (a, b)  
[10:49:47.886]  $ ...          :List of 1
[10:49:47.886]   ..$ b:Formal class 'classRepresentation' [package "methods"] with 11 slots
[10:49:47.886]   .. .. ..@ slots     :List of 4
[10:49:47.886]   .. .. .. ..$ .Data  : chr "function"
[10:49:47.886]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. ..$ target : chr "signature"
[10:49:47.886]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. ..$ defined: chr "signature"
[10:49:47.886]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. ..$ generic: chr "character"
[10:49:47.886]   .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. ..@ contains  :List of 4
[10:49:47.886]   .. .. .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "function"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.886]   .. .. .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "OptionalFunction"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.886]   .. .. .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "PossibleMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.886]   .. .. .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "optionalMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "function"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 3
[10:49:47.886]   .. .. ..@ virtual   : logi FALSE
[10:49:47.886]   .. .. ..@ prototype :Formal class 'function' [package ""] with 0 slots
[10:49:47.886]  list()
[10:49:47.886]   .. .. .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
[10:49:47.886]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:47.886]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:47.886]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:47.886]   .. .. .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
[10:49:47.886]   .. .. .. .. .. .. ..@ .Data  : chr(0) 
[10:49:47.886]   .. .. .. .. .. .. ..@ names  : chr(0) 
[10:49:47.886]   .. .. .. .. .. .. ..@ package: chr(0) 
[10:49:47.886]   .. .. .. .. ..$ generic: chr(0) 
[10:49:47.886]   .. .. ..@ validity  : NULL
[10:49:47.886]   .. .. ..@ access    : list()
[10:49:47.886]   .. .. ..@ className : chr "MethodDefinition"
[10:49:47.886]   .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. ..@ subclasses:List of 7
[10:49:47.886]   .. .. .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.886]   .. .. .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNext"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.886]   .. .. .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.886]   .. .. .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr(0) 
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 1
[10:49:47.886]   .. .. .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "internalDispatchMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.886]   .. .. .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "MethodWithNext"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.886]   .. .. .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
[10:49:47.886]   .. .. .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ superClass: chr "MethodDefinition"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ package   : chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ coerce    :function (from, strict = TRUE)  
[10:49:47.886]   .. .. .. .. .. ..@ test      :function (object)  
[10:49:47.886]   .. .. .. .. .. ..@ replace   :function (from, to, value)  
[10:49:47.886]   .. .. .. .. .. ..@ simple    : logi TRUE
[10:49:47.886]   .. .. .. .. .. ..@ by        : chr "derivedDefaultMethod"
[10:49:47.886]   .. .. .. .. .. .. ..- attr(*, "package")= chr "methods"
[10:49:47.886]   .. .. .. .. .. ..@ dataPart  : logi FALSE
[10:49:47.886]   .. .. .. .. .. ..@ distance  : num 2
[10:49:47.886]   .. .. ..@ versionKey:<externalptr> 
[10:49:47.886]   .. .. ..@ sealed    : logi TRUE
[10:49:47.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:47.886]  - attr(*, "where")=List of 2
[10:49:47.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:47.886]   ..$ ...          :<environment: 0x55d1ce49abf8> 
[10:49:47.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:47.886]  - attr(*, "resolved")= logi FALSE
[10:49:47.886]  - attr(*, "total_size")= num 105785
[10:49:47.942] Packages to be attached in all futures: [n=0] 
[10:49:47.942] getGlobalsAndPackagesXApply() ... DONE
[10:49:47.942] Number of futures (= number of chunks): 1
[10:49:47.942] Launching 1 futures (chunks) ...
[10:49:47.942] Chunk #1 of 1 ...
[10:49:47.943]  - Finding globals in 'X' for chunk #1 ...
[10:49:47.943]    + additional globals found: [n=0] 
[10:49:47.943]    + additional namespaces needed: [n=0] 
[10:49:47.943]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:47.943]  - seeds: <none>
[10:49:47.943]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.024] Created future:
[10:49:48.024] MultisessionFuture:
[10:49:48.024] Label: ‘future_lapply-1’
[10:49:48.024] Expression:
[10:49:48.024] {
[10:49:48.024]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.024]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.024]     "# as a global variable                                         "
[10:49:48.024]     do.call(function(...) {
[10:49:48.024]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.024]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.024]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.024]         "# anonymous function.                                          "
[10:49:48.024]         "#                                                              "
[10:49:48.024]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.024]         "# function environment of FUN() to the calling environment.    "
[10:49:48.024]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.024]         "# global environment, which is where globals are written.      "
[10:49:48.024]         penv <- env <- environment(...future.FUN)
[10:49:48.024]         repeat {
[10:49:48.024]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.024]                 emptyenv())) 
[10:49:48.024]                 break
[10:49:48.024]             penv <- env
[10:49:48.024]             env <- parent.env(env)
[10:49:48.024]         }
[10:49:48.024]         if (identical(penv, globalenv())) {
[10:49:48.024]             environment(...future.FUN) <- environment()
[10:49:48.024]         }
[10:49:48.024]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.024]             !isNamespace(penv)) {
[10:49:48.024]             parent.env(penv) <- environment()
[10:49:48.024]         }
[10:49:48.024]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.024]         {
[10:49:48.024]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.024]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.024]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.024]                 on.exit(options(oopts), add = TRUE)
[10:49:48.024]             }
[10:49:48.024]             {
[10:49:48.024]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.024]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.024]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.024]                 })
[10:49:48.024]             }
[10:49:48.024]         }
[10:49:48.024]     }, args = future.call.arguments)
[10:49:48.024] }
[10:49:48.024] Lazy evaluation: FALSE
[10:49:48.024] Asynchronous evaluation: TRUE
[10:49:48.024] Local evaluation: TRUE
[10:49:48.024] Environment: R_GlobalEnv
[10:49:48.024] Capture standard output: TRUE
[10:49:48.024] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.024] Immediate condition classes: ‘immediateCondition’
[10:49:48.024] Globals: 5 objects totaling 50.72 KiB (function ‘...future.FUN’ of 332 bytes, DotDotDotList ‘future.call.arguments’ of 50.30 KiB, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:48.024] Packages: <none>
[10:49:48.024] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.024] Resolved: TRUE
[10:49:48.024] Value: <not collected>
[10:49:48.024] Conditions captured: <none>
[10:49:48.024] Early signaling: FALSE
[10:49:48.024] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.024] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.028] Chunk #1 of 1 ... DONE
[10:49:48.028] Launching 1 futures (chunks) ... DONE
[10:49:48.028] Resolving 1 futures (chunks) ...
[10:49:48.028]  - Number of value chunks collected: 1
[10:49:48.028] Resolving 1 futures (chunks) ... DONE
[10:49:48.029] Reducing values from 1 chunks ...
[10:49:48.029]  - Number of values collected after concatenation: 1
[10:49:48.029]  - Number of values expected: 1
[10:49:48.029] Reducing values from 1 chunks ... DONE
[10:49:48.029] future_lapply() ... DONE
- future_lapply(X, ...) - 'X' containing globals ...
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
[10:49:48.031] future_lapply() ...
[10:49:48.032] Number of chunks: 2
[10:49:48.032] getGlobalsAndPackagesXApply() ...
[10:49:48.032]  - future.globals: TRUE
[10:49:48.034]  - globals found/used: [n=1] ‘FUN’
[10:49:48.034]  - needed namespaces: [n=0] 
[10:49:48.034] Finding globals ... DONE
[10:49:48.034]  - use_args: TRUE
[10:49:48.034]  - Getting '...' globals ...
[10:49:48.034]    - '...' content: [n=0] 
[10:49:48.035] List of 1
[10:49:48.035]  $ ...: list()
[10:49:48.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.035]  - attr(*, "where")=List of 1
[10:49:48.035]   ..$ ...:<environment: 0x55d1ce15d2e8> 
[10:49:48.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.035]  - attr(*, "resolved")= logi TRUE
[10:49:48.035]  - attr(*, "total_size")= num NA
[10:49:48.037]  - Getting '...' globals ... DONE
[10:49:48.037] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:48.037] List of 2
[10:49:48.037]  $ ...future.FUN:function (f)  
[10:49:48.037]  $ ...          : list()
[10:49:48.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.037]  - attr(*, "where")=List of 2
[10:49:48.037]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:48.037]   ..$ ...          :<environment: 0x55d1ce15d2e8> 
[10:49:48.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.037]  - attr(*, "resolved")= logi FALSE
[10:49:48.037]  - attr(*, "total_size")= num 4837
[10:49:48.042] Packages to be attached in all futures: [n=0] 
[10:49:48.042] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.043] Number of futures (= number of chunks): 2
[10:49:48.043] Launching 2 futures (chunks) ...
[10:49:48.043] Chunk #1 of 2 ...
[10:49:48.043]  - Finding globals in 'X' for chunk #1 ...
[10:49:48.045]    + additional globals found: [n=2] ‘a’, ‘b’
[10:49:48.045]    + additional namespaces needed: [n=0] 
[10:49:48.045]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:48.045]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:48.045]  - seeds: <none>
[10:49:48.045]  - All globals exported: [n=7] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’, ‘a’, ‘b’
[10:49:48.125] Created future:
[10:49:48.125] MultisessionFuture:
[10:49:48.125] Label: ‘future_lapply-1’
[10:49:48.125] Expression:
[10:49:48.125] {
[10:49:48.125]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.125]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.125]     "# as a global variable                                         "
[10:49:48.125]     do.call(function(...) {
[10:49:48.125]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.125]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.125]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.125]         "# anonymous function.                                          "
[10:49:48.125]         "#                                                              "
[10:49:48.125]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.125]         "# function environment of FUN() to the calling environment.    "
[10:49:48.125]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.125]         "# global environment, which is where globals are written.      "
[10:49:48.125]         penv <- env <- environment(...future.FUN)
[10:49:48.125]         repeat {
[10:49:48.125]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.125]                 emptyenv())) 
[10:49:48.125]                 break
[10:49:48.125]             penv <- env
[10:49:48.125]             env <- parent.env(env)
[10:49:48.125]         }
[10:49:48.125]         if (identical(penv, globalenv())) {
[10:49:48.125]             environment(...future.FUN) <- environment()
[10:49:48.125]         }
[10:49:48.125]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.125]             !isNamespace(penv)) {
[10:49:48.125]             parent.env(penv) <- environment()
[10:49:48.125]         }
[10:49:48.125]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.125]         {
[10:49:48.125]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.125]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.125]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.125]                 on.exit(options(oopts), add = TRUE)
[10:49:48.125]             }
[10:49:48.125]             {
[10:49:48.125]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.125]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.125]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.125]                 })
[10:49:48.125]             }
[10:49:48.125]         }
[10:49:48.125]     }, args = future.call.arguments)
[10:49:48.125] }
[10:49:48.125] Lazy evaluation: FALSE
[10:49:48.125] Asynchronous evaluation: TRUE
[10:49:48.125] Local evaluation: TRUE
[10:49:48.125] Environment: R_GlobalEnv
[10:49:48.125] Capture standard output: TRUE
[10:49:48.125] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.125] Immediate condition classes: ‘immediateCondition’
[10:49:48.125] Globals: 7 objects totaling 1.02 KiB (function ‘...future.FUN’ of 225 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 588 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes, ...)
[10:49:48.125] Packages: <none>
[10:49:48.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.125] Resolved: FALSE
[10:49:48.125] Value: <not collected>
[10:49:48.125] Conditions captured: <none>
[10:49:48.125] Early signaling: FALSE
[10:49:48.125] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.125] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.137] Chunk #1 of 2 ... DONE
[10:49:48.137] Chunk #2 of 2 ...
[10:49:48.137]  - Finding globals in 'X' for chunk #2 ...
[10:49:48.139]    + additional globals found: [n=2] ‘a’, ‘b’
[10:49:48.139]    + additional namespaces needed: [n=1] ‘tools’
[10:49:48.140]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:48.140]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:48.140]  - seeds: <none>
[10:49:48.140]  - All globals exported: [n=7] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’, ‘a’, ‘b’
[10:49:48.182] Created future:
[10:49:48.182] MultisessionFuture:
[10:49:48.182] Label: ‘future_lapply-2’
[10:49:48.182] Expression:
[10:49:48.182] {
[10:49:48.182]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.182]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.182]     "# as a global variable                                         "
[10:49:48.182]     do.call(function(...) {
[10:49:48.182]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.182]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.182]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.182]         "# anonymous function.                                          "
[10:49:48.182]         "#                                                              "
[10:49:48.182]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.182]         "# function environment of FUN() to the calling environment.    "
[10:49:48.182]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.182]         "# global environment, which is where globals are written.      "
[10:49:48.182]         penv <- env <- environment(...future.FUN)
[10:49:48.182]         repeat {
[10:49:48.182]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.182]                 emptyenv())) 
[10:49:48.182]                 break
[10:49:48.182]             penv <- env
[10:49:48.182]             env <- parent.env(env)
[10:49:48.182]         }
[10:49:48.182]         if (identical(penv, globalenv())) {
[10:49:48.182]             environment(...future.FUN) <- environment()
[10:49:48.182]         }
[10:49:48.182]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.182]             !isNamespace(penv)) {
[10:49:48.182]             parent.env(penv) <- environment()
[10:49:48.182]         }
[10:49:48.182]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.182]         {
[10:49:48.182]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.182]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.182]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.182]                 on.exit(options(oopts), add = TRUE)
[10:49:48.182]             }
[10:49:48.182]             {
[10:49:48.182]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.182]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.182]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.182]                 })
[10:49:48.182]             }
[10:49:48.182]         }
[10:49:48.182]     }, args = future.call.arguments)
[10:49:48.182] }
[10:49:48.182] Lazy evaluation: FALSE
[10:49:48.182] Asynchronous evaluation: TRUE
[10:49:48.182] Local evaluation: TRUE
[10:49:48.182] Environment: R_GlobalEnv
[10:49:48.182] Capture standard output: TRUE
[10:49:48.182] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.182] Immediate condition classes: ‘immediateCondition’
[10:49:48.182] Globals: 7 objects totaling 1.33 KiB (function ‘...future.FUN’ of 225 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 903 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes, ...)
[10:49:48.182] Packages: 1 packages (‘tools’)
[10:49:48.182] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.182] Resolved: FALSE
[10:49:48.182] Value: <not collected>
[10:49:48.182] Conditions captured: <none>
[10:49:48.182] Early signaling: FALSE
[10:49:48.182] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.182] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.194] Chunk #2 of 2 ... DONE
[10:49:48.194] Launching 2 futures (chunks) ... DONE
[10:49:48.194] Resolving 2 futures (chunks) ...
[10:49:48.238]  - Number of value chunks collected: 2
[10:49:48.238] Resolving 2 futures (chunks) ... DONE
[10:49:48.238] Reducing values from 2 chunks ...
[10:49:48.238]  - Number of values collected after concatenation: 4
[10:49:48.238]  - Number of values expected: 4
[10:49:48.238] Reducing values from 2 chunks ... DONE
[10:49:48.238] future_lapply() ... DONE
List of 4
 $ : num 84
 $ : num 10.5
 $ : num 63
 $ : int 11
- future_lapply(x, ...) - passing '...' as a global ...
List of 1
 $ z0:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
[10:49:48.241] future_lapply() ...
[10:49:48.242] Number of chunks: 1
[10:49:48.242] getGlobalsAndPackagesXApply() ...
[10:49:48.242]  - future.globals: TRUE
[10:49:48.244]  - globals found/used: [n=2] ‘FUN’, ‘future.call.arguments’
[10:49:48.244]  - needed namespaces: [n=0] 
[10:49:48.245] Finding globals ... DONE
[10:49:48.245]  - use_args: TRUE
[10:49:48.245]  - Getting '...' globals ...
[10:49:48.245]    - '...' content: [n=0] 
[10:49:48.245] List of 1
[10:49:48.245]  $ ...: list()
[10:49:48.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.245]  - attr(*, "where")=List of 1
[10:49:48.245]   ..$ ...:<environment: 0x55d1ce7d83b8> 
[10:49:48.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.245]  - attr(*, "resolved")= logi TRUE
[10:49:48.245]  - attr(*, "total_size")= num NA
[10:49:48.248]  - Getting '...' globals ... DONE
[10:49:48.248] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘future.call.arguments’, ‘...’
[10:49:48.248] List of 3
[10:49:48.248]  $ ...future.FUN        :function (x)  
[10:49:48.248]  $ future.call.arguments:List of 1
[10:49:48.248]   ..$ a: num 1
[10:49:48.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.248]  $ ...                  : list()
[10:49:48.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.248]  - attr(*, "where")=List of 3
[10:49:48.248]   ..$ ...future.FUN        :<environment: R_EmptyEnv> 
[10:49:48.248]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:49:48.248]   ..$ ...                  :<environment: 0x55d1ce7d83b8> 
[10:49:48.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.248]  - attr(*, "resolved")= logi FALSE
[10:49:48.248]  - attr(*, "total_size")= num 3563
[10:49:48.252] Packages to be attached in all futures: [n=0] 
[10:49:48.252] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.252] Number of futures (= number of chunks): 1
[10:49:48.252] Launching 1 futures (chunks) ...
[10:49:48.252] Chunk #1 of 1 ...
[10:49:48.253]  - Finding globals in 'X' for chunk #1 ...
[10:49:48.253]    + additional globals found: [n=0] 
[10:49:48.253]    + additional namespaces needed: [n=0] 
[10:49:48.253]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:48.253]  - seeds: <none>
[10:49:48.253]  - All globals exported: [n=6] ‘...future.FUN’, ‘future.call.arguments’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.337] Created future:
[10:49:48.337] MultisessionFuture:
[10:49:48.337] Label: ‘future_lapply-1’
[10:49:48.337] Expression:
[10:49:48.337] {
[10:49:48.337]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.337]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.337]     "# as a global variable                                         "
[10:49:48.337]     do.call(function(...) {
[10:49:48.337]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.337]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.337]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.337]         "# anonymous function.                                          "
[10:49:48.337]         "#                                                              "
[10:49:48.337]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.337]         "# function environment of FUN() to the calling environment.    "
[10:49:48.337]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.337]         "# global environment, which is where globals are written.      "
[10:49:48.337]         penv <- env <- environment(...future.FUN)
[10:49:48.337]         repeat {
[10:49:48.337]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.337]                 emptyenv())) 
[10:49:48.337]                 break
[10:49:48.337]             penv <- env
[10:49:48.337]             env <- parent.env(env)
[10:49:48.337]         }
[10:49:48.337]         if (identical(penv, globalenv())) {
[10:49:48.337]             environment(...future.FUN) <- environment()
[10:49:48.337]         }
[10:49:48.337]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.337]             !isNamespace(penv)) {
[10:49:48.337]             parent.env(penv) <- environment()
[10:49:48.337]         }
[10:49:48.337]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.337]         {
[10:49:48.337]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.337]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.337]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.337]                 on.exit(options(oopts), add = TRUE)
[10:49:48.337]             }
[10:49:48.337]             {
[10:49:48.337]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.337]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.337]                   ...future.FUN(...future.X_jj)
[10:49:48.337]                 })
[10:49:48.337]             }
[10:49:48.337]         }
[10:49:48.337]     }, args = future.call.arguments)
[10:49:48.337] }
[10:49:48.337] Lazy evaluation: FALSE
[10:49:48.337] Asynchronous evaluation: TRUE
[10:49:48.337] Local evaluation: TRUE
[10:49:48.337] Environment: 0x55d1ce7d8738
[10:49:48.337] Capture standard output: TRUE
[10:49:48.337] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.337] Immediate condition classes: ‘immediateCondition’
[10:49:48.337] Globals: 5 objects totaling 613 bytes (function ‘...future.FUN’ of 361 bytes, DotDotDotList ‘future.call.arguments’ of 151 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:48.337] Packages: <none>
[10:49:48.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.337] Resolved: FALSE
[10:49:48.337] Value: <not collected>
[10:49:48.337] Conditions captured: <none>
[10:49:48.337] Early signaling: FALSE
[10:49:48.337] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.337] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.349] Chunk #1 of 1 ... DONE
[10:49:48.349] Launching 1 futures (chunks) ... DONE
[10:49:48.349] Resolving 1 futures (chunks) ...
[10:49:48.381]  - Number of value chunks collected: 1
[10:49:48.381] Resolving 1 futures (chunks) ... DONE
[10:49:48.381] Reducing values from 1 chunks ...
[10:49:48.383]  - Number of values collected after concatenation: 1
[10:49:48.383]  - Number of values expected: 1
[10:49:48.383] Reducing values from 1 chunks ... DONE
[10:49:48.384] future_lapply() ... DONE
List of 1
 $ z1:List of 1
  ..$ :List of 1
  .. ..$ a: num 1
- future_lapply(X, ...) - '{ a <- a + 1; a }' ...
[10:49:48.385] future_lapply() ...
[10:49:48.386] Number of chunks: 1
[10:49:48.386] getGlobalsAndPackagesXApply() ...
[10:49:48.386]  - future.globals: TRUE
[10:49:48.389]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:48.389]  - needed namespaces: [n=0] 
[10:49:48.389] Finding globals ... DONE
[10:49:48.389]  - use_args: TRUE
[10:49:48.389]  - Getting '...' globals ...
[10:49:48.390]    - '...' content: [n=0] 
[10:49:48.390] List of 1
[10:49:48.390]  $ ...: list()
[10:49:48.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.390]  - attr(*, "where")=List of 1
[10:49:48.390]   ..$ ...:<environment: 0x55d1cddb8c48> 
[10:49:48.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.390]  - attr(*, "resolved")= logi TRUE
[10:49:48.390]  - attr(*, "total_size")= num NA
[10:49:48.392]  - Getting '...' globals ... DONE
[10:49:48.392] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:48.392] List of 3
[10:49:48.392]  $ ...future.FUN:function (ii)  
[10:49:48.392]  $ a            : num 1
[10:49:48.392]  $ ...          : list()
[10:49:48.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.392]  - attr(*, "where")=List of 3
[10:49:48.392]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:48.392]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:48.392]   ..$ ...          :<environment: 0x55d1cddb8c48> 
[10:49:48.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.392]  - attr(*, "resolved")= logi FALSE
[10:49:48.392]  - attr(*, "total_size")= num 3759
[10:49:48.396] Packages to be attached in all futures: [n=0] 
[10:49:48.396] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.396] Number of futures (= number of chunks): 1
[10:49:48.396] Launching 1 futures (chunks) ...
[10:49:48.396] Chunk #1 of 1 ...
[10:49:48.396]  - Finding globals in 'X' for chunk #1 ...
[10:49:48.397]    + additional globals found: [n=0] 
[10:49:48.397]    + additional namespaces needed: [n=0] 
[10:49:48.397]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:48.397]  - seeds: <none>
[10:49:48.397]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.478] Created future:
[10:49:48.478] MultisessionFuture:
[10:49:48.478] Label: ‘future_lapply-1’
[10:49:48.478] Expression:
[10:49:48.478] {
[10:49:48.478]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.478]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.478]     "# as a global variable                                         "
[10:49:48.478]     do.call(function(...) {
[10:49:48.478]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.478]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.478]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.478]         "# anonymous function.                                          "
[10:49:48.478]         "#                                                              "
[10:49:48.478]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.478]         "# function environment of FUN() to the calling environment.    "
[10:49:48.478]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.478]         "# global environment, which is where globals are written.      "
[10:49:48.478]         penv <- env <- environment(...future.FUN)
[10:49:48.478]         repeat {
[10:49:48.478]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.478]                 emptyenv())) 
[10:49:48.478]                 break
[10:49:48.478]             penv <- env
[10:49:48.478]             env <- parent.env(env)
[10:49:48.478]         }
[10:49:48.478]         if (identical(penv, globalenv())) {
[10:49:48.478]             environment(...future.FUN) <- environment()
[10:49:48.478]         }
[10:49:48.478]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.478]             !isNamespace(penv)) {
[10:49:48.478]             parent.env(penv) <- environment()
[10:49:48.478]         }
[10:49:48.478]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.478]         {
[10:49:48.478]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.478]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.478]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.478]                 on.exit(options(oopts), add = TRUE)
[10:49:48.478]             }
[10:49:48.478]             {
[10:49:48.478]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.478]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.478]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.478]                 })
[10:49:48.478]             }
[10:49:48.478]         }
[10:49:48.478]     }, args = future.call.arguments)
[10:49:48.478] }
[10:49:48.478] Lazy evaluation: FALSE
[10:49:48.478] Asynchronous evaluation: TRUE
[10:49:48.478] Local evaluation: TRUE
[10:49:48.478] Environment: R_GlobalEnv
[10:49:48.478] Capture standard output: TRUE
[10:49:48.478] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.478] Immediate condition classes: ‘immediateCondition’
[10:49:48.478] Globals: 6 objects totaling 748 bytes (function ‘...future.FUN’ of 511 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:48.478] Packages: <none>
[10:49:48.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.478] Resolved: FALSE
[10:49:48.478] Value: <not collected>
[10:49:48.478] Conditions captured: <none>
[10:49:48.478] Early signaling: FALSE
[10:49:48.478] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.478] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.490] Chunk #1 of 1 ... DONE
[10:49:48.490] Launching 1 futures (chunks) ... DONE
[10:49:48.490] Resolving 1 futures (chunks) ...
[10:49:48.533]  - Number of value chunks collected: 1
[10:49:48.533] Resolving 1 futures (chunks) ... DONE
[10:49:48.533] Reducing values from 1 chunks ...
[10:49:48.533]  - Number of values collected after concatenation: 1
[10:49:48.533]  - Number of values expected: 1
[10:49:48.533] Reducing values from 1 chunks ... DONE
[10:49:48.533] future_lapply() ... DONE
- future_lapply(X, ...) - '{ a; a <- a + 1 }' ...
[10:49:48.533] future_lapply() ...
[10:49:48.534] Number of chunks: 1
[10:49:48.535] getGlobalsAndPackagesXApply() ...
[10:49:48.535]  - future.globals: TRUE
[10:49:48.537]  - globals found/used: [n=2] ‘FUN’, ‘a’
[10:49:48.537]  - needed namespaces: [n=0] 
[10:49:48.537] Finding globals ... DONE
[10:49:48.537]  - use_args: TRUE
[10:49:48.538]  - Getting '...' globals ...
[10:49:48.538]    - '...' content: [n=0] 
[10:49:48.538] List of 1
[10:49:48.538]  $ ...: list()
[10:49:48.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.538]  - attr(*, "where")=List of 1
[10:49:48.538]   ..$ ...:<environment: 0x55d1cae4e2e8> 
[10:49:48.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.538]  - attr(*, "resolved")= logi TRUE
[10:49:48.538]  - attr(*, "total_size")= num NA
[10:49:48.541]  - Getting '...' globals ... DONE
[10:49:48.541] Globals to be used in all futures (chunks): [n=3] ‘...future.FUN’, ‘a’, ‘...’
[10:49:48.541] List of 3
[10:49:48.541]  $ ...future.FUN:function (ii)  
[10:49:48.541]  $ a            : num 1
[10:49:48.541]  $ ...          : list()
[10:49:48.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.541]  - attr(*, "where")=List of 3
[10:49:48.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:48.541]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:48.541]   ..$ ...          :<environment: 0x55d1cae4e2e8> 
[10:49:48.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.541]  - attr(*, "resolved")= logi FALSE
[10:49:48.541]  - attr(*, "total_size")= num 3775
[10:49:48.544] Packages to be attached in all futures: [n=0] 
[10:49:48.544] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.545] Number of futures (= number of chunks): 1
[10:49:48.545] Launching 1 futures (chunks) ...
[10:49:48.545] Chunk #1 of 1 ...
[10:49:48.545]  - Finding globals in 'X' for chunk #1 ...
[10:49:48.545]    + additional globals found: [n=0] 
[10:49:48.545]    + additional namespaces needed: [n=0] 
[10:49:48.545]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:48.545]  - seeds: <none>
[10:49:48.546]  - All globals exported: [n=6] ‘...future.FUN’, ‘a’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.626] Created future:
[10:49:48.626] MultisessionFuture:
[10:49:48.626] Label: ‘future_lapply-1’
[10:49:48.626] Expression:
[10:49:48.626] {
[10:49:48.626]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.626]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.626]     "# as a global variable                                         "
[10:49:48.626]     do.call(function(...) {
[10:49:48.626]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.626]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.626]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.626]         "# anonymous function.                                          "
[10:49:48.626]         "#                                                              "
[10:49:48.626]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.626]         "# function environment of FUN() to the calling environment.    "
[10:49:48.626]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.626]         "# global environment, which is where globals are written.      "
[10:49:48.626]         penv <- env <- environment(...future.FUN)
[10:49:48.626]         repeat {
[10:49:48.626]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.626]                 emptyenv())) 
[10:49:48.626]                 break
[10:49:48.626]             penv <- env
[10:49:48.626]             env <- parent.env(env)
[10:49:48.626]         }
[10:49:48.626]         if (identical(penv, globalenv())) {
[10:49:48.626]             environment(...future.FUN) <- environment()
[10:49:48.626]         }
[10:49:48.626]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.626]             !isNamespace(penv)) {
[10:49:48.626]             parent.env(penv) <- environment()
[10:49:48.626]         }
[10:49:48.626]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.626]         {
[10:49:48.626]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.626]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.626]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.626]                 on.exit(options(oopts), add = TRUE)
[10:49:48.626]             }
[10:49:48.626]             {
[10:49:48.626]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.626]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.626]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.626]                 })
[10:49:48.626]             }
[10:49:48.626]         }
[10:49:48.626]     }, args = future.call.arguments)
[10:49:48.626] }
[10:49:48.626] Lazy evaluation: FALSE
[10:49:48.626] Asynchronous evaluation: TRUE
[10:49:48.626] Local evaluation: TRUE
[10:49:48.626] Environment: R_GlobalEnv
[10:49:48.626] Capture standard output: TRUE
[10:49:48.626] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.626] Immediate condition classes: ‘immediateCondition’
[10:49:48.626] Globals: 6 objects totaling 756 bytes (function ‘...future.FUN’ of 519 bytes, numeric ‘a’ of 39 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:48.626] Packages: <none>
[10:49:48.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.626] Resolved: FALSE
[10:49:48.626] Value: <not collected>
[10:49:48.626] Conditions captured: <none>
[10:49:48.626] Early signaling: FALSE
[10:49:48.626] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.638] Chunk #1 of 1 ... DONE
[10:49:48.638] Launching 1 futures (chunks) ... DONE
[10:49:48.639] Resolving 1 futures (chunks) ...
[10:49:48.681]  - Number of value chunks collected: 1
[10:49:48.681] Resolving 1 futures (chunks) ... DONE
[10:49:48.681] Reducing values from 1 chunks ...
[10:49:48.681]  - Number of values collected after concatenation: 1
[10:49:48.682]  - Number of values expected: 1
[10:49:48.682] Reducing values from 1 chunks ... DONE
[10:49:48.682] future_lapply() ... DONE
- future_lapply(..., future.globals = <list>) ...
[10:49:48.682] future_lapply() ...
[10:49:48.682] Number of chunks: 1
[10:49:48.683] getGlobalsAndPackagesXApply() ...
[10:49:48.683]  - future.globals: <name-value list> with names ‘42’
[10:49:48.683]  - use_args: TRUE
[10:49:48.683]  - Getting '...' globals ...
[10:49:48.685]    - '...' content: [n=0] 
[10:49:48.686] List of 1
[10:49:48.686]  $ ...: list()
[10:49:48.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.686]  - attr(*, "where")=List of 1
[10:49:48.686]   ..$ ...:<environment: 0x55d1cdf8fc40> 
[10:49:48.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.686]  - attr(*, "resolved")= logi TRUE
[10:49:48.686]  - attr(*, "total_size")= num NA
[10:49:48.688]  - Getting '...' globals ... DONE
[10:49:48.689] Globals to be used in all futures (chunks): [n=3] ‘a’, ‘...future.FUN’, ‘...’
[10:49:48.689] List of 3
[10:49:48.689]  $ a            : num 42
[10:49:48.689]  $ ...future.FUN:function (x)  
[10:49:48.689]  $ ...          : list()
[10:49:48.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.689]  - attr(*, "where")=List of 3
[10:49:48.689]   ..$ a            :<environment: R_EmptyEnv> 
[10:49:48.689]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:49:48.689]   ..$ ...          :<environment: 0x55d1cdf8fc40> 
[10:49:48.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.689]  - attr(*, "resolved")= logi FALSE
[10:49:48.689]  - attr(*, "total_size")= num NA
[10:49:48.692] Packages to be attached in all futures: [n=0] 
[10:49:48.692] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.692] Number of futures (= number of chunks): 1
[10:49:48.692] Launching 1 futures (chunks) ...
[10:49:48.692] Chunk #1 of 1 ...
[10:49:48.693]  - seeds: <none>
[10:49:48.693]  - All globals exported: [n=6] ‘a’, ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.773] Created future:
[10:49:48.773] MultisessionFuture:
[10:49:48.773] Label: ‘future_lapply-1’
[10:49:48.773] Expression:
[10:49:48.773] {
[10:49:48.773]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.773]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.773]     "# as a global variable                                         "
[10:49:48.773]     do.call(function(...) {
[10:49:48.773]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.773]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.773]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.773]         "# anonymous function.                                          "
[10:49:48.773]         "#                                                              "
[10:49:48.773]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.773]         "# function environment of FUN() to the calling environment.    "
[10:49:48.773]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.773]         "# global environment, which is where globals are written.      "
[10:49:48.773]         penv <- env <- environment(...future.FUN)
[10:49:48.773]         repeat {
[10:49:48.773]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.773]                 emptyenv())) 
[10:49:48.773]                 break
[10:49:48.773]             penv <- env
[10:49:48.773]             env <- parent.env(env)
[10:49:48.773]         }
[10:49:48.773]         if (identical(penv, globalenv())) {
[10:49:48.773]             environment(...future.FUN) <- environment()
[10:49:48.773]         }
[10:49:48.773]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.773]             !isNamespace(penv)) {
[10:49:48.773]             parent.env(penv) <- environment()
[10:49:48.773]         }
[10:49:48.773]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.773]         {
[10:49:48.773]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.773]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.773]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.773]                 on.exit(options(oopts), add = TRUE)
[10:49:48.773]             }
[10:49:48.773]             {
[10:49:48.773]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.773]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.773]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.773]                 })
[10:49:48.773]             }
[10:49:48.773]         }
[10:49:48.773]     }, args = future.call.arguments)
[10:49:48.773] }
[10:49:48.773] Lazy evaluation: FALSE
[10:49:48.773] Asynchronous evaluation: TRUE
[10:49:48.773] Local evaluation: TRUE
[10:49:48.773] Environment: R_GlobalEnv
[10:49:48.773] Capture standard output: TRUE
[10:49:48.773] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.773] Immediate condition classes: ‘immediateCondition’
[10:49:48.773] Globals: 6 objects totaling 535 bytes (numeric ‘a’ of 39 bytes, function ‘...future.FUN’ of 298 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, ...)
[10:49:48.773] Packages: <none>
[10:49:48.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.773] Resolved: FALSE
[10:49:48.773] Value: <not collected>
[10:49:48.773] Conditions captured: <none>
[10:49:48.773] Early signaling: FALSE
[10:49:48.773] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.773] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.785] Chunk #1 of 1 ... DONE
[10:49:48.785] Launching 1 futures (chunks) ... DONE
[10:49:48.785] Resolving 1 futures (chunks) ...
[10:49:48.817]  - Number of value chunks collected: 1
[10:49:48.817] Resolving 1 futures (chunks) ... DONE
[10:49:48.817] Reducing values from 1 chunks ...
[10:49:48.817]  - Number of values collected after concatenation: 1
[10:49:48.818]  - Number of values expected: 1
[10:49:48.818] Reducing values from 1 chunks ... DONE
[10:49:48.818] future_lapply() ... DONE
List of 1
 $ : num 42
> 
> message("*** future_lapply() - tricky globals ... DONE")
*** future_lapply() - tricky globals ... DONE
> 
> 
> message("*** future_lapply() - missing arguments ...")
*** future_lapply() - missing arguments ...
> 
> ## Here 'abc' becomes missing, i.e. missing(abc) is TRUE
> foo <- function(x, abc) future_lapply(x, FUN = function(y) y)
> y <- foo(1:2)
[10:49:48.819] future_lapply() ...
[10:49:48.819] Number of chunks: 2
[10:49:48.820] getGlobalsAndPackagesXApply() ...
[10:49:48.820]  - future.globals: TRUE
[10:49:48.821]  - globals found/used: [n=1] ‘FUN’
[10:49:48.821]  - needed namespaces: [n=0] 
[10:49:48.821] Finding globals ... DONE
[10:49:48.821]  - use_args: TRUE
[10:49:48.821]  - Getting '...' globals ...
[10:49:48.822]    - '...' content: [n=0] 
[10:49:48.822] List of 1
[10:49:48.822]  $ ...: list()
[10:49:48.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.822]  - attr(*, "where")=List of 1
[10:49:48.822]   ..$ ...:<environment: 0x55d1cc9696f0> 
[10:49:48.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.822]  - attr(*, "resolved")= logi TRUE
[10:49:48.822]  - attr(*, "total_size")= num NA
[10:49:48.824]  - Getting '...' globals ... DONE
[10:49:48.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:48.825] List of 2
[10:49:48.825]  $ ...future.FUN:function (y)  
[10:49:48.825]  $ ...          : list()
[10:49:48.825]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:48.825]  - attr(*, "where")=List of 2
[10:49:48.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:48.825]   ..$ ...          :<environment: 0x55d1cc9696f0> 
[10:49:48.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:48.825]  - attr(*, "resolved")= logi FALSE
[10:49:48.825]  - attr(*, "total_size")= num 3388
[10:49:48.828] Packages to be attached in all futures: [n=0] 
[10:49:48.828] getGlobalsAndPackagesXApply() ... DONE
[10:49:48.828] Number of futures (= number of chunks): 2
[10:49:48.828] Launching 2 futures (chunks) ...
[10:49:48.828] Chunk #1 of 2 ...
[10:49:48.828]  - Finding globals in 'X' for chunk #1 ...
[10:49:48.828]    + additional globals found: [n=0] 
[10:49:48.829]    + additional namespaces needed: [n=0] 
[10:49:48.829]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:48.829]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:48.829]  - seeds: <none>
[10:49:48.829]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:48.909] Created future:
[10:49:48.909] MultisessionFuture:
[10:49:48.909] Label: ‘future_lapply-1’
[10:49:48.909] Expression:
[10:49:48.909] {
[10:49:48.909]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:48.909]     "# expression in do.call(), because function called uses '...'  "
[10:49:48.909]     "# as a global variable                                         "
[10:49:48.909]     do.call(function(...) {
[10:49:48.909]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:48.909]         "# without having an '...' argument. This means '...' is treated"
[10:49:48.909]         "# as a global variable. This may happen when FUN() is an       "
[10:49:48.909]         "# anonymous function.                                          "
[10:49:48.909]         "#                                                              "
[10:49:48.909]         "# If an anonymous function, we will make sure to restore the   "
[10:49:48.909]         "# function environment of FUN() to the calling environment.    "
[10:49:48.909]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:48.909]         "# global environment, which is where globals are written.      "
[10:49:48.909]         penv <- env <- environment(...future.FUN)
[10:49:48.909]         repeat {
[10:49:48.909]             if (identical(env, globalenv()) || identical(env, 
[10:49:48.909]                 emptyenv())) 
[10:49:48.909]                 break
[10:49:48.909]             penv <- env
[10:49:48.909]             env <- parent.env(env)
[10:49:48.909]         }
[10:49:48.909]         if (identical(penv, globalenv())) {
[10:49:48.909]             environment(...future.FUN) <- environment()
[10:49:48.909]         }
[10:49:48.909]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:48.909]             !isNamespace(penv)) {
[10:49:48.909]             parent.env(penv) <- environment()
[10:49:48.909]         }
[10:49:48.909]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:48.909]         {
[10:49:48.909]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:48.909]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:48.909]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:48.909]                 on.exit(options(oopts), add = TRUE)
[10:49:48.909]             }
[10:49:48.909]             {
[10:49:48.909]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:48.909]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:48.909]                   ...future.FUN(...future.X_jj, ...)
[10:49:48.909]                 })
[10:49:48.909]             }
[10:49:48.909]         }
[10:49:48.909]     }, args = future.call.arguments)
[10:49:48.909] }
[10:49:48.909] Lazy evaluation: FALSE
[10:49:48.909] Asynchronous evaluation: TRUE
[10:49:48.909] Local evaluation: TRUE
[10:49:48.909] Environment: 0x55d1cc969300
[10:49:48.909] Capture standard output: TRUE
[10:49:48.909] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:48.909] Immediate condition classes: ‘immediateCondition’
[10:49:48.909] Globals: 5 objects totaling 489 bytes (function ‘...future.FUN’ of 295 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:48.909] Packages: <none>
[10:49:48.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:48.909] Resolved: FALSE
[10:49:48.909] Value: <not collected>
[10:49:48.909] Conditions captured: <none>
[10:49:48.909] Early signaling: FALSE
[10:49:48.909] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:48.909] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:48.921] Chunk #1 of 2 ... DONE
[10:49:48.922] Chunk #2 of 2 ...
[10:49:48.922]  - Finding globals in 'X' for chunk #2 ...
[10:49:48.922]    + additional globals found: [n=0] 
[10:49:48.922]    + additional namespaces needed: [n=0] 
[10:49:48.922]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:48.922]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:48.922]  - seeds: <none>
[10:49:48.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.003] Created future:
[10:49:49.003] MultisessionFuture:
[10:49:49.003] Label: ‘future_lapply-2’
[10:49:49.003] Expression:
[10:49:49.003] {
[10:49:49.003]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.003]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.003]     "# as a global variable                                         "
[10:49:49.003]     do.call(function(...) {
[10:49:49.003]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.003]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.003]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.003]         "# anonymous function.                                          "
[10:49:49.003]         "#                                                              "
[10:49:49.003]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.003]         "# function environment of FUN() to the calling environment.    "
[10:49:49.003]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.003]         "# global environment, which is where globals are written.      "
[10:49:49.003]         penv <- env <- environment(...future.FUN)
[10:49:49.003]         repeat {
[10:49:49.003]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.003]                 emptyenv())) 
[10:49:49.003]                 break
[10:49:49.003]             penv <- env
[10:49:49.003]             env <- parent.env(env)
[10:49:49.003]         }
[10:49:49.003]         if (identical(penv, globalenv())) {
[10:49:49.003]             environment(...future.FUN) <- environment()
[10:49:49.003]         }
[10:49:49.003]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.003]             !isNamespace(penv)) {
[10:49:49.003]             parent.env(penv) <- environment()
[10:49:49.003]         }
[10:49:49.003]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.003]         {
[10:49:49.003]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.003]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.003]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.003]                 on.exit(options(oopts), add = TRUE)
[10:49:49.003]             }
[10:49:49.003]             {
[10:49:49.003]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.003]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.003]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.003]                 })
[10:49:49.003]             }
[10:49:49.003]         }
[10:49:49.003]     }, args = future.call.arguments)
[10:49:49.003] }
[10:49:49.003] Lazy evaluation: FALSE
[10:49:49.003] Asynchronous evaluation: TRUE
[10:49:49.003] Local evaluation: TRUE
[10:49:49.003] Environment: 0x55d1cc969300
[10:49:49.003] Capture standard output: TRUE
[10:49:49.003] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.003] Immediate condition classes: ‘immediateCondition’
[10:49:49.003] Globals: 5 objects totaling 489 bytes (function ‘...future.FUN’ of 295 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:49.003] Packages: <none>
[10:49:49.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.003] Resolved: FALSE
[10:49:49.003] Value: <not collected>
[10:49:49.003] Conditions captured: <none>
[10:49:49.003] Early signaling: FALSE
[10:49:49.003] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.003] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.016] Chunk #2 of 2 ... DONE
[10:49:49.016] Launching 2 futures (chunks) ... DONE
[10:49:49.016] Resolving 2 futures (chunks) ...
[10:49:49.048]  - Number of value chunks collected: 2
[10:49:49.048] Resolving 2 futures (chunks) ... DONE
[10:49:49.048] Reducing values from 2 chunks ...
[10:49:49.048]  - Number of values collected after concatenation: 2
[10:49:49.048]  - Number of values expected: 2
[10:49:49.049] Reducing values from 2 chunks ... DONE
[10:49:49.049] future_lapply() ... DONE
> stopifnot(identical(y, as.list(1:2)))
> 
> message("*** future_lapply() - missing arguments ... DONE")
*** future_lapply() - missing arguments ... DONE
> 
> 
> message("*** future_lapply() - false positives ...")
*** future_lapply() - false positives ...
> 
> ## Here 'abc' becomes a promise, which fails to resolve
> ## iff 'xyz' does not exist. (Issue #161)
> suppressWarnings(rm(list = "xyz"))
> foo <- function(x, abc) future_lapply(x, FUN = function(y) y)
> y <- foo(1:2, abc = (xyz >= 3.14))
[10:49:49.049] future_lapply() ...
[10:49:49.050] Number of chunks: 2
[10:49:49.050] getGlobalsAndPackagesXApply() ...
[10:49:49.050]  - future.globals: TRUE
[10:49:49.054]  - globals found/used: [n=1] ‘FUN’
[10:49:49.054]  - needed namespaces: [n=0] 
[10:49:49.054] Finding globals ... DONE
[10:49:49.054]  - use_args: TRUE
[10:49:49.054]  - Getting '...' globals ...
[10:49:49.055]    - '...' content: [n=0] 
[10:49:49.055] List of 1
[10:49:49.055]  $ ...: list()
[10:49:49.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.055]  - attr(*, "where")=List of 1
[10:49:49.055]   ..$ ...:<environment: 0x55d1ce700088> 
[10:49:49.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.055]  - attr(*, "resolved")= logi TRUE
[10:49:49.055]  - attr(*, "total_size")= num NA
[10:49:49.057]  - Getting '...' globals ... DONE
[10:49:49.057] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:49.058] List of 2
[10:49:49.058]  $ ...future.FUN:function (y)  
[10:49:49.058]  $ ...          : list()
[10:49:49.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.058]  - attr(*, "where")=List of 2
[10:49:49.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:49.058]   ..$ ...          :<environment: 0x55d1ce700088> 
[10:49:49.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.058]  - attr(*, "resolved")= logi FALSE
[10:49:49.058]  - attr(*, "total_size")= num 3576
[10:49:49.060] Packages to be attached in all futures: [n=0] 
[10:49:49.060] getGlobalsAndPackagesXApply() ... DONE
[10:49:49.061] Number of futures (= number of chunks): 2
[10:49:49.061] Launching 2 futures (chunks) ...
[10:49:49.061] Chunk #1 of 2 ...
[10:49:49.061]  - Finding globals in 'X' for chunk #1 ...
[10:49:49.061]    + additional globals found: [n=0] 
[10:49:49.061]    + additional namespaces needed: [n=0] 
[10:49:49.061]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:49.062]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:49.062]  - seeds: <none>
[10:49:49.062]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.142] Created future:
[10:49:49.142] MultisessionFuture:
[10:49:49.142] Label: ‘future_lapply-1’
[10:49:49.142] Expression:
[10:49:49.142] {
[10:49:49.142]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.142]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.142]     "# as a global variable                                         "
[10:49:49.142]     do.call(function(...) {
[10:49:49.142]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.142]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.142]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.142]         "# anonymous function.                                          "
[10:49:49.142]         "#                                                              "
[10:49:49.142]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.142]         "# function environment of FUN() to the calling environment.    "
[10:49:49.142]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.142]         "# global environment, which is where globals are written.      "
[10:49:49.142]         penv <- env <- environment(...future.FUN)
[10:49:49.142]         repeat {
[10:49:49.142]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.142]                 emptyenv())) 
[10:49:49.142]                 break
[10:49:49.142]             penv <- env
[10:49:49.142]             env <- parent.env(env)
[10:49:49.142]         }
[10:49:49.142]         if (identical(penv, globalenv())) {
[10:49:49.142]             environment(...future.FUN) <- environment()
[10:49:49.142]         }
[10:49:49.142]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.142]             !isNamespace(penv)) {
[10:49:49.142]             parent.env(penv) <- environment()
[10:49:49.142]         }
[10:49:49.142]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.142]         {
[10:49:49.142]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.142]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.142]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.142]                 on.exit(options(oopts), add = TRUE)
[10:49:49.142]             }
[10:49:49.142]             {
[10:49:49.142]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.142]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.142]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.142]                 })
[10:49:49.142]             }
[10:49:49.142]         }
[10:49:49.142]     }, args = future.call.arguments)
[10:49:49.142] }
[10:49:49.142] Lazy evaluation: FALSE
[10:49:49.142] Asynchronous evaluation: TRUE
[10:49:49.142] Local evaluation: TRUE
[10:49:49.142] Environment: 0x55d1ce700478
[10:49:49.142] Capture standard output: TRUE
[10:49:49.142] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.142] Immediate condition classes: ‘immediateCondition’
[10:49:49.142] Globals: 5 objects totaling 583 bytes (function ‘...future.FUN’ of 389 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:49.142] Packages: <none>
[10:49:49.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.142] Resolved: FALSE
[10:49:49.142] Value: <not collected>
[10:49:49.142] Conditions captured: <none>
[10:49:49.142] Early signaling: FALSE
[10:49:49.142] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.142] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.154] Chunk #1 of 2 ... DONE
[10:49:49.155] Chunk #2 of 2 ...
[10:49:49.155]  - Finding globals in 'X' for chunk #2 ...
[10:49:49.155]    + additional globals found: [n=0] 
[10:49:49.155]    + additional namespaces needed: [n=0] 
[10:49:49.155]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:49.155]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:49.156]  - seeds: <none>
[10:49:49.156]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.241] Created future:
[10:49:49.241] MultisessionFuture:
[10:49:49.241] Label: ‘future_lapply-2’
[10:49:49.241] Expression:
[10:49:49.241] {
[10:49:49.241]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.241]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.241]     "# as a global variable                                         "
[10:49:49.241]     do.call(function(...) {
[10:49:49.241]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.241]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.241]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.241]         "# anonymous function.                                          "
[10:49:49.241]         "#                                                              "
[10:49:49.241]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.241]         "# function environment of FUN() to the calling environment.    "
[10:49:49.241]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.241]         "# global environment, which is where globals are written.      "
[10:49:49.241]         penv <- env <- environment(...future.FUN)
[10:49:49.241]         repeat {
[10:49:49.241]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.241]                 emptyenv())) 
[10:49:49.241]                 break
[10:49:49.241]             penv <- env
[10:49:49.241]             env <- parent.env(env)
[10:49:49.241]         }
[10:49:49.241]         if (identical(penv, globalenv())) {
[10:49:49.241]             environment(...future.FUN) <- environment()
[10:49:49.241]         }
[10:49:49.241]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.241]             !isNamespace(penv)) {
[10:49:49.241]             parent.env(penv) <- environment()
[10:49:49.241]         }
[10:49:49.241]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.241]         {
[10:49:49.241]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.241]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.241]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.241]                 on.exit(options(oopts), add = TRUE)
[10:49:49.241]             }
[10:49:49.241]             {
[10:49:49.241]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.241]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.241]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.241]                 })
[10:49:49.241]             }
[10:49:49.241]         }
[10:49:49.241]     }, args = future.call.arguments)
[10:49:49.241] }
[10:49:49.241] Lazy evaluation: FALSE
[10:49:49.241] Asynchronous evaluation: TRUE
[10:49:49.241] Local evaluation: TRUE
[10:49:49.241] Environment: 0x55d1ce700478
[10:49:49.241] Capture standard output: TRUE
[10:49:49.241] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.241] Immediate condition classes: ‘immediateCondition’
[10:49:49.241] Globals: 5 objects totaling 583 bytes (function ‘...future.FUN’ of 389 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:49.241] Packages: <none>
[10:49:49.241] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.241] Resolved: FALSE
[10:49:49.241] Value: <not collected>
[10:49:49.241] Conditions captured: <none>
[10:49:49.241] Early signaling: FALSE
[10:49:49.241] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.241] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.253] Chunk #2 of 2 ... DONE
[10:49:49.254] Launching 2 futures (chunks) ... DONE
[10:49:49.254] Resolving 2 futures (chunks) ...
[10:49:49.286]  - Number of value chunks collected: 2
[10:49:49.286] Resolving 2 futures (chunks) ... DONE
[10:49:49.286] Reducing values from 2 chunks ...
[10:49:49.286]  - Number of values collected after concatenation: 2
[10:49:49.286]  - Number of values expected: 2
[10:49:49.287] Reducing values from 2 chunks ... DONE
[10:49:49.287] future_lapply() ... DONE
> stopifnot(identical(y, as.list(1:2)))
> 
> message("*** future_lapply() - false positives ... DONE")
*** future_lapply() - false positives ... DONE
> 
> 
> message("*** future_lapply() - too large ...")
*** future_lapply() - too large ...
> 
> oMaxSize <- getOption("future.globals.maxSize")
> X <- replicate(10L, 1:100, simplify = FALSE)
> FUN <- function(x) {
+   getOption("future.globals.maxSize")
+ }
> 
> y0 <- lapply(X, FUN = FUN)
> stopifnot(all(sapply(y0, FUN = identical, oMaxSize)))
> 
> sizes <- unclass(c(FUN = object.size(FUN), X = object.size(X)))
> cat(sprintf("Baseline size of globals: %.2f KiB\n", sizes[["FUN"]] / 1024))
Baseline size of globals: 1.80 KiB
> 
> message("- true positive ...")
- true positive ...
> options(future.globals.maxSize = 1L)
> res <- tryCatch({
+   y <- future_lapply(X, FUN = FUN)
+ }, error = identity)
[10:49:49.289] future_lapply() ...
[10:49:49.290] Number of chunks: 2
[10:49:49.290] getGlobalsAndPackagesXApply() ...
[10:49:49.290]  - future.globals: TRUE
[10:49:49.292] getGlobalsAndPackagesXApply() ... DONE
> stopifnot(inherits(res, "error"))
> res <- NULL
> options(future.globals.maxSize = oMaxSize)
> 
> maxSize <- getOption("future.globals.maxSize")
> y <- future_lapply(X, FUN = FUN)
[10:49:49.292] future_lapply() ...
[10:49:49.293] Number of chunks: 2
[10:49:49.293] getGlobalsAndPackagesXApply() ...
[10:49:49.293]  - future.globals: TRUE
[10:49:49.295]  - globals found/used: [n=1] ‘FUN’
[10:49:49.295]  - needed namespaces: [n=0] 
[10:49:49.295] Finding globals ... DONE
[10:49:49.295]  - use_args: TRUE
[10:49:49.295]  - Getting '...' globals ...
[10:49:49.296]    - '...' content: [n=0] 
[10:49:49.296] List of 1
[10:49:49.296]  $ ...: list()
[10:49:49.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.296]  - attr(*, "where")=List of 1
[10:49:49.296]   ..$ ...:<environment: 0x55d1ce739448> 
[10:49:49.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.296]  - attr(*, "resolved")= logi TRUE
[10:49:49.296]  - attr(*, "total_size")= num NA
[10:49:49.298]  - Getting '...' globals ... DONE
[10:49:49.299] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:49.299] List of 2
[10:49:49.299]  $ ...future.FUN:function (x)  
[10:49:49.299]  $ ...          : list()
[10:49:49.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.299]  - attr(*, "where")=List of 2
[10:49:49.299]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:49.299]   ..$ ...          :<environment: 0x55d1ce739448> 
[10:49:49.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.299]  - attr(*, "resolved")= logi FALSE
[10:49:49.299]  - attr(*, "total_size")= num 4316
[10:49:49.301] Packages to be attached in all futures: [n=0] 
[10:49:49.302] getGlobalsAndPackagesXApply() ... DONE
[10:49:49.302] Number of futures (= number of chunks): 2
[10:49:49.302] Launching 2 futures (chunks) ...
[10:49:49.302] Chunk #1 of 2 ...
[10:49:49.302]  - Finding globals in 'X' for chunk #1 ...
[10:49:49.302]    + additional globals found: [n=0] 
[10:49:49.302]    + additional namespaces needed: [n=0] 
[10:49:49.303]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:49.303]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:49.303]  - seeds: <none>
[10:49:49.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.393] Created future:
[10:49:49.393] MultisessionFuture:
[10:49:49.393] Label: ‘future_lapply-1’
[10:49:49.393] Expression:
[10:49:49.393] {
[10:49:49.393]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.393]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.393]     "# as a global variable                                         "
[10:49:49.393]     do.call(function(...) {
[10:49:49.393]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.393]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.393]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.393]         "# anonymous function.                                          "
[10:49:49.393]         "#                                                              "
[10:49:49.393]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.393]         "# function environment of FUN() to the calling environment.    "
[10:49:49.393]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.393]         "# global environment, which is where globals are written.      "
[10:49:49.393]         penv <- env <- environment(...future.FUN)
[10:49:49.393]         repeat {
[10:49:49.393]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.393]                 emptyenv())) 
[10:49:49.393]                 break
[10:49:49.393]             penv <- env
[10:49:49.393]             env <- parent.env(env)
[10:49:49.393]         }
[10:49:49.393]         if (identical(penv, globalenv())) {
[10:49:49.393]             environment(...future.FUN) <- environment()
[10:49:49.393]         }
[10:49:49.393]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.393]             !isNamespace(penv)) {
[10:49:49.393]             parent.env(penv) <- environment()
[10:49:49.393]         }
[10:49:49.393]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.393]         {
[10:49:49.393]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.393]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.393]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.393]                 on.exit(options(oopts), add = TRUE)
[10:49:49.393]             }
[10:49:49.393]             {
[10:49:49.393]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.393]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.393]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.393]                 })
[10:49:49.393]             }
[10:49:49.393]         }
[10:49:49.393]     }, args = future.call.arguments)
[10:49:49.393] }
[10:49:49.393] Lazy evaluation: FALSE
[10:49:49.393] Asynchronous evaluation: TRUE
[10:49:49.393] Local evaluation: TRUE
[10:49:49.393] Environment: R_GlobalEnv
[10:49:49.393] Capture standard output: TRUE
[10:49:49.393] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.393] Immediate condition classes: ‘immediateCondition’
[10:49:49.393] Globals: 5 objects totaling 0.98 KiB (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 445 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:49.393] Packages: <none>
[10:49:49.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.393] Resolved: FALSE
[10:49:49.393] Value: <not collected>
[10:49:49.393] Conditions captured: <none>
[10:49:49.393] Early signaling: FALSE
[10:49:49.393] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.393] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.405] Chunk #1 of 2 ... DONE
[10:49:49.405] Chunk #2 of 2 ...
[10:49:49.405]  - Finding globals in 'X' for chunk #2 ...
[10:49:49.406]    + additional globals found: [n=0] 
[10:49:49.406]    + additional namespaces needed: [n=0] 
[10:49:49.406]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:49.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:49:49.406]  - seeds: <none>
[10:49:49.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.487] Created future:
[10:49:49.487] MultisessionFuture:
[10:49:49.487] Label: ‘future_lapply-2’
[10:49:49.487] Expression:
[10:49:49.487] {
[10:49:49.487]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.487]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.487]     "# as a global variable                                         "
[10:49:49.487]     do.call(function(...) {
[10:49:49.487]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.487]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.487]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.487]         "# anonymous function.                                          "
[10:49:49.487]         "#                                                              "
[10:49:49.487]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.487]         "# function environment of FUN() to the calling environment.    "
[10:49:49.487]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.487]         "# global environment, which is where globals are written.      "
[10:49:49.487]         penv <- env <- environment(...future.FUN)
[10:49:49.487]         repeat {
[10:49:49.487]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.487]                 emptyenv())) 
[10:49:49.487]                 break
[10:49:49.487]             penv <- env
[10:49:49.487]             env <- parent.env(env)
[10:49:49.487]         }
[10:49:49.487]         if (identical(penv, globalenv())) {
[10:49:49.487]             environment(...future.FUN) <- environment()
[10:49:49.487]         }
[10:49:49.487]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.487]             !isNamespace(penv)) {
[10:49:49.487]             parent.env(penv) <- environment()
[10:49:49.487]         }
[10:49:49.487]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.487]         {
[10:49:49.487]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.487]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.487]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.487]                 on.exit(options(oopts), add = TRUE)
[10:49:49.487]             }
[10:49:49.487]             {
[10:49:49.487]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.487]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.487]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.487]                 })
[10:49:49.487]             }
[10:49:49.487]         }
[10:49:49.487]     }, args = future.call.arguments)
[10:49:49.487] }
[10:49:49.487] Lazy evaluation: FALSE
[10:49:49.487] Asynchronous evaluation: TRUE
[10:49:49.487] Local evaluation: TRUE
[10:49:49.487] Environment: R_GlobalEnv
[10:49:49.487] Capture standard output: TRUE
[10:49:49.487] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.487] Immediate condition classes: ‘immediateCondition’
[10:49:49.487] Globals: 5 objects totaling 0.98 KiB (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 445 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:49:49.487] Packages: <none>
[10:49:49.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.487] Resolved: FALSE
[10:49:49.487] Value: <not collected>
[10:49:49.487] Conditions captured: <none>
[10:49:49.487] Early signaling: FALSE
[10:49:49.487] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.487] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.499] Chunk #2 of 2 ... DONE
[10:49:49.499] Launching 2 futures (chunks) ... DONE
[10:49:49.500] Resolving 2 futures (chunks) ...
[10:49:49.532]  - Number of value chunks collected: 2
[10:49:49.532] Resolving 2 futures (chunks) ... DONE
[10:49:49.532] Reducing values from 2 chunks ...
[10:49:49.532]  - Number of values collected after concatenation: 10
[10:49:49.532]  - Number of values expected: 10
[10:49:49.533] Reducing values from 2 chunks ... DONE
[10:49:49.533] future_lapply() ... DONE
> str(y)
List of 10
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
 $ : NULL
> stopifnot(all(sapply(y, FUN = identical, oMaxSize)))
> 
> message("- approximately invariant to chunk size ...")
- approximately invariant to chunk size ...
> maxSize <- sizes[["FUN"]] + sizes[["X"]] / length(X)
> options(future.globals.maxSize = maxSize)
> 
> for (chunk.size in c(1L, 2L, 5L, 10L)) {
+   y <- future_lapply(X, FUN = FUN, future.chunk.size = chunk.size)
+   str(y)
+   stopifnot(all(unlist(y) == maxSize))
+   cat(sprintf("maxSize = %g bytes\nfuture.globals.maxSize = %g bytes\n",
+               maxSize, getOption("future.globals.maxSize")))
+   stopifnot(getOption("future.globals.maxSize") == maxSize)
+ }
[10:49:49.540] future_lapply() ...
[10:49:49.541] Number of chunks: 10
[10:49:49.541] getGlobalsAndPackagesXApply() ...
[10:49:49.541]  - future.globals: TRUE
[10:49:49.543]  - globals found/used: [n=1] ‘FUN’
[10:49:49.543]  - needed namespaces: [n=0] 
[10:49:49.543] Finding globals ... DONE
[10:49:49.543]  - use_args: TRUE
[10:49:49.543]  - Getting '...' globals ...
[10:49:49.544]    - '...' content: [n=0] 
[10:49:49.544] List of 1
[10:49:49.544]  $ ...: list()
[10:49:49.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.544]  - attr(*, "where")=List of 1
[10:49:49.544]   ..$ ...:<environment: 0x55d1caf1ba68> 
[10:49:49.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.544]  - attr(*, "resolved")= logi TRUE
[10:49:49.544]  - attr(*, "total_size")= num NA
[10:49:49.546]  - Getting '...' globals ... DONE
[10:49:49.547] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:49.547] List of 2
[10:49:49.547]  $ ...future.FUN:function (x)  
[10:49:49.547]  $ ...          : list()
[10:49:49.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:49.547]  - attr(*, "where")=List of 2
[10:49:49.547]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:49.547]   ..$ ...          :<environment: 0x55d1caf1ba68> 
[10:49:49.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:49.547]  - attr(*, "resolved")= logi FALSE
[10:49:49.547]  - attr(*, "total_size")= num 4731
[10:49:49.550] Packages to be attached in all futures: [n=0] 
[10:49:49.550] getGlobalsAndPackagesXApply() ... DONE
[10:49:49.550] Number of futures (= number of chunks): 10
[10:49:49.550] Launching 10 futures (chunks) ...
[10:49:49.550] Chunk #1 of 10 ...
[10:49:49.550]  - Finding globals in 'X' for chunk #1 ...
[10:49:49.550]    + additional globals found: [n=0] 
[10:49:49.551]    + additional namespaces needed: [n=0] 
[10:49:49.551]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:49.551]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:49.551]  - seeds: <none>
[10:49:49.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.631] Created future:
[10:49:49.631] MultisessionFuture:
[10:49:49.631] Label: ‘future_lapply-1’
[10:49:49.631] Expression:
[10:49:49.631] {
[10:49:49.631]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.631]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.631]     "# as a global variable                                         "
[10:49:49.631]     do.call(function(...) {
[10:49:49.631]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.631]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.631]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.631]         "# anonymous function.                                          "
[10:49:49.631]         "#                                                              "
[10:49:49.631]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.631]         "# function environment of FUN() to the calling environment.    "
[10:49:49.631]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.631]         "# global environment, which is where globals are written.      "
[10:49:49.631]         penv <- env <- environment(...future.FUN)
[10:49:49.631]         repeat {
[10:49:49.631]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.631]                 emptyenv())) 
[10:49:49.631]                 break
[10:49:49.631]             penv <- env
[10:49:49.631]             env <- parent.env(env)
[10:49:49.631]         }
[10:49:49.631]         if (identical(penv, globalenv())) {
[10:49:49.631]             environment(...future.FUN) <- environment()
[10:49:49.631]         }
[10:49:49.631]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.631]             !isNamespace(penv)) {
[10:49:49.631]             parent.env(penv) <- environment()
[10:49:49.631]         }
[10:49:49.631]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.631]         {
[10:49:49.631]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.631]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.631]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.631]                 on.exit(options(oopts), add = TRUE)
[10:49:49.631]             }
[10:49:49.631]             {
[10:49:49.631]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.631]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.631]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.631]                 })
[10:49:49.631]             }
[10:49:49.631]         }
[10:49:49.631]     }, args = future.call.arguments)
[10:49:49.631] }
[10:49:49.631] Lazy evaluation: FALSE
[10:49:49.631] Asynchronous evaluation: TRUE
[10:49:49.631] Local evaluation: TRUE
[10:49:49.631] Environment: R_GlobalEnv
[10:49:49.631] Capture standard output: TRUE
[10:49:49.631] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.631] Immediate condition classes: ‘immediateCondition’
[10:49:49.631] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:49.631] Packages: <none>
[10:49:49.631] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.631] Resolved: FALSE
[10:49:49.631] Value: <not collected>
[10:49:49.631] Conditions captured: <none>
[10:49:49.631] Early signaling: FALSE
[10:49:49.631] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.631] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.643] Chunk #1 of 10 ... DONE
[10:49:49.643] Chunk #2 of 10 ...
[10:49:49.644]  - Finding globals in 'X' for chunk #2 ...
[10:49:49.644]    + additional globals found: [n=0] 
[10:49:49.644]    + additional namespaces needed: [n=0] 
[10:49:49.644]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:49.644]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:49.644]  - seeds: <none>
[10:49:49.644]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.733] Created future:
[10:49:49.733] MultisessionFuture:
[10:49:49.733] Label: ‘future_lapply-2’
[10:49:49.733] Expression:
[10:49:49.733] {
[10:49:49.733]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.733]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.733]     "# as a global variable                                         "
[10:49:49.733]     do.call(function(...) {
[10:49:49.733]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.733]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.733]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.733]         "# anonymous function.                                          "
[10:49:49.733]         "#                                                              "
[10:49:49.733]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.733]         "# function environment of FUN() to the calling environment.    "
[10:49:49.733]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.733]         "# global environment, which is where globals are written.      "
[10:49:49.733]         penv <- env <- environment(...future.FUN)
[10:49:49.733]         repeat {
[10:49:49.733]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.733]                 emptyenv())) 
[10:49:49.733]                 break
[10:49:49.733]             penv <- env
[10:49:49.733]             env <- parent.env(env)
[10:49:49.733]         }
[10:49:49.733]         if (identical(penv, globalenv())) {
[10:49:49.733]             environment(...future.FUN) <- environment()
[10:49:49.733]         }
[10:49:49.733]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.733]             !isNamespace(penv)) {
[10:49:49.733]             parent.env(penv) <- environment()
[10:49:49.733]         }
[10:49:49.733]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.733]         {
[10:49:49.733]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.733]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.733]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.733]                 on.exit(options(oopts), add = TRUE)
[10:49:49.733]             }
[10:49:49.733]             {
[10:49:49.733]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.733]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.733]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.733]                 })
[10:49:49.733]             }
[10:49:49.733]         }
[10:49:49.733]     }, args = future.call.arguments)
[10:49:49.733] }
[10:49:49.733] Lazy evaluation: FALSE
[10:49:49.733] Asynchronous evaluation: TRUE
[10:49:49.733] Local evaluation: TRUE
[10:49:49.733] Environment: R_GlobalEnv
[10:49:49.733] Capture standard output: TRUE
[10:49:49.733] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.733] Immediate condition classes: ‘immediateCondition’
[10:49:49.733] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:49.733] Packages: <none>
[10:49:49.733] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.733] Resolved: FALSE
[10:49:49.733] Value: <not collected>
[10:49:49.733] Conditions captured: <none>
[10:49:49.733] Early signaling: FALSE
[10:49:49.733] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.733] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.745] Chunk #2 of 10 ... DONE
[10:49:49.745] Chunk #3 of 10 ...
[10:49:49.745]  - Finding globals in 'X' for chunk #3 ...
[10:49:49.746]    + additional globals found: [n=0] 
[10:49:49.746]    + additional namespaces needed: [n=0] 
[10:49:49.746]  - Finding globals in 'X' for chunk #3 ... DONE
[10:49:49.746]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:49.746]  - seeds: <none>
[10:49:49.746]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.838] Created future:
[10:49:49.838] MultisessionFuture:
[10:49:49.838] Label: ‘future_lapply-3’
[10:49:49.838] Expression:
[10:49:49.838] {
[10:49:49.838]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.838]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.838]     "# as a global variable                                         "
[10:49:49.838]     do.call(function(...) {
[10:49:49.838]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.838]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.838]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.838]         "# anonymous function.                                          "
[10:49:49.838]         "#                                                              "
[10:49:49.838]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.838]         "# function environment of FUN() to the calling environment.    "
[10:49:49.838]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.838]         "# global environment, which is where globals are written.      "
[10:49:49.838]         penv <- env <- environment(...future.FUN)
[10:49:49.838]         repeat {
[10:49:49.838]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.838]                 emptyenv())) 
[10:49:49.838]                 break
[10:49:49.838]             penv <- env
[10:49:49.838]             env <- parent.env(env)
[10:49:49.838]         }
[10:49:49.838]         if (identical(penv, globalenv())) {
[10:49:49.838]             environment(...future.FUN) <- environment()
[10:49:49.838]         }
[10:49:49.838]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.838]             !isNamespace(penv)) {
[10:49:49.838]             parent.env(penv) <- environment()
[10:49:49.838]         }
[10:49:49.838]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.838]         {
[10:49:49.838]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.838]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.838]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.838]                 on.exit(options(oopts), add = TRUE)
[10:49:49.838]             }
[10:49:49.838]             {
[10:49:49.838]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.838]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.838]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.838]                 })
[10:49:49.838]             }
[10:49:49.838]         }
[10:49:49.838]     }, args = future.call.arguments)
[10:49:49.838] }
[10:49:49.838] Lazy evaluation: FALSE
[10:49:49.838] Asynchronous evaluation: TRUE
[10:49:49.838] Local evaluation: TRUE
[10:49:49.838] Environment: R_GlobalEnv
[10:49:49.838] Capture standard output: TRUE
[10:49:49.838] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.838] Immediate condition classes: ‘immediateCondition’
[10:49:49.838] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:49.838] Packages: <none>
[10:49:49.838] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.838] Resolved: FALSE
[10:49:49.838] Value: <not collected>
[10:49:49.838] Conditions captured: <none>
[10:49:49.838] Early signaling: FALSE
[10:49:49.838] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.838] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.850] Chunk #3 of 10 ... DONE
[10:49:49.851] Chunk #4 of 10 ...
[10:49:49.851]  - Finding globals in 'X' for chunk #4 ...
[10:49:49.851]    + additional globals found: [n=0] 
[10:49:49.851]    + additional namespaces needed: [n=0] 
[10:49:49.851]  - Finding globals in 'X' for chunk #4 ... DONE
[10:49:49.851]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:49.851]  - seeds: <none>
[10:49:49.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:49.961] Created future:
[10:49:49.961] MultisessionFuture:
[10:49:49.961] Label: ‘future_lapply-4’
[10:49:49.961] Expression:
[10:49:49.961] {
[10:49:49.961]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:49.961]     "# expression in do.call(), because function called uses '...'  "
[10:49:49.961]     "# as a global variable                                         "
[10:49:49.961]     do.call(function(...) {
[10:49:49.961]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:49.961]         "# without having an '...' argument. This means '...' is treated"
[10:49:49.961]         "# as a global variable. This may happen when FUN() is an       "
[10:49:49.961]         "# anonymous function.                                          "
[10:49:49.961]         "#                                                              "
[10:49:49.961]         "# If an anonymous function, we will make sure to restore the   "
[10:49:49.961]         "# function environment of FUN() to the calling environment.    "
[10:49:49.961]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:49.961]         "# global environment, which is where globals are written.      "
[10:49:49.961]         penv <- env <- environment(...future.FUN)
[10:49:49.961]         repeat {
[10:49:49.961]             if (identical(env, globalenv()) || identical(env, 
[10:49:49.961]                 emptyenv())) 
[10:49:49.961]                 break
[10:49:49.961]             penv <- env
[10:49:49.961]             env <- parent.env(env)
[10:49:49.961]         }
[10:49:49.961]         if (identical(penv, globalenv())) {
[10:49:49.961]             environment(...future.FUN) <- environment()
[10:49:49.961]         }
[10:49:49.961]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:49.961]             !isNamespace(penv)) {
[10:49:49.961]             parent.env(penv) <- environment()
[10:49:49.961]         }
[10:49:49.961]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:49.961]         {
[10:49:49.961]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:49.961]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:49.961]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:49.961]                 on.exit(options(oopts), add = TRUE)
[10:49:49.961]             }
[10:49:49.961]             {
[10:49:49.961]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:49.961]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:49.961]                   ...future.FUN(...future.X_jj, ...)
[10:49:49.961]                 })
[10:49:49.961]             }
[10:49:49.961]         }
[10:49:49.961]     }, args = future.call.arguments)
[10:49:49.961] }
[10:49:49.961] Lazy evaluation: FALSE
[10:49:49.961] Asynchronous evaluation: TRUE
[10:49:49.961] Local evaluation: TRUE
[10:49:49.961] Environment: R_GlobalEnv
[10:49:49.961] Capture standard output: TRUE
[10:49:49.961] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:49.961] Immediate condition classes: ‘immediateCondition’
[10:49:49.961] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:49.961] Packages: <none>
[10:49:49.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:49.961] Resolved: FALSE
[10:49:49.961] Value: <not collected>
[10:49:49.961] Conditions captured: <none>
[10:49:49.961] Early signaling: FALSE
[10:49:49.961] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:49.961] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:49.973] Chunk #4 of 10 ... DONE
[10:49:49.974] Chunk #5 of 10 ...
[10:49:49.974]  - Finding globals in 'X' for chunk #5 ...
[10:49:49.974]    + additional globals found: [n=0] 
[10:49:49.974]    + additional namespaces needed: [n=0] 
[10:49:49.974]  - Finding globals in 'X' for chunk #5 ... DONE
[10:49:49.974]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:49.974]  - seeds: <none>
[10:49:49.975]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.075] Created future:
[10:49:50.075] MultisessionFuture:
[10:49:50.075] Label: ‘future_lapply-5’
[10:49:50.075] Expression:
[10:49:50.075] {
[10:49:50.075]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.075]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.075]     "# as a global variable                                         "
[10:49:50.075]     do.call(function(...) {
[10:49:50.075]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.075]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.075]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.075]         "# anonymous function.                                          "
[10:49:50.075]         "#                                                              "
[10:49:50.075]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.075]         "# function environment of FUN() to the calling environment.    "
[10:49:50.075]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.075]         "# global environment, which is where globals are written.      "
[10:49:50.075]         penv <- env <- environment(...future.FUN)
[10:49:50.075]         repeat {
[10:49:50.075]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.075]                 emptyenv())) 
[10:49:50.075]                 break
[10:49:50.075]             penv <- env
[10:49:50.075]             env <- parent.env(env)
[10:49:50.075]         }
[10:49:50.075]         if (identical(penv, globalenv())) {
[10:49:50.075]             environment(...future.FUN) <- environment()
[10:49:50.075]         }
[10:49:50.075]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.075]             !isNamespace(penv)) {
[10:49:50.075]             parent.env(penv) <- environment()
[10:49:50.075]         }
[10:49:50.075]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.075]         {
[10:49:50.075]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.075]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.075]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.075]                 on.exit(options(oopts), add = TRUE)
[10:49:50.075]             }
[10:49:50.075]             {
[10:49:50.075]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.075]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.075]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.075]                 })
[10:49:50.075]             }
[10:49:50.075]         }
[10:49:50.075]     }, args = future.call.arguments)
[10:49:50.075] }
[10:49:50.075] Lazy evaluation: FALSE
[10:49:50.075] Asynchronous evaluation: TRUE
[10:49:50.075] Local evaluation: TRUE
[10:49:50.075] Environment: R_GlobalEnv
[10:49:50.075] Capture standard output: TRUE
[10:49:50.075] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.075] Immediate condition classes: ‘immediateCondition’
[10:49:50.075] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.075] Packages: <none>
[10:49:50.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.075] Resolved: FALSE
[10:49:50.075] Value: <not collected>
[10:49:50.075] Conditions captured: <none>
[10:49:50.075] Early signaling: FALSE
[10:49:50.075] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.075] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.087] Chunk #5 of 10 ... DONE
[10:49:50.088] Chunk #6 of 10 ...
[10:49:50.088]  - Finding globals in 'X' for chunk #6 ...
[10:49:50.088]    + additional globals found: [n=0] 
[10:49:50.088]    + additional namespaces needed: [n=0] 
[10:49:50.088]  - Finding globals in 'X' for chunk #6 ... DONE
[10:49:50.088]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:50.089]  - seeds: <none>
[10:49:50.089]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.180] Created future:
[10:49:50.180] MultisessionFuture:
[10:49:50.180] Label: ‘future_lapply-6’
[10:49:50.180] Expression:
[10:49:50.180] {
[10:49:50.180]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.180]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.180]     "# as a global variable                                         "
[10:49:50.180]     do.call(function(...) {
[10:49:50.180]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.180]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.180]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.180]         "# anonymous function.                                          "
[10:49:50.180]         "#                                                              "
[10:49:50.180]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.180]         "# function environment of FUN() to the calling environment.    "
[10:49:50.180]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.180]         "# global environment, which is where globals are written.      "
[10:49:50.180]         penv <- env <- environment(...future.FUN)
[10:49:50.180]         repeat {
[10:49:50.180]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.180]                 emptyenv())) 
[10:49:50.180]                 break
[10:49:50.180]             penv <- env
[10:49:50.180]             env <- parent.env(env)
[10:49:50.180]         }
[10:49:50.180]         if (identical(penv, globalenv())) {
[10:49:50.180]             environment(...future.FUN) <- environment()
[10:49:50.180]         }
[10:49:50.180]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.180]             !isNamespace(penv)) {
[10:49:50.180]             parent.env(penv) <- environment()
[10:49:50.180]         }
[10:49:50.180]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.180]         {
[10:49:50.180]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.180]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.180]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.180]                 on.exit(options(oopts), add = TRUE)
[10:49:50.180]             }
[10:49:50.180]             {
[10:49:50.180]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.180]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.180]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.180]                 })
[10:49:50.180]             }
[10:49:50.180]         }
[10:49:50.180]     }, args = future.call.arguments)
[10:49:50.180] }
[10:49:50.180] Lazy evaluation: FALSE
[10:49:50.180] Asynchronous evaluation: TRUE
[10:49:50.180] Local evaluation: TRUE
[10:49:50.180] Environment: R_GlobalEnv
[10:49:50.180] Capture standard output: TRUE
[10:49:50.180] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.180] Immediate condition classes: ‘immediateCondition’
[10:49:50.180] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.180] Packages: <none>
[10:49:50.180] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.180] Resolved: FALSE
[10:49:50.180] Value: <not collected>
[10:49:50.180] Conditions captured: <none>
[10:49:50.180] Early signaling: FALSE
[10:49:50.180] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.180] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.192] Chunk #6 of 10 ... DONE
[10:49:50.192] Chunk #7 of 10 ...
[10:49:50.193]  - Finding globals in 'X' for chunk #7 ...
[10:49:50.193]    + additional globals found: [n=0] 
[10:49:50.193]    + additional namespaces needed: [n=0] 
[10:49:50.193]  - Finding globals in 'X' for chunk #7 ... DONE
[10:49:50.193]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:50.193]  - seeds: <none>
[10:49:50.194]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.286] Created future:
[10:49:50.287] MultisessionFuture:
[10:49:50.287] Label: ‘future_lapply-7’
[10:49:50.287] Expression:
[10:49:50.287] {
[10:49:50.287]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.287]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.287]     "# as a global variable                                         "
[10:49:50.287]     do.call(function(...) {
[10:49:50.287]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.287]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.287]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.287]         "# anonymous function.                                          "
[10:49:50.287]         "#                                                              "
[10:49:50.287]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.287]         "# function environment of FUN() to the calling environment.    "
[10:49:50.287]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.287]         "# global environment, which is where globals are written.      "
[10:49:50.287]         penv <- env <- environment(...future.FUN)
[10:49:50.287]         repeat {
[10:49:50.287]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.287]                 emptyenv())) 
[10:49:50.287]                 break
[10:49:50.287]             penv <- env
[10:49:50.287]             env <- parent.env(env)
[10:49:50.287]         }
[10:49:50.287]         if (identical(penv, globalenv())) {
[10:49:50.287]             environment(...future.FUN) <- environment()
[10:49:50.287]         }
[10:49:50.287]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.287]             !isNamespace(penv)) {
[10:49:50.287]             parent.env(penv) <- environment()
[10:49:50.287]         }
[10:49:50.287]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.287]         {
[10:49:50.287]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.287]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.287]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.287]                 on.exit(options(oopts), add = TRUE)
[10:49:50.287]             }
[10:49:50.287]             {
[10:49:50.287]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.287]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.287]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.287]                 })
[10:49:50.287]             }
[10:49:50.287]         }
[10:49:50.287]     }, args = future.call.arguments)
[10:49:50.287] }
[10:49:50.287] Lazy evaluation: FALSE
[10:49:50.287] Asynchronous evaluation: TRUE
[10:49:50.287] Local evaluation: TRUE
[10:49:50.287] Environment: R_GlobalEnv
[10:49:50.287] Capture standard output: TRUE
[10:49:50.287] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.287] Immediate condition classes: ‘immediateCondition’
[10:49:50.287] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.287] Packages: <none>
[10:49:50.287] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.287] Resolved: FALSE
[10:49:50.287] Value: <not collected>
[10:49:50.287] Conditions captured: <none>
[10:49:50.287] Early signaling: FALSE
[10:49:50.287] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.287] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.298] Chunk #7 of 10 ... DONE
[10:49:50.299] Chunk #8 of 10 ...
[10:49:50.299]  - Finding globals in 'X' for chunk #8 ...
[10:49:50.299]    + additional globals found: [n=0] 
[10:49:50.299]    + additional namespaces needed: [n=0] 
[10:49:50.299]  - Finding globals in 'X' for chunk #8 ... DONE
[10:49:50.299]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:50.300]  - seeds: <none>
[10:49:50.300]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.394] Created future:
[10:49:50.395] MultisessionFuture:
[10:49:50.395] Label: ‘future_lapply-8’
[10:49:50.395] Expression:
[10:49:50.395] {
[10:49:50.395]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.395]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.395]     "# as a global variable                                         "
[10:49:50.395]     do.call(function(...) {
[10:49:50.395]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.395]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.395]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.395]         "# anonymous function.                                          "
[10:49:50.395]         "#                                                              "
[10:49:50.395]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.395]         "# function environment of FUN() to the calling environment.    "
[10:49:50.395]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.395]         "# global environment, which is where globals are written.      "
[10:49:50.395]         penv <- env <- environment(...future.FUN)
[10:49:50.395]         repeat {
[10:49:50.395]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.395]                 emptyenv())) 
[10:49:50.395]                 break
[10:49:50.395]             penv <- env
[10:49:50.395]             env <- parent.env(env)
[10:49:50.395]         }
[10:49:50.395]         if (identical(penv, globalenv())) {
[10:49:50.395]             environment(...future.FUN) <- environment()
[10:49:50.395]         }
[10:49:50.395]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.395]             !isNamespace(penv)) {
[10:49:50.395]             parent.env(penv) <- environment()
[10:49:50.395]         }
[10:49:50.395]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.395]         {
[10:49:50.395]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.395]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.395]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.395]                 on.exit(options(oopts), add = TRUE)
[10:49:50.395]             }
[10:49:50.395]             {
[10:49:50.395]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.395]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.395]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.395]                 })
[10:49:50.395]             }
[10:49:50.395]         }
[10:49:50.395]     }, args = future.call.arguments)
[10:49:50.395] }
[10:49:50.395] Lazy evaluation: FALSE
[10:49:50.395] Asynchronous evaluation: TRUE
[10:49:50.395] Local evaluation: TRUE
[10:49:50.395] Environment: R_GlobalEnv
[10:49:50.395] Capture standard output: TRUE
[10:49:50.395] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.395] Immediate condition classes: ‘immediateCondition’
[10:49:50.395] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.395] Packages: <none>
[10:49:50.395] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.395] Resolved: FALSE
[10:49:50.395] Value: <not collected>
[10:49:50.395] Conditions captured: <none>
[10:49:50.395] Early signaling: FALSE
[10:49:50.395] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.395] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.407] Chunk #8 of 10 ... DONE
[10:49:50.407] Chunk #9 of 10 ...
[10:49:50.407]  - Finding globals in 'X' for chunk #9 ...
[10:49:50.407]    + additional globals found: [n=0] 
[10:49:50.407]    + additional namespaces needed: [n=0] 
[10:49:50.407]  - Finding globals in 'X' for chunk #9 ... DONE
[10:49:50.408]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:50.408]  - seeds: <none>
[10:49:50.408]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.499] Created future:
[10:49:50.499] MultisessionFuture:
[10:49:50.499] Label: ‘future_lapply-9’
[10:49:50.499] Expression:
[10:49:50.499] {
[10:49:50.499]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.499]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.499]     "# as a global variable                                         "
[10:49:50.499]     do.call(function(...) {
[10:49:50.499]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.499]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.499]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.499]         "# anonymous function.                                          "
[10:49:50.499]         "#                                                              "
[10:49:50.499]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.499]         "# function environment of FUN() to the calling environment.    "
[10:49:50.499]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.499]         "# global environment, which is where globals are written.      "
[10:49:50.499]         penv <- env <- environment(...future.FUN)
[10:49:50.499]         repeat {
[10:49:50.499]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.499]                 emptyenv())) 
[10:49:50.499]                 break
[10:49:50.499]             penv <- env
[10:49:50.499]             env <- parent.env(env)
[10:49:50.499]         }
[10:49:50.499]         if (identical(penv, globalenv())) {
[10:49:50.499]             environment(...future.FUN) <- environment()
[10:49:50.499]         }
[10:49:50.499]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.499]             !isNamespace(penv)) {
[10:49:50.499]             parent.env(penv) <- environment()
[10:49:50.499]         }
[10:49:50.499]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.499]         {
[10:49:50.499]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.499]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.499]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.499]                 on.exit(options(oopts), add = TRUE)
[10:49:50.499]             }
[10:49:50.499]             {
[10:49:50.499]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.499]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.499]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.499]                 })
[10:49:50.499]             }
[10:49:50.499]         }
[10:49:50.499]     }, args = future.call.arguments)
[10:49:50.499] }
[10:49:50.499] Lazy evaluation: FALSE
[10:49:50.499] Asynchronous evaluation: TRUE
[10:49:50.499] Local evaluation: TRUE
[10:49:50.499] Environment: R_GlobalEnv
[10:49:50.499] Capture standard output: TRUE
[10:49:50.499] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.499] Immediate condition classes: ‘immediateCondition’
[10:49:50.499] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.499] Packages: <none>
[10:49:50.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.499] Resolved: FALSE
[10:49:50.499] Value: <not collected>
[10:49:50.499] Conditions captured: <none>
[10:49:50.499] Early signaling: FALSE
[10:49:50.499] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.499] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.511] Chunk #9 of 10 ... DONE
[10:49:50.511] Chunk #10 of 10 ...
[10:49:50.512]  - Finding globals in 'X' for chunk #10 ...
[10:49:50.512]    + additional globals found: [n=0] 
[10:49:50.512]    + additional namespaces needed: [n=0] 
[10:49:50.512]  - Finding globals in 'X' for chunk #10 ... DONE
[10:49:50.512]  - Adjusted option 'future.globals.maxSize': 2306 -> 10 * 2306 = 23056 (bytes)
[10:49:50.512]  - seeds: <none>
[10:49:50.512]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.611] Created future:
[10:49:50.611] MultisessionFuture:
[10:49:50.611] Label: ‘future_lapply-10’
[10:49:50.611] Expression:
[10:49:50.611] {
[10:49:50.611]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.611]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.611]     "# as a global variable                                         "
[10:49:50.611]     do.call(function(...) {
[10:49:50.611]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.611]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.611]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.611]         "# anonymous function.                                          "
[10:49:50.611]         "#                                                              "
[10:49:50.611]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.611]         "# function environment of FUN() to the calling environment.    "
[10:49:50.611]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.611]         "# global environment, which is where globals are written.      "
[10:49:50.611]         penv <- env <- environment(...future.FUN)
[10:49:50.611]         repeat {
[10:49:50.611]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.611]                 emptyenv())) 
[10:49:50.611]                 break
[10:49:50.611]             penv <- env
[10:49:50.611]             env <- parent.env(env)
[10:49:50.611]         }
[10:49:50.611]         if (identical(penv, globalenv())) {
[10:49:50.611]             environment(...future.FUN) <- environment()
[10:49:50.611]         }
[10:49:50.611]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.611]             !isNamespace(penv)) {
[10:49:50.611]             parent.env(penv) <- environment()
[10:49:50.611]         }
[10:49:50.611]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.611]         {
[10:49:50.611]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.611]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.611]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.611]                 on.exit(options(oopts), add = TRUE)
[10:49:50.611]             }
[10:49:50.611]             {
[10:49:50.611]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.611]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.611]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.611]                 })
[10:49:50.611]             }
[10:49:50.611]         }
[10:49:50.611]     }, args = future.call.arguments)
[10:49:50.611] }
[10:49:50.611] Lazy evaluation: FALSE
[10:49:50.611] Asynchronous evaluation: TRUE
[10:49:50.611] Local evaluation: TRUE
[10:49:50.611] Environment: R_GlobalEnv
[10:49:50.611] Capture standard output: TRUE
[10:49:50.611] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.611] Immediate condition classes: ‘immediateCondition’
[10:49:50.611] Globals: 5 objects totaling 711 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 141 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.611] Packages: <none>
[10:49:50.611] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.611] Resolved: FALSE
[10:49:50.611] Value: <not collected>
[10:49:50.611] Conditions captured: <none>
[10:49:50.611] Early signaling: FALSE
[10:49:50.611] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.611] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.623] Chunk #10 of 10 ... DONE
[10:49:50.623] Launching 10 futures (chunks) ... DONE
[10:49:50.623] Resolving 10 futures (chunks) ...
[10:49:50.656]  - Number of value chunks collected: 10
[10:49:50.656] Resolving 10 futures (chunks) ... DONE
[10:49:50.656] Reducing values from 10 chunks ...
[10:49:50.656]  - Number of values collected after concatenation: 10
[10:49:50.656]  - Number of values expected: 10
[10:49:50.657] Reducing values from 10 chunks ... DONE
[10:49:50.657] future_lapply() ... DONE
List of 10
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
maxSize = 2305.6 bytes
future.globals.maxSize = 2305.6 bytes
[10:49:50.660] future_lapply() ...
[10:49:50.661] Number of chunks: 5
[10:49:50.661] getGlobalsAndPackagesXApply() ...
[10:49:50.661]  - future.globals: TRUE
[10:49:50.663]  - globals found/used: [n=1] ‘FUN’
[10:49:50.663]  - needed namespaces: [n=0] 
[10:49:50.663] Finding globals ... DONE
[10:49:50.664]  - use_args: TRUE
[10:49:50.664]  - Getting '...' globals ...
[10:49:50.664]    - '...' content: [n=0] 
[10:49:50.664] List of 1
[10:49:50.664]  $ ...: list()
[10:49:50.664]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:50.664]  - attr(*, "where")=List of 1
[10:49:50.664]   ..$ ...:<environment: 0x55d1ccd5e410> 
[10:49:50.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:50.664]  - attr(*, "resolved")= logi TRUE
[10:49:50.664]  - attr(*, "total_size")= num NA
[10:49:50.667]  - Getting '...' globals ... DONE
[10:49:50.667] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:50.667] List of 2
[10:49:50.667]  $ ...future.FUN:function (x)  
[10:49:50.667]  $ ...          : list()
[10:49:50.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:50.667]  - attr(*, "where")=List of 2
[10:49:50.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:50.667]   ..$ ...          :<environment: 0x55d1ccd5e410> 
[10:49:50.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:50.667]  - attr(*, "resolved")= logi FALSE
[10:49:50.667]  - attr(*, "total_size")= num 4731
[10:49:50.670] Packages to be attached in all futures: [n=0] 
[10:49:50.670] getGlobalsAndPackagesXApply() ... DONE
[10:49:50.670] Number of futures (= number of chunks): 5
[10:49:50.670] Launching 5 futures (chunks) ...
[10:49:50.670] Chunk #1 of 5 ...
[10:49:50.670]  - Finding globals in 'X' for chunk #1 ...
[10:49:50.671]    + additional globals found: [n=0] 
[10:49:50.671]    + additional namespaces needed: [n=0] 
[10:49:50.671]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:50.671]  - Adjusted option 'future.globals.maxSize': 2306 -> 5 * 2306 = 11528 (bytes)
[10:49:50.671]  - seeds: <none>
[10:49:50.671]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.753] Created future:
[10:49:50.753] MultisessionFuture:
[10:49:50.753] Label: ‘future_lapply-1’
[10:49:50.753] Expression:
[10:49:50.753] {
[10:49:50.753]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.753]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.753]     "# as a global variable                                         "
[10:49:50.753]     do.call(function(...) {
[10:49:50.753]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.753]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.753]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.753]         "# anonymous function.                                          "
[10:49:50.753]         "#                                                              "
[10:49:50.753]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.753]         "# function environment of FUN() to the calling environment.    "
[10:49:50.753]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.753]         "# global environment, which is where globals are written.      "
[10:49:50.753]         penv <- env <- environment(...future.FUN)
[10:49:50.753]         repeat {
[10:49:50.753]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.753]                 emptyenv())) 
[10:49:50.753]                 break
[10:49:50.753]             penv <- env
[10:49:50.753]             env <- parent.env(env)
[10:49:50.753]         }
[10:49:50.753]         if (identical(penv, globalenv())) {
[10:49:50.753]             environment(...future.FUN) <- environment()
[10:49:50.753]         }
[10:49:50.753]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.753]             !isNamespace(penv)) {
[10:49:50.753]             parent.env(penv) <- environment()
[10:49:50.753]         }
[10:49:50.753]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.753]         {
[10:49:50.753]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.753]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.753]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.753]                 on.exit(options(oopts), add = TRUE)
[10:49:50.753]             }
[10:49:50.753]             {
[10:49:50.753]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.753]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.753]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.753]                 })
[10:49:50.753]             }
[10:49:50.753]         }
[10:49:50.753]     }, args = future.call.arguments)
[10:49:50.753] }
[10:49:50.753] Lazy evaluation: FALSE
[10:49:50.753] Asynchronous evaluation: TRUE
[10:49:50.753] Local evaluation: TRUE
[10:49:50.753] Environment: R_GlobalEnv
[10:49:50.753] Capture standard output: TRUE
[10:49:50.753] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.753] Immediate condition classes: ‘immediateCondition’
[10:49:50.753] Globals: 5 objects totaling 787 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 217 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.753] Packages: <none>
[10:49:50.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.753] Resolved: FALSE
[10:49:50.753] Value: <not collected>
[10:49:50.753] Conditions captured: <none>
[10:49:50.753] Early signaling: FALSE
[10:49:50.753] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.753] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.765] Chunk #1 of 5 ... DONE
[10:49:50.765] Chunk #2 of 5 ...
[10:49:50.765]  - Finding globals in 'X' for chunk #2 ...
[10:49:50.766]    + additional globals found: [n=0] 
[10:49:50.766]    + additional namespaces needed: [n=0] 
[10:49:50.766]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:50.766]  - Adjusted option 'future.globals.maxSize': 2306 -> 5 * 2306 = 11528 (bytes)
[10:49:50.766]  - seeds: <none>
[10:49:50.766]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.847] Created future:
[10:49:50.847] MultisessionFuture:
[10:49:50.847] Label: ‘future_lapply-2’
[10:49:50.847] Expression:
[10:49:50.847] {
[10:49:50.847]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.847]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.847]     "# as a global variable                                         "
[10:49:50.847]     do.call(function(...) {
[10:49:50.847]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.847]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.847]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.847]         "# anonymous function.                                          "
[10:49:50.847]         "#                                                              "
[10:49:50.847]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.847]         "# function environment of FUN() to the calling environment.    "
[10:49:50.847]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.847]         "# global environment, which is where globals are written.      "
[10:49:50.847]         penv <- env <- environment(...future.FUN)
[10:49:50.847]         repeat {
[10:49:50.847]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.847]                 emptyenv())) 
[10:49:50.847]                 break
[10:49:50.847]             penv <- env
[10:49:50.847]             env <- parent.env(env)
[10:49:50.847]         }
[10:49:50.847]         if (identical(penv, globalenv())) {
[10:49:50.847]             environment(...future.FUN) <- environment()
[10:49:50.847]         }
[10:49:50.847]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.847]             !isNamespace(penv)) {
[10:49:50.847]             parent.env(penv) <- environment()
[10:49:50.847]         }
[10:49:50.847]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.847]         {
[10:49:50.847]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.847]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.847]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.847]                 on.exit(options(oopts), add = TRUE)
[10:49:50.847]             }
[10:49:50.847]             {
[10:49:50.847]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.847]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.847]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.847]                 })
[10:49:50.847]             }
[10:49:50.847]         }
[10:49:50.847]     }, args = future.call.arguments)
[10:49:50.847] }
[10:49:50.847] Lazy evaluation: FALSE
[10:49:50.847] Asynchronous evaluation: TRUE
[10:49:50.847] Local evaluation: TRUE
[10:49:50.847] Environment: R_GlobalEnv
[10:49:50.847] Capture standard output: TRUE
[10:49:50.847] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.847] Immediate condition classes: ‘immediateCondition’
[10:49:50.847] Globals: 5 objects totaling 787 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 217 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.847] Packages: <none>
[10:49:50.847] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.847] Resolved: FALSE
[10:49:50.847] Value: <not collected>
[10:49:50.847] Conditions captured: <none>
[10:49:50.847] Early signaling: FALSE
[10:49:50.847] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.847] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.859] Chunk #2 of 5 ... DONE
[10:49:50.860] Chunk #3 of 5 ...
[10:49:50.860]  - Finding globals in 'X' for chunk #3 ...
[10:49:50.860]    + additional globals found: [n=0] 
[10:49:50.860]    + additional namespaces needed: [n=0] 
[10:49:50.860]  - Finding globals in 'X' for chunk #3 ... DONE
[10:49:50.860]  - Adjusted option 'future.globals.maxSize': 2306 -> 5 * 2306 = 11528 (bytes)
[10:49:50.860]  - seeds: <none>
[10:49:50.861]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:50.952] Created future:
[10:49:50.952] MultisessionFuture:
[10:49:50.952] Label: ‘future_lapply-3’
[10:49:50.952] Expression:
[10:49:50.952] {
[10:49:50.952]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:50.952]     "# expression in do.call(), because function called uses '...'  "
[10:49:50.952]     "# as a global variable                                         "
[10:49:50.952]     do.call(function(...) {
[10:49:50.952]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:50.952]         "# without having an '...' argument. This means '...' is treated"
[10:49:50.952]         "# as a global variable. This may happen when FUN() is an       "
[10:49:50.952]         "# anonymous function.                                          "
[10:49:50.952]         "#                                                              "
[10:49:50.952]         "# If an anonymous function, we will make sure to restore the   "
[10:49:50.952]         "# function environment of FUN() to the calling environment.    "
[10:49:50.952]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:50.952]         "# global environment, which is where globals are written.      "
[10:49:50.952]         penv <- env <- environment(...future.FUN)
[10:49:50.952]         repeat {
[10:49:50.952]             if (identical(env, globalenv()) || identical(env, 
[10:49:50.952]                 emptyenv())) 
[10:49:50.952]                 break
[10:49:50.952]             penv <- env
[10:49:50.952]             env <- parent.env(env)
[10:49:50.952]         }
[10:49:50.952]         if (identical(penv, globalenv())) {
[10:49:50.952]             environment(...future.FUN) <- environment()
[10:49:50.952]         }
[10:49:50.952]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:50.952]             !isNamespace(penv)) {
[10:49:50.952]             parent.env(penv) <- environment()
[10:49:50.952]         }
[10:49:50.952]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:50.952]         {
[10:49:50.952]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:50.952]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:50.952]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:50.952]                 on.exit(options(oopts), add = TRUE)
[10:49:50.952]             }
[10:49:50.952]             {
[10:49:50.952]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:50.952]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:50.952]                   ...future.FUN(...future.X_jj, ...)
[10:49:50.952]                 })
[10:49:50.952]             }
[10:49:50.952]         }
[10:49:50.952]     }, args = future.call.arguments)
[10:49:50.952] }
[10:49:50.952] Lazy evaluation: FALSE
[10:49:50.952] Asynchronous evaluation: TRUE
[10:49:50.952] Local evaluation: TRUE
[10:49:50.952] Environment: R_GlobalEnv
[10:49:50.952] Capture standard output: TRUE
[10:49:50.952] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:50.952] Immediate condition classes: ‘immediateCondition’
[10:49:50.952] Globals: 5 objects totaling 787 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 217 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:50.952] Packages: <none>
[10:49:50.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:50.952] Resolved: FALSE
[10:49:50.952] Value: <not collected>
[10:49:50.952] Conditions captured: <none>
[10:49:50.952] Early signaling: FALSE
[10:49:50.952] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:50.952] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:50.964] Chunk #3 of 5 ... DONE
[10:49:50.964] Chunk #4 of 5 ...
[10:49:50.964]  - Finding globals in 'X' for chunk #4 ...
[10:49:50.965]    + additional globals found: [n=0] 
[10:49:50.965]    + additional namespaces needed: [n=0] 
[10:49:50.965]  - Finding globals in 'X' for chunk #4 ... DONE
[10:49:50.965]  - Adjusted option 'future.globals.maxSize': 2306 -> 5 * 2306 = 11528 (bytes)
[10:49:50.965]  - seeds: <none>
[10:49:50.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:51.057] Created future:
[10:49:51.057] MultisessionFuture:
[10:49:51.057] Label: ‘future_lapply-4’
[10:49:51.057] Expression:
[10:49:51.057] {
[10:49:51.057]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:51.057]     "# expression in do.call(), because function called uses '...'  "
[10:49:51.057]     "# as a global variable                                         "
[10:49:51.057]     do.call(function(...) {
[10:49:51.057]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:51.057]         "# without having an '...' argument. This means '...' is treated"
[10:49:51.057]         "# as a global variable. This may happen when FUN() is an       "
[10:49:51.057]         "# anonymous function.                                          "
[10:49:51.057]         "#                                                              "
[10:49:51.057]         "# If an anonymous function, we will make sure to restore the   "
[10:49:51.057]         "# function environment of FUN() to the calling environment.    "
[10:49:51.057]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:51.057]         "# global environment, which is where globals are written.      "
[10:49:51.057]         penv <- env <- environment(...future.FUN)
[10:49:51.057]         repeat {
[10:49:51.057]             if (identical(env, globalenv()) || identical(env, 
[10:49:51.057]                 emptyenv())) 
[10:49:51.057]                 break
[10:49:51.057]             penv <- env
[10:49:51.057]             env <- parent.env(env)
[10:49:51.057]         }
[10:49:51.057]         if (identical(penv, globalenv())) {
[10:49:51.057]             environment(...future.FUN) <- environment()
[10:49:51.057]         }
[10:49:51.057]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:51.057]             !isNamespace(penv)) {
[10:49:51.057]             parent.env(penv) <- environment()
[10:49:51.057]         }
[10:49:51.057]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:51.057]         {
[10:49:51.057]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:51.057]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:51.057]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:51.057]                 on.exit(options(oopts), add = TRUE)
[10:49:51.057]             }
[10:49:51.057]             {
[10:49:51.057]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:51.057]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:51.057]                   ...future.FUN(...future.X_jj, ...)
[10:49:51.057]                 })
[10:49:51.057]             }
[10:49:51.057]         }
[10:49:51.057]     }, args = future.call.arguments)
[10:49:51.057] }
[10:49:51.057] Lazy evaluation: FALSE
[10:49:51.057] Asynchronous evaluation: TRUE
[10:49:51.057] Local evaluation: TRUE
[10:49:51.057] Environment: R_GlobalEnv
[10:49:51.057] Capture standard output: TRUE
[10:49:51.057] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:51.057] Immediate condition classes: ‘immediateCondition’
[10:49:51.057] Globals: 5 objects totaling 787 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 217 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:51.057] Packages: <none>
[10:49:51.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:51.057] Resolved: FALSE
[10:49:51.057] Value: <not collected>
[10:49:51.057] Conditions captured: <none>
[10:49:51.057] Early signaling: FALSE
[10:49:51.057] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:51.057] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:51.069] Chunk #4 of 5 ... DONE
[10:49:51.069] Chunk #5 of 5 ...
[10:49:51.069]  - Finding globals in 'X' for chunk #5 ...
[10:49:51.070]    + additional globals found: [n=0] 
[10:49:51.070]    + additional namespaces needed: [n=0] 
[10:49:51.070]  - Finding globals in 'X' for chunk #5 ... DONE
[10:49:51.070]  - Adjusted option 'future.globals.maxSize': 2306 -> 5 * 2306 = 11528 (bytes)
[10:49:51.070]  - seeds: <none>
[10:49:51.070]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:51.163] Created future:
[10:49:51.163] MultisessionFuture:
[10:49:51.163] Label: ‘future_lapply-5’
[10:49:51.163] Expression:
[10:49:51.163] {
[10:49:51.163]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:51.163]     "# expression in do.call(), because function called uses '...'  "
[10:49:51.163]     "# as a global variable                                         "
[10:49:51.163]     do.call(function(...) {
[10:49:51.163]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:51.163]         "# without having an '...' argument. This means '...' is treated"
[10:49:51.163]         "# as a global variable. This may happen when FUN() is an       "
[10:49:51.163]         "# anonymous function.                                          "
[10:49:51.163]         "#                                                              "
[10:49:51.163]         "# If an anonymous function, we will make sure to restore the   "
[10:49:51.163]         "# function environment of FUN() to the calling environment.    "
[10:49:51.163]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:51.163]         "# global environment, which is where globals are written.      "
[10:49:51.163]         penv <- env <- environment(...future.FUN)
[10:49:51.163]         repeat {
[10:49:51.163]             if (identical(env, globalenv()) || identical(env, 
[10:49:51.163]                 emptyenv())) 
[10:49:51.163]                 break
[10:49:51.163]             penv <- env
[10:49:51.163]             env <- parent.env(env)
[10:49:51.163]         }
[10:49:51.163]         if (identical(penv, globalenv())) {
[10:49:51.163]             environment(...future.FUN) <- environment()
[10:49:51.163]         }
[10:49:51.163]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:51.163]             !isNamespace(penv)) {
[10:49:51.163]             parent.env(penv) <- environment()
[10:49:51.163]         }
[10:49:51.163]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:51.163]         {
[10:49:51.163]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:51.163]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:51.163]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:51.163]                 on.exit(options(oopts), add = TRUE)
[10:49:51.163]             }
[10:49:51.163]             {
[10:49:51.163]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:51.163]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:51.163]                   ...future.FUN(...future.X_jj, ...)
[10:49:51.163]                 })
[10:49:51.163]             }
[10:49:51.163]         }
[10:49:51.163]     }, args = future.call.arguments)
[10:49:51.163] }
[10:49:51.163] Lazy evaluation: FALSE
[10:49:51.163] Asynchronous evaluation: TRUE
[10:49:51.163] Local evaluation: TRUE
[10:49:51.163] Environment: R_GlobalEnv
[10:49:51.163] Capture standard output: TRUE
[10:49:51.163] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:51.163] Immediate condition classes: ‘immediateCondition’
[10:49:51.163] Globals: 5 objects totaling 787 bytes (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 217 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:51.163] Packages: <none>
[10:49:51.163] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:51.163] Resolved: FALSE
[10:49:51.163] Value: <not collected>
[10:49:51.163] Conditions captured: <none>
[10:49:51.163] Early signaling: FALSE
[10:49:51.163] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:51.163] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:51.175] Chunk #5 of 5 ... DONE
[10:49:51.175] Launching 5 futures (chunks) ... DONE
[10:49:51.175] Resolving 5 futures (chunks) ...
[10:49:51.220]  - Number of value chunks collected: 5
[10:49:51.220] Resolving 5 futures (chunks) ... DONE
[10:49:51.220] Reducing values from 5 chunks ...
[10:49:51.220]  - Number of values collected after concatenation: 10
[10:49:51.220]  - Number of values expected: 10
[10:49:51.220] Reducing values from 5 chunks ... DONE
[10:49:51.220] future_lapply() ... DONE
List of 10
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
maxSize = 2305.6 bytes
future.globals.maxSize = 2305.6 bytes
[10:49:51.224] future_lapply() ...
[10:49:51.225] Number of chunks: 2
[10:49:51.225] getGlobalsAndPackagesXApply() ...
[10:49:51.225]  - future.globals: TRUE
[10:49:51.227]  - globals found/used: [n=1] ‘FUN’
[10:49:51.227]  - needed namespaces: [n=0] 
[10:49:51.227] Finding globals ... DONE
[10:49:51.227]  - use_args: TRUE
[10:49:51.227]  - Getting '...' globals ...
[10:49:51.228]    - '...' content: [n=0] 
[10:49:51.228] List of 1
[10:49:51.228]  $ ...: list()
[10:49:51.228]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.228]  - attr(*, "where")=List of 1
[10:49:51.228]   ..$ ...:<environment: 0x55d1ced33e70> 
[10:49:51.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.228]  - attr(*, "resolved")= logi TRUE
[10:49:51.228]  - attr(*, "total_size")= num NA
[10:49:51.230]  - Getting '...' globals ... DONE
[10:49:51.230] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:51.230] List of 2
[10:49:51.230]  $ ...future.FUN:function (x)  
[10:49:51.230]  $ ...          : list()
[10:49:51.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.230]  - attr(*, "where")=List of 2
[10:49:51.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:51.230]   ..$ ...          :<environment: 0x55d1ced33e70> 
[10:49:51.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.230]  - attr(*, "resolved")= logi FALSE
[10:49:51.230]  - attr(*, "total_size")= num 4731
[10:49:51.233] Packages to be attached in all futures: [n=0] 
[10:49:51.233] getGlobalsAndPackagesXApply() ... DONE
[10:49:51.233] Number of futures (= number of chunks): 2
[10:49:51.234] Launching 2 futures (chunks) ...
[10:49:51.234] Chunk #1 of 2 ...
[10:49:51.234]  - Finding globals in 'X' for chunk #1 ...
[10:49:51.234]    + additional globals found: [n=0] 
[10:49:51.234]    + additional namespaces needed: [n=0] 
[10:49:51.234]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:51.234]  - Adjusted option 'future.globals.maxSize': 2306 -> 2 * 2306 = 4611 (bytes)
[10:49:51.234]  - seeds: <none>
[10:49:51.235]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:51.319] Created future:
[10:49:51.319] MultisessionFuture:
[10:49:51.319] Label: ‘future_lapply-1’
[10:49:51.319] Expression:
[10:49:51.319] {
[10:49:51.319]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:51.319]     "# expression in do.call(), because function called uses '...'  "
[10:49:51.319]     "# as a global variable                                         "
[10:49:51.319]     do.call(function(...) {
[10:49:51.319]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:51.319]         "# without having an '...' argument. This means '...' is treated"
[10:49:51.319]         "# as a global variable. This may happen when FUN() is an       "
[10:49:51.319]         "# anonymous function.                                          "
[10:49:51.319]         "#                                                              "
[10:49:51.319]         "# If an anonymous function, we will make sure to restore the   "
[10:49:51.319]         "# function environment of FUN() to the calling environment.    "
[10:49:51.319]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:51.319]         "# global environment, which is where globals are written.      "
[10:49:51.319]         penv <- env <- environment(...future.FUN)
[10:49:51.319]         repeat {
[10:49:51.319]             if (identical(env, globalenv()) || identical(env, 
[10:49:51.319]                 emptyenv())) 
[10:49:51.319]                 break
[10:49:51.319]             penv <- env
[10:49:51.319]             env <- parent.env(env)
[10:49:51.319]         }
[10:49:51.319]         if (identical(penv, globalenv())) {
[10:49:51.319]             environment(...future.FUN) <- environment()
[10:49:51.319]         }
[10:49:51.319]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:51.319]             !isNamespace(penv)) {
[10:49:51.319]             parent.env(penv) <- environment()
[10:49:51.319]         }
[10:49:51.319]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:51.319]         {
[10:49:51.319]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:51.319]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:51.319]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:51.319]                 on.exit(options(oopts), add = TRUE)
[10:49:51.319]             }
[10:49:51.319]             {
[10:49:51.319]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:51.319]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:51.319]                   ...future.FUN(...future.X_jj, ...)
[10:49:51.319]                 })
[10:49:51.319]             }
[10:49:51.319]         }
[10:49:51.319]     }, args = future.call.arguments)
[10:49:51.319] }
[10:49:51.319] Lazy evaluation: FALSE
[10:49:51.319] Asynchronous evaluation: TRUE
[10:49:51.319] Local evaluation: TRUE
[10:49:51.319] Environment: R_GlobalEnv
[10:49:51.319] Capture standard output: TRUE
[10:49:51.319] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:51.319] Immediate condition classes: ‘immediateCondition’
[10:49:51.319] Globals: 5 objects totaling 0.99 KiB (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 445 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:51.319] Packages: <none>
[10:49:51.319] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:51.319] Resolved: FALSE
[10:49:51.319] Value: <not collected>
[10:49:51.319] Conditions captured: <none>
[10:49:51.319] Early signaling: FALSE
[10:49:51.319] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:51.319] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:51.331] Chunk #1 of 2 ... DONE
[10:49:51.331] Chunk #2 of 2 ...
[10:49:51.331]  - Finding globals in 'X' for chunk #2 ...
[10:49:51.332]    + additional globals found: [n=0] 
[10:49:51.332]    + additional namespaces needed: [n=0] 
[10:49:51.332]  - Finding globals in 'X' for chunk #2 ... DONE
[10:49:51.332]  - Adjusted option 'future.globals.maxSize': 2306 -> 2 * 2306 = 4611 (bytes)
[10:49:51.332]  - seeds: <none>
[10:49:51.332]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:51.413] Created future:
[10:49:51.413] MultisessionFuture:
[10:49:51.413] Label: ‘future_lapply-2’
[10:49:51.413] Expression:
[10:49:51.413] {
[10:49:51.413]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:51.413]     "# expression in do.call(), because function called uses '...'  "
[10:49:51.413]     "# as a global variable                                         "
[10:49:51.413]     do.call(function(...) {
[10:49:51.413]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:51.413]         "# without having an '...' argument. This means '...' is treated"
[10:49:51.413]         "# as a global variable. This may happen when FUN() is an       "
[10:49:51.413]         "# anonymous function.                                          "
[10:49:51.413]         "#                                                              "
[10:49:51.413]         "# If an anonymous function, we will make sure to restore the   "
[10:49:51.413]         "# function environment of FUN() to the calling environment.    "
[10:49:51.413]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:51.413]         "# global environment, which is where globals are written.      "
[10:49:51.413]         penv <- env <- environment(...future.FUN)
[10:49:51.413]         repeat {
[10:49:51.413]             if (identical(env, globalenv()) || identical(env, 
[10:49:51.413]                 emptyenv())) 
[10:49:51.413]                 break
[10:49:51.413]             penv <- env
[10:49:51.413]             env <- parent.env(env)
[10:49:51.413]         }
[10:49:51.413]         if (identical(penv, globalenv())) {
[10:49:51.413]             environment(...future.FUN) <- environment()
[10:49:51.413]         }
[10:49:51.413]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:51.413]             !isNamespace(penv)) {
[10:49:51.413]             parent.env(penv) <- environment()
[10:49:51.413]         }
[10:49:51.413]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:51.413]         {
[10:49:51.413]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:51.413]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:51.413]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:51.413]                 on.exit(options(oopts), add = TRUE)
[10:49:51.413]             }
[10:49:51.413]             {
[10:49:51.413]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:51.413]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:51.413]                   ...future.FUN(...future.X_jj, ...)
[10:49:51.413]                 })
[10:49:51.413]             }
[10:49:51.413]         }
[10:49:51.413]     }, args = future.call.arguments)
[10:49:51.413] }
[10:49:51.413] Lazy evaluation: FALSE
[10:49:51.413] Asynchronous evaluation: TRUE
[10:49:51.413] Local evaluation: TRUE
[10:49:51.413] Environment: R_GlobalEnv
[10:49:51.413] Capture standard output: TRUE
[10:49:51.413] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:51.413] Immediate condition classes: ‘immediateCondition’
[10:49:51.413] Globals: 5 objects totaling 0.99 KiB (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 445 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:51.413] Packages: <none>
[10:49:51.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:51.413] Resolved: FALSE
[10:49:51.413] Value: <not collected>
[10:49:51.413] Conditions captured: <none>
[10:49:51.413] Early signaling: FALSE
[10:49:51.413] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:51.413] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:51.425] Chunk #2 of 2 ... DONE
[10:49:51.425] Launching 2 futures (chunks) ... DONE
[10:49:51.426] Resolving 2 futures (chunks) ...
[10:49:51.490]  - Number of value chunks collected: 2
[10:49:51.490] Resolving 2 futures (chunks) ... DONE
[10:49:51.490] Reducing values from 2 chunks ...
[10:49:51.490]  - Number of values collected after concatenation: 10
[10:49:51.490]  - Number of values expected: 10
[10:49:51.490] Reducing values from 2 chunks ... DONE
[10:49:51.490] future_lapply() ... DONE
List of 10
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
maxSize = 2305.6 bytes
future.globals.maxSize = 2305.6 bytes
[10:49:51.494] future_lapply() ...
[10:49:51.495] Number of chunks: 1
[10:49:51.495] getGlobalsAndPackagesXApply() ...
[10:49:51.495]  - future.globals: TRUE
[10:49:51.497]  - globals found/used: [n=1] ‘FUN’
[10:49:51.497]  - needed namespaces: [n=0] 
[10:49:51.497] Finding globals ... DONE
[10:49:51.497]  - use_args: TRUE
[10:49:51.497]  - Getting '...' globals ...
[10:49:51.498]    - '...' content: [n=0] 
[10:49:51.498] List of 1
[10:49:51.498]  $ ...: list()
[10:49:51.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.498]  - attr(*, "where")=List of 1
[10:49:51.498]   ..$ ...:<environment: 0x55d1cb49af70> 
[10:49:51.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.498]  - attr(*, "resolved")= logi TRUE
[10:49:51.498]  - attr(*, "total_size")= num NA
[10:49:51.500]  - Getting '...' globals ... DONE
[10:49:51.501] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:51.501] List of 2
[10:49:51.501]  $ ...future.FUN:function (x)  
[10:49:51.501]  $ ...          : list()
[10:49:51.501]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.501]  - attr(*, "where")=List of 2
[10:49:51.501]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:51.501]   ..$ ...          :<environment: 0x55d1cb49af70> 
[10:49:51.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.501]  - attr(*, "resolved")= logi FALSE
[10:49:51.501]  - attr(*, "total_size")= num 4731
[10:49:51.504] Packages to be attached in all futures: [n=0] 
[10:49:51.504] getGlobalsAndPackagesXApply() ... DONE
[10:49:51.504] Number of futures (= number of chunks): 1
[10:49:51.504] Launching 1 futures (chunks) ...
[10:49:51.504] Chunk #1 of 1 ...
[10:49:51.504]  - Finding globals in 'X' for chunk #1 ...
[10:49:51.504]    + additional globals found: [n=0] 
[10:49:51.505]    + additional namespaces needed: [n=0] 
[10:49:51.505]  - Finding globals in 'X' for chunk #1 ... DONE
[10:49:51.505]  - seeds: <none>
[10:49:51.505]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:49:51.585] Created future:
[10:49:51.585] MultisessionFuture:
[10:49:51.585] Label: ‘future_lapply-1’
[10:49:51.585] Expression:
[10:49:51.585] {
[10:49:51.585]     "# future::getGlobalsAndPackages(): wrapping the original future"
[10:49:51.585]     "# expression in do.call(), because function called uses '...'  "
[10:49:51.585]     "# as a global variable                                         "
[10:49:51.585]     do.call(function(...) {
[10:49:51.585]         "# future::getGlobalsAndPackages(): FUN() uses '...' internally "
[10:49:51.585]         "# without having an '...' argument. This means '...' is treated"
[10:49:51.585]         "# as a global variable. This may happen when FUN() is an       "
[10:49:51.585]         "# anonymous function.                                          "
[10:49:51.585]         "#                                                              "
[10:49:51.585]         "# If an anonymous function, we will make sure to restore the   "
[10:49:51.585]         "# function environment of FUN() to the calling environment.    "
[10:49:51.585]         "# We assume FUN() an anonymous function if it lives in the     "
[10:49:51.585]         "# global environment, which is where globals are written.      "
[10:49:51.585]         penv <- env <- environment(...future.FUN)
[10:49:51.585]         repeat {
[10:49:51.585]             if (identical(env, globalenv()) || identical(env, 
[10:49:51.585]                 emptyenv())) 
[10:49:51.585]                 break
[10:49:51.585]             penv <- env
[10:49:51.585]             env <- parent.env(env)
[10:49:51.585]         }
[10:49:51.585]         if (identical(penv, globalenv())) {
[10:49:51.585]             environment(...future.FUN) <- environment()
[10:49:51.585]         }
[10:49:51.585]         else if (!identical(penv, emptyenv()) && !is.null(penv) && 
[10:49:51.585]             !isNamespace(penv)) {
[10:49:51.585]             parent.env(penv) <- environment()
[10:49:51.585]         }
[10:49:51.585]         rm(list = c("env", "penv"), inherits = FALSE)
[10:49:51.585]         {
[10:49:51.585]             ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:49:51.585]             if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:49:51.585]                 oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:49:51.585]                 on.exit(options(oopts), add = TRUE)
[10:49:51.585]             }
[10:49:51.585]             {
[10:49:51.585]                 lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:49:51.585]                   ...future.X_jj <- ...future.elements_ii[[jj]]
[10:49:51.585]                   ...future.FUN(...future.X_jj, ...)
[10:49:51.585]                 })
[10:49:51.585]             }
[10:49:51.585]         }
[10:49:51.585]     }, args = future.call.arguments)
[10:49:51.585] }
[10:49:51.585] Lazy evaluation: FALSE
[10:49:51.585] Asynchronous evaluation: TRUE
[10:49:51.585] Local evaluation: TRUE
[10:49:51.585] Environment: R_GlobalEnv
[10:49:51.585] Capture standard output: TRUE
[10:49:51.585] Capture condition classes: ‘condition’ (excluding ‘<none>’)
[10:49:51.585] Immediate condition classes: ‘immediateCondition’
[10:49:51.585] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 407 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 825 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:49:51.585] Packages: <none>
[10:49:51.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:49:51.585] Resolved: FALSE
[10:49:51.585] Value: <not collected>
[10:49:51.585] Conditions captured: <none>
[10:49:51.585] Early signaling: FALSE
[10:49:51.585] Owner process: 930611c8182d27dd779f0e0c92479294
[10:49:51.585] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’
[10:49:51.597] Chunk #1 of 1 ... DONE
[10:49:51.597] Launching 1 futures (chunks) ... DONE
[10:49:51.597] Resolving 1 futures (chunks) ...
[10:49:51.640]  - Number of value chunks collected: 1
[10:49:51.640] Resolving 1 futures (chunks) ... DONE
[10:49:51.640] Reducing values from 1 chunks ...
[10:49:51.640]  - Number of values collected after concatenation: 10
[10:49:51.640]  - Number of values expected: 10
[10:49:51.640] Reducing values from 1 chunks ... DONE
[10:49:51.640] future_lapply() ... DONE
List of 10
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
 $ : num 2306
maxSize = 2305.6 bytes
future.globals.maxSize = 2305.6 bytes
> y <- NULL
> options(future.globals.maxSize = oMaxSize)
> 
> 
> message("*** future_lapply() - too large ... DONE")
*** future_lapply() - too large ... DONE
> 
> 
> message("*** future_lapply() - globals exceptions ...")
*** future_lapply() - globals exceptions ...
> 
> res <- tryCatch({
+   y <- future_lapply(1, FUN = function(x) x, future.globals = 42)
+ }, error = identity)
[10:49:51.644] future_lapply() ...
[10:49:51.645] Number of chunks: 1
[10:49:51.645] getGlobalsAndPackagesXApply() ...
[10:49:51.645] getGlobalsAndPackagesXApply() ... DONE
> stopifnot(inherits(res, "error"))
> 
> res <- tryCatch({
+   y <- future_lapply(1, FUN = function(x) x, future.globals = list(1))
+ }, error = identity)
[10:49:51.645] future_lapply() ...
[10:49:51.646] Number of chunks: 1
[10:49:51.646] getGlobalsAndPackagesXApply() ...
[10:49:51.646]  - future.globals: <name-value list> with names ‘1’
[10:49:51.646] getGlobalsAndPackagesXApply() ... DONE
> stopifnot(inherits(res, "error"))
> 
> res <- tryCatch({
+   y <- future_lapply(1, FUN = function(x) x, future.globals = "...future.FUN")
+ }, error = identity)
[10:49:51.646] future_lapply() ...
[10:49:51.649] Number of chunks: 1
[10:49:51.649] getGlobalsAndPackagesXApply() ...
[10:49:51.649]  - future.globals: ‘...future.FUN’
[10:49:51.649]  - use_args: TRUE
[10:49:51.649] getGlobalsAndPackagesXApply() ... DONE
> stopifnot(inherits(res, "error"))
> 
> res <- tryCatch({
+   y <- future_lapply(1, FUN = function(x) x, future.globals = "...future.FUN")
+ }, error = identity)
[10:49:51.649] future_lapply() ...
[10:49:51.650] Number of chunks: 1
[10:49:51.650] getGlobalsAndPackagesXApply() ...
[10:49:51.650]  - future.globals: ‘...future.FUN’
[10:49:51.650]  - use_args: TRUE
[10:49:51.651] getGlobalsAndPackagesXApply() ... DONE
> stopifnot(inherits(res, "error"))
> 
> ...future.elements_ii <- 42L
> X <- list(function() 2 * ...future.elements_ii)
> res <- tryCatch({
+   y <- future_lapply(X, FUN = function(f) f())
+ }, error = identity)
[10:49:51.651] future_lapply() ...
[10:49:51.651] Number of chunks: 1
[10:49:51.651] getGlobalsAndPackagesXApply() ...
[10:49:51.651]  - future.globals: TRUE
[10:49:51.653]  - globals found/used: [n=1] ‘FUN’
[10:49:51.653]  - needed namespaces: [n=0] 
[10:49:51.653] Finding globals ... DONE
[10:49:51.653]  - use_args: TRUE
[10:49:51.653]  - Getting '...' globals ...
[10:49:51.654]    - '...' content: [n=0] 
[10:49:51.654] List of 1
[10:49:51.654]  $ ...: list()
[10:49:51.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.654]  - attr(*, "where")=List of 1
[10:49:51.654]   ..$ ...:<environment: 0x55d1cd7fc420> 
[10:49:51.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.654]  - attr(*, "resolved")= logi TRUE
[10:49:51.654]  - attr(*, "total_size")= num NA
[10:49:51.656]  - Getting '...' globals ... DONE
[10:49:51.656] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:49:51.656] List of 2
[10:49:51.656]  $ ...future.FUN:function (f)  
[10:49:51.656]  $ ...          : list()
[10:49:51.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:49:51.656]  - attr(*, "where")=List of 2
[10:49:51.656]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:49:51.656]   ..$ ...          :<environment: 0x55d1cd7fc420> 
[10:49:51.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:49:51.656]  - attr(*, "resolved")= logi FALSE
[10:49:51.656]  - attr(*, "total_size")= num 2927
[10:49:51.659] Packages to be attached in all futures: [n=0] 
[10:49:51.659] getGlobalsAndPackagesXApply() ... DONE
[10:49:51.659] Number of futures (= number of chunks): 1
[10:49:51.659] Launching 1 futures (chunks) ...
[10:49:51.660] Chunk #1 of 1 ...
[10:49:51.660]  - Finding globals in 'X' for chunk #1 ...
[10:49:51.661]    + additional globals found: [n=1] ‘...future.elements_ii’
[10:49:51.661]    + additional namespaces needed: [n=0] 
> stopifnot(inherits(res, "error"))
> 
> message("*** future_lapply() - globals exceptions ... DONE")
*** future_lapply() - globals exceptions ... DONE
> 
> source("incl/end.R")
> 
