
R version 4.5.0 (2025-04-11) -- "How About a Twenty-Six"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start,load-only.R")
[10:52:09.690] Future-specific environment variables:
[10:52:09.690] Environment variable ‘R_FUTURE_DEMO_MANDELBROT_REGION’ not set
[10:52:09.690] Environment variable ‘R_FUTURE_DEMO_MANDELBROT_NROW’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_DEPRECATED_IGNORE’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_DEPRECATED_DEFUNCT’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_FORK_MULTITHREADING_ENABLE’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_GLOBALS_MAXSIZE’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_GLOBALS_ONMISSING’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_GLOBALS_ONREFERENCE’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_GLOBALS_METHOD’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_GLOBALS_RESOLVE’ not set
[10:52:09.691] Environment variable ‘R_FUTURE_LAZY_ASSERTOWNER’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_PLAN’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_PLAN_DISALLOW’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_PSOCK_RELAY_IMMEDIATE’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_RELAY_IMMEDIATE’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_RESOLVE_RECURSIVE’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_ALIVE_TIMEOUT’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_RESOLVED_TIMEOUT’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_CLUSTER_RESOLVED_TIMEOUT’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_MULTICORE_RESOLVED_TIMEOUT’ not set
[10:52:09.692] Environment variable ‘R_FUTURE_ONFUTURECONDITION_KEEPFUTURE’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_RNG_ONMISUSE’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_GLOBALENV_ONMISUSE’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_WAIT_TIMEOUT’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_WAIT_INTERVAL’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_WAIT_ALPHA’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_ASSIGN_GLOBALS_EXCLUDE’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_OUTPUT_WINDOWS_REENCODE’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_GLOBALS_GLOBALSOF_LOCALS’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_STATE_ONINVALID’ not set
[10:52:09.693] Environment variable ‘R_FUTURE_JOURNAL’ not set
[10:52:09.694] Environment variable ‘R_FUTURE_GLOBALS_KEEPWHERE’ not set
[10:52:09.694] Environment variable ‘R_FUTURE_GLOBALS_OBJECTSIZE_METHOD’ not set
[10:52:09.694] Environment variable ‘R_FUTURE_CONNECTIONS_ONMISUSE’ not set
[10:52:09.694] Environment variable ‘R_FUTURE_DEVICES_ONMISUSE’ not set
[10:52:09.694] R process uuid: 8c14c066e409263c7eee012222931dae
[10:52:09.695] Setting plan('default')
[10:52:09.695] plan(<character>, .skip = FALSE, .cleanup = NA, .init = FALSE) ...
[10:52:09.695] |  Created default stack
[10:52:09.695] |  Getting default stack: ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:52:09.695] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = FALSE) ...
[10:52:09.696] |  :  all.equal() for FutureStrategyList ...
[10:52:09.696] |  :  .  New stack:
[10:52:09.696] |  :  .  List of 1
[10:52:09.696] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.696] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.696] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.696] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.696] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.696] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:52:09.700] |  :  .  Old stack:
[10:52:09.700] |  :  .  List of 1
[10:52:09.700] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.700] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.700] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.700] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.700] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.700] |  :  .    ..- attr(*, "call")= language plan(sequential)
[10:52:09.700] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:52:09.702] |  :  .  Not identical
[10:52:09.702] |  :  .  all.equal() for future ...
[10:52:09.702] |  :  .  |  List of 2
[10:52:09.702] |  :  .  |   $ target :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.702] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.702] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.702] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.702] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.702] |  :  .  |   $ current:function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.702] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.702] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.702] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.702] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.702] |  :  .  |    ..- attr(*, "call")= language plan(sequential)
[10:52:09.706] |  :  .  all.equal() for future ... done
[10:52:09.706] |  :  all.equal() for FutureStrategyList ... done
[10:52:09.706] |  :  plan(): Skip setting new future strategy stack because it is the same as the current one:
[10:52:09.706] |  :  List of future strategies:
[10:52:09.706] |  :  1. sequential:
[10:52:09.706] |  :     - args: function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame(), workers = "<NULL>")
[10:52:09.706] |  :     - tweaked: FALSE
[10:52:09.706] |  :     - call: plan(sequential)
[10:52:09.707] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = FALSE) ... done
[10:52:09.707] plan(<list>, .skip = FALSE, .cleanup = NA, .init = FALSE) ... done
[10:52:09.707] plan(<NULL>, .skip = FALSE, .cleanup = NA, .init = TRUE) ...
[10:52:09.708] |  Getting current ("next") strategy: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:52:09.708] plan(<FutureStrategy>, .skip = FALSE, .cleanup = NA, .init = TRUE) ... done
[10:52:09.708] plan(<character>, .skip = FALSE, .cleanup = NA, .init = TRUE) ...
[10:52:09.746] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = TRUE) ...
[10:52:09.746] |  :  all.equal() for FutureStrategyList ...
[10:52:09.746] |  :  .  New stack:
[10:52:09.746] |  :  .  List of 1
[10:52:09.746] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.746] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.746] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.746] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.746] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.746] |  :  .    ..- attr(*, "call")= language future::plan("sequential")
[10:52:09.746] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:52:09.749] |  :  .  Old stack:
[10:52:09.749] |  :  .  List of 1
[10:52:09.749] |  :  .   $ :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.749] |  :  .    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.749] |  :  .    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.749] |  :  .    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.749] |  :  .    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.749] |  :  .    ..- attr(*, "call")= language plan(sequential)
[10:52:09.749] |  :  .   - attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:52:09.751] |  :  .  Not identical
[10:52:09.751] |  :  .  all.equal() for future ...
[10:52:09.751] |  :  .  |  List of 2
[10:52:09.751] |  :  .  |   $ target :function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.751] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.751] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.751] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.751] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.751] |  :  .  |    ..- attr(*, "call")= language future::plan("sequential")
[10:52:09.751] |  :  .  |   $ current:function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame())  
[10:52:09.751] |  :  .  |    ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:52:09.751] |  :  .  |    ..- attr(*, "factory")=function (..., maxSizeOfObjects = +Inf)  
[10:52:09.751] |  :  .  |    .. ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.751] |  :  .  |    ..- attr(*, "tweakable")= chr [1:5] "maxSizeOfObjects" "earlySignal" "gc" "interrupts" ...
[10:52:09.751] |  :  .  |    ..- attr(*, "call")= language plan(sequential)
[10:52:09.756] |  :  .  all.equal() for future ... done
[10:52:09.756] |  :  all.equal() for FutureStrategyList ... done
[10:52:09.756] |  :  plan(): Skip setting new future strategy stack because it is the same as the current one:
[10:52:09.756] |  :  List of future strategies:
[10:52:09.756] |  :  1. sequential:
[10:52:09.756] |  :     - args: function (..., gc = FALSE, earlySignal = FALSE, envir = parent.frame(), workers = "<NULL>")
[10:52:09.756] |  :     - tweaked: FALSE
[10:52:09.756] |  :     - call: plan(sequential)
[10:52:09.757] |  plan(): plan_set(<1 strategies>, skip = FALSE, cleanup = NA, init = TRUE) ... done
[10:52:09.757] plan(<sequential>, .skip = FALSE, .cleanup = NA, .init = TRUE) ... done
> stop_if_not <- future.apply:::stop_if_not
> 
> message("*** utils ...")
*** utils ...
> 
> message("*** hpaste() ...")
*** hpaste() ...
> 
> # Some vectors
> x <- 1:6
> y <- 10:1
> z <- LETTERS[x]
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> # Abbreviation of output vector
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> printf("x = %s.\n", hpaste(x))
x = 1, 2, 3, 4, 5, 6.
> ## x = 1, 2, 3, ..., 6.
> 
> printf("x = %s.\n", hpaste(x, maxHead = 2))
x = 1, 2, ..., 6.
> ## x = 1, 2, ..., 6.
> 
> printf("x = %s.\n", hpaste(x, maxHead = 3)) # Default
x = 1, 2, 3, ..., 6.
> ## x = 1, 2, 3, ..., 6.
> 
> # It will never output 1, 2, 3, 4, ..., 6
> printf("x = %s.\n", hpaste(x, maxHead = 4))
x = 1, 2, 3, 4, 5, 6.
> ## x = 1, 2, 3, 4, 5 and 6.
> 
> # Showing the tail
> printf("x = %s.\n", hpaste(x, maxHead = 1, maxTail = 2))
x = 1, ..., 5, 6.
> ## x = 1, ..., 5, 6.
> 
> # Turning off abbreviation
> printf("y = %s.\n", hpaste(y, maxHead = Inf))
y = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
> ## y = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
> 
> ## ...or simply
> printf("y = %s.\n", paste(y, collapse = ", "))
y = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
> ## y = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
> 
> # Change last separator
> printf("x = %s.\n", hpaste(x, lastCollapse = " and "))
x = 1, 2, 3, 4, 5 and 6.
> ## x = 1, 2, 3, 4, 5 and 6.
> 
> # No collapse
> stopifnot(all(hpaste(x, collapse = NULL) == x))
> 
> # Empty input
> stopifnot(identical(hpaste(character(0)), character(0)))
> 
> message("*** hpaste() ...")
*** hpaste() ...
> 
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> # debug()
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> message("*** mdebug() ...")
*** mdebug() ...
> 
> mdebug("Hello #", 1)
[10:52:09.777] Hello #1
> mdebugf("Hello #%d", 1)
[10:52:09.777] Hello #1
> options(future.debug = TRUE)
> 
> mdebug("Hello #", 2)
[10:52:09.777] Hello #2
> mdebugf("Hello #%d", 2)
[10:52:09.777] Hello #2
> options(future.debug = FALSE)
> 
> mdebug("Hello #", 3)
NULL
> mdebugf("Hello #%d", 3)
NULL
> 
> message("*** mdebug() ... DONE")
*** mdebug() ... DONE
> 
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> # import_from()
> # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> message("*** import_from() ...")
*** import_from() ...
> 
> obj <- import_from("non-existing-fcn", default = NA, package = "future")
> stopifnot(identical(obj, NA))
> 
> res <- tryCatch({
+   obj <- import_from("non-existing-fcn", package = "future")
+ }, error = identity)
> print(res)
<simpleError: No such 'future' function: non-existing-fcn()>
> stopifnot(inherits(res, "simpleError"))
> 
> message("*** import_from() ... DONE")
*** import_from() ... DONE
> 
> 
> message("*** stop_if_not() ...")
*** stop_if_not() ...
> 
> stop_if_not(TRUE)
NULL
> stop_if_not(TRUE, TRUE)
NULL
> res <- tryCatch({
+   stop_if_not(FALSE)
+ }, error = identity)
> stopifnot(inherits(res, "simpleError"))
> res <- tryCatch({
+   stop_if_not(list(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
+ }, error = identity)
> stopifnot(inherits(res, "simpleError"))
> 
> message("*** stop_if_not() ... DONE")
*** stop_if_not() ... DONE
> 
> 
> message("*** assert_values2() ...")
*** assert_values2() ...
> 
> assert_values2 <- future.apply:::assert_values2
> assert_values2(nX = 2L, values2 = as.list(1:2))
> res <- tryCatch({
+   assert_values2(nX = 1L, values = as.list(1:2), values2 = as.list(1:2), fcn = "tests", debug = TRUE)
+ }, error = identity)
> stopifnot(inherits(res, "FutureError"))
> 
> message("*** assert_values2() ... DONE")
*** assert_values2() ... DONE
> 
> 
> message("*** utils ... DONE")
*** utils ... DONE
> 
> source("incl/end.R")
> 
