
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "Deriv"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('Deriv')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Deriv-package")
> ### * Deriv-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Deriv-package
> ### Title: Symbolic Differentiation
> ### Aliases: Deriv-package
> ### Keywords: package
> 
> ### ** Examples
> 
> ## Not run: f <- function(x) x^2
> ## Not run: Deriv(f)
> # function (x)
> # 2 * x
> 
> 
> 
> cleanEx()
> nameEx("Deriv")
> ### * Deriv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Deriv
> ### Title: Symbolic differentiation of an expression or function
> ### Aliases: Deriv drule
> 
> ### ** Examples
> 
> 
> ## Not run: f <- function(x) x^2
> ## Not run: Deriv(f)
> # function (x)
> # 2 * x
> 
> ## Not run: f <- function(x, y) sin(x) * cos(y)
> ## Not run: Deriv(f)
> # function (x, y)
> # c(x = cos(x) * cos(y), y = -(sin(x) * sin(y)))
> 
> ## Not run: f_ <- Deriv(f)
> ## Not run: f_(3, 4)
> #              x         y
> # [1,] 0.6471023 0.1068000
> 
> ## Not run: Deriv(~ f(x, y^2), "y")
> # -(2 * (y * sin(x) * sin(y^2)))
> 
> ## Not run: Deriv(quote(f(x, y^2)), c("x", "y"), cache.exp=FALSE)
> # c(x = cos(x) * cos(y^2), y = -(2 * (y * sin(x) * sin(y^2))))
> 
> ## Not run: Deriv(expression(sin(x^2) * y), "x")
> # expression(2*(x*y*cos(x^2)))
> 
> Deriv("sin(x^2) * y", "x") # differentiate only by x
[1] "2 * (x * y * cos(x^2))"
> "2 * (x * y * cos(x^2))"
[1] "2 * (x * y * cos(x^2))"
> 
> Deriv("sin(x^2) * y", cache.exp=FALSE) # differentiate by all variables (here by x and y)
[1] "c(x = 2 * (x * y * cos(x^2)), y = sin(x^2))"
> "c(x = 2 * (x * y * cos(x^2)), y = sin(x^2))"
[1] "c(x = 2 * (x * y * cos(x^2)), y = sin(x^2))"
> 
> # Compound function example (here abs(x) smoothed near 0)
> fc <- function(x, h=0.1) if (abs(x) < h) 0.5*h*(x/h)**2 else abs(x)-0.5*h
> Deriv("fc(x)", "x", cache.exp=FALSE)
[1] "if (abs(x) < 0.1) 10 * x else sign(x)"
> "if (abs(x) < h) x/h else sign(x)"
[1] "if (abs(x) < h) x/h else sign(x)"
> 
> # Example of a first argument that cannot be evaluated in the current environment:
> ## Not run: 
> ##D   suppressWarnings(rm("xx", "yy"))
> ##D   Deriv(xx^2+yy^2)
> ## End(Not run)
> # c(xx = 2 * xx, yy = 2 * yy)
> 
> # Automatic differentiation (AD), note intermediate variable 'd' assignment
> ## Not run: Deriv(~{d <- ((x-m)/s)^2; exp(-0.5*d)}, "x", cache.exp=FALSE)
> #{
> #   d <- ((x - m)/s)^2
> #   .d_x <- 2 * ((x - m)/s^2)
> #   -(0.5 * (.d_x * exp(-(0.5 * d))))
> #}
> 
> # Custom differentiation rule
> ## Not run: 
> ##D   myfun <- function(x, y=TRUE) NULL # do something useful
> ##D   dmyfun <- function(x, y=TRUE) NULL # myfun derivative by x.
> ##D   drule[["myfun"]] <- alist(x=dmyfun(x, y), y=NULL) # y is just a logical => no derivate
> ##D   Deriv(~myfun(z^2, FALSE), "z", drule=drule)
> ##D   # 2 * (z * dmyfun(z^2, FALSE))
> ## End(Not run)
> 
> # Differentiation by list components
> ## Not run: 
> ##D   theta <- list(m=0.1, sd=2.)
> ##D   x <- names(theta)
> ##D   names(x)=rep("theta", length(theta))
> ##D   Deriv(~exp(-(x-theta$m)**2/(2*theta$sd)), x, cache.exp=FALSE)
> ##D # c(theta_m = exp(-((x - theta$m)^2/(2 * theta$sd))) *
> ##D #  (x - theta$m)/theta$sd, theta_sd = 2 * (exp(-((x - theta$m)^2/
> ##D #  (2 * theta$sd))) * (x - theta$m)^2/(2 * theta$sd)^2))
> ## End(Not run)
> 
> # Differentiation by list components used in "with()" expression (since v4.2)
> # Compare with precedent example.
> ## Not run: 
> ##D   theta <- list(m=0.1, sd=2.)
> ##D   x <- names(theta)
> ##D   names(x)=rep("theta", length(theta))
> ##D   Deriv(~with(theta, exp(-(x-m)**2/(2*sd))), x, cache.exp=FALSE)
> ##D # c(theta_m = with(theta, exp(-((x - m)^2/(2 * sd))) * (x - m)/sd), 
> ##D #     theta_sd = with(theta, 2 * (exp(-((x - m)^2/(2 * sd))) * 
> ##D #         (x - m)^2/(2 * sd)^2)))
> ## End(Not run)
> # Differentiation in matrix calculus
> ## Not run: 
> ##D  Deriv(~solve(matrix(c(1, x, x**2, x**3), nrow=2, ncol=2)))
> ## End(Not run)
> 
> # Two component Gaussian mixture model (GMM) example
> ## Not run: 
> ##D # define GMM probability density function -> p(x, ...)
> ##D ncomp=2
> ##D a=runif(ncomp)
> ##D a=a/sum(a) # amplitude or weight of each component
> ##D m=rnorm(ncomp) # mean
> ##D s=runif(ncomp) # sd
> ##D # two column matrix of probabilities: one row per x value, one column per component
> ##D pn=function(x, a, m, s, log=FALSE) {
> ##D   n=length(a)
> ##D   structure(vapply(seq(n), function(i) a[i]*dnorm(x, m[i], s[i], log),
> ##D     double(length(x))), dim=c(length(x), n))
> ##D }
> ##D p=function(x, a, m, s) rowSums(pn(x, a, m, s)) # overall probability
> ##D dp=Deriv(p, "x")
> ##D # plot density and its derivative
> ##D xp=seq(min(m-2*s), max(m+2*s), length.out=200)
> ##D matplot(xp, cbind(p(xp, a, m, s), dp(xp, a, m, s)),
> ##D    xlab="x", ylab="p, dp/dx", type="l", main="Two component GMM")
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.078 0.009 0.088 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
