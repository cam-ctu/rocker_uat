
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ape"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ape')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AAbin")
> ### * AAbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AAbin
> ### Title: Amino Acid Sequences
> ### Aliases: AAbin print.AAbin [.AAbin as.character.AAbin labels.AAbin
> ###   image.AAbin as.AAbin as.AAbin.AAString as.AAbin.AAStringSet
> ###   as.AAbin.AAMultipleAlignment as.AAbin.character as.phyDat.AAbin
> ###   dist.aa AAsubst c.AAbin cbind.AAbin rbind.AAbin as.AAbin.list
> ###   as.list.AAbin as.matrix.AAbin
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(woodmouse)
> AA <- trans(woodmouse, 2)
Warning in trans(woodmouse, 2) :
  sequence length not a multiple of 3: 2 nucleotides dropped
> seg.sites(woodmouse)
 [1]  30  33  35  36  42  51  54  60  72  96 106 123 201 213 234 237 279 291 297
[20] 306 314 316 318 340 342 343 349 365 409 417 438 456 462 477 510 514 534 540
[39] 546 576 591 672 675 684 697 715 738 810 837 876 909 920 957 959 960 963
> AAsubst(AA)
 [1]  12  36 105 106 114 115 122 137 145 146 233 307 320
> 
> 
> 
> cleanEx()
> nameEx("CADM.global")
> ### * CADM.global
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CADM.global
> ### Title: Congruence among distance matrices
> ### Aliases: CADM CADM.global CADM.post
> ### Keywords: multivariate nonparametric
> 
> ### ** Examples
> 
> # Examples 1 and 2: 5 genetic distance matrices computed from simulated DNA
> # sequences representing 50 taxa having evolved along additive trees with
> # identical evolutionary parameters (GTR+ Gamma + I). Distance matrices were
> # computed from the DNA sequence matrices using a p distance corrected with the
> # same parameters as those used to simulate the DNA sequences. See Campbell et
> # al. (2009) for details.
> 
> # Example 1: five independent additive trees. Data provided by V. Campbell.
> 
> data(mat5Mrand)
> res.global <- CADM.global(mat5Mrand, 5, 50)
Analysis of symmetric matrices 

Time to compute global test = 0.077000  sec 
> 
> # Example 2: three partly similar trees, two independent trees.
> # Data provided by V. Campbell.
> 
> data(mat5M3ID)
> res.global <- CADM.global(mat5M3ID, 5, 50)
Analysis of symmetric matrices 

Time to compute global test = 0.052000  sec 
> res.post   <- CADM.post(mat5M3ID, 5, 50, mantel=TRUE)
Analysis of symmetric matrices 
Time to compute a posteriori tests (per matrix) = 0.096000  sec 
> 
> # Example 3: three matrices respectively representing Serological
> # (asymmetric), DNA hybridization (asymmetric) and Anatomical (symmetric)
> # distances among 9 families. Data from Lapointe et al. (1999).
> 
> data(mat3)
> res.global <- CADM.global(mat3, 3, 9, nperm=999)
Matrix # 1  is asymmetric 
Matrix # 2  is asymmetric 

Asymmetric matrices were transformed to be symmetric 

Time to compute global test = 0.110000  sec 
> res.post   <- CADM.post(mat3, 3, 9, nperm=999, mantel=TRUE)
Matrix # 1  is asymmetric 
Matrix # 2  is asymmetric 

Asymmetric matrices were transformed to be symmetric 
Time to compute a posteriori tests (per matrix) = 0.254000  sec 
> 
> # Example 4, showing how to bind two D matrices (cophenetic matrices
> # in this example) into a file using rbind(), then run the global test.
> 
> a <- rtree(5)
> b <- rtree(5)
> A <- cophenetic(a)
> B <- cophenetic(b)
> x <- rownames(A)
> B <- B[x, x]
> M <- rbind(A, B)
> CADM.global(M, 2, 5)
Analysis of symmetric matrices 

Time to compute global test = 0.008000  sec 
$congruence_analysis
          Statistics
W          0.5515152
Chi2       9.9272727
Prob.perm  0.3300000

$nperm
[1] 99

attr(,"class")
[1] "CADM.global"
> 
> 
> 
> cleanEx()
> nameEx("DNAbin")
> ### * DNAbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: DNAbin
> ### Title: Manipulate DNA Sequences in Bit-Level Format
> ### Aliases: DNAbin print.DNAbin [.DNAbin rbind.DNAbin cbind.DNAbin
> ###   as.matrix.DNAbin c.DNAbin as.list.DNAbin labels.DNAbin
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(woodmouse)
> woodmouse
15 DNA sequences in binary format stored in a matrix.

All sequences of same length: 965 

Labels:
No305
No304
No306
No0906S
No0908S
No0909S
...

Base composition:
    a     c     g     t 
0.307 0.261 0.126 0.306 
(Total: 14.47 kb)
> print(woodmouse, 15, 6)
15 DNA sequences in binary format stored in a matrix.

All sequences of same length: 965 

Labels:
No305
No304
No306
No0906S
No0908S
No0909S
No0910S
No0912S
No0913S
No1103S
No1007S
No1114S
No1202S
No1206S
No1208S

Base composition:
       a        c        g        t 
0.306541 0.261308 0.126026 0.306124 
(Total: 14.47 kb)
> print(woodmouse[1:5, 1:300], 15, 6)
5 DNA sequences in binary format stored in a matrix.

All sequences of same length: 300 

Labels:
No305
No304
No306
No0906S
No0908S

Base composition:
       a        c        g        t 
0.331108 0.249666 0.121495 0.297730 
(Total: 1.5 kb)
> ### Just to show how distances could be influenced by sampling:
> dist.dna(woodmouse[1:2, ])
           No305
No304 0.01696875
> dist.dna(woodmouse[1:3, ])
            No305       No304
No304 0.017004827            
No306 0.013772057 0.005252149
> ### cbind and its options:
> x <- woodmouse[1:2, 1:5]
> y <- woodmouse[2:4, 6:10]
> as.character(cbind(x, y)) # gives warning
Warning in cbind(deparse.level, ...) : some rows were dropped.
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
No304 "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"  
> as.character(cbind(x, y, fill.with.gaps = TRUE))
        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
No305   "n"  "t"  "t"  "c"  "g"  "-"  "-"  "-"  "-"  "-"  
No304   "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"  
No306   "-"  "-"  "-"  "-"  "-"  "a"  "a"  "a"  "a"  "a"  
No0906S "-"  "-"  "-"  "-"  "-"  "a"  "a"  "a"  "a"  "a"  
> ## Not run: 
> ##D as.character(cbind(x, y, check.names = FALSE)) # gives an error
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("LTT")
> ### * LTT
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LTT
> ### Title: Theoretical Lineage-Through Time Plots
> ### Aliases: LTT
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ### predicted LTT plot under a Yule model with lambda = 0.1
> ### and 50 species after 50 units of time...
> LTT(N = 50)
> ### ... and with a birth-death model with the same rate of
> ### diversification (try with N = 500):
> LTT(0.2, 0.1, N = 50, PI = 0, add = TRUE, ltt.style = list("red", 2, 1))
> ### predictions under different tree sizes:
> layout(matrix(1:4, 2, 2, byrow = TRUE))
> for (N in c(50, 100, 500, 1000)) {
+     LTT(0.2, 0.1, N = N)
+     title(paste("N =", N))
+ }
> layout(1)
> ## Not run: 
> ##D ### speciation rate decreasing with time
> ##D birth.logis <- function(t) 1/(1 + exp(0.02 * t + 4))
> ##D LTT(birth.logis)
> ##D LTT(birth.logis, 0.05)
> ##D LTT(birth.logis, 0.1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("MPR")
> ### * MPR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MPR
> ### Title: Most Parsimonious Reconstruction
> ### Aliases: MPR
> ### Keywords: models
> 
> ### ** Examples
> 
> ## the example in Narushima and Hanazawa (1997):
> tr <- read.tree(text = "(((i,j)c,(k,l)b)a,(h,g)e,f)d;")
> x <- c(1, 3, 0, 6, 5, 2, 4)
> names(x) <- letters[6:12]
> (o <- MPR(x, tr, "f"))
  lower upper
d     1     3
a     2     4
c     5     5
b     2     4
e     1     3
> plot(tr)
> nodelabels(paste0("[", o[, 1], ",", o[, 2], "]"))
> tiplabels(x[tr$tip.label], adj = -2)
> ## some random data:
> x <- rpois(30, 1)
> tr <- rtree(30, rooted = FALSE)
> MPR(x, tr, "t1")
   lower upper
45     1     1
31     1     1
32     1     1
33     1     1
34     1     1
35     1     1
36     1     1
37     1     1
38     1     2
39     1     2
40     1     1
41     1     1
42     1     1
43     1     1
44     0     0
46     1     1
47     1     1
48     1     2
49     1     2
50     1     1
51     1     1
52     1     1
53     0     1
54     0     1
55     0     0
56     1     1
57     1     1
58     1     1
> 
> 
> 
> cleanEx()
> nameEx("MoranI")
> ### * MoranI
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Moran.I
> ### Title: Moran's I Autocorrelation Index
> ### Aliases: Moran.I
> ### Keywords: models regression
> 
> ### ** Examples
> 
> tr <- rtree(30)
> x <- rnorm(30)
> ## weights w[i,j] = 1/d[i,j]:
> w <- 1/cophenetic(tr)
> ## set the diagonal w[i,i] = 0 (instead of Inf...):
> diag(w) <- 0
> Moran.I(x, w)
$observed
[1] -0.0173216

$expected
[1] -0.03448276

$sd
[1] 0.02856046

$p.value
[1] 0.5479257

> Moran.I(x, w, alt = "l")
$observed
[1] -0.0173216

$expected
[1] -0.03448276

$sd
[1] 0.02856046

$p.value
[1] 0.7260372

> Moran.I(x, w, alt = "g")
$observed
[1] -0.0173216

$expected
[1] -0.03448276

$sd
[1] 0.02856046

$p.value
[1] 0.2739628

> Moran.I(x, w, scaled = TRUE) # usualy the same
$observed
[1] -0.0173216

$expected
[1] -0.03448276

$sd
[1] 0.02856046

$p.value
[1] 0.5479257

> 
> 
> 
> cleanEx()
> nameEx("ace")
> ### * ace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ace
> ### Title: Ancestral Character Estimation
> ### Aliases: ace print.ace logLik.ace deviance.ace AIC.ace anova.ace
> ### Keywords: models
> 
> ### ** Examples
> 
> ### Some random data...
> data(bird.orders)
> x <- rnorm(23)
> ### Compare the three methods for continuous characters:
> ace(x, bird.orders)

    Ancestral Character Estimation

Call: ace(x = x, phy = bird.orders)

    Residual log-likelihood: 65.71454 

$ace
        24         25         26         27         28         29         30 
0.14483984 0.13777012 0.03959219 0.19950518 0.21887730 0.14820697 0.17567997 
        31         32         33         34         35         36         37 
0.21129301 0.24830820 0.28991794 0.25897326 0.35948442 0.19414582 0.19333538 
        38         39         40         41         42         43         44 
0.25369085 0.29141761 0.30331251 0.28550470 0.37757159 0.33016687 0.37407923 
        45 
0.40510468 

$sigma2
[1] 0.029904438 0.008877443

$CI95
         [,1]      [,2]
24 -0.4681078 0.7577875
25 -0.5059400 0.7814802
26 -0.7362924 0.8154768
27 -0.5059988 0.9050092
28 -0.5198843 0.9576389
29 -0.4230793 0.7194932
30 -0.3684022 0.7197622
31 -0.2743641 0.6969502
32 -0.2639665 0.7605829
33 -0.2639895 0.8438254
34 -0.4221177 0.9400642
35 -0.2691835 0.9881523
36 -0.2932629 0.6815545
37 -0.2943633 0.6810340
38 -0.2317026 0.7390843
39 -0.1913410 0.7741762
40 -0.2074361 0.8140611
41 -0.2684226 0.8394320
42 -0.2277845 0.9829277
43 -0.1938762 0.8542099
44 -0.1864510 0.9346094
45 -0.1938759 1.0040853

> ace(x, bird.orders, method = "pic")

    Ancestral Character Estimation

Call: ace(x = x, phy = bird.orders, method = "pic")

$ace
         24          25          26          27          28          29 
 0.14486514  0.11650354 -0.22140524  0.36243033  0.37982609  0.15993555 
         30          31          32          33          34          35 
 0.30467262  0.27857807  0.59618157  0.55346095  0.13519648  0.95081220 
         36          37          38          39          40          41 
 0.07247573  0.18996664  0.58574236  0.49585533  0.41703151 -0.03056194 
         42          43          44          45 
 0.88252870  0.57893715  0.76310686  0.85055684 

$CI95
         [,1]      [,2]
24  -6.892373  7.182104
25  -9.861399 10.094406
26 -13.163105 12.720295
27 -11.232873 11.957734
28 -12.502372 13.262024
29 -10.750220 11.070091
30 -10.440364 11.049709
31  -6.007715  6.564872
32 -10.444756 11.637119
33  -9.314719 10.421641
34 -12.506191 12.776584
35 -12.079632 13.981257
36 -10.418263 10.563215
37 -10.106972 10.486906
38  -9.589275 10.760760
39  -6.574378  7.566088
40  -8.972403  9.806466
41 -12.822987 12.761863
42 -11.636717 13.401775
43 -10.064076 11.221950
44 -10.245891 11.772104
45 -11.576295 13.277409

> ace(x, bird.orders, method = "GLS",
+     corStruct = corBrownian(1, bird.orders))
Warning in Initialize.corPhyl(corStruct, DF) :
  No covariate specified, species will be taken as ordered in the data frame. To avoid this message, specify a covariate containing the species names with the 'form' argument.
Warning in Initialize.corPhyl(X[[i]], ...) :
  No covariate specified, species will be taken as ordered in the data frame. To avoid this message, specify a covariate containing the species names with the 'form' argument.

    Ancestral Character Estimation

Call: ace(x = x, phy = bird.orders, method = "GLS", corStruct = corBrownian(1, 
    bird.orders))

$ace
        24         25         26         27         28         29         30 
0.14486514 0.13779023 0.03961013 0.19952231 0.21889379 0.14823414 0.17570696 
        31         32         33         34         35         36         37 
0.21131958 0.24833352 0.28994180 0.25899274 0.35950711 0.19417180 0.19336105 
        38         39         40         41         42         43         44 
0.25371656 0.29144313 0.30333729 0.28552933 0.37759260 0.33019173 0.37410259 
        45 
0.40512751 

$CI95
         [,1]      [,2]
24  0.1448651 0.1448651
25 -2.3228405 2.5984210
26 -3.7868947 3.8661149
27 -3.1977779 3.5968225
28 -3.4759962 3.9137837
29 -1.5788146 1.8752829
30 -1.8843580 2.2357719
31 -2.0423904 2.4650295
32 -2.2481465 2.7448135
33 -2.5325002 3.1123839
34 -3.3588228 3.8768082
35 -2.9337557 3.6527699
36 -2.1692131 2.5575567
37 -2.2805229 2.6672450
38 -2.2627248 2.7701579
39 -2.2499528 2.8328390
40 -2.4132483 3.0199228
41 -2.6802074 3.2512661
42 -2.8831307 3.6383159
43 -2.4673684 3.1277518
44 -2.6393096 3.3875148
45 -2.8275930 3.6378480

> ### For discrete characters:
> x <- factor(c(rep(0, 5), rep(1, 18)))
> ans <- ace(x, bird.orders, type = "d")
> #### Showing the likelihoods on each node:
> plot(bird.orders, type = "c", FALSE, label.offset = 1)
> co <- c("blue", "yellow")
> tiplabels(pch = 22, bg = co[as.numeric(x)], cex = 2, adj = 1)
> nodelabels(thermo = ans$lik.anc, piecol = co, cex = 0.75)
> 
> 
> 
> cleanEx()
> nameEx("add.scale.bar")
> ### * add.scale.bar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add.scale.bar
> ### Title: Add a Scale Bar to a Phylogeny Plot
> ### Aliases: add.scale.bar
> ### Keywords: aplot
> 
> ### ** Examples
> 
> tr <- rtree(10)
> layout(matrix(1:2, 2, 1))
> plot(tr)
> add.scale.bar()
> plot(tr)
> add.scale.bar(cex = 0.7, font = 2, col = "red")
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("alex")
> ### * alex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alex
> ### Title: Alignment Explorer With Multiple Devices
> ### Aliases: alex
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(woodmouse)
> ##D image(woodmouse)
> ##D alex(woodmouse)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("all.equal.DNAbin")
> ### * all.equal.DNAbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal.DNAbin
> ### Title: Compare DNA Sets
> ### Aliases: all.equal.DNAbin
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(woodmouse)
> woodm2 <- woodmouse
> woodm2[1, c(1:5, 10:12, 30:40)] <- as.DNAbin("g")
> res <- all.equal(woodmouse, woodm2, plot = TRUE)
> str(res)
List of 2
 $ messages       : chr "Labels in both objects identical."
 $ different.sites: int [1:17, 1:2] 1 1 1 1 1 1 1 1 1 1 ...
> 
> ## if used for testing in R programs:
> isTRUE(all.equal(woodmouse, woodmouse)) # TRUE
[1] TRUE
> isTRUE(all.equal(woodmouse, woodm2)) # FALSE
[1] FALSE
> 
> all.equal(woodmouse, woodmouse[15:1, ])
[1] "Labels in both objects identical but not in the same order."    
[2] "Comparing sequences after reordering rows of the second matrix."
[3] "Sequences are identical."                                       
> all.equal(woodmouse, woodmouse[-1, ])
[1] "Number of sequences different:"                         
[2] "15 sequences in 1st object; 14 sequences in 2nd object."
[3] "Subset your data for further comparison."               
> all.equal(woodmouse, woodmouse[, -1])
[1] "Numbers of columns different: comparison stopped here."
> 
> ## Not run: 
> ##D ## To run the followings you need internet and Clustal and MUSCLE
> ##D ## correctly installed.
> ##D ## Data from Johnson et al. (2006, Science)
> ##D refs <- paste("DQ082", 505:545, sep = "")
> ##D DNA <- read.GenBank(refs)
> ##D DNA.clustal <- clustal(DNA)
> ##D DNA.muscle <- muscle(DNA)
> ##D isTRUE(all.equal(DNA.clustal, DNA.muscle)) # FALSE
> ##D all.equal(DNA.clustal, DNA.muscle, TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("all.equal.phylo")
> ### * all.equal.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: all.equal.phylo
> ### Title: Global Comparison of two Phylogenies
> ### Aliases: all.equal.phylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> ### maybe the simplest example of two representations
> ### for the same rooted tree...:
> t1 <- read.tree(text = "(a:1,b:1);")
> t2 <- read.tree(text = "(b:1,a:1);")
> all.equal(t1, t2)
[1] TRUE
> ### ... compare with this:
> identical(t1, t2)
[1] FALSE
> ### one just slightly more complicated...:
> t3 <- read.tree(text = "((a:1,b:1):1,c:2);")
> t4 <- read.tree(text = "(c:2,(a:1,b:1):1);")
> all.equal(t3, t4) # == all.equal.phylo(t3, t4)
[1] TRUE
> ### ... here we force the comparison as lists:
> all.equal.list(t3, t4)
[1] "Component “edge”: Mean relative difference: 0.6666667"       
[2] "Component “edge.length”: Mean relative difference: 0.6666667"
[3] "Component “tip.label”: 3 string mismatches"                  
> 
> 
> 
> cleanEx()
> nameEx("alview")
> ### * alview
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alview
> ### Title: Print DNA or AA Sequence Alignement
> ### Aliases: alview
> ### Keywords: IO
> 
> ### ** Examples
> 
> data(woodmouse)
> alview(woodmouse[, 1:50])
        00000000011111111112222222222333333333344444444445
        12345678901234567890123456789012345678901234567890
No305   NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACTCCTTCATCGA
No304   A..........................A......AC..............
No306   A..........................A......A...............
No0906S A..........................A.C....A...............
No0908S A..........................A......A...............
No0909S A..........................A......A...............
No0910S A..........................A......A......T........
No0912S A..........................A......A...............
No0913S A..........................A......AC..............
No1103S A..........................A....T.A...............
No1007S A..........................A......A...............
No1114S .NNNNNNNNNNNNNNNNNNNNNNNNNN.NNNNNNNNNNNNNNNNN.....
No1202S A..........................A......A...............
No1206S A..........................A......A...............
No1208S .NN........................A......A...............
> alview(woodmouse[, 1:50], uppercase = FALSE)
        00000000011111111112222222222333333333344444444445
        12345678901234567890123456789012345678901234567890
No305   nttcgaaaaacacacccactactaaaanttatcagtcactccttcatcga
No304   a..........................a......ac..............
No306   a..........................a......a...............
No0906S a..........................a.c....a...............
No0908S a..........................a......a...............
No0909S a..........................a......a...............
No0910S a..........................a......a......t........
No0912S a..........................a......a...............
No0913S a..........................a......ac..............
No1103S a..........................a....t.a...............
No1007S a..........................a......a...............
No1114S .nnnnnnnnnnnnnnnnnnnnnnnnnn.nnnnnnnnnnnnnnnnn.....
No1202S a..........................a......a...............
No1206S a..........................a......a...............
No1208S .nn........................a......a...............
> ## display only some sites:
> j <- c(10, 49, 125, 567) # just random
> x <- woodmouse[, j]
> alview(x, showpos = FALSE) # no site position displayed
No305   AGTA
No304   ....
No306   ....
No0906S ....
No0908S ....
No0909S ....
No0910S ....
No0912S ....
No0913S ....
No1103S ....
No1007S ....
No1114S N...
No1202S ....
No1206S ....
No1208S ....
> alview(x, showpos = j)
        0015
        1426
        0957
No305   AGTA
No304   ....
No306   ....
No0906S ....
No0908S ....
No0909S ....
No0910S ....
No0912S ....
No0913S ....
No1103S ....
No1007S ....
No1114S N...
No1202S ....
No1206S ....
No1208S ....
> ## Not run: 
> ##D alview(woodmouse, file = "woodmouse.txt")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("apetools")
> ### * apetools
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apetools
> ### Title: Tools to Explore Files
> ### Aliases: apetools Xplorefiles Xplor editFileExtensions bydir
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- Xplorefiles()
> ##D x # all data files on your disk
> ##D bydir(x) # sorted by directories
> ##D bydir(x["fasta"]) # only the FASTA files
> ##D Xplorefiles(getwd(), recursive = FALSE) # look only in current dir
> ##D Xplor()
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("as.alignment")
> ### * as.alignment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.alignment
> ### Title: Conversion Among DNA Sequence Internal Formats
> ### Aliases: as.alignment as.DNAbin as.DNAbin.character as.DNAbin.list
> ###   as.DNAbin.alignment as.character.DNAbin as.DNAbin.DNAString
> ###   as.DNAbin.DNAStringSet as.DNAbin.PairwiseAlignmentsSingleSubject
> ###   as.DNAbin.DNAMultipleAlignment
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(woodmouse)
> x <- as.character(woodmouse)
> x[, 1:20]
        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
No305   "n"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No304   "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No306   "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0906S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0908S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0909S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0910S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0912S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No0913S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No1103S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No1007S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No1114S "n"  "n"  "n"  "n"  "n"  "n"  "n"  "n"  "n"  "n"   "n"   "n"   "n"  
No1202S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No1206S "a"  "t"  "t"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
No1208S "n"  "n"  "n"  "c"  "g"  "a"  "a"  "a"  "a"  "a"   "c"   "a"   "c"  
        [,14] [,15] [,16] [,17] [,18] [,19] [,20]
No305   "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No304   "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No306   "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0906S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0908S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0909S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0910S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0912S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No0913S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No1103S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No1007S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No1114S "n"   "n"   "n"   "n"   "n"   "n"   "n"  
No1202S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No1206S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
No1208S "a"   "c"   "c"   "c"   "a"   "c"   "t"  
> str(as.alignment(x))
List of 4
 $ nb : int 15
 $ seq: chr [1:15] "nttcgaaaaacacacccactactaaaanttatcagtcactccttcatcgacttaccagctccatctaacatttcatcatgatgaaacttcggctcattactaggagtctgc"| __truncated__ "attcgaaaaacacacccactactaaaaattatcaaccactccttcatcgacttaccagctccatctaacatttcatcatgatgaaacttcggctcattactaggaatctgc"| __truncated__ "attcgaaaaacacacccactactaaaaattatcaatcactccttcatcgacttaccagctccatctaacatttcatcatgatgaaacttcggctcattactaggaatctgc"| __truncated__ "attcgaaaaacacacccactactaaaaatcatcaatcactccttcatcgatttaccagctccatctaacatttcatcatgatgaaacttcggctcattactaggaatctgc"| __truncated__ ...
 $ nam: chr [1:15] "No305" "No304" "No306" "No0906S" ...
 $ com: logi NA
 - attr(*, "class")= chr "alignment"
> identical(as.DNAbin(x), woodmouse)
[1] TRUE
> ### conversion from BioConductor:
> ## Not run: 
> ##D if (require(Biostrings)) {
> ##D data(phiX174Phage)
> ##D X <- as.DNAbin(phiX174Phage)
> ##D ## base frequencies:
> ##D base.freq(X) # from ape
> ##D alphabetFrequency(phiX174Phage) # from Biostrings
> ##D ### for objects of class "DNAStringSetList"
> ##D X <- lapply(x, as.DNAbin) # a list of lists
> ##D ### to put all sequences in a single list:
> ##D X <- unlist(X, recursive = FALSE)
> ##D class(X) <- "DNAbin"
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("as.bitsplits")
> ### * as.bitsplits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.bitsplits
> ### Title: Split Frequencies and Conversion Among Split Classes
> ### Aliases: as.bitsplits as.bitsplits.prop.part print.bitsplits
> ###   sort.bitsplits bitsplits countBipartitions as.prop.part
> ###   as.prop.part.bitsplits
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- rtree(20)
> pp <- prop.part(tr)
> as.bitsplits(pp)
Object of class "bitsplits"
    20 tips
    38 partitions
> ## works only with unrooted trees (ape 5.5):
> countBipartitions(rtree(10, rooted = FALSE), rmtree(100, 10, rooted = FALSE))
[1] 10  9  3  7  2  7  5
> 
> 
> 
> cleanEx()
> nameEx("as.matching")
> ### * as.matching
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.matching
> ### Title: Conversion Between Phylo and Matching Objects
> ### Aliases: as.matching matching as.matching.phylo as.phylo.matching
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> m <- as.matching(bird.orders)
Warning in as.matching.phylo(bird.orders) :
  branch lengths have been ignored
> str(m)
List of 2
 $ matching : int [1:22, 1:2] 1 3 9 11 16 18 21 5 26 28 ...
 $ tip.label: chr [1:23] "Struthioniformes" "Tinamiformes" "Craciformes" "Galliformes" ...
 - attr(*, "class")= chr "matching"
> m
$matching
      [,1] [,2]
 [1,]    1    2
 [2,]    3    4
 [3,]    9   10
 [4,]   11   12
 [5,]   16   17
 [6,]   18   19
 [7,]   21   22
 [8,]    5   25
 [9,]   26   27
[10,]   28   29
[11,]   20   30
[12,]   24   31
[13,]    8   32
[14,]   23   34
[15,]   33   37
[16,]   15   38
[17,]   14   39
[18,]   13   40
[19,]   36   41
[20,]    7   42
[21,]    6   43
[22,]   35   44

$tip.label
 [1] "Struthioniformes" "Tinamiformes"     "Craciformes"      "Galliformes"     
 [5] "Anseriformes"     "Turniciformes"    "Piciformes"       "Galbuliformes"   
 [9] "Bucerotiformes"   "Upupiformes"      "Trogoniformes"    "Coraciiformes"   
[13] "Coliiformes"      "Cuculiformes"     "Psittaciformes"   "Apodiformes"     
[17] "Trochiliformes"   "Musophagiformes"  "Strigiformes"     "Columbiformes"   
[21] "Gruiformes"       "Ciconiiformes"    "Passeriformes"   

attr(,"class")
[1] "matching"
> tr <- as.phylo(m)
> all.equal(tr, bird.orders, use.edge.length = FALSE)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("as.phylo")
> ### * as.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.phylo
> ### Title: Conversion Among Tree and Network Objects
> ### Aliases: as.phylo as.phylo.default as.phylo.hclust as.phylo.phylog
> ###   as.hclust.phylo old2new.phylo new2old.phylo as.network.phylo
> ###   as.igraph as.igraph.phylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> hc <- as.hclust(bird.orders)
> tr <- as.phylo(hc)
> all.equal(bird.orders, tr) # TRUE
[1] TRUE
> 
> ### shows the three plots for tree objects:
> dend <- as.dendrogram(hc)
> layout(matrix(c(1:3, 3), 2, 2))
> plot(bird.orders, font = 1)
> plot(hc)
> par(mar = c(8, 0, 0, 0)) # leave space for the labels
> plot(dend)
> 
> ### how to get identical plots with
> ### plot.phylo and plot.dendrogram:
> layout(matrix(1:2, 2, 1))
> plot(bird.orders, font = 1, no.margin = TRUE, label.offset = 0.4)
> par(mar = c(0, 0, 0, 8))
> plot(dend, horiz = TRUE)
> layout(1)
> 
> ## Not run: 
> ##D ### convert into networks:
> ##D if (require(network)) {
> ##D     x <- as.network(rtree(10))
> ##D     print(x)
> ##D     plot(x, vertex.cex = 1:4)
> ##D     plot(x, displaylabels = TRUE)
> ##D }
> ##D tr <- rtree(5)
> ##D if (require(igraph)) {
> ##D     print((x <- as.igraph(tr)))
> ##D     plot(x)
> ##D     print(as.igraph(tr, TRUE, FALSE))
> ##D     print(as.igraph(tr, FALSE, FALSE))
> ##D }
> ## End(Not run)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("as.phylo.formula")
> ### * as.phylo.formula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.phylo.formula
> ### Title: Conversion from Taxonomy Variables to Phylogenetic Trees
> ### Aliases: as.phylo.formula
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(carnivora)
> frm <- ~SuperFamily/Family/Genus/Species
> tr <- as.phylo(frm, data = carnivora, collapse=FALSE)
> tr$edge.length <- rep(1, nrow(tr$edge))
> plot(tr, show.node.label=TRUE)
> Nnode(tr)
[1] 83
> ## compare with:
> Nnode(as.phylo(frm, data = carnivora, collapse = FALSE))
[1] 83
> 
> 
> 
> cleanEx()
> nameEx("axisPhylo")
> ### * axisPhylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: axisPhylo
> ### Title: Axis on Side of Phylogeny
> ### Aliases: axisPhylo
> ### Keywords: aplot
> 
> ### ** Examples
> 
> tr <- rtree(30)
> ch <- rcoal(30)
> plot(ch)
> axisPhylo()
> plot(tr, "c", FALSE, direction = "u")
> axisPhylo(las = 1)
> 
> 
> 
> cleanEx()
> nameEx("base.freq")
> ### * base.freq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base.freq
> ### Title: Base frequencies from DNA Sequences
> ### Aliases: base.freq GC.content Ftab
> ### Keywords: univar manip
> 
> ### ** Examples
> 
> data(woodmouse)
> base.freq(woodmouse)
        a         c         g         t 
0.3065414 0.2613083 0.1260264 0.3061239 
> base.freq(woodmouse, TRUE)
   a    c    g    t 
4405 3755 1811 4399 
> base.freq(woodmouse, TRUE, TRUE)
   a    c    g    t    r    m    w    s    k    y    v    h    d    b    n    - 
4405 3755 1811 4399    0    0    0    0    0    0    0    0    0    0  105    0 
   ? 
   0 
> GC.content(woodmouse)
[1] 0.3873347
> Ftab(woodmouse)
    a   c   g   t
a 287   0   2   0
c   0 247   0   5
g   5   0 119   0
t   0   4   0 290
> Ftab(woodmouse[1, ], woodmouse[2, ]) # same than above
    a   c   g   t
a 287   0   2   0
c   0 247   0   5
g   5   0 119   0
t   0   4   0 290
> Ftab(woodmouse[14:15, ]) # between the last two
    a   c   g   t
a 292   1   1   0
c   0 246   0   3
g   1   0 120   1
t   0  10   0 283
> 
> 
> 
> cleanEx()
> nameEx("bd.ext")
> ### * bd.ext
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bd.ext
> ### Title: Extended Version of the Birth-Death Models to Estimate
> ###   Speciation and Extinction Rates
> ### Aliases: bd.ext
> ### Keywords: models
> 
> ### ** Examples
> 
> ### An example from Paradis (2003) using the avian orders:
> data(bird.orders)
> ### Number of species in each order from Sibley and Monroe (1990):
> S <- c(10, 47, 69, 214, 161, 17, 355, 51, 56, 10, 39, 152,
+        6, 143, 358, 103, 319, 23, 291, 313, 196, 1027, 5712)
> bd.ext(bird.orders, S)
Warning in nlm(function(p) dev(p[1], p[2]), c(0.1, 0.2), hessian = TRUE) :
  Inf replaced by maximum positive value

Extended Version of the Birth-Death Models to
    Estimate Speciation and Extinction Rates

    Data: phylogenetic: bird.orders 
             taxonomic: S 
        Number of tips: 23 
              Deviance: 290.2335 
        Log-likelihood: -145.1167 
   Parameter estimates:
      d / b = 1.177201e-07   StdErr = 0.1542077 
      b - d = 0.2765149   StdErr = 0.009577571 
   (b: speciation rate, d: extinction rate)
> bd.ext(bird.orders, S, FALSE) # same than older versions

Extended Version of the Birth-Death Models to
    Estimate Speciation and Extinction Rates

    Data: phylogenetic: bird.orders 
             taxonomic: S 
        Number of tips: 23 
              Deviance: 290.2541 
        Log-likelihood: -145.127 
   Parameter estimates:
      d / b = 5.606196e-07   StdErr = 0.1067571 
      b - d = 0.276421   StdErr = 0.008114677 
   (b: speciation rate, d: extinction rate)
> 
> 
> 
> cleanEx()
> nameEx("bd.time")
> ### * bd.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bd.time
> ### Title: Time-Dependent Birth-Death Models
> ### Aliases: bd.time
> ### Keywords: models
> 
> ### ** Examples
> 
> set.seed(3)
> tr <- rbdtree(0.1, 0.02)
> bd.time(tr, 0, 0) # fits a simple BD model
Warning in nlminb(ip, foo, control = list(trace = trace, eval.max = 500),  :
  NA/NaN function evaluation
$par
     birth      death 
0.10044901 0.00612507 

$SS
[1] 21.01908

$convergence
[1] 0

$iterations
[1] 44

$evaluations
function gradient 
      60      101 

$message
[1] "relative convergence (4)"

> bd.time(tr, 0, 0, ip = c(.1, .01)) # 'ip' is useful here
$par
      birth       death 
0.100449011 0.006125072 

$SS
[1] 21.01908

$convergence
[1] 0

$iterations
[1] 18

$evaluations
function gradient 
      25       46 

$message
[1] "relative convergence (4)"

> ## the classic logistic:
> birth.logis <- function(a, b) 1/(1 + exp(-a*t - b))
> ## Not run: 
> ##D bd.time(tr, birth.logis, 0, ip = c(0, -2, 0.01))
> ##D ## slow to get:
> ##D ## $par
> ##D ##            a            b        death
> ##D ## -0.003486961 -1.995983179  0.016496454
> ##D ##
> ##D ## $SS
> ##D ## [1] 20.73023
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("binaryPGLMM")
> ### * binaryPGLMM
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: binaryPGLMM
> ### Title: Phylogenetic Generalized Linear Mixed Model for Binary Data
> ### Aliases: binaryPGLMM binaryPGLMM.sim print.binaryPGLMM
> ### Keywords: regression
> 
> ### ** Examples
> 
> ## Illustration of binaryPGLMM() with simulated data
> 
> # Generate random phylogeny
> 
> n <- 100
> phy <- compute.brlen(rtree(n=n), method = "Grafen", power = 1)
> 
> # Generate random data and standardize to have mean 0 and variance 1
> X1 <- rTraitCont(phy, model = "BM", sigma = 1)
> X1 <- (X1 - mean(X1))/var(X1)
> 
> # Simulate binary Y
> sim.dat <- data.frame(Y=array(0, dim=n), X1=X1, row.names=phy$tip.label)
> sim.dat$Y <- binaryPGLMM.sim(Y ~ X1, phy=phy, data=sim.dat, s2=.5,
+                              B=matrix(c(0,.25),nrow=2,ncol=1), nrep=1)$Y
> 
> # Fit model
> binaryPGLMM(Y ~ X1, phy=phy, data=sim.dat)


Call:Y ~ X1

Random effect (phylogenetic signal s2):
         s2  Pr
1 3.136e-11 0.5

Fixed effects:
              Value Std.Error Zscore    Pvalue    
(Intercept) 0.86490   0.22177 3.9000 9.621e-05 ***
X1          0.31863   0.24004 1.3274    0.1844    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

> 
> ## Not run: 
> ##D # Compare with phyloglm()
> ##D library(phylolm)
> ##D summary(phyloglm(Y ~ X1, phy=phy, data=sim.dat))
> ##D 
> ##D # Compare with glm() that does not account for phylogeny
> ##D summary(glm(Y ~ X1, data=sim.dat, family="binomial"))
> ##D 
> ##D # Compare with logistf() that does not account
> ##D # for phylogeny but is less biased than glm()
> ##D library(logistf)
> ##D logistf(Y ~ X1, data=sim.dat)
> ##D 
> ##D # Compare with MCMCglmm
> ##D library(MCMCglmm)
> ##D 
> ##D V <- vcv(phy)
> ##D V <- V/max(V)
> ##D detV <- exp(determinant(V)$modulus[1])
> ##D V <- V/detV^(1/n)
> ##D 
> ##D invV <- Matrix(solve(V),sparse=T)
> ##D sim.dat$species <- phy$tip.label
> ##D rownames(invV) <- sim.dat$species
> ##D 
> ##D nitt <- 43000
> ##D thin <- 10
> ##D burnin <- 3000
> ##D 
> ##D prior <- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=1000, alpha.mu=0, alpha.V=1)))
> ##D summary(MCMCglmm(Y ~ X1, random=~species, ginvers=list(species=invV),
> ##D     data=sim.dat, slice=TRUE, nitt=nitt, thin=thin, burnin=burnin,
> ##D     family="categorical", prior=prior, verbose=FALSE))
> ##D 
> ##D ## Examine bias in estimates of B1 and s2 from binaryPGLMM with
> ##D # simulated data. Note that this will take a while.
> ##D 
> ##D Reps = 1000
> ##D 
> ##D s2 <- 0.4
> ##D B1 <- 1
> ##D 
> ##D meanEsts <- data.frame(n = Inf, B1 = B1, s2 = s2, Pr.s2 = 1, propconverged = 1)
> ##D 
> ##D for (n in c(160, 80, 40, 20)) {
> ##D 
> ##D   meanEsts.n <- data.frame(B1 = 0, s2 = 0, Pr.s2 = 0, convergefailure = 0)
> ##D     for (rep in 1:Reps) {
> ##D       phy <- compute.brlen(rtree(n = n), method = "Grafen", power = 1)
> ##D       X <- rTraitCont(phy, model = "BM", sigma = 1)
> ##D       X <- (X - mean(X))/var(X)
> ##D 
> ##D       sim.dat <- data.frame(Y = array(0, dim = n), X = X, row.names = phy$tip.label)
> ##D       sim <- binaryPGLMM.sim(Y ~ 1 + X, phy = phy, data = sim.dat, s2 = s2,
> ##D                                        B = matrix(c(0,B1), nrow = 2, ncol = 1), nrep = 1)
> ##D       sim.dat$Y <- sim$Y
> ##D 
> ##D       z <- binaryPGLMM(Y ~ 1 + X, phy = phy, data = sim.dat)
> ##D 
> ##D       meanEsts.n[rep, ] <- c(z$B[2], z$s2, z$P.H0.s2, z$convergeflag == "converged")
> ##D   }
> ##D converged <- meanEsts.n[,4]
> ##D meanEsts <- rbind(meanEsts,
> ##D                   c(n, mean(meanEsts.n[converged==1,1]),
> ##D                             mean(meanEsts.n[converged==1,2]),
> ##D                             mean(meanEsts.n[converged==1, 3] < 0.05),
> ##D                             mean(converged)))
> ##D }
> ##D meanEsts
> ##D 
> ##D # Results output for B1 = 0.5, s2 = 0.4; n-Inf gives the values used to
> ##D # simulate the data
> ##D #    n       B1        s2      Pr.s2 propconverged
> ##D # 1 Inf 1.000000 0.4000000 1.00000000         1.000
> ##D # 2 160 1.012719 0.4479946 0.36153072         0.993
> ##D # 3  80 1.030876 0.5992027 0.24623116         0.995
> ##D # 4  40 1.110201 0.7425203 0.13373860         0.987
> ##D # 5  20 1.249886 0.8774708 0.05727377         0.873
> ##D 
> ##D 
> ##D ## Examine type I errors for estimates of B0 and s2 from binaryPGLMM()
> ##D # with simulated data. Note that this will take a while.
> ##D 
> ##D Reps = 1000
> ##D 
> ##D s2 <- 0
> ##D B0 <- 0
> ##D B1 <- 0
> ##D 
> ##D H0.tests <- data.frame(n = Inf, B0 = B0, s2 = s2, Pr.B0 = .05,
> ##D                        Pr.s2 = .05, propconverged = 1)
> ##D for (n in c(160, 80, 40, 20)) {
> ##D 
> ##D   ests.n <- data.frame(B1 = 0, s2 = 0, Pr.B0 = 0, Pr.s2 = 0, convergefailure = 0)
> ##D   for (rep in 1:Reps) {
> ##D     phy <- compute.brlen(rtree(n = n), method = "Grafen", power = 1)
> ##D     X <- rTraitCont(phy, model = "BM", sigma = 1)
> ##D     X <- (X - mean(X))/var(X)
> ##D 
> ##D     sim.dat <- data.frame(Y = array(0, dim = n), X = X, row.names = phy$tip.label)
> ##D     sim <- binaryPGLMM.sim(Y ~ 1, phy = phy, data = sim.dat, s2 = s2,
> ##D                            B = matrix(B0, nrow = 1, ncol = 1), nrep = 1)
> ##D     sim.dat$Y <- sim$Y
> ##D 
> ##D     z <- binaryPGLMM(Y ~ 1, phy = phy, data = sim.dat)
> ##D 
> ##D     ests.n[rep, ] <- c(z$B[1], z$s2, z$B.pvalue, z$P.H0.s2, z$convergeflag == "converged")
> ##D   }
> ##D 
> ##D converged <- ests.n[,5]
> ##D H0.tests <- rbind(H0.tests,
> ##D                   c(n, mean(ests.n[converged==1,1]),
> ##D                     mean(ests.n[converged==1,2]),
> ##D                     mean(ests.n[converged==1, 3] < 0.05),
> ##D                     mean(ests.n[converged==1, 4] < 0.05),
> ##D                     mean(converged)))
> ##D }
> ##D H0.tests
> ##D 
> ##D # Results for type I errors for B0 = 0 and s2 = 0; n-Inf gives the values
> ##D # used to simulate the data. These results show that binaryPGLMM() tends to
> ##D # have lower-than-nominal p-values; fewer than 0.05 of the simulated
> ##D # data sets have H0:B0=0 and H0:s2=0 rejected at the alpha=0.05 level.
> ##D #     n            B0         s2      Pr.B0      Pr.s2 propconverged
> ##D # 1 Inf  0.0000000000 0.00000000 0.05000000 0.05000000         1.000
> ##D # 2 160 -0.0009350357 0.07273163 0.02802803 0.04804805         0.999
> ##D # 3  80 -0.0085831477 0.12205876 0.04004004 0.03403403         0.999
> ##D # 4  40  0.0019303847 0.25486307 0.02206620 0.03711133         0.997
> ##D # 5  20  0.0181394905 0.45949266 0.02811245 0.03313253         0.996
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("bind.tree")
> ### * bind.tree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bind.tree
> ### Title: Binds Trees
> ### Aliases: bind.tree +.phylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> ### binds the two clades of bird orders
> treefile1 <- tempfile("tree", fileext = ".tre")
> treefile2 <- tempfile("tree", fileext = ".tre")
> cat("((Struthioniformes:21.8,Tinamiformes:21.8):4.1,",
+     "((Craciformes:21.6,Galliformes:21.6):1.3,Anseriformes:22.9):3.0):2.1;",
+     file = treefile1, sep = "\n")
> cat("(Turniciformes:27.0,(Piciformes:26.3,((Galbuliformes:24.4,",
+     "((Bucerotiformes:20.8,Upupiformes:20.8):2.6,",
+     "(Trogoniformes:22.1,Coraciiformes:22.1):1.3):1.0):0.6,",
+     "(Coliiformes:24.5,(Cuculiformes:23.7,(Psittaciformes:23.1,",
+     "(((Apodiformes:21.3,Trochiliformes:21.3):0.6,",
+     "(Musophagiformes:20.4,Strigiformes:20.4):1.5):0.6,",
+     "((Columbiformes:20.8,(Gruiformes:20.1,Ciconiiformes:20.1):0.7):0.8,",
+     "Passeriformes:21.6):0.9):0.6):0.6):0.8):0.5):1.3):0.7):1.0;",
+     file = treefile2, sep = "\n")
> tree.bird1 <- read.tree(treefile1)
> tree.bird2 <- read.tree(treefile2)
> unlink(c(treefile1, treefile2)) # clean-up
> (birds <- tree.bird1 + tree.bird2)

Phylogenetic tree with 23 tips and 22 internal nodes.

Tip labels:
  Struthioniformes, Tinamiformes, Craciformes, Galliformes, Anseriformes, Turniciformes, ...

Rooted; includes branch length(s).
> layout(matrix(c(1, 2, 3, 3), 2, 2))
> plot(tree.bird1)
> plot(tree.bird2)
> plot(birds)
> 
> ### examples with random trees
> x <- rtree(4, tip.label = LETTERS[1:4])
> y <- rtree(4, tip.label = LETTERS[5:8])
> x <- makeNodeLabel(x, prefix = "x_")
> y <- makeNodeLabel(y, prefix = "y_")
> x$root.edge <- y$root.edge <- .2
> 
> z <- bind.tree(x, y, po=.2)
> plot(y, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("y")
> plot(x, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("x")
> plot(z, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("z <- bind.tree(x, y, po=.2)")
> 
> ## make sure the terminal branch length is long enough:
> x$edge.length[x$edge[, 2] == 2] <- 0.2
> 
> z <- bind.tree(x, y, 2, .1)
> plot(y, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("y")
> plot(x, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("x")
> plot(z, show.node.label = TRUE, font = 1, root.edge = TRUE)
> title("z <- bind.tree(x, y, 2, .1)")
> 
> x <- rtree(50)
> y <- rtree(50)
> x$root.edge <- y$root.edge <- .2
> z <- x + y
> plot(y, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
> title("y")
> plot(x, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
> title("x")
> plot(z, show.tip.label = FALSE, root.edge = TRUE); axisPhylo()
> title("z <- x + y")
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("bionj")
> ### * bionj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BIONJ
> ### Title: Tree Estimation Based on an Improved Version of the NJ Algorithm
> ### Aliases: bionj
> ### Keywords: models
> 
> ### ** Examples
> 
> ### From Saitou and Nei (1987, Table 1):
> x <- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
+        10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
+        5, 6, 10, 9, 13, 8)
> M <- matrix(0, 8, 8)
> M[lower.tri(M)] <- x
> M <- t(M)
> M[lower.tri(M)] <- x
> dimnames(M) <- list(1:8, 1:8)
> tr <- bionj(M)
> plot(tr, "u")
> ### a less theoretical example
> data(woodmouse)
> trw <- bionj(dist.dna(woodmouse))
> plot(trw)
> 
> 
> 
> cleanEx()
> nameEx("bird.families")
> ### * bird.families
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bird.families
> ### Title: Phylogeny of the Families of Birds From Sibley and Ahlquist
> ### Aliases: bird.families
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(bird.families)
> op <- par(cex = 0.3)
> plot(bird.families)
> par(op)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("bird.orders")
> ### * bird.orders
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bird.orders
> ### Title: Phylogeny of the Orders of Birds From Sibley and Ahlquist
> ### Aliases: bird.orders
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(bird.orders)
> plot(bird.orders)
> 
> 
> 
> cleanEx()
> nameEx("boot.phylo")
> ### * boot.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boot.phylo
> ### Title: Tree Bipartition and Bootstrapping Phylogenies
> ### Aliases: boot.phylo prop.part prop.clades print.prop.part
> ###   summary.prop.part plot.prop.part
> ### Keywords: manip htest
> 
> ### ** Examples
> 
> data(woodmouse)
> f <- function(x) nj(dist.dna(x))
> tr <- f(woodmouse)
> ### Are bootstrap values stable?
> for (i in 1:5)
+   print(boot.phylo(tr, woodmouse, f, quiet = TRUE))
 [1]  NA  44  71  63  65  45  77  67  81  96  88 100  57
 [1]  NA  47  48  54  64  54  65  67  87  93  80 100  65
 [1]  NA  41  56  58  57  44  81  68  83  91  90 100  51
 [1]  NA  51  57  64  62  49  67  65  87  90  87 100  53
 [1]  NA  52  51  65  68  47  75  69  82  93  89 100  54
> ### How many partitions in 100 random trees of 10 labels?...
> TR <- rmtree(100, 10)
> pp10 <- prop.part(TR)
> length(pp10)
[1] 381
> ### ... and in 100 random trees of 20 labels?
> TR <- rmtree(100, 20)
> pp20 <- prop.part(TR)
> length(pp20)
[1] 1261
> plot(pp10, pch = "x", col = 2)
> plot(pp20, pch = "x", col = 2)
> 
> set.seed(2)
> tr <- rtree(10) # rooted
> ## the following used to return a wrong result with ape <= 3.4:
> prop.clades(tr, tr)
[1] 1 1 1 1 1 1 1 1 1
> prop.clades(tr, tr, rooted = TRUE)
[1] 1 1 1 1 1 1 1 1 1
> tr <- rtree(10, rooted = FALSE)
> prop.clades(tr, tr) # correct
[1] 1 1 1 1 1 1 1 1
> 
> ### an illustration of the use of prop.clades with bootstrap trees:
> 
> fun <- function(x) as.phylo(hclust(dist.dna(x), "average")) # upgma() in phangorn
> tree <- fun(woodmouse)
> ## get 100 bootstrap trees:
> bstrees <- boot.phylo(tree, woodmouse, fun, trees = TRUE)$trees
Running bootstraps:       100 / 100
Calculating bootstrap values... done.
> ## get proportions of each clade:
> clad <- prop.clades(tree, bstrees, rooted = TRUE)
> ## get proportions of each bipartition:
> boot <- prop.clades(tree, bstrees)
> layout(1)
> par(mar = rep(2, 4))
> plot(tree, main = "Bipartition vs. Clade Support Values")
> drawSupportOnEdges(boot)
> nodelabels(clad)
> legend("bottomleft", legend = c("Bipartitions", "Clades"), pch = 22,
+        pt.bg = c("green", "lightblue"), pt.cex = 2.5)
> 
> ## Not run: 
> ##D ## an example of double bootstrap:
> ##D nrep1 <- 100
> ##D nrep2 <- 100
> ##D p <- ncol(woodmouse)
> ##D DB <- 0
> ##D 
> ##D for (b in 1:nrep1) {
> ##D     X <- woodmouse[, sample(p, p, TRUE)]
> ##D     DB <- DB + boot.phylo(tr, X, f, nrep2, quiet = TRUE)
> ##D }
> ##D DB
> ##D ## to compare with:
> ##D boot.phylo(tr, woodmouse, f, 1e4)
> ## End(Not run)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("c.phylo")
> ### * c.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: c.phylo
> ### Title: Building Lists of Trees
> ### Aliases: c.phylo c.multiPhylo .compressTipLabel .uncompressTipLabel
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- c(rtree(4), rtree(2))
> x
2 phylogenetic trees
> y <- c(rtree(4), rtree(4))
> z <- c(x, y)
> z
4 phylogenetic trees
> print(z, TRUE)
4 phylogenetic trees
tree 1 : 4 tips
tree 2 : 2 tips
tree 3 : 4 tips
tree 4 : 4 tips
> try(.compressTipLabel(x)) # error
Error in FUN(X[[i]], ...) : one tree has a different number of tips
> a <- .compressTipLabel(y)
> .uncompressTipLabel(a) # back to y
2 phylogenetic trees
> ## eventually compare str(a) and str(y)
> 
> 
> 
> cleanEx()
> nameEx("carnivora")
> ### * carnivora
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: carnivora
> ### Title: Carnivora body sizes and life history traits
> ### Aliases: carnivora
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(carnivora)
> ## Fig. 1 in Gittleman (1986):
> plot(carnivora$BW ~ carnivora$FW, pch = (1:8)[carnivora$Family], log = "xy",
+      xlab = "Female body weight (kg)", ylab = "Birth weigth (g)",
+      ylim = c(1, 2000))
> legend("bottomright", legend = levels(carnivora$Family), pch = 1:8)
> plot(carnivora$BW ~ carnivora$FB, pch = (1:8)[carnivora$Family], log = "xy",
+      xlab = "Female brain weight (g)", ylab = "Birth weigth (g)",
+      ylim = c(1, 2000))
> legend("bottomright", legend = levels(carnivora$Family), pch = 1:8)
> 
> 
> 
> cleanEx()
> nameEx("checkAlignment")
> ### * checkAlignment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkAlignment
> ### Title: Check DNA Alignments
> ### Aliases: checkAlignment
> 
> ### ** Examples
> 
> data(woodmouse)
> checkAlignment(woodmouse)

Number of sequences: 15 
Number of sites: 965 

No gap in alignment.

Number of segregating sites (including gaps): 56
Number of sites with at least one substitution: 56
Number of sites with 1, 2, 3 or 4 observed bases:
  1   2   3   4 
909  54   2   0 

> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("checkLabel")
> ### * checkLabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkLabel
> ### Title: Checking Labels
> ### Aliases: checkLabel
> ### Keywords: manip
> 
> ### ** Examples
> 
> checkLabel(" Homo sapiens\t(Primates; World)   ")
[1] "Homo_sapiens_-Primates-_World"
> 
> 
> 
> cleanEx()
> nameEx("checkValidPhylo")
> ### * checkValidPhylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkValidPhylo
> ### Title: Check the Structure of a "phylo" Object
> ### Aliases: checkValidPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- rtree(3)
> checkValidPhylo(tr)
Starting checking the validity of tr...
Found number of tips: n = 3 
Found number of nodes: m = 2 
Done.
> tr$edge[1] <- 0
> checkValidPhylo(tr)
Starting checking the validity of tr...
Found number of tips: n = 3 
Found number of nodes: m = 2 
  MODERATE: the matrix 'edge' is not stored as integers
  FATAL: some elements in 'edge' are negative or zero
  FATAL: all nodes should appear at least twice in 'edge'
Done.
> 
> 
> 
> cleanEx()
> nameEx("chiroptera")
> ### * chiroptera
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chiroptera
> ### Title: Bat Phylogeny
> ### Aliases: chiroptera
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(chiroptera)
> str(chiroptera)
List of 3
 $ edge     : int [1:1344, 1:2] 917 918 919 920 920 921 922 922 921 923 ...
 $ tip.label: chr [1:916] "Paranyctimene_raptor" "Nyctimene_aello" "Nyctimene_celaeno" "Nyctimene_certans" ...
 $ Nnode    : int 429
 - attr(*, "class")= chr "phylo"
> op <- par(cex = 0.3)
> plot(chiroptera, type = "c")
> par(op)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("chronoMPL")
> ### * chronoMPL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chronoMPL
> ### Title: Molecular Dating With Mean Path Lengths
> ### Aliases: chronoMPL
> ### Keywords: models
> 
> ### ** Examples
> 
> tr <- rtree(10)
> tr$edge.length <- 5*tr$edge.length
> chr <- chronoMPL(tr)
> layout(matrix(1:4, 2, 2, byrow = TRUE))
> plot(tr)
> title("The original tree")
> plot(chr)
> axisPhylo()
> title("The dated MPL tree")
> plot(chr)
> nodelabels(round(attr(chr, "stderr"), 3))
> title("The standard-errors")
> plot(tr)
> nodelabels(round(attr(chr, "Pval"), 3))
> title("The tests")
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("chronos")
> ### * chronos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chronos
> ### Title: Molecular Dating by Penalised Likelihood and Maximum Likelihood
> ### Aliases: chronos makeChronosCalib chronos.control print.chronos
> ### Keywords: models
> 
> ### ** Examples
> 
> library(ape)
> tr <- rtree(10)
> ### the default is the correlated rate model:
> chr <- chronos(tr)

Setting initial dates...
Fitting in progress... get a first set of estimates
         (Penalised) log-lik = -12.6253 
Optimising rates... dates... -12.6253 
Optimising rates... dates... -12.62529 

log-Lik = -12.88558 
PHIIC = 79.67 
> ### strict clock model:
> ctrl <- chronos.control(nb.rate.cat = 1)
> chr.clock <- chronos(tr, model = "discrete", control = ctrl)

Setting initial dates...
Fitting in progress... get a first set of estimates
         (Penalised) log-lik = -13.42211 
Optimising rates... dates... -13.42211 

log-Lik = -13.42211 
PHIIC = 44.84 
> ### How different are the rates?
> attr(chr, "rates")
 [1] 1.5321795 1.7944104 2.0287369 2.0184549 2.1552796 2.1711601 2.1791999
 [8] 1.7287308 1.7135237 1.7323903 1.7926369 1.6941790 1.8226323 1.8274115
[15] 1.8845843 1.8685697 1.9238003 0.5718564
> attr(chr.clock, "rates")
[1] 1.483914
> ## Not run: 
> ##D cal <- makeChronosCalib(tr, interactive = TRUE)
> ##D cal
> ##D ### if you made mistakes, you can edit the data frame with:
> ##D ### fix(cal)
> ##D chr <- chronos(tr, calibration = cal)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("clustal")
> ### * clustal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clustal
> ### Title: Multiple Sequence Alignment with External Applications
> ### Aliases: clustal clustalomega muscle muscle5 tcoffee efastats
> ###   letterconf
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ### display the options:
> ##D clustal()
> ##D clustalomega()
> ##D muscle()
> ##D tcoffee()
> ##D 
> ##D data(woodmouse)
> ##D ### open gaps more easily:
> ##D clustal(woodmouse, pw.gapopen = 1, pw.gapext = 1)
> ##D ### T-Coffee requires negative values (quite slow; muscle() is much faster):
> ##D tcoffee(woodmouse,  MoreArgs = "-gapopen=-10 -gapext=-2")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("coalescent.intervals")
> ### * coalescent.intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coalescent.intervals
> ### Title: Coalescent Intervals
> ### Aliases: coalescent.intervals coalescent.intervals.phylo
> ###   coalescent.intervals.default
> ### Keywords: manip
> 
> ### ** Examples
> 
> data("hivtree.newick") # example tree in NH format
> tree.hiv <- read.tree(text = hivtree.newick) # load tree
> ci <- coalescent.intervals(tree.hiv) # from tree
> ci
$lineages
  [1] 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176
 [19] 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158
 [37] 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
 [55] 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122
 [73] 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104
 [91] 103 102 101 100  99  98  97  96  95  94  93  92  91  90  89  88  87  86
[109]  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68
[127]  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50
[145]  49  48  47  46  45  44  43  42  41  40  39  38  37  36  35  34  33  32
[163]  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14
[181]  13  12  11  10   9   8   7   6   5   4   3   2

$interval.length
  [1] 0.021161 0.028661 0.000236 0.004386 0.003136 0.000040 0.000962 0.000754
  [9] 0.000390 0.002121 0.001165 0.002138 0.000392 0.002225 0.000479 0.000039
 [17] 0.001056 0.000290 0.000094 0.000405 0.000376 0.000892 0.005770 0.000606
 [25] 0.000311 0.000354 0.000049 0.001303 0.000111 0.000191 0.000113 0.000701
 [33] 0.000012 0.000004 0.000343 0.000466 0.000701 0.000001 0.000286 0.000404
 [41] 0.000048 0.000264 0.000382 0.000723 0.000025 0.000063 0.001082 0.000293
 [49] 0.001458 0.000057 0.000268 0.000822 0.000035 0.000141 0.000038 0.000393
 [57] 0.000263 0.000061 0.000697 0.000011 0.000331 0.000198 0.000637 0.000161
 [65] 0.000722 0.000568 0.000016 0.000892 0.000233 0.000124 0.000044 0.000210
 [73] 0.000137 0.000162 0.000066 0.000319 0.000039 0.000226 0.000001 0.000035
 [81] 0.000794 0.000107 0.000162 0.000130 0.000588 0.000128 0.000063 0.000001
 [89] 0.002044 0.000081 0.000115 0.000144 0.000222 0.001136 0.000794 0.000014
 [97] 0.000069 0.000001 0.000437 0.000191 0.000470 0.000654 0.000164 0.000048
[105] 0.000460 0.000098 0.000207 0.000326 0.000001 0.000002 0.000161 0.000873
[113] 0.000141 0.000868 0.000224 0.000342 0.000700 0.000222 0.000151 0.000631
[121] 0.000663 0.001550 0.000323 0.000711 0.000086 0.000651 0.000346 0.000001
[129] 0.000067 0.000255 0.000146 0.000260 0.000169 0.000071 0.000142 0.001229
[137] 0.000106 0.001085 0.000116 0.000204 0.000214 0.000810 0.000112 0.000132
[145] 0.000208 0.000093 0.001182 0.000143 0.000083 0.000003 0.001560 0.000368
[153] 0.000150 0.000537 0.001174 0.000957 0.002662 0.000001 0.000001 0.000095
[161] 0.001008 0.001359 0.000001 0.000103 0.000747 0.000245 0.000829 0.002804
[169] 0.000699 0.000001 0.000119 0.004393 0.002748 0.001334 0.002036 0.001906
[177] 0.001858 0.001173 0.004342 0.009066 0.001531 0.000545 0.009855 0.001407
[185] 0.001059 0.002167 0.011000 0.004665 0.000001 0.007899 0.000001 0.004212

$interval.count
[1] 192

$total.depth
[1] 0.209112

attr(,"class")
[1] "coalescentIntervals"
> data("hivtree.table") # same tree, but in table format
> ci <- coalescent.intervals(hivtree.table$size) # from vector of interval lengths
> ci
$lineages
  [1] 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176
 [19] 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158
 [37] 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
 [55] 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122
 [73] 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104
 [91] 103 102 101 100  99  98  97  96  95  94  93  92  91  90  89  88  87  86
[109]  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68
[127]  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50
[145]  49  48  47  46  45  44  43  42  41  40  39  38  37  36  35  34  33  32
[163]  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14
[181]  13  12  11  10   9   8   7   6   5   4   3   2

$interval.length
  [1] 0.021163 0.028658 0.000237 0.004382 0.003138 0.000046 0.000956 0.000754
  [9] 0.000394 0.002115 0.001170 0.002138 0.000391 0.002226 0.000478 0.000035
 [17] 0.001063 0.000289 0.000093 0.000406 0.000374 0.000894 0.005766 0.000608
 [25] 0.000313 0.000351 0.000051 0.001306 0.000103 0.000196 0.000114 0.000699
 [33] 0.000014 0.000002 0.000340 0.000467 0.000706 0.000001 0.000281 0.000405
 [41] 0.000044 0.000269 0.000381 0.000727 0.000024 0.000061 0.001083 0.000291
 [49] 0.001460 0.000056 0.000268 0.000818 0.000041 0.000138 0.000037 0.000397
 [57] 0.000262 0.000060 0.000699 0.000008 0.000332 0.000197 0.000641 0.000158
 [65] 0.000722 0.000562 0.000023 0.000893 0.000232 0.000122 0.000045 0.000212
 [73] 0.000138 0.000158 0.000070 0.000316 0.000040 0.000221 0.000004 0.000037
 [81] 0.000795 0.000105 0.000162 0.000129 0.000588 0.000132 0.000065 0.000001
 [89] 0.002039 0.000083 0.000108 0.000152 0.000221 0.001135 0.000794 0.000013
 [97] 0.000069 0.000001 0.000439 0.000189 0.000468 0.000656 0.000163 0.000052
[105] 0.000456 0.000100 0.000206 0.000328 0.000001 0.000001 0.000162 0.000872
[113] 0.000142 0.000869 0.000222 0.000342 0.000699 0.000225 0.000149 0.000632
[121] 0.000661 0.001551 0.000325 0.000710 0.000084 0.000656 0.000343 0.000001
[129] 0.000062 0.000260 0.000149 0.000257 0.000169 0.000067 0.000146 0.001228
[137] 0.000108 0.001083 0.000115 0.000206 0.000214 0.000810 0.000113 0.000129
[145] 0.000211 0.000090 0.001179 0.000149 0.000080 0.000006 0.001562 0.000365
[153] 0.000148 0.000540 0.001173 0.000955 0.002667 0.000001 0.000001 0.000092
[161] 0.001009 0.001358 0.000001 0.000103 0.000742 0.000244 0.000833 0.002804
[169] 0.000700 0.000005 0.000116 0.004393 0.002747 0.001338 0.002033 0.001904
[177] 0.001861 0.001175 0.004338 0.009062 0.001534 0.000548 0.009855 0.001403
[185] 0.001063 0.002169 0.010997 0.004668 0.000001 0.007897 0.000001 0.004214

$interval.count
[1] 192

$total.depth
[1] 0.209117

attr(,"class")
[1] "coalescentIntervals"
> 
> 
> 
> cleanEx()
> nameEx("collapse.singles")
> ### * collapse.singles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: collapse.singles
> ### Title: Collapse Single Nodes
> ### Aliases: collapse.singles has.singles
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## a tree with 3 tips and 3 nodes:
> e <- c(4L, 6L, 6L, 5L, 5L, 6L, 1L, 5L, 3L, 2L)
> dim(e) <- c(5, 2)
> tr <- structure(list(edge = e, tip.label = LETTERS[1:3], Nnode = 3L),
+                 class = "phylo")
> tr

Phylogenetic tree with 3 tips and 3 internal nodes.

Tip labels:
  A, B, C

Rooted; no branch length.
> has.singles(tr)
[1] TRUE
> ## the following shows that node #4 (ie, the root) is a singleton
> ## and node #6 is the first bifurcating node
> tr$edge
     [,1] [,2]
[1,]    4    6
[2,]    6    1
[3,]    6    5
[4,]    5    3
[5,]    5    2
> ## A bifurcating tree has less nodes than it has tips:
> ## the following used to fail with ape 4.1 or lower:
> plot(tr)
> collapse.singles(tr) # only 2 nodes

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  A, B, C

Rooted; no branch length.
> ## give branch lengths to use the 'root.edge' option:
> tr$edge.length <- runif(5)
> str(collapse.singles(tr, TRUE)) # has a 'root.edge'
List of 5
 $ edge       : int [1:4, 1:2] 4 4 5 5 1 5 3 2
 $ tip.label  : chr [1:3] "A" "B" "C"
 $ Nnode      : int 2
 $ edge.length: num [1:4] 0.372 0.573 0.908 0.202
 $ root.edge  : num 0.266
 - attr(*, "class")= chr "phylo"
 - attr(*, "order")= chr "cladewise"
> 
> 
> 
> cleanEx()
> nameEx("collapsed.intervals")
> ### * collapsed.intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: collapsed.intervals
> ### Title: Collapsed Coalescent Intervals
> ### Aliases: collapsed.intervals
> ### Keywords: manip
> 
> ### ** Examples
> 
> data("hivtree.table") # example tree
> # colescent intervals from vector of interval lengths
> ci <- coalescent.intervals(hivtree.table$size)
> ci
$lineages
  [1] 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176
 [19] 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158
 [37] 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
 [55] 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122
 [73] 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104
 [91] 103 102 101 100  99  98  97  96  95  94  93  92  91  90  89  88  87  86
[109]  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68
[127]  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50
[145]  49  48  47  46  45  44  43  42  41  40  39  38  37  36  35  34  33  32
[163]  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14
[181]  13  12  11  10   9   8   7   6   5   4   3   2

$interval.length
  [1] 0.021163 0.028658 0.000237 0.004382 0.003138 0.000046 0.000956 0.000754
  [9] 0.000394 0.002115 0.001170 0.002138 0.000391 0.002226 0.000478 0.000035
 [17] 0.001063 0.000289 0.000093 0.000406 0.000374 0.000894 0.005766 0.000608
 [25] 0.000313 0.000351 0.000051 0.001306 0.000103 0.000196 0.000114 0.000699
 [33] 0.000014 0.000002 0.000340 0.000467 0.000706 0.000001 0.000281 0.000405
 [41] 0.000044 0.000269 0.000381 0.000727 0.000024 0.000061 0.001083 0.000291
 [49] 0.001460 0.000056 0.000268 0.000818 0.000041 0.000138 0.000037 0.000397
 [57] 0.000262 0.000060 0.000699 0.000008 0.000332 0.000197 0.000641 0.000158
 [65] 0.000722 0.000562 0.000023 0.000893 0.000232 0.000122 0.000045 0.000212
 [73] 0.000138 0.000158 0.000070 0.000316 0.000040 0.000221 0.000004 0.000037
 [81] 0.000795 0.000105 0.000162 0.000129 0.000588 0.000132 0.000065 0.000001
 [89] 0.002039 0.000083 0.000108 0.000152 0.000221 0.001135 0.000794 0.000013
 [97] 0.000069 0.000001 0.000439 0.000189 0.000468 0.000656 0.000163 0.000052
[105] 0.000456 0.000100 0.000206 0.000328 0.000001 0.000001 0.000162 0.000872
[113] 0.000142 0.000869 0.000222 0.000342 0.000699 0.000225 0.000149 0.000632
[121] 0.000661 0.001551 0.000325 0.000710 0.000084 0.000656 0.000343 0.000001
[129] 0.000062 0.000260 0.000149 0.000257 0.000169 0.000067 0.000146 0.001228
[137] 0.000108 0.001083 0.000115 0.000206 0.000214 0.000810 0.000113 0.000129
[145] 0.000211 0.000090 0.001179 0.000149 0.000080 0.000006 0.001562 0.000365
[153] 0.000148 0.000540 0.001173 0.000955 0.002667 0.000001 0.000001 0.000092
[161] 0.001009 0.001358 0.000001 0.000103 0.000742 0.000244 0.000833 0.002804
[169] 0.000700 0.000005 0.000116 0.004393 0.002747 0.001338 0.002033 0.001904
[177] 0.001861 0.001175 0.004338 0.009062 0.001534 0.000548 0.009855 0.001403
[185] 0.001063 0.002169 0.010997 0.004668 0.000001 0.007897 0.000001 0.004214

$interval.count
[1] 192

$total.depth
[1] 0.209117

attr(,"class")
[1] "coalescentIntervals"
> # collapsed intervals
> cl1 <- collapsed.intervals(ci,0)
> cl2 <- collapsed.intervals(ci,0.0119)
> cl1
$lineages
  [1] 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176
 [19] 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158
 [37] 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
 [55] 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122
 [73] 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104
 [91] 103 102 101 100  99  98  97  96  95  94  93  92  91  90  89  88  87  86
[109]  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68
[127]  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50
[145]  49  48  47  46  45  44  43  42  41  40  39  38  37  36  35  34  33  32
[163]  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14
[181]  13  12  11  10   9   8   7   6   5   4   3   2

$interval.length
  [1] 0.021163 0.028658 0.000237 0.004382 0.003138 0.000046 0.000956 0.000754
  [9] 0.000394 0.002115 0.001170 0.002138 0.000391 0.002226 0.000478 0.000035
 [17] 0.001063 0.000289 0.000093 0.000406 0.000374 0.000894 0.005766 0.000608
 [25] 0.000313 0.000351 0.000051 0.001306 0.000103 0.000196 0.000114 0.000699
 [33] 0.000014 0.000002 0.000340 0.000467 0.000706 0.000001 0.000281 0.000405
 [41] 0.000044 0.000269 0.000381 0.000727 0.000024 0.000061 0.001083 0.000291
 [49] 0.001460 0.000056 0.000268 0.000818 0.000041 0.000138 0.000037 0.000397
 [57] 0.000262 0.000060 0.000699 0.000008 0.000332 0.000197 0.000641 0.000158
 [65] 0.000722 0.000562 0.000023 0.000893 0.000232 0.000122 0.000045 0.000212
 [73] 0.000138 0.000158 0.000070 0.000316 0.000040 0.000221 0.000004 0.000037
 [81] 0.000795 0.000105 0.000162 0.000129 0.000588 0.000132 0.000065 0.000001
 [89] 0.002039 0.000083 0.000108 0.000152 0.000221 0.001135 0.000794 0.000013
 [97] 0.000069 0.000001 0.000439 0.000189 0.000468 0.000656 0.000163 0.000052
[105] 0.000456 0.000100 0.000206 0.000328 0.000001 0.000001 0.000162 0.000872
[113] 0.000142 0.000869 0.000222 0.000342 0.000699 0.000225 0.000149 0.000632
[121] 0.000661 0.001551 0.000325 0.000710 0.000084 0.000656 0.000343 0.000001
[129] 0.000062 0.000260 0.000149 0.000257 0.000169 0.000067 0.000146 0.001228
[137] 0.000108 0.001083 0.000115 0.000206 0.000214 0.000810 0.000113 0.000129
[145] 0.000211 0.000090 0.001179 0.000149 0.000080 0.000006 0.001562 0.000365
[153] 0.000148 0.000540 0.001173 0.000955 0.002667 0.000001 0.000001 0.000092
[161] 0.001009 0.001358 0.000001 0.000103 0.000742 0.000244 0.000833 0.002804
[169] 0.000700 0.000005 0.000116 0.004393 0.002747 0.001338 0.002033 0.001904
[177] 0.001861 0.001175 0.004338 0.009062 0.001534 0.000548 0.009855 0.001403
[185] 0.001063 0.002169 0.010997 0.004668 0.000001 0.007897 0.000001 0.004214

$collapsed.interval
  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
 [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
 [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72
 [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
 [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108
[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126
[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144
[145] 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162
[163] 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180
[181] 181 182 183 184 185 186 187 188 189 190 191 192

$interval.count
[1] 192

$collapsed.interval.count
[1] 192

$total.depth
[1] 0.209117

$epsilon
[1] 0

attr(,"class")
[1] "collapsedIntervals"
> cl2
$lineages
  [1] 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176
 [19] 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158
 [37] 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
 [55] 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122
 [73] 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104
 [91] 103 102 101 100  99  98  97  96  95  94  93  92  91  90  89  88  87  86
[109]  85  84  83  82  81  80  79  78  77  76  75  74  73  72  71  70  69  68
[127]  67  66  65  64  63  62  61  60  59  58  57  56  55  54  53  52  51  50
[145]  49  48  47  46  45  44  43  42  41  40  39  38  37  36  35  34  33  32
[163]  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14
[181]  13  12  11  10   9   8   7   6   5   4   3   2

$interval.length
  [1] 0.021163 0.028658 0.000237 0.004382 0.003138 0.000046 0.000956 0.000754
  [9] 0.000394 0.002115 0.001170 0.002138 0.000391 0.002226 0.000478 0.000035
 [17] 0.001063 0.000289 0.000093 0.000406 0.000374 0.000894 0.005766 0.000608
 [25] 0.000313 0.000351 0.000051 0.001306 0.000103 0.000196 0.000114 0.000699
 [33] 0.000014 0.000002 0.000340 0.000467 0.000706 0.000001 0.000281 0.000405
 [41] 0.000044 0.000269 0.000381 0.000727 0.000024 0.000061 0.001083 0.000291
 [49] 0.001460 0.000056 0.000268 0.000818 0.000041 0.000138 0.000037 0.000397
 [57] 0.000262 0.000060 0.000699 0.000008 0.000332 0.000197 0.000641 0.000158
 [65] 0.000722 0.000562 0.000023 0.000893 0.000232 0.000122 0.000045 0.000212
 [73] 0.000138 0.000158 0.000070 0.000316 0.000040 0.000221 0.000004 0.000037
 [81] 0.000795 0.000105 0.000162 0.000129 0.000588 0.000132 0.000065 0.000001
 [89] 0.002039 0.000083 0.000108 0.000152 0.000221 0.001135 0.000794 0.000013
 [97] 0.000069 0.000001 0.000439 0.000189 0.000468 0.000656 0.000163 0.000052
[105] 0.000456 0.000100 0.000206 0.000328 0.000001 0.000001 0.000162 0.000872
[113] 0.000142 0.000869 0.000222 0.000342 0.000699 0.000225 0.000149 0.000632
[121] 0.000661 0.001551 0.000325 0.000710 0.000084 0.000656 0.000343 0.000001
[129] 0.000062 0.000260 0.000149 0.000257 0.000169 0.000067 0.000146 0.001228
[137] 0.000108 0.001083 0.000115 0.000206 0.000214 0.000810 0.000113 0.000129
[145] 0.000211 0.000090 0.001179 0.000149 0.000080 0.000006 0.001562 0.000365
[153] 0.000148 0.000540 0.001173 0.000955 0.002667 0.000001 0.000001 0.000092
[161] 0.001009 0.001358 0.000001 0.000103 0.000742 0.000244 0.000833 0.002804
[169] 0.000700 0.000005 0.000116 0.004393 0.002747 0.001338 0.002033 0.001904
[177] 0.001861 0.001175 0.004338 0.009062 0.001534 0.000548 0.009855 0.001403
[185] 0.001063 0.002169 0.010997 0.004668 0.000001 0.007897 0.000001 0.004214

$collapsed.interval
  [1]  1  2  3  3  3  3  3  3  3  3  4  4  4  4  4  4  4  4  4  4  4  4  4  5  5
 [26]  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5
 [51]  5  5  5  5  5  5  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6
 [76]  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  7  7  7  7  7
[101]  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  7
[126]  7  7  7  7  7  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8
[151]  8  8  8  8  8  8  8  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9 10 10 10
[176] 10 10 10 10 11 11 11 11 12 12 12 12 13 13 13 13 13

$interval.count
[1] 192

$collapsed.interval.count
[1] 13

$total.depth
[1] 0.209117

$epsilon
[1] 0.0119

attr(,"class")
[1] "collapsedIntervals"
> 
> 
> 
> cleanEx()
> nameEx("compar.cheverud")
> ### * compar.cheverud
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compar.cheverud
> ### Title: Cheverud's Comparative Method
> ### Aliases: compar.cheverud
> ### Keywords: regression
> 
> ### ** Examples
> 
> ### Example from Harvey and Pagel's book:
> y<-c(10,8,3,4)
> W <- matrix(c(1,1/6,1/6,1/6,1/6,1,1/2,1/2,1/6,1/2,1,1,1/6,1/2,1,1), 4)
> compar.cheverud(y,W)
$rhohat
[1] -5.442614

$Wnorm
          [,1]      [,2]      [,3]      [,4]
[1,] 0.0000000 0.3333333 0.3333333 0.3333333
[2,] 0.1428571 0.0000000 0.4285714 0.4285714
[3,] 0.1000000 0.3000000 0.0000000 0.6000000
[4,] 0.1000000 0.3000000 0.6000000 0.0000000

$residuals
          [,1]
[1,] -3.053268
[2,] -8.163333
[3,] -5.699176
[4,] -7.964745

> ### Example from Rohlf's 2001 article:
> W<- matrix(c(
+   0,1,1,2,0,0,0,0,
+   1,0,1,2,0,0,0,0,
+   1,1,0,2,0,0,0,0,
+   2,2,2,0,0,0,0,0,
+   0,0,0,0,0,1,1,2,
+   0,0,0,0,1,0,1,2,
+   0,0,0,0,1,1,0,2,
+   0,0,0,0,2,2,2,0
+ ),8)
> W <- 1/W
> W[W == Inf] <- 0
> y<-c(-0.12,0.36,-0.1,0.04,-0.15,0.29,-0.11,-0.06)
> compar.cheverud(y,W)
$rhohat
[1] -1.441461

$Wnorm
          [,1]      [,2]      [,3] [,4]      [,5]      [,6]      [,7] [,8]
[1,] 0.0000000 0.4000000 0.4000000  0.2 0.0000000 0.0000000 0.0000000  0.0
[2,] 0.4000000 0.0000000 0.4000000  0.2 0.0000000 0.0000000 0.0000000  0.0
[3,] 0.4000000 0.4000000 0.0000000  0.2 0.0000000 0.0000000 0.0000000  0.0
[4,] 0.3333333 0.3333333 0.3333333  0.0 0.0000000 0.0000000 0.0000000  0.0
[5,] 0.0000000 0.0000000 0.0000000  0.0 0.0000000 0.4000000 0.4000000  0.2
[6,] 0.0000000 0.0000000 0.0000000  0.0 0.4000000 0.0000000 0.4000000  0.2
[7,] 0.0000000 0.0000000 0.0000000  0.0 0.4000000 0.4000000 0.0000000  0.2
[8,] 0.0000000 0.0000000 0.0000000  0.0 0.3333333 0.3333333 0.3333333  0.0

$residuals
             [,1]
[1,] -0.004333781
[2,]  0.198905747
[3,]  0.004134532
[4,]  0.061490780
[5,] -0.109289742
[6,]  0.077013158
[7,] -0.092353115
[8,] -0.091362782

> 
> 
> 
> cleanEx()
> nameEx("compar.gee")
> ### * compar.gee
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compar.gee
> ### Title: Comparative Analysis with GEEs
> ### Aliases: compar.gee print.compar.gee drop1.compar.gee
> ###   predict.compar.gee
> ### Keywords: regression
> 
> ### ** Examples
> 
> ### The example in Phylip 3.5c (originally from Lynch 1991)
> ### (the same analysis than in help(pic)...)
> tr <- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
> tree.primates <- read.tree(text = tr)
> X <- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
> Y <- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
> ### Both regressions... the results are quite close to those obtained
> ### with pic().
> compar.gee(X ~ Y, phy = tree.primates)
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
(Intercept)           Y 
  -4.559093    2.009296 
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
(Intercept)           Y 
  -4.559093    2.009296 
Call: compar.gee(formula = X ~ Y, phy = tree.primates)
Number of observations:  5 
Model:
                      Link: identity 
 Variance to Mean Relation: gaussian 

QIC: 20.4241 

Summary of Residuals:
       Min         1Q     Median         3Q        Max 
-1.9460519  0.8312820  0.9651706  1.1805002  2.1069920 


Coefficients:
              Estimate      S.E.          t Pr(T > |t|)
(Intercept) -1.8216247 2.5273632 -0.7207609   0.5770502
Y            0.9980051 0.7410169  1.3468048   0.3637334

Estimated Scale Parameter:  3.747566
"Phylogenetic" df (dfP):  3.32 
> compar.gee(Y ~ X, phy = tree.primates)
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
(Intercept)           X 
  2.5989768   0.3425349 
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
(Intercept)           X 
  2.5989768   0.3425349 
Call: compar.gee(formula = Y ~ X, phy = tree.primates)
Number of observations:  5 
Model:
                      Link: identity 
 Variance to Mean Relation: gaussian 

QIC: 9.239319 

Summary of Residuals:
       Min         1Q     Median         3Q        Max 
-0.7275418 -0.4857216 -0.1565515  0.4373258  0.4763833 


Coefficients:
             Estimate      S.E.        t Pr(T > |t|)
(Intercept) 2.5000672 0.4325167 5.780279  0.06773259
X           0.4319328 0.1597932 2.703074  0.17406821

Estimated Scale Parameter:  0.4026486
"Phylogenetic" df (dfP):  3.32 
> ### Now do the GEE regressions through the origin: the results are quite
> ### different!
> compar.gee(X ~ Y - 1, phy = tree.primates)
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
        Y 
0.7151854 
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
        Y 
0.7151854 
Call: compar.gee(formula = X ~ Y - 1, phy = tree.primates)
Number of observations:  5 
Model:
                      Link: identity 
 Variance to Mean Relation: gaussian 

QIC: 18.26341 

Summary of Residuals:
       Min         1Q     Median         3Q        Max 
-2.6818546  0.5065447  0.5975598  1.5964208  1.8567179 


Coefficients:
   Estimate      S.E.        t Pr(T > |t|)
Y 0.5264396 0.3338464 1.576892    0.238429

Estimated Scale Parameter:  3.450493
"Phylogenetic" df (dfP):  3.32 
> compar.gee(Y ~ X - 1, phy = tree.primates)
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
       X 
1.005403 
Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27
running glm to get initial regression estimate
       X 
1.005403 
Call: compar.gee(formula = Y ~ X - 1, phy = tree.primates)
Number of observations:  5 
Model:
                      Link: identity 
 Variance to Mean Relation: gaussian 

QIC: 22.25351 

Summary of Residuals:
      Min        1Q    Median        3Q       Max 
0.3139433 1.1951019 1.3225974 1.3860895 3.5310502 


Coefficients:
   Estimate      S.E.        t Pr(T > |t|)
X 0.8358692 0.4759221 1.756315   0.2034785

Estimated Scale Parameter:  4.416413
"Phylogenetic" df (dfP):  3.32 
> 
> 
> 
> cleanEx()
> nameEx("compar.lynch")
> ### * compar.lynch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compar.lynch
> ### Title: Lynch's Comparative Method
> ### Aliases: compar.lynch
> ### Keywords: regression
> 
> ### ** Examples
> 
> ### The example in Lynch (1991)
> x <- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
> tree.primates <- read.tree(text = x)
> X <- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
> Y <- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
> compar.lynch(cbind(X, Y),
+              G = vcv.phylo(tree.primates, cor = TRUE))
$vare
           X         Y
X 0.04988386 0.1056546
Y 0.10565457 0.2675678

$vara
          X         Y
X 3.0016391 0.9580373
Y 0.9580373 0.3068246

$A
           [,1]       [,2]
[1,]  2.5098436  0.8019430
[2,]  2.5750239  0.8213858
[3,]  1.1534032  0.3678133
[4,]  0.9702777  0.3080176
[5,] -2.7479320 -0.8760176

$E
            [,1]        [,2]
[1,]  0.34974667  0.90011195
[2,] -0.19885358 -0.53206089
[3,] -0.01791292 -0.04338837
[4,] -0.17687739 -0.46052269
[5,]  0.04350229  0.13573252

$u
       X        Y 
1.234671 3.042850 

$lik
          [,1]
[1,] -12.21798

> 
> 
> 
> cleanEx()
> nameEx("compar.ou")
> ### * compar.ou
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compar.ou
> ### Title: Ornstein-Uhlenbeck Model for Continuous Characters
> ### Aliases: compar.ou
> ### Keywords: models
> 
> ### ** Examples
> 
> data(bird.orders)
> ### This is likely to give you estimates close to 0, 1, and 0
> ### for alpha, sigma^2, and theta, respectively:
> compar.ou(x <- rnorm(23), bird.orders)
$deviance
[1] 57.87844

$para
        estimate     stderr
alpha  0.3714799 65.5726592
sigma2 0.7251158  0.1512387
theta1 0.2428826  0.1262612

$call
compar.ou(x = x <- rnorm(23), phy = bird.orders)

attr(,"class")
[1] "compar.ou"
> ### Much better with a fixed alpha:
> compar.ou(x, bird.orders, alpha = 0.1)
$deviance
[1] 57.9556

$para
        estimate    stderr
sigma2 0.7303803 0.1523364
theta1 0.2521506 0.1377915

$call
compar.ou(x = x, phy = bird.orders, alpha = 0.1)

attr(,"class")
[1] "compar.ou"
> ### Let us 'mimick' the effect of different optima
> ### for the two clades of birds...
> x <- c(rnorm(5, 0), rnorm(18, 5))
> ### ... the model with two optima:
> compar.ou(x, bird.orders, node = 25, alpha = .1)
$deviance
[1] 52.19784

$para
         estimate    stderr
sigma2  0.5686287 0.1186089
theta1 -0.7429769 0.2595614
theta2  5.3566940 0.1382138

$call
compar.ou(x = x, phy = bird.orders, node = 25, alpha = 0.1)

attr(,"class")
[1] "compar.ou"
> ### ... and the model with a single optimum:
> compar.ou(x, bird.orders, node = NULL, alpha = .1)
Warning in sqrt(diag(solve(out$hessian))) : NaNs produced
$deviance
[1] 147.7085

$para
        estimate   stderr
sigma2 92.265835      NaN
theta1  3.950515 1.548669

$call
compar.ou(x = x, phy = bird.orders, node = NULL, alpha = 0.1)

attr(,"class")
[1] "compar.ou"
> ### => Compare both models with the difference in deviances
> ##     which follows a chi^2 with df = 1.
> 
> 
> 
> cleanEx()
> nameEx("comparePhylo")
> ### * comparePhylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparePhylo
> ### Title: Compare Two "phylo" Objects
> ### Aliases: comparePhylo print.comparePhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## two unrooted trees but force comparison as rooted:
> a <- read.tree(text = "(a,b,(c,d));")
> b <- read.tree(text = "(a,c,(b,d));")
> comparePhylo(a, b, plot = TRUE, force.rooted = TRUE)
=> Comparing a with b.
Both trees have the same number of tips: 4.
Both trees have the same tip labels.
Both trees have the same number of nodes: 2.
Both trees are unrooted.
Both trees are not ultrametric.
1 clade in a not in b.
1 clade in b not in a.
1 split in common.

> ## two random unrooted trees:
> c <- rtree(5, rooted = FALSE)
> d <- rtree(5, rooted = FALSE)
> comparePhylo(c, d, plot = TRUE)
=> Comparing c with d.
Both trees have the same number of tips: 5.
Both trees have the same tip labels.
Both trees have the same number of nodes: 3.
Both trees are unrooted.
Both trees are not ultrametric.
1 split in common.

> 
> 
> 
> cleanEx()
> nameEx("compute.brlen")
> ### * compute.brlen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute.brlen
> ### Title: Branch Lengths Computation
> ### Aliases: compute.brlen
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> plot(compute.brlen(bird.orders, 1))
> plot(compute.brlen(bird.orders, runif, min = 0, max = 5))
> layout(matrix(1:4, 2, 2))
> plot(compute.brlen(bird.orders, power=1), main=expression(rho==1))
> plot(compute.brlen(bird.orders, power=3), main=expression(rho==3))
> plot(compute.brlen(bird.orders, power=0.5), main=expression(rho==0.5))
> plot(compute.brlen(bird.orders, power=0.1), main=expression(rho==0.1))
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("compute.brtime")
> ### * compute.brtime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute.brtime
> ### Title: Compute and Set Branching Times
> ### Aliases: compute.brtime
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- rtree(10)
> layout(matrix(1:4, 2))
> plot(compute.brtime(tr)); axisPhylo()
> plot(compute.brtime(tr, force.positive = FALSE)); axisPhylo()
> plot(compute.brtime(tr, 1:9)); axisPhylo() # a bit nonsense
> plot(compute.brtime(tr, 1:9, TRUE)); axisPhylo()
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("cophyloplot")
> ### * cophyloplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cophyloplot
> ### Title: Plots two phylogenetic trees face to face with links between the
> ###   tips.
> ### Aliases: cophyloplot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> #two random trees
> tree1 <- rtree(40)
> tree2 <- rtree(20)
> 
> #creation of the association matrix:
> association <- cbind(tree2$tip.label, tree2$tip.label)
> 
> cophyloplot(tree1, tree2, assoc = association,
+             length.line = 4, space = 28, gap = 3)
> 
> #plot with rotations
> ## Not run: 
> ##D cophyloplot(tree1, tree2, assoc=association, length.line=4, space=28, gap=3, rotate=TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("corClasses")
> ### * corClasses
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: corClasses
> ### Title: Phylogenetic Correlation Structures
> ### Aliases: corClasses corPhyl
> ### Keywords: models
> 
> ### ** Examples
> 
> library(nlme)
> txt <- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
> tree.primates <- read.tree(text = txt)
> X <- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
> Y <- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
> Species <- c("Homo", "Pongo", "Macaca", "Ateles", "Galago")
> dat <- data.frame(Species = Species, X = X, Y = Y)
> 
> m1 <- gls(Y ~ X, dat, correlation=corBrownian(1, tree.primates, form = ~Species))
> summary(m1)
Generalized least squares fit by REML
  Model: Y ~ X 
  Data: dat 
       AIC      BIC   logLik
  17.48072 14.77656 -5.74036

Correlation Structure: corBrownian
 Formula: ~Species 
 Parameter estimate(s):
numeric(0)

Coefficients:
                Value Std.Error  t-value p-value
(Intercept) 2.5000672 0.7754516 3.224014  0.0484
X           0.4319328 0.2864904 1.507669  0.2288

 Correlation: 
  (Intr)
X -0.437

Standardized residuals:
         1          2          3          4          5 
 0.4187373 -0.6395037 -0.1376075 -0.4269456  0.3844060 
attr(,"std")
[1] 1.137666 1.137666 1.137666 1.137666 1.137666
attr(,"label")
[1] "Standardized residuals"

Residual standard error: 1.137666 
Degrees of freedom: 5 total; 3 residual
> m2 <- gls(Y ~ X, dat, correlation=corMartins(1, tree.primates, form = ~Species))
> summary(m2)
Generalized least squares fit by REML
  Model: Y ~ X 
  Data: dat 
       AIC      BIC    logLik
  17.81707 14.21152 -4.908536

Correlation Structure: corMartins
 Formula: ~Species 
 Parameter estimate(s):
   alpha 
51.55332 

Coefficients:
                Value Std.Error  t-value p-value
(Intercept) 2.5989768 0.3843447 6.762099  0.0066
X           0.3425349 0.1330977 2.573561  0.0822

 Correlation: 
  (Intr)
X -0.737

Standardized residuals:
         1          2          3          4          5 
 1.2789374 -0.8663467 -0.0749418 -0.6937734  0.3561246 
attr(,"std")
[1] 0.5813411 0.5813411 0.5813411 0.5813411 0.5813411
attr(,"label")
[1] "Standardized residuals"

Residual standard error: 0.5813411 
Degrees of freedom: 5 total; 3 residual
> corMatrix(m2$modelStruct$corStruct)
               Homo        Pongo       Macaca       Ateles       Galago
Homo   1.000000e+00 3.948974e-10 1.144098e-22 1.726789e-28 1.664767e-45
Pongo  3.948974e-10 1.000000e+00 1.144098e-22 1.726789e-28 1.664767e-45
Macaca 1.144098e-22 1.144098e-22 1.000000e+00 1.726789e-28 1.664767e-45
Ateles 1.726789e-28 1.726789e-28 1.726789e-28 1.000000e+00 1.664767e-45
Galago 1.664767e-45 1.664767e-45 1.664767e-45 1.664767e-45 1.000000e+00
> m3 <- gls(Y ~ X, dat, correlation=corGrafen(1, tree.primates, form = ~Species))
> summary(m3)
Generalized least squares fit by REML
  Model: Y ~ X 
  Data: dat 
       AIC      BIC    logLik
  17.81707 14.21152 -4.908536

Correlation Structure: corGrafen
 Formula: ~Species 
 Parameter estimate(s):
         rho 
3.216967e-10 

Coefficients:
                Value Std.Error  t-value p-value
(Intercept) 2.5989768 0.3843447 6.762099  0.0066
X           0.3425349 0.1330977 2.573561  0.0822

 Correlation: 
  (Intr)
X -0.737

Standardized residuals:
         1          2          3          4          5 
 1.2789374 -0.8663467 -0.0749418 -0.6937734  0.3561246 
attr(,"std")
[1] 0.5813411 0.5813411 0.5813411 0.5813411 0.5813411
attr(,"label")
[1] "Standardized residuals"

Residual standard error: 0.5813411 
Degrees of freedom: 5 total; 3 residual
> corMatrix(m3$modelStruct$corStruct)
               Homo        Pongo       Macaca       Ateles Galago
Homo   1.000000e+00 4.459664e-10 2.229832e-10 9.254641e-11      0
Pongo  4.459664e-10 1.000000e+00 2.229832e-10 9.254641e-11      0
Macaca 2.229832e-10 2.229832e-10 1.000000e+00 9.254641e-11      0
Ateles 9.254641e-11 9.254641e-11 9.254641e-11 1.000000e+00      0
Galago 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00      1
> 
> 
> 
> cleanEx()

detaching ‘package:nlme’

> nameEx("corphylo")
> ### * corphylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: corphylo
> ### Title: Correlations among Multiple Traits with Phylogenetic Signal
> ### Aliases: corphylo print.corphylo
> ### Keywords: regression
> 
> ### ** Examples
> 
> ## Simple example using data without correlations or phylogenetic
> ## signal. This illustrates the structure of the input data.
> 
> phy <- rcoal(10, tip.label = 1:10)
> X <- matrix(rnorm(20), nrow = 10, ncol = 2)
> rownames(X) <- phy$tip.label
> U <- list(NULL, matrix(rnorm(10, mean = 10, sd = 4), nrow = 10, ncol = 1))
> rownames(U[[2]]) <- phy$tip.label
> SeM <- matrix(c(0.2, 0.4), nrow = 10, ncol = 2)
> rownames(SeM) <- phy$tip.label
> 
> corphylo(X = X, SeM = SeM, U = U, phy = phy, method = "Nelder-Mead")
Call to corphylo

logLik    AIC    BIC 
-26.44  68.87  62.13 

correlation matrix:
       1      2
1 1.0000 0.5617
2 0.5617 1.0000

from OU process:
          d
1 4.385e-04
2 1.702e-05

coefficients:
         Value Std.Error  Zscore Pvalue
B1.0 -0.124051  0.417016 -0.2975 0.7661
B2.0  0.057053  0.287602  0.1984 0.8428
B2.1 -0.064933  0.054869 -1.1834 0.2366

> 
> ## Not run: 
> ##D ## Simulation example for the correlation between two variables. The
> ##D ## example compares the estimates of the correlation coefficients from
> ##D ## corphylo when measurement error is incorporated into the analyses with
> ##D ## three other cases: (i) when measurement error is excluded, (ii) when
> ##D ## phylogenetic signal is ignored (assuming a "star" phylogeny), and (iii)
> ##D ## neither measurement error nor phylogenetic signal are included.
> ##D 
> ##D ## In the simulations, variable 2 is associated with a single
> ##D ## independent variable. This requires setting up a list U that has 2
> ##D ## elements: element U[[1]] is NULL and element U[[2]] is a n x 1 vector
> ##D ## containing simulated values of the independent variable.
> ##D 
> ##D # Set up parameter values for simulating data
> ##D n <- 50
> ##D phy <- rcoal(n, tip.label = 1:n)
> ##D 
> ##D R <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
> ##D d <- c(0.3, .95)
> ##D B2 <- 1
> ##D 
> ##D Se <- c(0.2, 1)
> ##D SeM <- matrix(Se, nrow = n, ncol = 2, byrow = T)
> ##D rownames(SeM) <- phy$tip.label
> ##D 
> ##D # Set up needed matrices for the simulations
> ##D p <- length(d)
> ##D 
> ##D star <- stree(n)
> ##D star$edge.length <- array(1, dim = c(n, 1))
> ##D star$tip.label <- phy$tip.label
> ##D 
> ##D Vphy <- vcv(phy)
> ##D Vphy <- Vphy/max(Vphy)
> ##D Vphy <- Vphy/exp(determinant(Vphy)$modulus[1]/n)
> ##D 
> ##D tau <- matrix(1, nrow = n, ncol = 1) ##D 
> ##D C <- matrix(0, nrow = p * n, ncol = p * n)
> ##D for (i in 1:p) for (j in 1:p) {
> ##D 	Cd <- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
> ##D 	C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] <- R[i, j] * Cd
> ##D }
> ##D MM <- matrix(SeM^2, ncol = 1)
> ##D V <- C + diag(as.numeric(MM))
> ##D 
> ##D ## Perform a Cholesky decomposition of Vphy. This is used to generate
> ##D ## phylogenetic signal: a vector of independent normal random variables,
> ##D ## when multiplied by the transpose of the Cholesky deposition of Vphy will
> ##D ## have covariance matrix equal to Vphy.
> ##D iD <- t(chol(V))
> ##D 
> ##D # Perform Nrep simulations and collect the results
> ##D Nrep <- 100
> ##D cor.list <- matrix(0, nrow = Nrep, ncol = 1)
> ##D cor.noM.list <- matrix(0, nrow = Nrep, ncol = 1)
> ##D cor.noP.list <- matrix(0, nrow = Nrep, ncol = 1)
> ##D cor.noMP.list <- matrix(0, nrow = Nrep, ncol = 1)
> ##D d.list <- matrix(0, nrow = Nrep, ncol = 2)
> ##D d.noM.list <- matrix(0, nrow = Nrep, ncol = 2)
> ##D B.list <- matrix(0, nrow = Nrep, ncol = 3)
> ##D B.noM.list <- matrix(0, nrow = Nrep, ncol = 3)
> ##D B.noP.list <- matrix(0, nrow = Nrep, ncol = 3)
> ##D for (rep in 1:Nrep) {
> ##D 	XX <- iD ##D 
> ##D 	X <- matrix(XX, nrow = n, ncol = 2)
> ##D 	rownames(X) <- phy$tip.label
> ##D 
> ##D 	U <- list(NULL, matrix(rnorm(n, mean = 2, sd = 10), nrow = n, ncol = 1))
> ##D 	rownames(U[[2]]) <- phy$tip.label
> ##D 	colnames(U[[2]]) <- "V1"
> ##D 	X[,2] <- X[,2] + B2[1] * U[[2]][,1] - B2[1] * mean(U[[2]][,1])
> ##D 
> ##D 	z <- corphylo(X = X, SeM = SeM, U = U, phy = phy, method = "Nelder-Mead")
> ##D 	z.noM <- corphylo(X = X, U = U, phy = phy, method = "Nelder-Mead")
> ##D 	z.noP <- corphylo(X = X, SeM = SeM, U = U, phy = star, method = "Nelder-Mead")
> ##D 
> ##D 	cor.list[rep] <- z$cor.matrix[1, 2]
> ##D 	cor.noM.list[rep] <- z.noM$cor.matrix[1, 2]
> ##D 	cor.noP.list[rep] <- z.noP$cor.matrix[1, 2]
> ##D 	cor.noMP.list[rep] <- cor(cbind(lm(X[,1] ~ 1)$residuals, lm(X[,2] ~ U[[2]])$residuals))[1,2]
> ##D 
> ##D 	d.list[rep, ] <- z$d
> ##D 	d.noM.list[rep, ] <- z.noM$d
> ##D 
> ##D 	B.list[rep, ] <- z$B
> ##D 	B.noM.list[rep, ] <- z.noM$B
> ##D 	B.noP.list[rep, ] <- z.noP$B
> ##D 
> ##D 	show(c(rep, z$convcode, z$cor.matrix[1, 2], z$d))
> ##D }
> ##D correlation <- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
> ##D                      mean(cor.noP.list), mean(cor.noMP.list))
> ##D rownames(correlation) <- c("True", "With SeM and Phy", "Without SeM",
> ##D                            "Without Phy", "Without Phy or SeM")
> ##D correlation
> ##D 
> ##D signal.d <- rbind(d, colMeans(d.list), colMeans(d.noM.list))
> ##D rownames(signal.d) <- c("True", "With SeM and Phy", "Without SeM")
> ##D signal.d
> ##D 
> ##D est.B <- rbind(c(0, 0, B2), colMeans(B.list), colMeans(B.noM.list),
> ##D                colMeans(B.noP.list))
> ##D rownames(est.B) <- c("True", "With SeM and Phy", "Without SeM", "Without Phy")
> ##D colnames(est.B) <- rownames(z$B)
> ##D est.B
> ##D 
> ##D # Example simulation output
> ##D # correlation
> ##D                         # [,1]
> ##D # True               0.7000000
> ##D # With SeM and Phy   0.7055958
> ##D # Without SeM        0.3125253
> ##D # Without Phy        0.4054043
> ##D # Without Phy or SeM 0.3476589
> ##D 
> ##D # signal.d
> ##D                      # [,1]      [,2]
> ##D # True             0.300000 0.9500000
> ##D # With SeM and Phy 0.301513 0.9276663
> ##D # Without SeM      0.241319 0.4872675
> ##D 
> ##D # est.B
> ##D                         # B1.0      B2.0     B2.V1
> ##D # True              0.00000000 0.0000000 1.0000000
> ##D # With SeM and Phy -0.01285834 0.2807215 0.9963163
> ##D # Without SeM       0.01406953 0.3059110 0.9977796
> ##D # Without Phy       0.02139281 0.3165731 0.9942140
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("correlogram.formula")
> ### * correlogram.formula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: correlogram.formula
> ### Title: Phylogenetic Correlogram
> ### Aliases: correlogram.formula
> ### Keywords: regression
> 
> ### ** Examples
> 
> data(carnivora)
> ### Using the formula interface:
> co <- correlogram.formula(SW ~ Order/SuperFamily/Family/Genus,
+       data=carnivora)
> co
           obs     p.values      labels
1  0.432479537 8.806040e-05       Genus
2  0.572366226 0.000000e+00      Family
3 -0.119934300 2.135604e-10 SuperFamily
4 -0.004402383 6.776239e-01       Order
> plot(co)
> ### Several correlograms on the same plot:
> cos <- correlogram.formula(SW + FW ~ Order/SuperFamily/Family/Genus,
+       data=carnivora)
> cos
$SW
           obs     p.values      labels
1  0.432479537 8.806040e-05       Genus
2  0.572366226 0.000000e+00      Family
3 -0.119934300 2.135604e-10 SuperFamily
4 -0.004402383 6.776239e-01       Order

$FW
           obs     p.values      labels
1  0.416061385 1.438192e-04       Genus
2  0.553969731 0.000000e+00      Family
3 -0.115995018 6.972364e-10 SuperFamily
4 -0.004643436 6.915611e-01       Order

attr(,"class")
[1] "correlogramList"
> plot(cos)
> 
> 
> 
> cleanEx()
> nameEx("dbd")
> ### * dbd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dbd
> ### Title: Probability Density Under Birth-Death Models
> ### Aliases: dyule dbd dbdTime
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- 0:10
> plot(x, dyule(x), type = "h", main = "Density of the Yule process")
> text(7, 0.85, expression(list(lambda == 0.1, t == 1)))
> 
> y <- dbd(x, 0.1, 0.05, 10)
> z <- dbd(x, 0.1, 0.05, 10, conditional = TRUE)
> d <- rbind(y, z)
> colnames(d) <- x
> barplot(d, beside = TRUE, ylab = "Density", xlab = "Number of species",
+         legend = c("unconditional", "conditional on\nno extinction"),
+         args.legend = list(bty = "n"))
> title("Density of the birth-death process")
> text(17, 0.4, expression(list(lambda == 0.1, mu == 0.05, t == 10)))
> 
> ## Not run: 
> ##D ### generate 1000 values from a Yule process with lambda = 0.05
> ##D x <- replicate(1e3, Ntip(rlineage(0.05, 0)))
> ##D 
> ##D ### the correct way to calculate the log-likelihood...:
> ##D sum(dyule(x, 0.05, 50, log = TRUE))
> ##D 
> ##D ### ... and the wrong way:
> ##D log(prod(dyule(x, 0.05, 50)))
> ##D 
> ##D ### a third, less preferred, way:
> ##D sum(log(dyule(x, 0.05, 50)))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("def")
> ### * def
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: def
> ### Title: Definition of Vectors for Plotting or Annotating
> ### Aliases: def
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> a <- def(bird.orders$tip.label, Galliformes = 2)
> str(a) # numeric
 num [1:23] 1 1 1 2 1 1 1 1 1 1 ...
> plot(bird.orders, font = a)
> co <- def(bird.orders$tip.label, Passeriformes = "red", Trogoniformes = "blue")
> str(co) # character
 chr [1:23] "black" "black" "black" "black" "black" "black" "black" "black" ...
> plot(bird.orders, tip.color = co)
> ### use of a regexp (so we need to quote it) to colour all orders
> ### with names starting with "C" (and change the default):
> co2 <- def(bird.orders$tip.label, "^C" = "gold", default = "grey", regexp = TRUE)
> plot(bird.orders, tip.color = co2)
> 
> 
> 
> cleanEx()
> nameEx("degree")
> ### * degree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: degree
> ### Title: Vertex Degrees in Trees and Networks
> ### Aliases: degree degree.phylo degree.evonet
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> degree(bird.orders)
  Degree  N
1      1 23
2      2  1
3      3 21
> degree(bird.orders, details = TRUE)
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3
[39] 3 3 3 3 3 3 3
> 
> data(bird.families)
> degree(bird.families)
  Degree   N
1      1 137
2      2   1
3      3 133
4      4   1
> 
> degree(rtree(10)) # 10, 1, 8
  Degree  N
1      1 10
2      2  1
3      3  8
> degree(rtree(10, rooted = FALSE)) # 10, 0, 8
  Degree  N
1      1 10
3      3  8
> degree(stree(10)) # 10 + 1 node of degree 10
   Degree  N
1       1 10
10     10  1
> 
> 
> 
> cleanEx()
> nameEx("delta.plot")
> ### * delta.plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: delta.plot
> ### Title: Delta Plots
> ### Aliases: delta.plot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> data(woodmouse)
> d <- dist.dna(woodmouse)
> delta.plot(d)
> layout(1)
> delta.plot(d, 40, which = 1)
> 
> 
> 
> cleanEx()
> nameEx("dist.topo")
> ### * dist.topo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist.topo
> ### Title: Topological Distances Between Two Trees
> ### Aliases: dist.topo
> ### Keywords: manip
> 
> ### ** Examples
> 
> ta <- rtree(30, rooted = FALSE)
> tb <- rtree(30, rooted = FALSE)
> dist.topo(ta, ta) # 0
      tree1
tree2     0
> dist.topo(ta, tb) # unlikely to be 0
      tree1
tree2    54
> 
> ## rmtopology() simulated unrooted trees by default:
> TR <- rmtopology(100, 10)
> ## these trees have 7 internal branches, so the maximum distance
> ## between two of them is 14:
> DTR <- dist.topo(TR)
> table(DTR)
DTR
   6    8   10   12   14 
   4   18  130  839 3959 
> 
> 
> 
> cleanEx()
> nameEx("diversi.gof")
> ### * diversi.gof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diversi.gof
> ### Title: Tests of Constant Diversification Rates
> ### Aliases: diversi.gof
> ### Keywords: univar
> 
> ### ** Examples
> 
> data(bird.families)
> x <- branching.times(bird.families)
> ### suppose we have a sample of expected branching times `y';
> ### for simplicity, take them from a uniform distribution:
> y <- runif(500, 0, max(x) + 1) # + 1 to avoid A2 = Inf
> ### now compute the expected cumulative distribution:
> x <- sort(x)
> N <- length(x)
> ecdf <- numeric(N)
> for (i in 1:N) ecdf[i] <- sum(y <= x[i])/500
> ### finally do the test:
> diversi.gof(x, "user", z = ecdf)

Tests of Constant Diversification Rates

Data: x 
Number of branching times: 135 
Null model: ecdf (user-specified)

Cramer-von Mises test: W2 = 13.425   P < 0.01
Anderson-Darling test: A2 = 13.546   P < 0.01
> 
> 
> 
> cleanEx()
> nameEx("diversity.contrast.test")
> ### * diversity.contrast.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diversity.contrast.test
> ### Title: Diversity Contrast Test
> ### Aliases: diversity.contrast.test
> ### Keywords: htest
> 
> ### ** Examples
> 
> ### data from Vamosi & Vamosi (2005):
> fleshy <- c(1, 1, 1, 1, 1, 3, 3, 5, 9, 16, 33, 40, 50, 100, 216, 393, 850, 947,1700)
> dry <- c(2, 64, 300, 89, 67, 4, 34, 10, 150, 35, 2, 60, 81, 1, 3, 1, 11, 1, 18)
> x <- cbind(fleshy, dry)
> diversity.contrast.test(x)
[1] 0.9843216
> diversity.contrast.test(x, alt = "g")
[1] 0.5235081
> diversity.contrast.test(x, alt = "g", nrep = 1e4)
[1] 0.5345
> slowinskiguyer.test(x)
    chisq df        P.val
 71.29993 38 0.0008569431
> mcconwaysims.test(x)
    chisq df        P.val
 78.76498 19 3.033067e-09
> 
> 
> 
> cleanEx()
> nameEx("dnds")
> ### * dnds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dnds
> ### Title: dN/dS Ratio
> ### Aliases: dnds
> 
> ### ** Examples
> 
> data(woodmouse)
> res <- dnds(woodmouse, quiet = TRUE) # NOT correct
Warning in dnds(woodmouse, quiet = TRUE) :
  sequence length not a multiple of 3: 2 bases dropped
> res2 <- dnds(woodmouse, code = 2, quiet = TRUE) # using the correct code
Warning in dnds(woodmouse, code = 2, quiet = TRUE) :
  sequence length not a multiple of 3: 2 bases dropped
> identical(res, res2) # FALSE...
[1] FALSE
> cor(res, res2) # ... but very close
[1] 0.9998373
> ## There a few N's in the woodmouse data, but this does not affect
> ## greatly the results:
> res3 <- dnds(solveAmbiguousBases(woodmouse), code = 2, quiet = TRUE)
Warning in dnds(solveAmbiguousBases(woodmouse), code = 2, quiet = TRUE) :
  sequence length not a multiple of 3: 2 bases dropped
> cor(res, res3)
[1] 0.9571516
> 
> ## a simple example showing the usefulness of 'details = TRUE'
> X <- as.DNAbin(matrix(c("C", "A", "G", "G", "T", "T"), 2, 3))
> alview(X)
 123
 CGT
 A..
> dnds(X, quiet = TRUE) # NaN
    1
2 NaN
> dnds(X, details = TRUE) # only a TV at a nondegenerate site

Comparing sequences 1 and 2:
              Nondegenerate Twofold Fourfold
Transitions               0       0        0
Transversions             1       0        0
    1
2 NaN
> 
> 
> 
> cleanEx()
> nameEx("drop.tip")
> ### * drop.tip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drop.tip
> ### Title: Remove Tips in a Phylogenetic Tree
> ### Aliases: drop.tip drop.tip.phylo drop.tip.multiPhylo keep.tip
> ###   keep.tip.phylo keep.tip.multiPhylo extract.clade
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.families)
> tip <- c(
+ "Eopsaltriidae", "Acanthisittidae", "Pittidae", "Eurylaimidae",
+ "Philepittidae", "Tyrannidae", "Thamnophilidae", "Furnariidae",
+ "Formicariidae", "Conopophagidae", "Rhinocryptidae", "Climacteridae",
+ "Menuridae", "Ptilonorhynchidae", "Maluridae", "Meliphagidae",
+ "Pardalotidae", "Petroicidae", "Irenidae", "Orthonychidae",
+ "Pomatostomidae", "Laniidae", "Vireonidae", "Corvidae",
+ "Callaeatidae", "Picathartidae", "Bombycillidae", "Cinclidae",
+ "Muscicapidae", "Sturnidae", "Sittidae", "Certhiidae",
+ "Paridae", "Aegithalidae", "Hirundinidae", "Regulidae",
+ "Pycnonotidae", "Hypocoliidae", "Cisticolidae", "Zosteropidae",
+ "Sylviidae", "Alaudidae", "Nectariniidae", "Melanocharitidae",
+ "Paramythiidae","Passeridae", "Fringillidae")
> plot(drop.tip(bird.families, tip))
> plot(drop.tip(bird.families, tip, trim.internal = FALSE))
> data(bird.orders)
> plot(drop.tip(bird.orders, 6:23, subtree = TRUE))
> plot(drop.tip(bird.orders, c(1:5, 20:23), subtree = TRUE))
> plot(drop.tip(bird.orders, c(1:20, 23), subtree = TRUE))
> plot(drop.tip(bird.orders, c(1:20, 23), subtree = TRUE, rooted = FALSE))
> ### Examples of the use of `root.edge'
> tr <- read.tree(text = "(A:1,(B:1,(C:1,(D:1,E:1):1):1):1):1;")
> drop.tip(tr, c("A", "B"), root.edge = 0) # = (C:1,(D:1,E:1):1);

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  C, D, E

Rooted; includes branch length(s).
> drop.tip(tr, c("A", "B"), root.edge = 1) # = (C:1,(D:1,E:1):1):1;

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  C, D, E

Rooted; includes branch length(s).
> drop.tip(tr, c("A", "B"), root.edge = 2) # = (C:1,(D:1,E:1):1):2;

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  C, D, E

Rooted; includes branch length(s).
> drop.tip(tr, c("A", "B"), root.edge = 3) # = (C:1,(D:1,E:1):1):3;

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  C, D, E

Rooted; includes branch length(s).
> 
> 
> 
> cleanEx()
> nameEx("edges")
> ### * edges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edges
> ### Title: Draw Additional Edges on a Plotted Tree
> ### Aliases: edges fancyarrows
> ### Keywords: aplot
> 
> ### ** Examples
> 
> set.seed(2)
> tr <- rcoal(6)
> plot(tr, "c")
> edges(10, 9, col = "red", lty = 2)
> edges(10:11, 8, col = c("blue", "green")) # recycling of 'nodes1'
> edges(1, 2, lwd = 2, type = "h", arrows = 3, col = "green")
> nodelabels()
> 
> 
> 
> cleanEx()
> nameEx("evonet")
> ### * evonet
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evonet
> ### Title: Evolutionary Networks
> ### Aliases: evonet as.evonet as.evonet.phylo read.evonet write.evonet
> ###   print.evonet plot.evonet reorder.evonet as.phylo.evonet
> ###   as.networx.evonet as.network.evonet as.igraph.evonet Nedge.evonet
> ### Keywords: manip hplot
> 
> ### ** Examples
> 
> tr <- rcoal(5)
> (x <- evonet(tr, 6:7, 8:9))

    Evolutionary network with 2 reticulations

               --- Base tree ---
Phylogenetic tree with 5 tips and 4 internal nodes.

Tip labels:
  t2, t5, t4, t3, t1

Rooted; includes branch length(s).
> plot(x)
> ## simple example of extended Newick format:
> (enet <- read.evonet(text = "((a:2,(b:1)#H1:1):1,(#H1,c:1):2);"))

    Evolutionary network with 1 reticulation

               --- Base tree ---
Phylogenetic tree with 3 tips and 4 internal nodes.

Tip labels:
  a, b, c
Node labels:
  , , #H1, 

Rooted; includes branch length(s).
> plot(enet, arrows=1)
> ## from Fig. 2 in Cardona et al. 2008:
> z <- read.evonet(text =
+ "((1,((2,(3,(4)Y#H1)g)e,(((Y#H1, 5)h,6)f)X#H2)c)a,((X#H2,7)d,8)b)r;")
> z

    Evolutionary network with 2 reticulations

               --- Base tree ---
Phylogenetic tree with 8 tips and 11 internal nodes.

Tip labels:
  1, 2, 3, 4, 5, 6, ...
Node labels:
  r, a, c, e, g, Y#H1, ...

Rooted; no branch length.
> plot(z)
> ## Not run: 
> ##D if (require(igraph)) {
> ##D     plot(as.igraph(z))
> ##D }
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("fastme")
> ### * fastme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FastME
> ### Title: Tree Estimation Based on the Minimum Evolution Algorithm
> ### Aliases: FastME fastme fastme.bal fastme.ols
> ### Keywords: models
> 
> ### ** Examples
> 
> ### From Saitou and Nei (1987, Table 1):
> x <- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
+        10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
+        5, 6, 10, 9, 13, 8)
> M <- matrix(0, 8, 8)
> M[lower.tri(M)] <- x
> M <- t(M)
> M[lower.tri(M)] <- x
> dimnames(M) <- list(1:8, 1:8)
> tr <- fastme.bal(M)
> plot(tr, "u")
> ### a less theoretical example
> data(woodmouse)
> trw <- fastme.bal(dist.dna(woodmouse))
> plot(trw)
> 
> 
> 
> cleanEx()
> nameEx("getAnnotationsGenBank")
> ### * getAnnotationsGenBank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getAnnotationsGenBank
> ### Title: Read Annotations from GenBank
> ### Aliases: getAnnotationsGenBank
> ### Keywords: IO
> 
> ### ** Examples
> 
> ## The 8 sequences of tanagers (Ramphocelus):
> ref <- c("U15717", "U15718", "U15719", "U15720",
+          "U15721", "U15722", "U15723", "U15724")
> ## Copy/paste or type the following commands if you
> ## want to try them.
> ## Not run: 
> ##D annot.rampho <- getAnnotationsGenBank(ref)
> ##D annot.rampho
> ##D ## check all annotations are the same:
> ##D unique(do.call(rbind, annot.rampho)[, -5])
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("howmanytrees")
> ### * howmanytrees
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: howmanytrees
> ### Title: Calculate Numbers of Phylogenetic Trees
> ### Aliases: howmanytrees LargeNumber print.LargeNumber
> ### Keywords: arith math
> 
> ### ** Examples
> 
> ### Table 3.1 in Felsenstein 2004:
> for (i in c(1:20, 30, 40, 50))
+   cat(paste(i, howmanytrees(i), sep = "\t"), sep ="\n")
1	1
2	1
3	3
4	15
5	105
6	945
7	10395
8	135135
9	2027025
10	34459425
11	654729075
12	13749310575
13	316234143225
14	7905853580625
15	213458046676875
16	6190283353629375
17	191898783962510624
18	6332659870762850304
19	2.216430954767e+20
20	8.20079453263789e+21
30	4.9517976900802e+38
40	1.00984736473787e+57
50	2.75292135328357e+76
> ### Table 3.6:
> howmanytrees(8, binary = FALSE, detail = TRUE)
  1   2    3     4      5      6      7
1 1   0    0     0      0      0      0
2 1   0    0     0      0      0      0
3 1   3    0     0      0      0      0
4 1  10   15     0      0      0      0
5 1  25  105   105      0      0      0
6 1  56  490  1260    945      0      0
7 1 119 1918  9450  17325  10395      0
8 1 246 6825 56980 190575 270270 135135
> 
> 
> 
> cleanEx()
> nameEx("identify.phylo")
> ### * identify.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: identify.phylo
> ### Title: Graphical Identification of Nodes and Tips
> ### Aliases: identify.phylo
> ### Keywords: aplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D tr <- rtree(20)
> ##D f <- function(col) {
> ##D     o <- identify(tr)
> ##D     nodelabels(node=o$nodes, pch = 19, col = col)
> ##D }
> ##D plot(tr)
> ##D f("red") # click close to a node
> ##D f("green")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("image.DNAbin")
> ### * image.DNAbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: image.DNAbin
> ### Title: Plot of DNA Sequence Alignement
> ### Aliases: image.DNAbin
> ### Keywords: hplot
> 
> ### ** Examples
> 
> data(woodmouse)
> image(woodmouse)
> rug(seg.sites(woodmouse), -0.02, 3, 1)
> image(woodmouse, "n", "blue") # show missing data
> image(woodmouse, c("g", "c"), "green") # G+C
> par(mfcol = c(2, 2))
> ### barcoding style:
> for (x in c("a", "g", "c", "t"))
+     image(woodmouse, x, "black", cex.lab = 0.5, cex.axis = 0.7)
> par(mfcol = c(1, 1))
> ### zoom on a portion of the data:
> image(woodmouse[11:15, 1:50], c("a", "n"), c("blue", "grey"))
> grid(50, 5, col = "black")
> ### see the guanines on a black background:
> image(woodmouse, "g", "yellow", "black")
> ### Amino acid
> X <- trans(woodmouse, 2)
Warning in trans(woodmouse, 2) :
  sequence length not a multiple of 3: 2 nucleotides dropped
> image(X) # default ape colors
> image(X, scheme="Clustal") # Clustal coloring
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("is.binary.tree")
> ### * is.binary.tree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.binary
> ### Title: Test for Binary Tree
> ### Aliases: is.binary is.binary.phylo is.binary.multiPhylo is.binary.tree
> ### Keywords: logic
> 
> ### ** Examples
> 
> is.binary(rtree(10))
[1] TRUE
> is.binary(rtree(10, rooted = FALSE))
[1] TRUE
> is.binary(stree(10))
[1] FALSE
> x <- setNames(rmtree(10, 10), LETTERS[1:10])
> is.binary(x)
   A    B    C    D    E    F    G    H    I    J 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> 
> 
> 
> cleanEx()
> nameEx("is.monophyletic")
> ### * is.monophyletic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.monophyletic
> ### Title: Is Group Monophyletic
> ### Aliases: is.monophyletic
> ### Keywords: utilities
> 
> ### ** Examples
> 
>     ## Test one monophyletic and one paraphyletic group on the bird.orders tree
>     ## Not run: data("bird.orders")
>     ## Not run: is.monophyletic(phy = bird.orders, tips = c("Ciconiiformes", "Gruiformes"))
>     ## Not run: is.monophyletic(bird.orders, c("Passeriformes", "Ciconiiformes", "Gruiformes"))
>     ## Don't show: 
> ## Not run: rm(bird.orders)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("is.ultrametric")
> ### * is.ultrametric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.ultrametric
> ### Title: Test if a Tree is Ultrametric
> ### Aliases: is.ultrametric is.ultrametric.phylo is.ultrametric.multiPhylo
> ### Keywords: utilities
> 
> ### ** Examples
> 
> is.ultrametric(rtree(10))
[1] FALSE
> is.ultrametric(rcoal(10))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("kronoviz")
> ### * kronoviz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kronoviz
> ### Title: Plot Multiple Chronograms on the Same Scale
> ### Aliases: kronoviz
> ### Keywords: hplot
> 
> ### ** Examples
> 
> TR <- replicate(10, rcoal(sample(11:20, size = 1)), simplify = FALSE)
> kronoviz(TR)
> kronoviz(TR, side = 1)
> kronoviz(TR, horiz = FALSE, type = "c", show.tip.label = FALSE)
> kronoviz(TR, direction = "d", side = c(1,2))
> 
> 
> 
> cleanEx()
> nameEx("label2table")
> ### * label2table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label2table
> ### Title: Label Management
> ### Aliases: label2table stripLabel abbreviateGenus
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- c("Panthera_leo", "Panthera_pardus", "Panthera_onca", "Panthera_uncia",
+        "Panthera_tigris_altaica", "Panthera_tigris_amoyensis")
> label2table(x)
     genus species subspecies
1 Panthera     leo       <NA>
2 Panthera  pardus       <NA>
3 Panthera    onca       <NA>
4 Panthera   uncia       <NA>
5 Panthera  tigris    altaica
6 Panthera  tigris  amoyensis
> stripLabel(x)
[1] "Panthera_leo"    "Panthera_pardus" "Panthera_onca"   "Panthera_uncia" 
[5] "Panthera_tigris" "Panthera_tigris"
> stripLabel(x, TRUE)
[1] "Panthera" "Panthera" "Panthera" "Panthera" "Panthera" "Panthera"
> abbreviateGenus(x)
[1] "P._leo"              "P._pardus"           "P._onca"            
[4] "P._uncia"            "P._tigris_altaica"   "P._tigris_amoyensis"
> abbreviateGenus(x, species = TRUE)
[1] "P._l."           "P._p."           "P._o."           "P._u."          
[5] "P._t._altaica"   "P._t._amoyensis"
> abbreviateGenus(x, genus = FALSE, species = TRUE)
[1] "Panthera_l."           "Panthera_p."           "Panthera_o."          
[4] "Panthera_u."           "Panthera_t._altaica"   "Panthera_t._amoyensis"
> 
> 
> 
> cleanEx()
> nameEx("ladderize")
> ### * ladderize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ladderize
> ### Title: Ladderize a Tree
> ### Aliases: ladderize
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- rcoal(50)
> layout(matrix(1:4, 2, 2))
> plot(tr, main = "normal")
> plot(ladderize(tr), main = "right-ladderized")
> plot(ladderize(tr, FALSE), main = "left-ladderized")
> layout(matrix(1, 1))
> 
> 
> 
> cleanEx()
> nameEx("latag2n")
> ### * latag2n
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: latag2n
> ### Title: Leading and Trailing Alignment Gaps to N
> ### Aliases: latag2n
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- as.DNAbin(matrix(c("-", "A", "G", "-", "T", "C"), 2, 3))
> y <- latag2n(x)
> alview(x)
 123
 -GT
 A-C
> alview(y)
 123
 NGT
 A-C
> 
> 
> 
> cleanEx()
> nameEx("lmorigin")
> ### * lmorigin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lmorigin
> ### Title: Multiple regression through the origin
> ### Aliases: lmorigin print.lmorigin lmorigin.ex1 lmorigin.ex2
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> ## Example 1 from Sokal & Rohlf (1995) Table 16.1
> ## SO2 air pollution in 41 cities of the USA
> data(lmorigin.ex1)
> out <- lmorigin(SO2 ~ ., data=lmorigin.ex1, origin=FALSE, nperm=99)
Multiple regression with estimation of intercept 
Permutation method = residuals of full model 
Computation time = 0.120000  sec 
> out

Multiple regression with estimation of intercept 

Call:
lmorigin(formula = SO2 ~ ., data = lmorigin.ex1, origin = FALSE,      nperm = 99) 

Coefficients and parametric test results 
 
                   Coefficient Std_error t-value  Pr(>|t|)    
(Intercept)          58.195935 20.487894  2.8405   0.00728 ** 
Mean_Annual_Temp_F   -0.587145  0.371008 -1.5826   0.12203    
No_manufactures       0.071225  0.016060  4.4349 7.955e-05 ***
Population_x_1000    -0.046648  0.015372 -3.0346   0.00439 ** 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Two-tailed tests of regression coefficients
 
                   Coefficient p-param p-perm   
(Intercept)          58.195935  0.0073     NA   
Mean_Annual_Temp_F   -0.587145  0.1220   0.17   
No_manufactures       0.071225  0.0001   0.01 **
Population_x_1000    -0.046648  0.0044   0.02 * 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

One-tailed tests of regression coefficients: 
test in the direction of the sign of the coefficient
 
                   Coefficient p-param p-perm   
(Intercept)          58.195935  0.0036     NA   
Mean_Annual_Temp_F   -0.587145  0.0610   0.12   
No_manufactures       0.071225  0.0000   0.01 **
Population_x_1000    -0.046648  0.0022   0.01 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 15.19126 on 37 degrees of freedom 
Multiple R-square: 0.6125468   Adjusted R-square: 0.5811317 

F-statistic: 19.49847 on 3 and 37 DF:
   parametric p-value   : 9.48852e-08 
   permutational p-value: 0.01 
after 99 permutations of residuals of full model 
 
> 
> ## Example 2: Contrasts computed on the phylogenetic tree of Lamellodiscus
> ## parasites. Response variable: non-specificity index (NSI); explanatory
> ## variable: maximum host size. Data from Table 1 of Legendre & Desdevises
> ## (2009).
> data(lmorigin.ex2)
> out <- lmorigin(NSI ~ MaxHostSize, data=lmorigin.ex2, origin=TRUE, nperm=99)
Regression through the origin 
Permutation method = raw data 
Computation time = 0.065000  sec 
> out

Regression through the origin 

Call:
lmorigin(formula = NSI ~ MaxHostSize, data = lmorigin.ex2, origin = TRUE,      nperm = 99) 

Coefficients and parametric test results 
 
            Coefficient Std_error t-value Pr(>|t|)   
MaxHostSize     -1.3032    0.4008 -3.2516 0.005004 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Two-tailed tests of regression coefficients
 
            Coefficient p-param p-perm  
MaxHostSize     -1.3032   0.005   0.03 *
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

One-tailed tests of regression coefficients: 
test in the direction of the sign of the coefficient
 
            Coefficient p-param p-perm   
MaxHostSize     -1.3032  0.0025   0.01 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.1263982 on 16 degrees of freedom 
Multiple R-square: 0.3978839   Adjusted R-square: 0.3602516 

F-statistic: 10.57295 on 1 and 16 DF:
   parametric p-value   : 0.005004064 
   permutational p-value: 0.03 
after 99 permutations of raw data 
 
> 
> ## Example 3: random numbers
> y <- rnorm(50)
> X <- as.data.frame(matrix(rnorm(250),50,5))
> out <- lmorigin(y ~ ., data=X, origin=FALSE, nperm=99)
Multiple regression with estimation of intercept 
Permutation method = residuals of full model 
Computation time = 0.123000  sec 
> out

Multiple regression with estimation of intercept 

Call:
lmorigin(formula = y ~ ., data = X, origin = FALSE, nperm = 99) 

Coefficients and parametric test results 
 
            Coefficient Std_error t-value Pr(>|t|)
(Intercept)    0.108536  0.151970  0.7142   0.4789
V1             0.152884  0.154498  0.9896   0.3278
V2            -0.171704  0.154194 -1.1136   0.2715
V3             0.185239  0.161660  1.1459   0.2580
V4             0.054831  0.158235  0.3465   0.7306
V5            -0.118415  0.164654 -0.7192   0.4758

Two-tailed tests of regression coefficients
 
            Coefficient p-param p-perm
(Intercept)    0.108536  0.4789     NA
V1             0.152884  0.3278   0.36
V2            -0.171704  0.2715   0.30
V3             0.185239  0.2580   0.22
V4             0.054831  0.7306   0.73
V5            -0.118415  0.4758   0.46

One-tailed tests of regression coefficients: 
test in the direction of the sign of the coefficient
 
            Coefficient p-param p-perm
(Intercept)    0.108536  0.2394     NA
V1             0.152884  0.1639   0.23
V2            -0.171704  0.1358   0.15
V3             0.185239  0.1290   0.11
V4             0.054831  0.3653   0.41
V5            -0.118415  0.2379   0.20

Residual standard error: 1.065795 on 44 degrees of freedom 
Multiple R-square: 0.07661285   Adjusted R-square: -0.02831751 

F-statistic: 0.7301304 on 5 and 44 DF:
   parametric p-value   : 0.6046645 
   permutational p-value: 0.66 
after 99 permutations of residuals of full model 
 
> 
> 
> 
> 
> cleanEx()
> nameEx("ltt.plot")
> ### * ltt.plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ltt.plot
> ### Title: Lineages Through Time Plot
> ### Aliases: ltt.plot ltt.lines mltt.plot ltt.coplot ltt.plot.coords
> ### Keywords: hplot aplot
> 
> ### ** Examples
> 
> data(bird.families)
> opar <- par(mfrow = c(2, 1))
> ltt.plot(bird.families)
> title("Lineages Through Time Plot of the Bird Families")
> ltt.plot(bird.families, log = "y")
> title(main = "Lineages Through Time Plot of the Bird Families",
+       sub = "(with logarithmic transformation of the y-axis)")
> par(opar)
> 
> ### to plot the tree and the LTT plot together
> data(bird.orders)
> layout(matrix(1:4, 2, 2))
> plot(bird.families, show.tip.label = FALSE)
> ltt.plot(bird.families, main = "Bird families")
> plot(bird.orders, show.tip.label = FALSE)
> ltt.plot(bird.orders, main = "Bird orders")
> layout(1)
> 
> ### better with ltt.coplot():
> ltt.coplot(bird.families, show.tip.label = FALSE, x.lim = 27.5)
> data(chiroptera)
> chiroptera <- compute.brlen(chiroptera)
> ltt.coplot(chiroptera, show.tip.label = FALSE, type = "c")
> 
> ### with extinct lineages and a root edge:
> omar <- par("mar")
> set.seed(31)
> tr <- rlineage(0.2, 0.15)
> tr$root.edge <- 5
> ltt.coplot(tr, show.tip.label = FALSE, x.lim = 55)
> ## compare with:
> ## ltt.coplot(drop.fossil(tr), show.tip.label = FALSE)
> layout(1)
> par(mar = omar)
> 
> mltt.plot(bird.families, bird.orders)
> ### Generates 10 random trees with 23 tips:
> TR <- replicate(10, rcoal(23), FALSE)
> ### Give names to each tree:
> names(TR) <- paste("random tree", 1:10)
> ### And specify the class of the list so that mltt.plot()
> ### does not trash it!
> class(TR) <- "multiPhylo"
> mltt.plot(TR, bird.orders)
> ### And now for something (not so) completely different:
> ltt.plot(bird.orders, lwd = 2)
> for (i in 1:10) ltt.lines(TR[[i]], lty = 2)
> legend(-20, 10, lwd = c(2, 1), lty = c(1, 2), bty = "n",
+        legend = c("Bird orders", "Random (coalescent) trees"))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("makeLabel")
> ### * makeLabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeLabel
> ### Title: Label Management
> ### Aliases: makeLabel makeLabel.character makeLabel.phylo
> ###   makeLabel.multiPhylo makeLabel.DNAbin
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- rep("a", 3)
> makeLabel(x)
[1] "a1" "a2" "a3"
> make.unique(x) # <- from R's base
[1] "a"   "a.1" "a.2"
> x <- rep("aaaaa", 2)
> makeLabel(x, len = 3) # made unique and of length 3
[1] "aa1" "aa2"
> makeLabel(x, len = 3, make.unique = FALSE)
[1] "aaa" "aaa"
> 
> 
> 
> cleanEx()
> nameEx("makeNodeLabel")
> ### * makeNodeLabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeNodeLabel
> ### Title: Makes Node Labels
> ### Aliases: makeNodeLabel makeNodeLabel.phylo makeNodeLabel.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <-
+ "((Pan_paniscus,Pan_troglodytes),((Homo_sapiens,Homo_erectus),Homo_abilis));"
> tr <- read.tree(text = tr)
> tr <- makeNodeLabel(tr, "u", nodeList = list(Pan = "Pan", Homo = "Homo"))
> plot(tr, show.node.label = TRUE)
> ### does not erase the previous node labels:
> tr <- makeNodeLabel(tr, "u", nodeList = list(Hominid = c("Pan","Homo")))
> plot(tr, show.node.label = TRUE)
> ### the two previous commands could be combined:
> L <- list(Pan = "Pan", Homo = "Homo", Hominid = c("Pan","Homo"))
> tr <- makeNodeLabel(tr, "u", nodeList = L)
> ### combining different methods:
> tr <- makeNodeLabel(tr, c("n", "u"), prefix = "#", nodeList = list(Hominid = c("Pan","Homo")))
> plot(tr, show.node.label = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("mantel.test")
> ### * mantel.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mantel.test
> ### Title: Mantel Test for Similarity of Two Matrices
> ### Aliases: mantel.test
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> q1 <- matrix(runif(36), nrow = 6)
> q2 <- matrix(runif(36), nrow = 6)
> diag(q1) <- diag(q2) <- 0
> mantel.test(q1, q2, graph = TRUE,
+             main = "Mantel test: a random example with 6 X 6 matrices
+ representing asymmetric relationships",
+             xlab = "z-statistic", ylab = "Density",
+             sub = "The vertical line shows the observed z-statistic")
$z.stat
[1] 3.588413

$p
[1] 0.697

$alternative
[1] "two.sided"

> 
> 
> 
> cleanEx()
> nameEx("matexpo")
> ### * matexpo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matexpo
> ### Title: Matrix Exponential
> ### Aliases: matexpo
> ### Keywords: array multivariate
> 
> ### ** Examples
> 
> ### a simple rate matrix:
> m <- matrix(0.1, 4, 4)
> diag(m) <- -0.3
> ### towards equilibrium:
> for (t in c(1, 5, 10, 50)) print(matexpo(m*t))
           [,1]       [,2]       [,3]       [,4]
[1,] 0.75274003 0.08241999 0.08241999 0.08241999
[2,] 0.08241999 0.75274003 0.08241999 0.08241999
[3,] 0.08241999 0.08241999 0.75274003 0.08241999
[4,] 0.08241999 0.08241999 0.08241999 0.75274003
          [,1]      [,2]      [,3]      [,4]
[1,] 0.3515015 0.2161662 0.2161662 0.2161662
[2,] 0.2161662 0.3515015 0.2161662 0.2161662
[3,] 0.2161662 0.2161662 0.3515015 0.2161662
[4,] 0.2161662 0.2161662 0.2161662 0.3515015
          [,1]      [,2]      [,3]      [,4]
[1,] 0.2637367 0.2454211 0.2454211 0.2454211
[2,] 0.2454211 0.2637367 0.2454211 0.2454211
[3,] 0.2454211 0.2454211 0.2637367 0.2454211
[4,] 0.2454211 0.2454211 0.2454211 0.2637367
     [,1] [,2] [,3] [,4]
[1,] 0.25 0.25 0.25 0.25
[2,] 0.25 0.25 0.25 0.25
[3,] 0.25 0.25 0.25 0.25
[4,] 0.25 0.25 0.25 0.25
> 
> 
> 
> cleanEx()
> nameEx("mcconwaysims.test")
> ### * mcconwaysims.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mcconwaysims.test
> ### Title: McConway-Sims Test of Homogeneous Diversification
> ### Aliases: mcconwaysims.test
> ### Keywords: htest
> 
> ### ** Examples
> 
> ### simulate 10 clades with lambda = 0.1 and mu = 0.09:
> n0 <- replicate(10, balance(rbdtree(.1, .09, Tmax = 35))[1])
> ### simulate 10 clades with lambda = 0.15 and mu = 0.1:
> n1 <- replicate(10, balance(rbdtree(.15, .1, Tmax = 35))[1])
> x <- cbind(n1, n0)
> mcconwaysims.test(x)
    chisq df      P.val
 17.56027 10 0.06284997
> slowinskiguyer.test(x)
   chisq df      P.val
 37.0831 20 0.01143639
> richness.yule.test(x, 35)
   chisq df        P.val
 14.3926  1 0.0001483841
> 
> 
> 
> cleanEx()
> nameEx("mcmc.popsize")
> ### * mcmc.popsize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mcmc.popsize
> ### Title: Reversible Jump MCMC to Infer Demographic History
> ### Aliases: mcmc.popsize extract.popsize plot.popsize lines.popsize
> ### Keywords: manip
> 
> ### ** Examples
> 
> # get tree
> data("hivtree.newick") # example tree in NH format
> tree.hiv <- read.tree(text = hivtree.newick) # load tree
> 
> # run mcmc chain
> mcmc.out <- mcmc.popsize(tree.hiv, nstep=100, thinning=1, burn.in=0,progress.bar=FALSE) # toy run
> #mcmc.out <- mcmc.popsize(tree.hiv, nstep=10000, thinning=5, burn.in=500) # remove comments!!
> 
> # make list of population size versus time
> popsize  <- extract.popsize(mcmc.out)
> 
> # plot and compare with skyline plot
> sk <- skyline(tree.hiv)
> plot(sk, lwd=1, lty=3, show.years=TRUE, subst.rate=0.0023, present.year = 1997)
> lines(popsize, show.years=TRUE, subst.rate=0.0023, present.year = 1997)
> 
> 
> 
> cleanEx()
> nameEx("mixedFontLabel")
> ### * mixedFontLabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixedFontLabel
> ### Title: Mixed Font Labels for Plotting
> ### Aliases: mixedFontLabel
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- read.tree(text = "((a,(b,c)),d);")
> genus <- c("Gorilla", "Pan", "Homo", "Pongo")
> species <- c("gorilla", "spp.", "sapiens", "pygmaeus")
> geo <- c("Africa", "Africa", "World", "Asia")
> tr$tip.label <- mixedFontLabel(genus, species, geo, italic = 1:2,
+   parenthesis = 3)
> layout(matrix(c(1, 2), 2))
> plot(tr)
> tr$tip.label <- mixedFontLabel(genus, species, geo, sep = c(" ", " | "),
+   italic = 1:2, bold = 3)
> plot(tr)
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("mst")
> ### * mst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mst
> ### Title: Minimum Spanning Tree
> ### Aliases: mst plot.mst
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> require(stats)
> X <- matrix(runif(200), 20, 10)
> d <- dist(X)
> PC <- prcomp(X)
> M <- mst(d)
> opar <- par(mfcol = c(2, 2))
> plot(M)
> plot(M, graph = "nsca")
> plot(M, x1 = PC$x[, 1], x2 = PC$x[, 2])
> par(opar)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("multi2di")
> ### * multi2di
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: multi2di
> ### Title: Collapse and Resolve Multichotomies
> ### Aliases: multi2di multi2di.phylo multi2di.multiPhylo di2multi
> ###   di2multi.phylo di2multi.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.families)
> is.binary(bird.families)
[1] FALSE
> is.binary(multi2di(bird.families))
[1] TRUE
> all.equal(di2multi(multi2di(bird.families)), bird.families)
[1] TRUE
> ### To see the results of randomly resolving a trichotomy:
> tr <- read.tree(text = "(a:1,b:1,c:1);")
> layout(matrix(1:4, 2, 2))
> for (i in 1:4)
+   plot(multi2di(tr), use.edge.length = FALSE, cex = 1.5)
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("multiphylo")
> ### * multiphylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: multiphylo
> ### Title: Manipulating Lists of Trees
> ### Aliases: multiphylo [.multiPhylo [[.multiPhylo $.multiPhylo
> ###   [<-.multiPhylo [[<-.multiPhylo $<-.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- rmtree(10, 20)
> names(x) <- paste("tree", 1:10, sep = "")
> x[1:5]
5 phylogenetic trees
> x[1] # subsetting
1 phylogenetic tree
> x[[1]] # extraction

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; includes branch length(s).
> x$tree1 # same than above

Phylogenetic tree with 20 tips and 19 internal nodes.

Tip labels:
  t10, t14, t20, t7, t9, t15, ...

Rooted; includes branch length(s).
> x[[1]] <- rtree(20)
> 
> y <- .compressTipLabel(x)
> ## up to here 'x' and 'y' have exactly the same information
> ## but 'y' has a unique vector of tip labels for all the trees
> x[[1]] <- rtree(10) # no error
> try(y[[1]] <- rtree(10)) # error
Error in `[[<-.multiPhylo`(`*tmp*`, 1, value = structure(list(edge = structure(c(11L,  : 
  tree with different number of tips than those in the list (which all have the same labels; maybe you want to uncompress them)
> 
> try(x[1] <- rtree(20)) # error
Error in `[<-.multiPhylo`(`*tmp*`, 1, value = structure(list(edge = structure(c(21L,  : 
  at least one element in 'value' is not of class "phylo".
> ## use instead one of the two:
> x[1] <- list(rtree(20))
> x[1] <- c(rtree(20))
> 
> x[1:5] <- rmtree(5, 20) # replacement
> x[11:20] <- rmtree(10, 20) # elongation
> x # 20 trees
20 phylogenetic trees
> 
> 
> 
> cleanEx()
> nameEx("mvr")
> ### * mvr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mvr
> ### Title: Minimum Variance Reduction
> ### Aliases: mvr mvrs
> ### Keywords: models
> 
> ### ** Examples
> 
> data(woodmouse)
> rt <- dist.dna(woodmouse, variance = TRUE)
> v <- attr(rt, "variance")
> tr <- mvr(rt, v)
> plot(tr, "u")
> 
> 
> 
> cleanEx()
> nameEx("nj")
> ### * nj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nj
> ### Title: Neighbor-Joining Tree Estimation
> ### Aliases: nj
> ### Keywords: models
> 
> ### ** Examples
> 
> ### From Saitou and Nei (1987, Table 1):
> x <- c(7, 8, 11, 13, 16, 13, 17, 5, 8, 10, 13,
+        10, 14, 5, 7, 10, 7, 11, 8, 11, 8, 12,
+        5, 6, 10, 9, 13, 8)
> M <- matrix(0, 8, 8)
> M[lower.tri(M)] <- x
> M <- t(M)
> M[lower.tri(M)] <- x
> dimnames(M) <- list(1:8, 1:8)
> tr <- nj(M)
> plot(tr, "u")
> ### a less theoretical example
> data(woodmouse)
> trw <- nj(dist.dna(woodmouse))
> plot(trw)
> 
> 
> 
> cleanEx()
> nameEx("njs")
> ### * njs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: njs
> ### Title: Tree Reconstruction from Incomplete Distances With NJ* or
> ###   bio-NJ*
> ### Aliases: njs bionjs
> ### Keywords: models
> 
> ### ** Examples
> 
> data(woodmouse)
> d <- dist.dna(woodmouse)
> dm <- d
> dm[sample(length(dm), size = 3)] <- NA
> dist.topo(njs(dm), nj(d)) # often 0
      tree1
tree2     0
> dm[sample(length(dm), size = 10)] <- NA
> dist.topo(njs(dm), nj(d)) # sometimes 0
      tree1
tree2     8
> 
> 
> 
> cleanEx()
> nameEx("node.dating")
> ### * node.dating
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: node.dating
> ### Title: node.dating
> ### Aliases: node.dating estimate.mu estimate.dates
> ### Keywords: model
> 
> ### ** Examples
> 
> t <- rtree(100)
> tip.date <- rnorm(t$tip.label, mean = node.depth.edgelength(t)[1:Ntip(t)])^2
> t <- rtt(t, tip.date)
> mu <- estimate.mu(t, tip.date)
> 
> ## Run for 100 steps
> node.date <- estimate.dates(t, tip.date, mu, nsteps = 100)
> 
> ## Run until the difference between successive log likelihoods is
> ## less than $10^{-4}$ starting with the 100th step's results
> node.date <- estimate.dates(t, node.date, mu, nsteps = 0, lik.tol = 1e-4)
> 
> ## To rescale the tree over time
> t$edge.length <- node.date[t$edge[, 2]] - node.date[t$edge[, 1]]
> 
> 
> 
> cleanEx()
> nameEx("nodelabels")
> ### * nodelabels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nodelabels
> ### Title: Labelling the Nodes, Tips, and Edges of a Tree
> ### Aliases: nodelabels tiplabels edgelabels
> ### Keywords: aplot
> 
> ### ** Examples
> 
> tr <- read.tree(text = "((Homo,Pan),Gorilla);")
> plot(tr)
> nodelabels("7.3 Ma", 4, frame = "r", bg = "yellow", adj = 0)
> nodelabels("5.4 Ma", 5, frame = "c", bg = "tomato", font = 3)
> 
> ## A trick by Liam Revell when there are many categories:
> plot(tr, x.lim = c(-1, 4))
> nodelabels(node = 4, pie = matrix(rep(1, 100), 1), cex = 5)
> op <- par(fg = "transparent")
> nodelabels(node = 5, pie = matrix(rep(1, 100), 1), cex = 5)
> par(op)
> 
> data(bird.orders)
> plot(bird.orders, use.edge.length = FALSE, font = 1)
> bs <- round(runif(22, 90, 100), 0) # some imaginary bootstrap values
> bs2 <- round(runif(22, 90, 100), 0)
> bs3 <- round(runif(22, 90, 100), 0)
> nodelabels(bs, adj = 1.2)
> nodelabels(bs2, adj = -0.2, bg = "yellow")
> 
> ### something more classical
> plot(bird.orders, use.edge.length = FALSE, font = 1)
> nodelabels(bs, adj = -0.2, frame = "n", cex = 0.8)
> nodelabels(bs2, adj = c(1.2, 1), frame = "n", cex = 0.8)
> nodelabels(bs3, adj = c(1.2, -0.2), frame = "n", cex = 0.8)
> 
> ### the same but we play with the font
> plot(bird.orders, use.edge.length = FALSE, font = 1)
> nodelabels(bs, adj = -0.2, frame = "n", cex = 0.8, font = 2)
> nodelabels(bs2, adj = c(1.2, 1), frame = "n", cex = 0.8, font = 3)
> nodelabels(bs3, adj = c(1.2, -0.2), frame = "n", cex = 0.8)
> 
> plot(bird.orders, "c", use.edge.length = FALSE, font = 1)
> nodelabels(thermo = runif(22), cex = .8)
> 
> plot(bird.orders, "u", FALSE, font = 1, lab4ut = "a")
> nodelabels(cex = .75, bg = "yellow")
> 
> ### representing two characters at the tips (you could have as many
> ### as you want)
> plot(bird.orders, "c", FALSE, font = 1, label.offset = 3,
+      x.lim = 31, no.margin = TRUE)
> tiplabels(pch = 21, bg = gray(1:23/23), cex = 2, adj = 1.4)
> tiplabels(pch = 19, col = c("yellow", "red", "blue"), adj = 2.5, cex = 2)
> ### This can be used to highlight tip labels:
> plot(bird.orders, font = 1)
> i <- c(1, 7, 18)
> tiplabels(bird.orders$tip.label[i], i, adj = 0)
> ### Some random data to compare piecharts and thermometres:
> tr <- rtree(15)
> x <- runif(14, 0, 0.33)
> y <- runif(14, 0, 0.33)
> z <- runif(14, 0, 0.33)
> x <- cbind(x, y, z, 1 - x - y - z)
> layout(matrix(1:2, 1, 2))
> plot(tr, "c", FALSE, no.margin = TRUE)
> nodelabels(pie = x, cex = 1.3)
> text(4.5, 15, "Are you \"pie\"...", font = 4, cex = 1.5)
> plot(tr, "c", FALSE, no.margin = TRUE)
> nodelabels(thermo = x, col = rainbow(4), cex = 1.3)
> text(4.5, 15, "... or \"thermo\"?", font = 4, cex = 1.5)
> plot(tr, "c", FALSE, no.margin = TRUE)
> nodelabels(thermo = x, col = rainbow(4), cex = 1.3)
> plot(tr, "c", FALSE, no.margin = TRUE)
> nodelabels(thermo = x, col = rainbow(4), width = 3, horiz = TRUE)
> layout(1)
> plot(tr, main = "Showing Edge Lengths")
> edgelabels(round(tr$edge.length, 3), srt = 90)
> plot(tr, "p", FALSE)
> edgelabels("above", adj = c(0.5, -0.25), bg = "yellow")
> edgelabels("below", adj = c(0.5, 1.25), bg = "lightblue")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("nodepath")
> ### * nodepath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nodepath
> ### Title: Find Paths of Nodes
> ### Aliases: nodepath
> ### Keywords: manip
> 
> ### ** Examples
> 
> tr <- rtree(2)
> nodepath(tr)
[[1]]
[1] 3 1

[[2]]
[1] 3 2

> nodepath(tr, 1, 2)
[1] 1 3 2
> 
> 
> 
> cleanEx()
> nameEx("parafit")
> ### * parafit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parafit
> ### Title: Test of host-parasite coevolution
> ### Aliases: parafit print.parafit gopher.D lice.D HP.links
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> ## Gopher and lice data from Hafner et al. (1994)
> 
> data(gopher.D)
> data(lice.D)
> data(HP.links)
> 
> res <- parafit(gopher.D, lice.D, HP.links, nperm=99, test.links=TRUE)
n.hosts = 15 , n.parasites = 17 
Computation time = 0.335000  sec 
> # res     # or else: print(res)
> 
> 
> 
> cleanEx()
> nameEx("pcoa")
> ### * pcoa
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pcoa
> ### Title: Principal Coordinate Analysis
> ### Aliases: pcoa biplot.pcoa
> ### Keywords: multivariate
> 
> ### ** Examples
> 
> ## Oribatid mite data from Borcard and Legendre (1994)
> 
> ## Not run: 
> ##D if (require(vegan)) {
> ##D data(mite) # Community composition data, 70 peat cores, 35 species
> ##D 
> ##D ## Select rows 1:30. Species 35 is absent from these rows. Transform to log
> ##D mite.log <- log(mite[1:30, -35] + 1)  # Equivalent: log1p(mite[1:30, -35])
> ##D 
> ##D ## Principal coordinate analysis and simple ordination plot
> ##D mite.D <- vegdist(mite.log, "bray")
> ##D res <- pcoa(mite.D)
> ##D res$values
> ##D biplot(res)
> ##D 
> ##D ## Project unstandardized and standardized species on the PCoA ordination plot
> ##D mite.log.st = apply(mite.log, 2, scale, center=TRUE, scale=TRUE)
> ##D 
> ##D par(mfrow=c(1,2))
> ##D biplot(res, mite.log)
> ##D biplot(res, mite.log.st)
> ##D 
> ##D # Reverse the ordination axes in the  plot
> ##D par(mfrow=c(1,2))
> ##D biplot(res, mite.log, dir.axis1=-1, dir.axis2=-1)
> ##D biplot(res, mite.log.st, dir.axis1=-1, dir.axis2=-1)
> ##D }
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("phydataplot")
> ### * phydataplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: phydataplot
> ### Title: Tree Annotation
> ### Aliases: phydataplot ring
> ### Keywords: aplot
> 
> ### ** Examples
> 
> ## demonstrates matching with names:
> tr <- rcoal(n <- 10)
> x <- 1:n
> names(x) <- tr$tip.label
> plot(tr, x.lim = 11)
> phydataplot(x, tr)
> ## shuffle x but matching names with tip labels reorders them:
> phydataplot(sample(x), tr, "s", lwd = 3, lty = 3)
> 
> ## adapts to the tree:
> plot(tr, "f", x.l = c(-11, 11), y.l = c(-11, 11))
> phydataplot(x, tr, "s")
> 
> ## leave more space with x.lim to show a barplot and a dotchart:
> plot(tr, x.lim = 22)
> phydataplot(x, tr, col = "yellow")
> phydataplot(x, tr, "d", offset = 13)
> 
> ts <- rcoal(N <- 100)
> X <- rTraitCont(ts) # names are set
> dd <- dist(X)
> op <- par(mar = rep(0, 4))
> plot(ts, x.lim = 10, cex = 0.4, font = 1)
> phydataplot(as.matrix(dd), ts, "i", offset = 0.2)
> 
> par(xpd = TRUE, mar = op$mar)
> co <- c("blue", "red"); l <- c(-2, 2)
> X <- X + abs(min(X)) # move scale so X >= 0
> plot(ts, "f", show.tip.label = FALSE, x.lim = l, y.lim = l, open.angle = 30)
> phydataplot(X, ts, "s", col = co, offset = 0.05)
> ring(X, ts, "ring", col = co, offset = max(X) + 0.1) # the same info as a ring
> 
> ## as many rings as you want...
> co <- c("blue", "yellow")
> plot(ts, "r", show.tip.label = FALSE, x.l = c(-1, 1), y.l = c(-1, 1))
> for (o in seq(0, 0.4, 0.2)) {
+     co <- rev(co)
+     ring(0.2, ts, "r", col = rep(co, each = 5), offset = o)
+ }
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
> 
> lim <- c(-5, 5)
> co <- rgb(0, 0.4, 1, alpha = 0.1)
> y <- seq(0.01, 1, 0.01)
> plot(ts, "f", x.lim = lim, y.lim = lim, show.tip.label = FALSE)
> ring(y, ts, offset = 0, col = co, lwd = 0.1)
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
> for (i in 1:3) {
+     y <- y + 1
+     ring(y, ts, offset = 0, col = co, lwd = 0.1)
+ }
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
> 
> ## rings can be in the background
> plot(ts, "r", plot = FALSE)
> ring(1, ts, "r", col = rainbow(100), offset = -1)
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
> par(new = TRUE)
> plot(ts, "r", font = 1, edge.color = "white")
> 
> ## might be more useful:
> co <- c("lightblue", "yellow")
> plot(ts, "r", plot = FALSE)
> ring(0.1, ts, "r", col = sample(co, size = N, rep = TRUE), offset = -.1)
Warning in .matchDataPhylo(x, phy) :
  'x' has no (row)names: data are assumed to be in the same order than the tips of the tree
> par(new = TRUE)
> plot(ts, "r", font = 1)
> 
> ## if x is matrix:
> tx <- rcoal(m <- 20)
> X <- runif(m, 0, 0.5); Y <- runif(m, 0, 0.5)
> X <- cbind(X, Y, 1 - X - Y)
> rownames(X) <- tx$tip.label
> plot(tx, x.lim = 6)
> co <- rgb(diag(3))
> phydataplot(X, tx, col = co)
> ## a variation:
> plot(tx, show.tip.label = FALSE, x.lim = 5)
> phydataplot(X, tx, col = co, offset = 0.05, border = NA)
> 
> plot(tx, "f", show.tip.label = FALSE, open.angle = 180)
> ring(X, tx, col = co, offset = 0.05)
> 
> Z <- matrix(rnorm(m * 5), m)
> rownames(Z) <- rownames(X)
> plot(tx, x.lim = 5)
> phydataplot(Z, tx, "bo", scaling = .5, offset = 0.5,
+             boxfill = c("gold", "skyblue"))
> 
> ## plot an alignment with a NJ tree:
> data(woodmouse)
> trw <- nj(dist.dna(woodmouse))
> plot(trw, x.lim = 0.1, align.tip = TRUE, font = 1)
> phydataplot(woodmouse[, 1:50], trw, "m", 0.02, border = NA)
> 
> ## use type = "mosaic" on a 30x5 matrix:
> tr <- rtree(n <- 30)
> p <- 5
> x <- matrix(sample(3, size = n*p, replace = TRUE), n, p)
> dimnames(x) <- list(paste0("t", 1:n), LETTERS[1:p])
> plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
> phydataplot(x, tr, "m", 2)
> ## change the aspect:
> plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
> phydataplot(x, tr, "m", 2, width = 2, border = "white", lwd = 3, legend = "side")
> ## user-defined colour:
> f <- function(n) c("yellow", "blue", "red")
> phydataplot(x, tr, "m", 18, width = 2, border = "white", lwd = 3,
+             legend = "side", funcol = f)
> 
> ## alternative colour function...:
> ## fb <- function(n) c("3" = "red", "2" = "blue", "1" = "yellow")
> ## ... but since the values are sorted alphabetically,
> ## both f and fb will produce the same plot.
> 
> ## use continuous = TRUE with two different scales:
> x[] <- 1:(n*p)
> plot(tr, x.lim = 35, align.tip = TRUE, adj = 1)
> phydataplot(x, tr, "m", 2, width = 1.5, continuous = TRUE, legend = "side",
+             funcol = colorRampPalette(c("white", "darkgreen")))
> phydataplot(x, tr, "m", 18, width = 1.5, continuous = 5, legend = "side",
+             funcol = topo.colors)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("phymltest")
> ### * phymltest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: phymltest
> ### Title: Fits a Bunch of Models with PhyML
> ### Aliases: phymltest print.phymltest summary.phymltest plot.phymltest
> ### Keywords: models
> 
> ### ** Examples
> 
> ### A `fake' example with random likelihood values: it does not
> ### make sense, but does not need PhyML and gives you a flavour
> ### of what the output looks like:
> x <- runif(28, -100, -50)
> names(x) <- ape:::.phymltest.model
> class(x) <- "phymltest"
> x
          nb.free.para    loglik      AIC
JC69                 1 -86.72457 175.4491
JC69+I               2 -81.39381 166.7876
JC69+G               2 -71.35733 146.7147
JC69+I+G             3 -54.58961 115.1792
K80                  2 -89.91590 183.8318
K80+I                3 -55.08052 116.1610
K80+G                3 -52.76624 111.5325
K80+I+G              4 -66.96011 141.9202
F81                  4 -68.54430 145.0886
F81+I                5 -96.91069 203.8214
F81+G                5 -89.70127 189.4025
F81+I+G              6 -91.17216 194.3443
F84                  5 -65.64886 141.2977
F84+I                6 -80.79481 173.5896
F84+G                6 -61.50793 135.0159
F84+I+G              7 -75.11504 164.2301
HKY85                5 -64.11907 138.2381
HKY85+I              6 -50.40470 112.8094
HKY85+G              6 -80.99824 173.9965
HKY85+I+G            7 -61.12774 136.2555
TN93                 6 -53.26474 118.5295
TN93+I               7 -89.39287 192.7857
TN93+G               7 -67.41631 148.8326
TN93+I+G             8 -93.72225 203.4445
GTR                  9 -86.63897 191.2779
GTR+I               10 -80.69430 181.3886
GTR+G               10 -99.33048 218.6610
GTR+I+G             11 -80.88060 183.7612
> summary(x)
       model1    model2        chi2 df  P.val
1        JC69    JC69+I  10.6615236  1 0.0011
2        JC69    JC69+G  30.7344700  1 0.0000
3        JC69  JC69+I+G  64.2699127  2 0.0000
4        JC69       K80  -6.3826732  1 1.0000
5        JC69     K80+I  63.2881022  2 0.0000
6        JC69     K80+G  67.9166605  2 0.0000
7        JC69   K80+I+G  39.5289129  3 0.0000
8        JC69       F81  36.3605381  3 0.0000
9        JC69     F81+I -20.3722393  4 1.0000
10       JC69     F81+G  -5.9534088  4 1.0000
11       JC69   F81+I+G  -8.8951911  5 1.0000
12       JC69       F84  42.1514184  4 0.0000
13       JC69     F84+I  11.8595055  5 0.0368
14       JC69     F84+G  50.4332757  5 0.0000
15       JC69   F84+I+G  23.2190579  6 0.0007
16       JC69     HKY85  45.2109845  4 0.0000
17       JC69   HKY85+I  72.6397432  5 0.0000
18       JC69   HKY85+G  11.4526516  5 0.0431
19       JC69 HKY85+I+G  51.1936558  6 0.0000
20       JC69      TN93  66.9196568  5 0.0000
21       JC69    TN93+I  -5.3366142  6 1.0000
22       JC69    TN93+G  38.6165103  6 0.0000
23       JC69  TN93+I+G -13.9953567  7 1.0000
24       JC69       GTR   0.1712006  8 1.0000
25       JC69     GTR+I  12.0605429  9 0.2099
26       JC69     GTR+G -25.2118330  9 1.0000
27       JC69   GTR+I+G  11.6879294 10 0.3065
28     JC69+I  JC69+I+G  53.6083890  1 0.0000
29     JC69+I     K80+I  52.6265785  1 0.0000
30     JC69+I   K80+I+G  28.8673893  2 0.0000
31     JC69+I     F81+I -31.0337629  3 1.0000
32     JC69+I   F81+I+G -19.5567147  4 1.0000
33     JC69+I     F84+I   1.1979819  4 0.8784
34     JC69+I   F84+I+G  12.5575342  5 0.0279
35     JC69+I   HKY85+I  61.9782195  4 0.0000
36     JC69+I HKY85+I+G  40.5321322  5 0.0000
37     JC69+I    TN93+I -15.9981378  5 1.0000
38     JC69+I  TN93+I+G -24.6568804  6 1.0000
39     JC69+I     GTR+I   1.3990193  8 0.9943
40     JC69+I   GTR+I+G   1.0264057  9 0.9994
41     JC69+G  JC69+I+G  33.5354427  1 0.0000
42     JC69+G     K80+G  37.1821905  1 0.0000
43     JC69+G   K80+I+G   8.7944429  2 0.0123
44     JC69+G     F81+G -36.6878788  3 1.0000
45     JC69+G   F81+I+G -39.6296611  4 1.0000
46     JC69+G     F84+G  19.6988057  4 0.0006
47     JC69+G   F84+I+G  -7.5154121  5 1.0000
48     JC69+G   HKY85+G -19.2818184  4 1.0000
49     JC69+G HKY85+I+G  20.4591858  5 0.0010
50     JC69+G    TN93+G   7.8820403  5 0.1629
51     JC69+G  TN93+I+G -44.7298267  6 1.0000
52     JC69+G     GTR+G -55.9463030  8 1.0000
53     JC69+G   GTR+I+G -19.0465406  9 1.0000
54   JC69+I+G   K80+I+G -24.7409998  1 1.0000
55   JC69+I+G   F81+I+G -73.1651037  3 1.0000
56   JC69+I+G   F84+I+G -41.0508548  4 1.0000
57   JC69+I+G HKY85+I+G -13.0762569  4 1.0000
58   JC69+I+G  TN93+I+G -78.2652694  5 1.0000
59   JC69+I+G   GTR+I+G -52.5819833  8 1.0000
60        K80     K80+I  69.6707754  1 0.0000
61        K80     K80+G  74.2993338  1 0.0000
62        K80   K80+I+G  45.9115861  2 0.0000
63        K80       F84  48.5340916  3 0.0000
64        K80     F84+I  18.2421787  4 0.0011
65        K80     F84+G  56.8159489  4 0.0000
66        K80   F84+I+G  29.6017311  5 0.0000
67        K80     HKY85  51.5936577  3 0.0000
68        K80   HKY85+I  79.0224164  4 0.0000
69        K80   HKY85+G  17.8353248  4 0.0013
70        K80 HKY85+I+G  57.5763290  5 0.0000
71        K80      TN93  73.3023300  4 0.0000
72        K80    TN93+I   1.0460590  5 0.9588
73        K80    TN93+G  44.9991835  5 0.0000
74        K80  TN93+I+G  -7.6126835  6 1.0000
75        K80       GTR   6.5538738  7 0.4768
76        K80     GTR+I  18.4432162  8 0.0181
77        K80     GTR+G -18.8291598  8 1.0000
78        K80   GTR+I+G  18.0706026  9 0.0344
79      K80+I   K80+I+G -23.7591892  1 1.0000
80      K80+I     F84+I -51.4285967  3 1.0000
81      K80+I   F84+I+G -40.0690443  4 1.0000
82      K80+I   HKY85+I   9.3516410  3 0.0250
83      K80+I HKY85+I+G -12.0944464  4 1.0000
84      K80+I    TN93+I -68.6247164  4 1.0000
85      K80+I  TN93+I+G -77.2834589  5 1.0000
86      K80+I     GTR+I -51.2275592  7 1.0000
87      K80+I   GTR+I+G -51.6001728  8 1.0000
88      K80+G   K80+I+G -28.3877476  1 1.0000
89      K80+G     F84+G -17.4833849  3 1.0000
90      K80+G   F84+I+G -44.6976027  4 1.0000
91      K80+G   HKY85+G -56.4640089  3 1.0000
92      K80+G HKY85+I+G -16.7230047  4 1.0000
93      K80+G    TN93+G -29.3001503  4 1.0000
94      K80+G  TN93+I+G -81.9120173  5 1.0000
95      K80+G     GTR+G -93.1284935  7 1.0000
96      K80+G   GTR+I+G -56.2287312  8 1.0000
97    K80+I+G   F84+I+G -16.3098550  3 1.0000
98    K80+I+G HKY85+I+G  11.6647429  3 0.0086
99    K80+I+G  TN93+I+G -53.5242697  4 1.0000
100   K80+I+G   GTR+I+G -27.8409835  7 1.0000
101       F81     F81+I -56.7327773  1 1.0000
102       F81     F81+G -42.3139469  1 1.0000
103       F81   F81+I+G -45.2557291  2 1.0000
104       F81       F84   5.7908803  1 0.0161
105       F81     F84+I -24.5010326  2 1.0000
106       F81     F84+G  14.0727376  2 0.0009
107       F81   F84+I+G -13.1414802  3 1.0000
108       F81     HKY85   8.8504464  1 0.0029
109       F81   HKY85+I  36.2792051  2 0.0000
110       F81   HKY85+G -24.9078864  2 1.0000
111       F81 HKY85+I+G  14.8331177  3 0.0020
112       F81      TN93  30.5591187  2 0.0000
113       F81    TN93+I -41.6971523  3 1.0000
114       F81    TN93+G   2.2559722  3 0.5210
115       F81  TN93+I+G -50.3558948  4 1.0000
116       F81       GTR -36.1893375  5 1.0000
117       F81     GTR+I -24.2999951  6 1.0000
118       F81     GTR+G -61.5723711  6 1.0000
119       F81   GTR+I+G -24.6726087  7 1.0000
120     F81+I   F81+I+G  11.4770482  1 0.0007
121     F81+I     F84+I  32.2317448  1 0.0000
122     F81+I   F84+I+G  43.5912972  2 0.0000
123     F81+I   HKY85+I  93.0119824  1 0.0000
124     F81+I HKY85+I+G  71.5658951  2 0.0000
125     F81+I    TN93+I  15.0356251  2 0.0005
126     F81+I  TN93+I+G   6.3768825  3 0.0946
127     F81+I     GTR+I  32.4327822  5 0.0000
128     F81+I   GTR+I+G  32.0601687  6 0.0000
129     F81+G   F81+I+G  -2.9417822  1 1.0000
130     F81+G     F84+G  56.3866845  1 0.0000
131     F81+G   F84+I+G  29.1724667  2 0.0000
132     F81+G   HKY85+G  17.4060605  1 0.0000
133     F81+G HKY85+I+G  57.1470646  2 0.0000
134     F81+G    TN93+G  44.5699191  2 0.0000
135     F81+G  TN93+I+G  -8.0419479  3 1.0000
136     F81+G     GTR+G -19.2584242  5 1.0000
137     F81+G   GTR+I+G  17.6413382  6 0.0072
138   F81+I+G   F84+I+G  32.1142490  1 0.0000
139   F81+I+G HKY85+I+G  60.0888469  1 0.0000
140   F81+I+G  TN93+I+G  -5.1001657  2 1.0000
141   F81+I+G   GTR+I+G  20.5831205  5 0.0010
142       F84     F84+I -30.2919128  1 1.0000
143       F84     F84+G   8.2818573  1 0.0040
144       F84   F84+I+G -18.9323605  2 1.0000
145       F84   HKY85+I  30.4883248  1 0.0000
146       F84   HKY85+G -30.6987667  1 1.0000
147       F84 HKY85+I+G   9.0422375  2 0.0109
148       F84      TN93  24.7682384  1 0.0000
149       F84    TN93+I -47.4880325  2 1.0000
150       F84    TN93+G  -3.5349081  2 1.0000
151       F84  TN93+I+G -56.1467751  3 1.0000
152       F84       GTR -41.9802178  4 1.0000
153       F84     GTR+I -30.0908754  5 1.0000
154       F84     GTR+G -67.3632513  5 1.0000
155       F84   GTR+I+G -30.4634890  6 1.0000
156     F84+I   F84+I+G  11.3595524  1 0.0008
157     F84+I HKY85+I+G  39.3341503  1 0.0000
158     F84+I    TN93+I -17.1961197  1 1.0000
159     F84+I  TN93+I+G -25.8548622  2 1.0000
160     F84+I     GTR+I   0.2010374  4 0.9953
161     F84+I   GTR+I+G  -0.1715761  5 1.0000
162     F84+G   F84+I+G -27.2142178  1 1.0000
163     F84+G HKY85+I+G   0.7603801  1 0.3832
164     F84+G    TN93+G -11.8167654  1 1.0000
165     F84+G  TN93+I+G -64.4286324  2 1.0000
166     F84+G     GTR+G -75.6451087  4 1.0000
167     F84+G   GTR+I+G -38.7453463  5 1.0000
168   F84+I+G  TN93+I+G -37.2144146  1 1.0000
169   F84+I+G   GTR+I+G -11.5311285  4 1.0000
170     HKY85   HKY85+I  27.4287587  1 0.0000
171     HKY85   HKY85+G -33.7583329  1 1.0000
172     HKY85 HKY85+I+G   5.9826713  2 0.0502
173     HKY85      TN93  21.7086723  1 0.0000
174     HKY85    TN93+I -50.5475987  2 1.0000
175     HKY85    TN93+G  -6.5944742  2 1.0000
176     HKY85  TN93+I+G -59.2063412  3 1.0000
177     HKY85       GTR -45.0397840  4 1.0000
178     HKY85     GTR+I -33.1504416  5 1.0000
179     HKY85     GTR+G -70.4228175  5 1.0000
180     HKY85   GTR+I+G -33.5230551  6 1.0000
181   HKY85+I HKY85+I+G -21.4460874  1 1.0000
182   HKY85+I    TN93+I -77.9763574  1 1.0000
183   HKY85+I  TN93+I+G -86.6350999  2 1.0000
184   HKY85+I     GTR+I -60.5792002  4 1.0000
185   HKY85+I   GTR+I+G -60.9518138  5 1.0000
186   HKY85+G HKY85+I+G  39.7410042  1 0.0000
187   HKY85+G    TN93+G  27.1638587  1 0.0000
188   HKY85+G  TN93+I+G -25.4480083  2 1.0000
189   HKY85+G     GTR+G -36.6644846  4 1.0000
190   HKY85+G   GTR+I+G   0.2352778  5 0.9987
191 HKY85+I+G  TN93+I+G -65.1890125  1 1.0000
192 HKY85+I+G   GTR+I+G -39.5057264  4 1.0000
193      TN93    TN93+I -72.2562710  1 1.0000
194      TN93    TN93+G -28.3031465  1 1.0000
195      TN93  TN93+I+G -80.9150135  2 1.0000
196      TN93       GTR -66.7484562  3 1.0000
197      TN93     GTR+I -54.8591139  4 1.0000
198      TN93     GTR+G -92.1314898  4 1.0000
199      TN93   GTR+I+G -55.2317274  5 1.0000
200    TN93+I  TN93+I+G  -8.6587425  1 1.0000
201    TN93+I     GTR+I  17.3971571  3 0.0006
202    TN93+I   GTR+I+G  17.0245436  4 0.0019
203    TN93+G  TN93+I+G -52.6118670  1 1.0000
204    TN93+G     GTR+G -63.8283433  3 1.0000
205    TN93+G   GTR+I+G -26.9285809  4 1.0000
206  TN93+I+G   GTR+I+G  25.6832861  3 0.0000
207       GTR     GTR+I  11.8893424  1 0.0006
208       GTR     GTR+G -25.3830336  1 1.0000
209       GTR   GTR+I+G  11.5167288  2 0.0032
210     GTR+I   GTR+I+G  -0.3726135  1 1.0000
211     GTR+G   GTR+I+G  36.8997624  1 0.0000
> plot(x)
> plot(x, main = "", col = "red")
> ### This example needs PhyML, copy/paste or type the
> ### following commands if you want to try them, eventually
> ### changing setwd() and the options of phymltest()
> ## Not run: 
> ##D setwd("D:/phyml_v2.4/exe") # under Windows
> ##D data(woodmouse)
> ##D write.dna(woodmouse, "woodmouse.txt")
> ##D X <- phymltest("woodmouse.txt")
> ##D X
> ##D summary(X)
> ##D plot(X)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pic")
> ### * pic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pic
> ### Title: Phylogenetically Independent Contrasts
> ### Aliases: pic
> ### Keywords: regression
> 
> ### ** Examples
> 
> ### The example in Phylip 3.5c (originally from Lynch 1991)
> x <- "((((Homo:0.21,Pongo:0.21):0.28,Macaca:0.49):0.13,Ateles:0.62):0.38,Galago:1.00);"
> tree.primates <- read.tree(text = x)
> X <- c(4.09434, 3.61092, 2.37024, 2.02815, -1.46968)
> Y <- c(4.74493, 3.33220, 3.36730, 2.89037, 2.30259)
> names(X) <- names(Y) <- c("Homo", "Pongo", "Macaca", "Ateles", "Galago")
> pic.X <- pic(X, tree.primates)
> pic.Y <- pic(Y, tree.primates)
> cor.test(pic.X, pic.Y)

	Pearson's product-moment correlation

data:  pic.X and pic.Y
t = -0.85623, df = 2, p-value = 0.4821
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 -0.9874751  0.8823934
sample estimates:
       cor 
-0.5179156 

> lm(pic.Y ~ pic.X - 1) # both regressions

Call:
lm(formula = pic.Y ~ pic.X - 1)

Coefficients:
 pic.X  
0.4319  

> lm(pic.X ~ pic.Y - 1) # through the origin

Call:
lm(formula = pic.X ~ pic.Y - 1)

Coefficients:
pic.Y  
0.998  

> 
> 
> 
> cleanEx()
> nameEx("pic.ortho")
> ### * pic.ortho
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pic.ortho
> ### Title: Phylogenetically Independent Orthonormal Contrasts
> ### Aliases: pic.ortho
> ### Keywords: regression
> 
> ### ** Examples
> 
> tr <- rcoal(30)
> ### a single observation per species:
> x <- rTraitCont(tr)
> pic.ortho(x, tr)
           31            32            33            34            35 
 0.4136644616  0.2188976442  0.0084618061  0.0100365006 -0.0806247780 
           36            37            38            39            40 
 0.1047995955  0.0121089326 -0.0670569933 -0.0459177096 -0.0713829123 
           41            42            43            44            45 
 0.0667873169 -0.0232405736  0.0268044339 -0.0197054266  0.0024840799 
           46            47            48            49            50 
 0.0199839214  0.0040184065  0.0022632447 -0.0164849062 -0.0046289578 
           51            52            53            54            55 
 0.0018212601 -0.0043107393 -0.0026241454  0.0133849115 -0.0058117565 
           56            57            58            59 
-0.0096786794  0.0082861477 -0.0003965564  0.0037523575 
> pic.ortho(x, tr, TRUE)
       contrasts     variance
31  0.4136644616 11.383586783
32  0.2188976442  2.921913291
33  0.0084618061  1.396111631
34  0.0100365006  0.858965259
35 -0.0806247780  0.314081145
36  0.1047995955  0.559199247
37  0.0121089326  0.418155950
38 -0.0670569933  0.260835129
39 -0.0459177096  0.433990393
40 -0.0713829123  0.164860934
41  0.0667873169  0.198600664
42 -0.0232405736  0.277255872
43  0.0268044339  0.219300222
44 -0.0197054266  0.126612014
45  0.0024840799  0.111751506
46  0.0199839214  0.080244976
47  0.0040184065  0.062072564
48  0.0022632447  0.039627136
49 -0.0164849062  0.048835389
50 -0.0046289578  0.027851162
51  0.0018212601  0.034523935
52 -0.0043107393  0.023009958
53 -0.0026241454  0.020876825
54  0.0133849115  0.016421890
55 -0.0058117565  0.007219245
56 -0.0096786794  0.005430245
57  0.0082861477  0.005031968
58 -0.0003965564  0.004646500
59  0.0037523575  0.001736050
> ### different number of observations per species:
> x <- lapply(sample(1:5, 30, TRUE), rnorm)
> pic.ortho(x, tr, intra = TRUE)
         31          32          33          34          35          36 
 0.12214797  0.08178600 -1.31895894  0.79603533 -1.09667949  1.07301225 
         37          38          39          40          41          42 
-0.89081344  0.57146478  1.46573028 -0.23682440 -0.42891336 -0.36291523 
         43          44          45          46          47          48 
 0.83147897  0.91494707  0.59408548  0.07136413  1.51675192  0.50656580 
         49          50          51          52          53          54 
-0.62289646  0.71911815 -1.07611230  0.11546391  0.25818692  1.11389536 
         55          56          57          58          59 
-0.01900669 -0.40722353 -0.58693852 -1.00335252 -0.75407654 
attr(,"intra")
attr(,"intra")$t29
[1]  0.8728336 -1.0423774  1.7668126

attr(,"intra")$t2
[1] -0.4488534

attr(,"intra")$t10
[1]  0.2348482  1.1267556 -1.0414803  0.3716143

attr(,"intra")$t1
[1] 0.57690765 0.74449248 0.21426630 0.02165785

attr(,"intra")$t11
[1]  0.3172836 -0.6917513 -0.2752800

attr(,"intra")$t15
[1] -0.37898836  1.28312686 -0.06170964

attr(,"intra")$t24
NULL

attr(,"intra")$t28
[1] 1.929309

attr(,"intra")$t16
[1] -0.5866813 -1.9920915 -0.4717537

attr(,"intra")$t21
NULL

attr(,"intra")$t12
NULL

attr(,"intra")$t7
[1] -0.105717  1.829239

attr(,"intra")$t8
NULL

attr(,"intra")$t27
NULL

attr(,"intra")$t3
[1]  1.3596052  0.1800964 -0.6323225

attr(,"intra")$t23
[1] -1.0093532 -0.1432172

attr(,"intra")$t22
[1] -0.5853033  1.7534686  0.9601071 -1.6085276

attr(,"intra")$t26
[1] -0.5321747 -1.7111524

attr(,"intra")$t17
[1]  1.3790871 -0.1263420 -0.4986534  1.1969980

attr(,"intra")$t6
NULL

attr(,"intra")$t13
NULL

attr(,"intra")$t4
NULL

attr(,"intra")$t20
[1] -1.2888573 -2.3126445 -0.3771339 -0.3686569

attr(,"intra")$t5
[1] 1.7843477 0.1769425 1.1646679

attr(,"intra")$t19
[1] 0.3147985 0.2630376 0.7597378

attr(,"intra")$t18
[1] -1.8584830 -0.2408373 -2.6909002

attr(,"intra")$t14
[1] -1.87717882 -0.97737205  0.06694893

attr(,"intra")$t30
[1] 1.1592084 1.0353187 0.6720099 1.8195137

attr(,"intra")$t25
[1] 0.6736635

attr(,"intra")$t9
[1] -0.4869117 -0.9383138  0.1963380

> 
> 
> 
> cleanEx()
> nameEx("plot.phylo")
> ### * plot.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.phylo
> ### Title: Plot Phylogenies
> ### Aliases: plot.phylo plot.multiPhylo
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ### An extract from Sibley and Ahlquist (1990)
> x <- "(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
> tree.owls <- read.tree(text= x)
> plot(tree.owls)
> 
> ### Show the types of trees.
> layout(matrix(1:6, 3, 2))
> plot(tree.owls, main = "With branch lengths")
> plot(tree.owls, type = "c")
> plot(tree.owls, type = "u")
> plot(tree.owls, use.edge.length = FALSE, main = "Without branch lengths")
> plot(tree.owls, type = "c", use.edge.length = FALSE)
> plot(tree.owls, type = "u", use.edge.length = FALSE)
> layout(1)
> 
> data(bird.orders)
> ### using random colours and thickness
> plot(bird.orders,
+      edge.color = sample(colors(), length(bird.orders$edge)/2),
+      edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
> title("Random colours and branch thickness")
> ### rainbow colouring...
> X <- c("red", "orange", "yellow", "green", "blue", "purple")
> plot(bird.orders,
+      edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
+      edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
> title("Rainbow colouring")
> plot(bird.orders, type = "c", use.edge.length = FALSE,
+      edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
+      edge.width = rep(5, length(bird.orders$edge)/2))
> segments(rep(0, 6), 6.5:1.5, rep(2, 6), 6.5:1.5, lwd = 5, col = X)
> text(rep(2.5, 6), 6.5:1.5, paste(X, "..."), adj = 0)
> title("Character mapping...")
> plot(bird.orders, "u", font = 1, cex = 0.75)
> data(bird.families)
> plot(bird.families, "u", lab4ut = "axial", font = 1, cex = 0.5)
> plot(bird.families, "r", font = 1, cex = 0.5)
> ### cladogram with oblique tip labels
> plot(bird.orders, "c", FALSE, direction = "u", srt = -40, x.lim = 25.5)
> ### facing trees with different informations...
> tr <- bird.orders
> tr$tip.label <- rep("", 23)
> layout(matrix(1:2, 1, 2), c(5, 4))
> plot(bird.orders, "c", FALSE, adj = 0.5, no.margin = TRUE, label.offset = 0.8,
+      edge.color = sample(X, length(bird.orders$edge)/2, replace = TRUE),
+      edge.width = rep(5, length(bird.orders$edge)/2))
> text(7.5, 23, "Facing trees with\ndifferent informations", font = 2)
> plot(tr, "p", direction = "l", no.margin = TRUE,
+      edge.width = sample(1:10, length(bird.orders$edge)/2, replace = TRUE))
> ### Recycling of arguments gives a lot of possibilities
> ### for tip labels:
> plot(bird.orders, tip.col = c(rep("red", 5), rep("blue", 18)),
+      font = c(rep(3, 5), rep(2, 17), 1))
> plot(bird.orders, tip.col = c("blue", "green"),
+      cex = 23:1/23 + .3, font = 1:3)
> co <- c(rep("blue", 9), rep("green", 35))
> plot(bird.orders, "f", edge.col = co)
> plot(bird.orders, edge.col = co)
> layout(1)
> 
> ## tidy trees
> tr <- rtree(100)
> layout(matrix(1:2, 2))
> plot(tr)
> axis(2)
> plot(tr, "t")
> axis(2)
> ## around 20 percent gain on the y-axis
> 
> 
> 
> cleanEx()
> nameEx("plot.phyloExtra")
> ### * plot.phyloExtra
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.phylo.extra
> ### Title: Extra Fuctions to Plot and Annotate Phylogenies
> ### Aliases: plot.phylo.extra plotBreakLongEdges drawSupportOnEdges
> ### Keywords: hplot
> 
> ### ** Examples
> 
> tr <- rtree(10)
> tr$edge.length[c(1, 18)] <- 100
> op <- par(mfcol = 1:2)
> plot(tr); axisPhylo()
> plotBreakLongEdges(tr, 2); axisPhylo()
> 
> ## from ?boot.phylo:
> f <- function(x) nj(dist.dna(x))
> data(woodmouse)
> tw <- f(woodmouse) # NJ tree with K80 distance
> set.seed(1)
> ## bootstrap with 100 replications:
> (bp <- boot.phylo(tw, woodmouse, f, quiet = TRUE))
 [1]  NA  44  71  63  65  45  77  67  81  96  88 100  57
> ## the first value relates to the root node and is always 100
> ## it is ignored below:
> plot(tw, "u")
> drawSupportOnEdges(bp)
> ## more readable but the tree is really unrooted:
> plot(tw)
> drawSupportOnEdges(bp)
> par(op)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("plotTreeTime")
> ### * plotTreeTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotTreeTime
> ### Title: Plot Tree With Time Axis
> ### Aliases: plotTreeTime
> ### Keywords: hplot
> 
> ### ** Examples
> 
> dates <- as.Date(.leap.seconds)
> tr <- rtree(length(dates))
> plotTreeTime(tr, dates)
> 
> ## handling NA's:
> dates[11:26] <- NA
> plotTreeTime(tr, dates)
> 
> ## dates can be on an arbitrary scale, e.g., [-1, 1]:
> plotTreeTime(tr, runif(Ntip(tr), -1, 1))
> 
> 
> 
> cleanEx()
> nameEx("print.phylo")
> ### * print.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.phylo
> ### Title: Compact Display of a Phylogeny
> ### Aliases: print.phylo print.multiPhylo str.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- rtree(10)
> print(x)

Phylogenetic tree with 10 tips and 9 internal nodes.

Tip labels:
  t7, t2, t3, t8, t1, t5, ...

Rooted; includes branch length(s).
> print(x, printlen = 10)

Phylogenetic tree with 10 tips and 9 internal nodes.

Tip labels:
  t7, t2, t3, t8, t1, t5, t6, t9, t10, t4

Rooted; includes branch length(s).
> x <- rmtree(2, 10)
> print(x)
2 phylogenetic trees
> print(x, TRUE)
2 phylogenetic trees
tree 1 : 10 tips
tree 2 : 10 tips
> str(x)
Class "multiPhylo"
List of 2
 $ :List of 4
  ..$ edge       : int [1:18, 1:2] 11 12 13 14 14 13 12 11 15 16 ...
  ..$ tip.label  : chr [1:10] "t6" "t4" "t9" "t8" ...
  ..$ Nnode      : int 9
  ..$ edge.length: num [1:18] 0.4381 0.2448 0.0707 0.0995 0.3163 ...
  ..- attr(*, "class")= chr "phylo"
  ..- attr(*, "order")= chr "cladewise"
 $ :List of 4
  ..$ edge       : int [1:18, 1:2] 11 12 12 13 14 14 15 15 13 16 ...
  ..$ tip.label  : chr [1:10] "t7" "t6" "t8" "t10" ...
  ..$ Nnode      : int 9
  ..$ edge.length: num [1:18] 0.1433 0.2396 0.0589 0.6423 0.8763 ...
  ..- attr(*, "class")= chr "phylo"
  ..- attr(*, "order")= chr "cladewise"
> 
> 
> 
> cleanEx()
> nameEx("rDNAbin")
> ### * rDNAbin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rDNAbin
> ### Title: Random DNA Sequences
> ### Aliases: rDNAbin
> ### Keywords: datagen
> 
> ### ** Examples
> 
> rDNAbin(1:10)
10 DNA sequences in binary format stored in a list.

Mean sequence length: 5.5 
   Shortest sequence: 1 
    Longest sequence: 10 

Labels:
Ind_1
Ind_2
Ind_3
Ind_4
Ind_5
Ind_6
...

Base composition:
    a     c     g     t 
0.327 0.200 0.309 0.164 
(Total: 55 bases)
> rDNAbin(rep(10, 10))
10 DNA sequences in binary format stored in a list.

All sequences of same length: 10 

Labels:
Ind_1
Ind_2
Ind_3
Ind_4
Ind_5
Ind_6
...

Base composition:
   a    c    g    t 
0.22 0.27 0.27 0.24 
(Total: 100 bases)
> rDNAbin(nrow = 10, ncol = 10)
10 DNA sequences in binary format stored in a matrix.

All sequences of same length: 10 

Labels:
Ind_1
Ind_2
Ind_3
Ind_4
Ind_5
Ind_6
...

Base composition:
   a    c    g    t 
0.25 0.26 0.24 0.25 
(Total: 100 bases)
> 
> 
> 
> cleanEx()
> nameEx("rTraitCont")
> ### * rTraitCont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rTraitCont
> ### Title: Continuous Character Simulation
> ### Aliases: rTraitCont
> ### Keywords: datagen
> 
> ### ** Examples
> 
> data(bird.orders)
> rTraitCont(bird.orders) # BM with sigma = 0.1
Struthioniformes     Tinamiformes      Craciformes      Galliformes 
     -0.03344836       0.50348092      -0.17587240       0.23365828 
    Anseriformes    Turniciformes       Piciformes    Galbuliformes 
      0.11513135       0.13992311      -1.07193688       0.45574714 
  Bucerotiformes      Upupiformes    Trogoniformes    Coraciiformes 
      0.44038016       0.50278929      -0.85366587       0.11659451 
     Coliiformes     Cuculiformes   Psittaciformes      Apodiformes 
      0.04476930      -0.58801066       0.31679563      -0.12477230 
  Trochiliformes  Musophagiformes     Strigiformes    Columbiformes 
     -0.56878379       0.09161358      -0.05968314       0.16049077 
      Gruiformes    Ciconiiformes    Passeriformes 
      0.51184538       0.57474619       0.71902655 
> ### OU model with two optima:
> tr <- reorder(bird.orders, "postorder")
> plot(tr)
> edgelabels()
> theta <- rep(0, Nedge(tr))
> theta[c(1:4, 15:16, 23:24)] <- 2
> ## sensitive to 'alpha' and 'sigma':
> rTraitCont(tr, "OU", theta = theta, alpha=.1, sigma=.01)
Struthioniformes     Tinamiformes      Craciformes      Galliformes 
    0.0203340081    -0.0017379095    -0.0259805065     0.0066810996 
    Anseriformes    Turniciformes       Piciformes    Galbuliformes 
    0.0087156566     0.0437422970    -0.0228927012    -0.0008909879 
  Bucerotiformes      Upupiformes    Trogoniformes    Coraciiformes 
    1.7565633724     1.7358850371     0.0355681132    -0.0371214226 
     Coliiformes     Cuculiformes   Psittaciformes      Apodiformes 
    0.0488105969    -0.0152714485     1.7815824214     0.0008063659 
  Trochiliformes  Musophagiformes     Strigiformes    Columbiformes 
    0.0155455862     0.0102408620     0.0006300207     1.7682263753 
      Gruiformes    Ciconiiformes    Passeriformes 
    1.7547424722     1.7850401821     0.0385037591 
> ### an imaginary model with stasis 0.5 time unit after a node, then
> ### BM evolution with sigma = 0.1:
> foo <- function(x, l) {
+     if (l <= 0.5) return(x)
+     x + (l - 0.5)*rnorm(1, 0, 0.1)
+ }
> tr <- rcoal(20, br = runif)
> rTraitCont(tr, foo, ancestor = TRUE)
          t9           t6          t17           t5          t20          t11 
-0.680631026 -0.551397901  1.229087325 -0.705684709 -0.814870821 -0.845044255 
         t12          t18           t8           t4           t1          t16 
-0.263985478 -0.237467159 -0.638819632  0.528955451 -0.377129478 -0.007400717 
         t13          t14          t10           t7          t15           t2 
 0.207884413 -0.074922040  0.026371483  0.166080505 -0.202429383  0.775663182 
          t3          t19        Node1        Node2        Node3        Node4 
 0.459682716 -0.104812572  0.000000000  0.000000000 -0.021385395 -0.021385395 
       Node5        Node6        Node7        Node8        Node9       Node10 
-0.021385395 -0.136371196 -0.144304222 -0.193820366  0.235573449  0.154712380 
      Node11       Node12       Node13       Node14       Node15       Node16 
-0.242365023  0.102087140  0.122394787  0.207649825 -0.160588700 -0.045728221 
      Node17       Node18       Node19 
-0.070770339 -0.235823881 -0.821367731 
> ### a cumulative Poisson process:
> bar <- function(x, l) x + rpois(1, l)
> (x <- rTraitCont(tr, bar, ancestor = TRUE))
    t9     t6    t17     t5    t20    t11    t12    t18     t8     t4     t1 
    10     12      5     11     12     12     15     17     13     12      9 
   t16    t13    t14    t10     t7    t15     t2     t3    t19  Node1  Node2 
     9      9     11     12      8      7      8     14     14      0      0 
 Node3  Node4  Node5  Node6  Node7  Node8  Node9 Node10 Node11 Node12 Node13 
     1      1      1      1      1      1      3      5      7      6      5 
Node14 Node15 Node16 Node17 Node18 Node19 
     5     11      6      7     14     12 
> plot(tr, show.tip.label = FALSE)
> Y <- x[1:20]
> A <- x[-(1:20)]
> nodelabels(A)
> tiplabels(Y)
> 
> 
> 
> cleanEx()
> nameEx("rTraitDisc")
> ### * rTraitDisc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rTraitDisc
> ### Title: Discrete Character Simulation
> ### Aliases: rTraitDisc
> ### Keywords: datagen
> 
> ### ** Examples
> 
> data(bird.orders)
> ### the two followings are the same:
> rTraitDisc(bird.orders)
Struthioniformes     Tinamiformes      Craciformes      Galliformes 
               A                B                A                B 
    Anseriformes    Turniciformes       Piciformes    Galbuliformes 
               B                A                A                B 
  Bucerotiformes      Upupiformes    Trogoniformes    Coraciiformes 
               A                B                A                B 
     Coliiformes     Cuculiformes   Psittaciformes      Apodiformes 
               A                A                A                B 
  Trochiliformes  Musophagiformes     Strigiformes    Columbiformes 
               B                A                B                B 
      Gruiformes    Ciconiiformes    Passeriformes 
               A                B                B 
Levels: A B
> rTraitDisc(bird.orders, model = matrix(c(0, 0.1, 0.1, 0), 2))
Struthioniformes     Tinamiformes      Craciformes      Galliformes 
               B                B                A                A 
    Anseriformes    Turniciformes       Piciformes    Galbuliformes 
               A                A                A                A 
  Bucerotiformes      Upupiformes    Trogoniformes    Coraciiformes 
               A                B                B                A 
     Coliiformes     Cuculiformes   Psittaciformes      Apodiformes 
               B                B                A                B 
  Trochiliformes  Musophagiformes     Strigiformes    Columbiformes 
               B                B                A                A 
      Gruiformes    Ciconiiformes    Passeriformes 
               A                B                A 
Levels: A B
> 
> ### two-state model with irreversibility:
> rTraitDisc(bird.orders, model = matrix(c(0, 0, 0.1, 0), 2))
Struthioniformes     Tinamiformes      Craciformes      Galliformes 
               A                B                B                B 
    Anseriformes    Turniciformes       Piciformes    Galbuliformes 
               A                B                B                B 
  Bucerotiformes      Upupiformes    Trogoniformes    Coraciiformes 
               B                B                B                B 
     Coliiformes     Cuculiformes   Psittaciformes      Apodiformes 
               B                B                B                B 
  Trochiliformes  Musophagiformes     Strigiformes    Columbiformes 
               B                B                B                B 
      Gruiformes    Ciconiiformes    Passeriformes 
               B                B                B 
Levels: A B
> 
> ### simple two-state model:
> tr <- rcoal(n <- 40, br = runif)
> x <- rTraitDisc(tr, ancestor = TRUE)
> plot(tr, show.tip.label = FALSE)
> nodelabels(pch = 19, col = x[-(1:n)])
> tiplabels(pch = 19, col = x[1:n])
> 
> ### an imaginary model with stasis 0.5 time unit after a node, then
> ### random evolution:
> foo <- function(x, l) {
+     if (l < 0.5) return(x)
+     sample(2, size = 1)
+ }
> tr <- rcoal(20, br = runif)
> x <- rTraitDisc(tr, foo, ancestor = TRUE)
> plot(tr, show.tip.label = FALSE)
> co <- c("blue", "yellow")
> cot <- c("white", "black")
> Y <- x[1:20]
> A <- x[-(1:20)]
> nodelabels(A, bg = co[A], col = cot[A])
> tiplabels(Y, bg = co[Y], col = cot[Y])
> 
> 
> 
> cleanEx()
> nameEx("rTraitMult")
> ### * rTraitMult
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rTraitMult
> ### Title: Multivariate Character Simulation
> ### Aliases: rTraitMult
> ### Keywords: datagen
> 
> ### ** Examples
> 
> ## correlated evolution of 2 continuous traits:
> mod <- function(x, l) {
+     y1 <- rnorm(1, x[1] + 0.5*x[2], 0.1)
+     y2 <- rnorm(1, 0.5*x[1] + x[2], 0.1)
+     c(y1, y2)
+ }
> set.seed(11)
> tr <- makeNodeLabel(rcoal(20))
> x <- rTraitMult(tr, mod, 2, ancestor = TRUE)
> op <- par(mfcol = c(2, 1))
> plot(x, type = "n")
> text(x, labels = rownames(x), cex = 0.7)
> oq <- par(mar = c(0, 1, 0, 1), xpd = TRUE)
> plot(tr, font = 1, cex = 0.7)
> nodelabels(tr$node.label, cex = 0.7, adj = 1)
> par(c(op, oq))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("read.GenBank")
> ### * read.GenBank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.GenBank
> ### Title: Read DNA Sequences from GenBank via Internet
> ### Aliases: read.GenBank
> ### Keywords: IO
> 
> ### ** Examples
> 
> ## This won't work if your computer is not connected
> ## to the Internet
> 
> ## Get the 8 sequences of tanagers (Ramphocelus)
> ## as used in Paradis (1997)
> ref <- c("U15717", "U15718", "U15719", "U15720",
+          "U15721", "U15722", "U15723", "U15724")
> ## Copy/paste or type the following commands if you
> ## want to try them.
> ## Not run: 
> ##D Rampho <- read.GenBank(ref)
> ##D ## get the species names:
> ##D attr(Rampho, "species")
> ##D ## build a matrix with the species names and the accession numbers:
> ##D cbind(attr(Rampho, "species"), names(Rampho))
> ##D ## print the first sequence
> ##D ## (can be done with `Rampho$U15717' as well)
> ##D Rampho[[1]]
> ##D ## the description from each FASTA sequence:
> ##D attr(Rampho, "description")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read.caic")
> ### * read.caic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.caic
> ### Title: Read Tree File in CAIC Format
> ### Aliases: read.caic
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## The same example than in read.tree, without branch lengths.
> ## An extract from Sibley and Ahlquist (1990)
> fl <- tempfile("tree", fileext = ".tre")
> cat("AAA","Strix_aluco","AAB","Asio_otus",
+    "AB","Athene_noctua","B","Tyto_alba",
+    file = fl, sep = "\n")
> tree.owls <- read.caic(fl)
Read 8 items
> plot(tree.owls)
> tree.owls

Phylogenetic tree with 4 tips and 3 internal nodes.

Tip labels:
  Strix_aluco, Asio_otus, Athene_noctua, Tyto_alba

Rooted; no branch length.
> unlink(fl) # delete the file "ex.tre"
> 
> 
> 
> cleanEx()
> nameEx("read.dna")
> ### * read.dna
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.dna
> ### Title: Read DNA Sequences in a File
> ### Aliases: read.dna read.FASTA read.fastq
> ### Keywords: IO
> 
> ### ** Examples
> 
> ## 1. Simple text files
> 
> TEXTfile <- tempfile("exdna", fileext = ".txt")
> 
> ## 1a. Extract from data(woodmouse) in sequential format:
> cat("3 40",
+ "No305     NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
+ "No304     ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
+ "No306     ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
+ file = TEXTfile, sep = "\n")
> ex.dna <- read.dna(TEXTfile, format = "sequential")
> str(ex.dna)
 'DNAbin' raw [1:3, 1:40] n a a t ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:3] "No305" "No304" "No306"
  ..$ : NULL
> ex.dna
3 DNA sequences in binary format stored in a matrix.

All sequences of same length: 40 

Labels:
No305
No304
No306

Base composition:
    a     c     g     t 
0.458 0.288 0.034 0.220 
(Total: 120 bases)
> 
> ## 1b. The same data in interleaved format, ...
> cat("3 40",
+ "No305     NTTCGAAAAA CACACCCACT",
+ "No304     ATTCGAAAAA CACACCCACT",
+ "No306     ATTCGAAAAA CACACCCACT",
+ "          ACTAAAANTT ATCAGTCACT",
+ "          ACTAAAAATT ATCAACCACT",
+ "          ACTAAAAATT ATCAATCACT",
+ file = TEXTfile, sep = "\n")
> ex.dna2 <- read.dna(TEXTfile)
> 
> ## 1c. ... in clustal format, ...
> cat("CLUSTAL (ape) multiple sequence alignment", "",
+ "No305     NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
+ "No304     ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
+ "No306     ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
+ "           ************************** ******  ****",
+ file = TEXTfile, sep = "\n")
> ex.dna3 <- read.dna(TEXTfile, format = "clustal")
> 
> ## 1d. ... and in FASTA format
> FASTAfile <- tempfile("exdna", fileext = ".fas")
> cat(">No305",
+ "NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
+ ">No304",
+ "ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
+ ">No306",
+ "ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
+ file = FASTAfile, sep = "\n")
> ex.dna4 <- read.dna(FASTAfile, format = "fasta")
> 
> ## The 4 data objects are the same:
> identical(ex.dna, ex.dna2)
[1] TRUE
> identical(ex.dna, ex.dna3)
[1] TRUE
> identical(ex.dna, ex.dna4)
[1] TRUE
> 
> ## 2. How to read GZ compressed files
> 
> ## create a GZ file and open a connection:
> GZfile <- tempfile("exdna", fileext = ".fas.gz")
> con <- gzfile(GZfile, "wt")
> ## write the data using the connection:
> cat(">No305", "NTTCGAAAAACACACCCACTACTAAAANTTATCAGTCACT",
+     ">No304", "ATTCGAAAAACACACCCACTACTAAAAATTATCAACCACT",
+     ">No306", "ATTCGAAAAACACACCCACTACTAAAAATTATCAATCACT",
+     file = con, sep = "\n")
> close(con) # close the connection
> 
> ## read the GZ'ed file:
> ex.dna5 <- read.dna(gzfile(GZfile), "fasta")
> 
> ## This example is with a FASTA file but this works as well
> ## with the other formats described above.
> 
> ## All 5 data objects are identical:
> identical(ex.dna, ex.dna5)
[1] TRUE
> 
> unlink(c(TEXTfile, FASTAfile, GZfile)) # clean-up
> 
> ## Not run: 
> ##D ## 3. How to read files from a ZIP archive
> ##D 
> ##D ## NOTE: since ape 5.7-1, all files in these examples are written
> ##D ## in the temporary directory, thus the following commands work
> ##D ## best when run in the user's working directory.
> ##D 
> ##D ## write the woodmouse data in a FASTA file:
> ##D data(woodmouse)
> ##D write.dna(woodmouse, "woodmouse.fas", "fasta")
> ##D ## archive a FASTA file in a ZIP file:
> ##D zip("myarchive.zip", "woodmouse.fas")
> ##D ## Note: the file myarchive.zip is created if necessary
> ##D 
> ##D ## Read the FASTA file from the ZIP archive without extraction:
> ##D wood2 <- read.dna(unz("myarchive.zip", "woodmouse.fas"), "fasta")
> ##D 
> ##D ## Alternatively, unzip the archive:
> ##D fl <- unzip("myarchive.zip")
> ##D ## the previous command eventually creates locally
> ##D ## the fullpath archived with 'woodmouse.fas'
> ##D wood3 <- read.dna(fl, "fasta")
> ##D 
> ##D identical(woodmouse, wood2)
> ##D identical(woodmouse, wood3)
> ## End(Not run)
> 
> ## read a FASTQ file from 1000 Genomes:
> ## Not run: 
> ##D a <- "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/HG00096/sequence_read/"
> ##D file <- "SRR062641.filt.fastq.gz"
> ##D URL <- paste0(a, file)
> ##D download.file(URL, file)
> ##D ## If the above command doesn't work, you may copy/paste URL in
> ##D ## a Web browser instead.
> ##D X <- read.fastq(file)
> ##D X # 109,811 sequences
> ##D ## get the qualities of the first sequence:
> ##D (qual1 <- attr(X, "QUAL")[[1]])
> ##D ## the corresponding probabilities:
> ##D 10^(-qual1/10)
> ##D ## get the mean quality for each sequence:
> ##D mean.qual <- sapply(attr(X, "Q"), mean)
> ##D ## can do the same for var, sd, ...
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("read.gff")
> ### * read.gff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.gff
> ### Title: Read GFF Files
> ### Aliases: read.gff
> ### Keywords: IO
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## requires to be connected on Internet
> ##D d <- "https://ftp.ensembl.org/pub/release-86/gff3/homo_sapiens/"
> ##D f <- "Homo_sapiens.GRCh38.86.chromosome.MT.gff3.gz"
> ##D download.file(paste0(d, f), "mt_gff3.gz")
> ##D ## If the above command doesn't work, you may copy/paste the full URL in
> ##D ## a Web browser instead.
> ##D gff.mito <- read.gff("mt_gff3.gz")
> ##D ## the lengths of the sequence features:
> ##D gff.mito$end - (gff.mito$start - 1)
> ##D table(gff.mito$type)
> ##D ## where the exons start:
> ##D gff.mito$start[gff.mito$type == "exon"]
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read.nexus.data")
> ### * read.nexus.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.nexus.data
> ### Title: Read Character Data In NEXUS Format
> ### Aliases: read.nexus.data nexus2DNAbin
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Use read.nexus.data to read a file in NEXUS format into object x
> ## Not run: x <- read.nexus.data("file.nex")
> 
> 
> 
> cleanEx()
> nameEx("read.tree")
> ### * read.tree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.tree
> ### Title: Read Tree File in Parenthetic Format
> ### Aliases: read.tree phylo
> ### Keywords: manip IO
> 
> ### ** Examples
> 
> ### An extract from Sibley and Ahlquist (1990)
> s <- "owls(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
> treefile <- tempfile("tree", fileext = ".tre")
> cat(s, file = treefile, sep = "\n")
> tree.owls <- read.tree(treefile)
> str(tree.owls)
List of 4
 $ edge       : int [1:6, 1:2] 5 6 7 7 6 5 6 7 1 2 ...
 $ edge.length: num [1:6] 6.3 3.1 4.2 4.2 7.3 13.5
 $ Nnode      : int 3
 $ tip.label  : chr [1:4] "Strix_aluco" "Asio_otus" "Athene_noctua" "Tyto_alba"
 - attr(*, "class")= chr "phylo"
 - attr(*, "order")= chr "cladewise"
> tree.owls

Phylogenetic tree with 4 tips and 3 internal nodes.

Tip labels:
  Strix_aluco, Asio_otus, Athene_noctua, Tyto_alba

Rooted; includes branch length(s).
> tree.owls <- read.tree(treefile, keep.multi = TRUE)
> tree.owls
1 phylogenetic tree
> names(tree.owls)
[1] "owls"
> unlink(treefile) # clean-up
> ### Only the first three species using the option `text'
> TREE <- "((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);"
> TREE
[1] "((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);"
> tree.owls.bis <- read.tree(text = TREE)
> str(tree.owls.bis)
List of 4
 $ edge       : int [1:4, 1:2] 4 5 5 4 5 1 2 3
 $ edge.length: num [1:4] 3.1 4.2 4.2 7.3
 $ Nnode      : int 2
 $ tip.label  : chr [1:3] "Strix_aluco" "Asio_otus" "Athene_noctua"
 - attr(*, "class")= chr "phylo"
 - attr(*, "order")= chr "cladewise"
> tree.owls.bis

Phylogenetic tree with 3 tips and 2 internal nodes.

Tip labels:
  Strix_aluco, Asio_otus, Athene_noctua

Rooted; includes branch length(s).
> 
> ## tree with singleton nodes:
> ts <- read.tree(text = "((((a))),d);")
> plot(ts, node.depth = 2) # the default will overlap the singleton node with the tip
> nodelabels()
> 
> ## 'skeleton' tree with a singleton node:
> tx <- read.tree(text = "(((,)),);")
> plot(tx, node.depth = 2)
> nodelabels()
> 
> ## a tree with single quoted labels (the 2nd label is not quoted
> ## because it has no white spaces):
> z <- "(('a: France, Spain (Europe)',b),'c: Australia [Outgroup]');"
> tz <- read.tree(text = z)
> plot(tz, font = 1)
> 
> 
> 
> cleanEx()
> nameEx("reconstruct")
> ### * reconstruct
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reconstruct
> ### Title: Continuous Ancestral Character Estimation
> ### Aliases: reconstruct
> ### Keywords: models
> 
> ### ** Examples
> 
> ### Some random data...
> data(bird.orders)
> x <- rnorm(23, m=100)
> ### Reconstruct ancestral quantitative characters:
> reconstruct(x, bird.orders)
$ace
      24       25       26       27       28       29       30       31 
100.1449 100.1378 100.0396 100.1995 100.2189 100.1482 100.1757 100.2113 
      32       33       34       35       36       37       38       39 
100.2483 100.2899 100.2590 100.3595 100.1942 100.1934 100.2537 100.2914 
      40       41       42       43       44       45 
100.3033 100.2855 100.3776 100.3302 100.3741 100.4051 

$CI95
      lower    upper
24 99.70171 100.5880
25 99.67239 100.6032
26 99.47865 100.6006
27 99.68945 100.7096
28 99.68477 100.7530
29 99.73520 100.5613
30 99.78234 100.5691
31 99.86019 100.5624
32 99.87796 100.6187
33 99.88947 100.6904
34 99.76657 100.7514
35 99.90498 100.8140
36 99.84178 100.5466
37 99.84076 100.5460
38 99.90278 100.6047
39 99.94241 100.6405
40 99.93407 100.6726
41 99.88504 100.6860
42 99.93992 100.8153
43 99.95131 100.7091
44 99.96884 100.7794
45 99.97207 100.8382

> reconstruct(x, bird.orders, method = "GLS_OUS", alpha=NULL)
$ace
      24       25       26       27       28       29       30       31 
100.2429 100.2429 100.2427 100.2429 100.2429 100.2429 100.2429 100.2429 
      32       33       34       35       36       37       38       39 
100.2430 100.2430 100.2429 100.2431 100.2429 100.2429 100.2431 100.2431 
      40       41       42       43       44       45 
100.2431 100.2430 100.2433 100.2432 100.2434 100.2434 

$CI95
       lower    upper
24 100.24288 100.2429
25  98.62244 101.8633
26  98.44423 102.0411
27  98.45429 102.0315
28  98.44344 102.0424
29  98.91445 101.5713
30  98.69578 101.7900
31  98.52665 101.9592
32  98.49277 101.9932
33  98.46257 102.0235
34  98.44051 102.0452
35  98.44657 102.0397
36  98.49729 101.9886
37  98.46920 102.0167
38  98.45733 102.0288
39  98.44994 102.0364
40  98.44528 102.0410
41  98.44225 102.0438
42  98.44009 102.0466
43  98.44373 102.0427
44  98.44099 102.0457
45  98.43969 102.0472

> 
> 
> 
> cleanEx()
> nameEx("reorder.phylo")
> ### * reorder.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reorder.phylo
> ### Title: Internal Reordering of Trees
> ### Aliases: reorder.phylo reorder.multiPhylo cladewise postorder
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.families)
> tr <- reorder(bird.families, "postorder")
> all.equal(bird.families, tr) # uses all.equal.phylo actually
[1] TRUE
> all.equal.list(bird.families, tr) # bypasses the generic
[1] "Attributes: < Length mismatch: comparison on first 1 components >"
[2] "Component “edge”: Mean relative difference: 0.5084907"            
[3] "Component “edge.length”: Mean relative difference: 1.026202"      
> 
> ## get the number of descendants for each tip or node:
> nr_desc <-  function(x) {
+     res <- numeric(max(x$edge))
+     res[1:Ntip(x)] <- 1L
+     for (i in postorder(x)) {
+        tmp <- x$edge[i,1]
+        res[tmp] <- res[tmp] + res[x$edge[i, 2]]
+    }
+    res
+ }
> ## apply it to a random tree:
> tree <- rtree(10)
> plot(tree, show.tip.label = FALSE)
> tiplabels()
> nodelabels()
> nr_desc(tree)
 [1]  1  1  1  1  1  1  1  1  1  1 10  9  4  3  2  5  2  3  2
> 
> 
> 
> cleanEx()
> nameEx("richness.yule.test")
> ### * richness.yule.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: richness.yule.test
> ### Title: Test of Diversification-Shift With the Yule Process
> ### Aliases: richness.yule.test
> ### Keywords: htest
> 
> ### ** Examples
> 
> ### see example(mcconwaysims.test)
> 
> 
> 
> cleanEx()
> nameEx("rlineage")
> ### * rlineage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rlineage
> ### Title: Tree Simulation Under the Time-Dependent Birth-Death Models
> ### Aliases: rlineage rbdtree rphylo drop.fossil
> ### Keywords: datagen
> 
> ### ** Examples
> 
> set.seed(10)
> plot(rlineage(0.1, 0)) # Yule process with lambda = 0.1
> plot(rlineage(0.1, 0.05)) # simple birth-death process
> b <- function(t) 1/(1 + exp(0.2*t - 1)) # logistic
> layout(matrix(0:3, 2, byrow = TRUE))
> curve(b, 0, 50, xlab = "Time", ylab = "")
> mu <- 0.07
> segments(0, mu, 50, mu, lty = 2)
> legend("topright", c(expression(lambda), expression(mu)),
+        lty = 1:2, bty = "n")
> plot(rlineage(b, mu), show.tip.label = FALSE)
> title("Simulated with 'rlineage'")
> plot(rbdtree(b, mu), show.tip.label = FALSE)
> title("Simulated with 'rbdtree'")
> 
> 
> 
> cleanEx()
> nameEx("root")
> ### * root
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: root
> ### Title: Roots Phylogenetic Trees
> ### Aliases: root root.phylo root.multiPhylo unroot unroot.phylo
> ###   unroot.multiPhylo is.rooted is.rooted.phylo is.rooted.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.orders)
> plot(root(bird.orders, 1))
> plot(root(bird.orders, 1:5))
> 
> tr <- root(bird.orders, 1)
> is.rooted(bird.orders) # yes
[1] TRUE
> is.rooted(tr)          # no
[1] FALSE
> ### This is because the tree has been unrooted first before rerooting.
> ### You can delete the outgroup...
> is.rooted(drop.tip(tr, "Struthioniformes"))
[1] TRUE
> ### ... or resolve the basal trichotomy in two ways:
> is.rooted(multi2di(tr))
[1] TRUE
> is.rooted(root(bird.orders, 1, r = TRUE))
[1] TRUE
> ### To keep the basal trichotomy but forcing the tree as rooted:
> tr$root.edge <- 0
> is.rooted(tr)
[1] TRUE
> 
> x <- setNames(rmtree(10, 10), LETTERS[1:10])
> is.rooted(x)
   A    B    C    D    E    F    G    H    I    J 
TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 
> 
> 
> 
> cleanEx()
> nameEx("rotate")
> ### * rotate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rotate
> ### Title: Swapping Sister Clades
> ### Aliases: rotate rotateConstr
> ### Keywords: manip
> 
> ### ** Examples
> 
> # create a random tree:
> tre <- rtree(25)
> 
> # visualize labels of internal nodes:
> plot(tre, use.edge.length=FALSE)
> nodelabels()
> 
> # rotate clades around node 30:
> tre.new <- rotate(tre, 30)
> 
> # compare the results:
> par(mfrow=c(1,2)) # split graphical device
> plot(tre) # plot old tre
> plot(tre.new) # plot new tree
> 
> # visualize labels of terminal nodes:
> plot(tre)
> tiplabels()
> 
> # rotate clades containing nodes 12 and 20:
> tre.new <- rotate(tre, c(12, 21))
> 
> # compare the results:
> par(mfrow=c(1,2)) # split graphical device
> plot(tre) # plot old tre
> plot(tre.new) # plot new tree
> 
> # or you migth just specify tiplabel names:
> tre.new <- rotate(tre, c("t3", "t14"))
> 
> # compare the results:
> par(mfrow=c(1,2)) # devide graphical device
> plot(tre) # plot old tre
> plot(tre.new) # plot new tree
> 
> # a simple example for rotateConstr:
> A <- read.tree(text = "((A,B),(C,D));")
> B <- read.tree(text = "(((D,C),B),A);")
> B <- rotateConstr(B, A$tip.label)
> plot(A); plot(B, d = "l")
> 
> # something more interesting (from ?cophyloplot):
> tr1 <- rtree(40)
> ## drop 20 randomly chosen tips:
> tr2 <- drop.tip(tr1, sample(tr1$tip.label, size = 20))
> ## rotate the root and reorder the whole:
> tr2 <- rotate(tr2, 21)
> tr2 <- read.tree(text = write.tree(tr2))
> X <- cbind(tr2$tip.label, tr2$tip.label) # association matrix
> cophyloplot(tr1, tr2, assoc = X, space = 28)
> ## before reordering tr2 we have to find the constraint:
> co <- tr2$tip.label[order(match(tr2$tip.label, tr1$tip.label))]
> newtr2 <- rotateConstr(tr2, co)
> cophyloplot(tr1, newtr2, assoc = X, space = 28)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("rtree")
> ### * rtree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rtree
> ### Title: Generate Random Trees
> ### Aliases: rtree rcoal rmtree rtopology rmtopology
> ### Keywords: datagen
> 
> ### ** Examples
> 
> layout(matrix(1:9, 3, 3))
> ### Nine random trees:
> for (i in 1:9) plot(rtree(20))
> ### Nine random cladograms:
> for (i in 1:9) plot(rtree(20, FALSE), type = "c")
> ### generate 4 random trees of bird orders:
> data(bird.orders)
> layout(matrix(1:4, 2, 2))
> for (i in 1:4)
+   plot(rcoal(23, tip.label = bird.orders$tip.label), no.margin = TRUE)
> layout(1)
> par(mar = c(5, 4, 4, 2))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("rtt")
> ### * rtt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rtt
> ### Title: Root a Tree by Root-to-Tip Regression
> ### Aliases: rtt
> 
> ### ** Examples
> 
> t <- rtree(100)
> tip.date <- rnorm(t$tip.label)^2
> rtt(t, tip.date)

Phylogenetic tree with 100 tips and 99 internal nodes.

Tip labels:
  t89, t48, t100, t23, t84, t29, ...

Rooted; includes branch length(s).
> 
> 
> 
> cleanEx()
> nameEx("seg.sites")
> ### * seg.sites
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: seg.sites
> ### Title: Find Segregating Sites in DNA Sequences
> ### Aliases: seg.sites
> ### Keywords: univar
> 
> ### ** Examples
> 
> data(woodmouse)
> y <- seg.sites(woodmouse)
> y
 [1]  30  33  35  36  42  51  54  60  72  96 106 123 201 213 234 237 279 291 297
[20] 306 314 316 318 340 342 343 349 365 409 417 438 456 462 477 510 514 534 540
[39] 546 576 591 672 675 684 697 715 738 810 837 876 909 920 957 959 960 963
> length(y)
[1] 56
> 
> 
> 
> cleanEx()
> nameEx("skyline")
> ### * skyline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: skyline
> ### Title: Skyline Plot Estimate of Effective Population Size
> ### Aliases: skyline skyline.phylo skyline.coalescentIntervals
> ###   skyline.collapsedIntervals find.skyline.epsilon
> ### Keywords: manip
> 
> ### ** Examples
> 
> # get tree
> data("hivtree.newick") # example tree in NH format
> tree.hiv <- read.tree(text = hivtree.newick) # load tree
> 
> # corresponding coalescent intervals
> ci <- coalescent.intervals(tree.hiv) # from tree
> 
> # collapsed intervals
> cl1 <- collapsed.intervals(ci,0)
> cl2 <- collapsed.intervals(ci,0.0119)
> 
> #### classic skyline plot ####
> sk1 <- skyline(cl1)        # from collapsed intervals 
> sk1 <- skyline(ci)         # from coalescent intervals
> sk1 <- skyline(tree.hiv)   # from tree
> sk1
$time
  [1] 0.021161 0.049822 0.050058 0.054444 0.057580 0.057620 0.058582 0.059336
  [9] 0.059726 0.061847 0.063012 0.065150 0.065542 0.067767 0.068246 0.068285
 [17] 0.069341 0.069631 0.069725 0.070130 0.070506 0.071398 0.077168 0.077774
 [25] 0.078085 0.078439 0.078488 0.079791 0.079902 0.080093 0.080206 0.080907
 [33] 0.080919 0.080923 0.081266 0.081732 0.082433 0.082434 0.082720 0.083124
 [41] 0.083172 0.083436 0.083818 0.084541 0.084566 0.084629 0.085711 0.086004
 [49] 0.087462 0.087519 0.087787 0.088609 0.088644 0.088785 0.088823 0.089216
 [57] 0.089479 0.089540 0.090237 0.090248 0.090579 0.090777 0.091414 0.091575
 [65] 0.092297 0.092865 0.092881 0.093773 0.094006 0.094130 0.094174 0.094384
 [73] 0.094521 0.094683 0.094749 0.095068 0.095107 0.095333 0.095334 0.095369
 [81] 0.096163 0.096270 0.096432 0.096562 0.097150 0.097278 0.097341 0.097342
 [89] 0.099386 0.099467 0.099582 0.099726 0.099948 0.101084 0.101878 0.101892
 [97] 0.101961 0.101962 0.102399 0.102590 0.103060 0.103714 0.103878 0.103926
[105] 0.104386 0.104484 0.104691 0.105017 0.105018 0.105020 0.105181 0.106054
[113] 0.106195 0.107063 0.107287 0.107629 0.108329 0.108551 0.108702 0.109333
[121] 0.109996 0.111546 0.111869 0.112580 0.112666 0.113317 0.113663 0.113664
[129] 0.113731 0.113986 0.114132 0.114392 0.114561 0.114632 0.114774 0.116003
[137] 0.116109 0.117194 0.117310 0.117514 0.117728 0.118538 0.118650 0.118782
[145] 0.118990 0.119083 0.120265 0.120408 0.120491 0.120494 0.122054 0.122422
[153] 0.122572 0.123109 0.124283 0.125240 0.127902 0.127903 0.127904 0.127999
[161] 0.129007 0.130366 0.130367 0.130470 0.131217 0.131462 0.132291 0.135095
[169] 0.135794 0.135795 0.135914 0.140307 0.143055 0.144389 0.146425 0.148331
[177] 0.150189 0.151362 0.155704 0.164770 0.166301 0.166846 0.176701 0.178108
[185] 0.179167 0.181334 0.192334 0.196999 0.197000 0.204899 0.204900 0.209112

$interval.length
  [1] 0.021161 0.028661 0.000236 0.004386 0.003136 0.000040 0.000962 0.000754
  [9] 0.000390 0.002121 0.001165 0.002138 0.000392 0.002225 0.000479 0.000039
 [17] 0.001056 0.000290 0.000094 0.000405 0.000376 0.000892 0.005770 0.000606
 [25] 0.000311 0.000354 0.000049 0.001303 0.000111 0.000191 0.000113 0.000701
 [33] 0.000012 0.000004 0.000343 0.000466 0.000701 0.000001 0.000286 0.000404
 [41] 0.000048 0.000264 0.000382 0.000723 0.000025 0.000063 0.001082 0.000293
 [49] 0.001458 0.000057 0.000268 0.000822 0.000035 0.000141 0.000038 0.000393
 [57] 0.000263 0.000061 0.000697 0.000011 0.000331 0.000198 0.000637 0.000161
 [65] 0.000722 0.000568 0.000016 0.000892 0.000233 0.000124 0.000044 0.000210
 [73] 0.000137 0.000162 0.000066 0.000319 0.000039 0.000226 0.000001 0.000035
 [81] 0.000794 0.000107 0.000162 0.000130 0.000588 0.000128 0.000063 0.000001
 [89] 0.002044 0.000081 0.000115 0.000144 0.000222 0.001136 0.000794 0.000014
 [97] 0.000069 0.000001 0.000437 0.000191 0.000470 0.000654 0.000164 0.000048
[105] 0.000460 0.000098 0.000207 0.000326 0.000001 0.000002 0.000161 0.000873
[113] 0.000141 0.000868 0.000224 0.000342 0.000700 0.000222 0.000151 0.000631
[121] 0.000663 0.001550 0.000323 0.000711 0.000086 0.000651 0.000346 0.000001
[129] 0.000067 0.000255 0.000146 0.000260 0.000169 0.000071 0.000142 0.001229
[137] 0.000106 0.001085 0.000116 0.000204 0.000214 0.000810 0.000112 0.000132
[145] 0.000208 0.000093 0.001182 0.000143 0.000083 0.000003 0.001560 0.000368
[153] 0.000150 0.000537 0.001174 0.000957 0.002662 0.000001 0.000001 0.000095
[161] 0.001008 0.001359 0.000001 0.000103 0.000747 0.000245 0.000829 0.002804
[169] 0.000699 0.000001 0.000119 0.004393 0.002748 0.001334 0.002036 0.001906
[177] 0.001858 0.001173 0.004342 0.009066 0.001531 0.000545 0.009855 0.001407
[185] 0.001059 0.002167 0.011000 0.004665 0.000001 0.007899 0.000001 0.004212

$population.size
  [1] 392.071008 525.528096   4.282220  78.750630  55.714176   0.703120
  [7]  16.730142  12.972570   6.637800  35.709156  19.400745  35.214998
 [13]   6.385680  35.844750   7.630949   0.614367  16.448256   4.466000
 [19]   1.431150   6.095655   5.594128  13.117752  83.866950   8.705190
 [25]   4.414956   4.965912   0.679189  17.844585   1.501830   2.552906
 [31]   1.491939   9.141741   0.154560   0.050880   4.308423   5.779798
 [37]   8.584446   0.012090   3.413410   4.759524   0.558144   3.029664
 [43]   4.326150   8.079525   0.275650   0.685314  11.610942   3.101405
 [49]  15.221520   0.586872   2.721004   8.229042   0.345450   1.371930
 [55]   0.364458   3.715029   2.450108   0.559980   6.304365   0.098021
 [61]   2.905518   1.711908   5.424055   1.349985   5.960832   4.616704
 [67]   0.128016   7.024500   1.805750   0.945624   0.330132   1.550010
 [73]   0.994620   1.156680   0.463386   2.202057   0.264654   1.507420
 [79]   0.006555   0.225435   5.024432   0.665112   0.989010   0.779350
 [85]   3.460968   0.739584   0.357273   0.005565  11.160240   0.433836
 [91]   0.604095   0.741744   1.121100   5.623200   3.851694   0.066542
 [97]   0.321264   0.004560   1.951205   0.834861   2.010660   2.737644
[103]   0.671580   0.192240   1.801360   0.375144   0.774387   1.191530
[109]   0.003570   0.006972   0.547883   2.899233   0.456840   2.742880
[115]   0.690144   1.027026   2.048200   0.632700   0.419025   1.704331
[121]   1.742364   3.961800   0.802655   1.717065   0.201756   1.482978
[127]   0.765006   0.002145   0.139360   0.514080   0.285138   0.491660
[133]   0.309270   0.125670   0.242962   2.031537   0.169176   1.670900
[139]   0.172260   0.291924   0.294892   1.074060   0.142800   0.161700
[145]   0.244608   0.104904   1.277742   0.148005   0.082170   0.002838
[151]   1.408680   0.316848   0.123000   0.418860   0.869934   0.672771
[157]   1.772892   0.000630   0.000595   0.053295   0.532224   0.674064
[163]   0.000465   0.044805   0.303282   0.092610   0.290979   0.911300
[169]   0.209700   0.000276   0.030107   1.014783   0.577080   0.253460
[175]   0.348156   0.291618   0.252688   0.140760   0.455910   0.825006
[181]   0.119418   0.035970   0.542025   0.063315   0.038124   0.060676
[187]   0.231000   0.069975   0.000010   0.047394   0.000003   0.004212

$parameter.count
[1] 192

$epsilon
[1] 0

$logL
[1] 1408.966

$logL.AICc
[1] NA

attr(,"class")
[1] "skyline"
> 
> plot(skyline(tree.hiv))
> skylineplot(tree.hiv) # shortcut
> 
> plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997)
> 
> #### generalized skyline plot ####
> 
> sk2 <- skyline(cl2)              # from collapsed intervals
> sk2 <- skyline(ci, 0.0119)       # from coalescent intervals
> sk2 <- skyline(tree.hiv, 0.0119) # from tree
> sk2
$time
 [1] 0.021161 0.049822 0.061847 0.077168 0.089216 0.101878 0.113986 0.127902
 [9] 0.140307 0.155704 0.176701 0.192334 0.209112

$interval.length
 [1] 0.021161 0.028661 0.012025 0.015321 0.012048 0.012662 0.012108 0.013916
 [9] 0.012405 0.015397 0.020997 0.015633 0.016778

$population.size
 [1] 392.07100800 525.52809600  26.43747675  18.16241385   4.32071145
 [6]   2.19342354   1.06974257   0.55211856   0.27727433   0.33138171
[11]   0.38060475   0.09827875   0.02431880

$parameter.count
[1] 13

$epsilon
[1] 0.0119

$logL
[1] 1239.478

$logL.AICc
[1] 1225.456

attr(,"class")
[1] "skyline"
> 
> plot(sk2)
> 
> # classic and generalized skyline plot together in one plot
> plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997, col=c(grey(.8),1))
> lines(sk2,  show.years=TRUE, subst.rate=0.0023, present.year = 1997)
> legend(.15,500, c("classic", "generalized"), col=c(grey(.8),1),lty=1)
> 
> 
> # find optimal epsilon parameter using AICc criterion
> find.skyline.epsilon(ci)
Searching for the optimal epsilon... epsilon = 0.01191938 
[1] 0.01191938
> 
> sk3 <- skyline(ci, -1) # negative epsilon also triggers estimation of epsilon
Searching for the optimal epsilon... epsilon = 0.01191938 
> sk3$epsilon
[1] 0.01191938
> 
> 
> 
> cleanEx()
> nameEx("skylineplot")
> ### * skylineplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: skylineplot
> ### Title: Drawing Skyline Plot Graphs
> ### Aliases: skylineplot plot.skyline lines.skyline skylineplot.deluxe
> ### Keywords: hplot
> 
> ### ** Examples
> 
> # get tree
> data("hivtree.newick") # example tree in NH format
> tree.hiv <- read.tree(text = hivtree.newick) # load tree
> 
> #### classic skyline plot
> skylineplot(tree.hiv) # shortcut
> 
> #### plot classic and generalized skyline plots and estimate epsilon
> sk.opt <- skylineplot.deluxe(tree.hiv)
Searching for the optimal epsilon... epsilon = 0.01191938 
> sk.opt$epsilon
[1] 0.01191938
> 
> #### classic and generalized skyline plot ####
> sk1 <- skyline(tree.hiv)
> sk2 <- skyline(tree.hiv, 0.0119)
> 
> # use years rather than substitutions as unit for the time axis
> plot(sk1, show.years=TRUE, subst.rate=0.0023, present.year = 1997, col=c(grey(.8),1))
> lines(sk2,  show.years=TRUE, subst.rate=0.0023, present.year = 1997)
> legend(.15,500, c("classic", "generalized"), col=c(grey(.8),1),lty=1)
> 
> #### various skyline plots for different epsilons
> layout(mat= matrix(1:6,2,3,byrow=TRUE))
> ci <- coalescent.intervals(tree.hiv)
> plot(skyline(ci, 0.0));title(main="0.0")
> plot(skyline(ci, 0.007));title(main="0.007")
> plot(skyline(ci, 0.0119),col=4);title(main="0.0119")
> plot(skyline(ci, 0.02));title(main="0.02")
> plot(skyline(ci, 0.05));title(main="0.05")
> plot(skyline(ci, 0.1));title(main="0.1")
> layout(mat= matrix(1:1,1,1,byrow=TRUE))
> 
> 
> 
> cleanEx()
> nameEx("slowinskiguyer.test")
> ### * slowinskiguyer.test
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: slowinskiguyer.test
> ### Title: Slowinski-Guyer Test of Homogeneous Diversification
> ### Aliases: slowinskiguyer.test
> ### Keywords: htest
> 
> ### ** Examples
> 
> ### from Table 1 in Slowinski and Guyer(1993):
> viviparous <- c(98, 8, 193, 36, 7, 128, 2, 3, 23, 70)
> oviparous <- c(234, 17, 100, 4, 1, 12, 6, 1, 481, 11)
> x <- data.frame(viviparous, oviparous)
> slowinskiguyer.test(x, TRUE) # 'P ~ 0.32' in the paper
[[1]]
    chisq df     P.val
 23.43517 20 0.2679353

$individual_Pvalues
 [1] 0.70694864 0.70833333 0.34246575 0.10256410 0.14285714 0.08633094
 [7] 0.85714286 0.33333333 0.95626243 0.13750000

> xalt <- x
> xalt[3, 2] <- 1
> slowinskiguyer.test(xalt)
    chisq df      P.val
 31.81738 20 0.04528352
> 
> 
> 
> cleanEx()
> nameEx("solveAmbiguousBases")
> ### * solveAmbiguousBases
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: solveAmbiguousBases
> ### Title: Solve Ambiguous Bases in DNA Sequences
> ### Aliases: solveAmbiguousBases
> ### Keywords: manip
> 
> ### ** Examples
> 
> X <- as.DNAbin(matrix(c("A", "G", "G", "R"), ncol = 1))
> alview(solveAmbiguousBases(X)) # R replaced by either A or G
 1
 A
 G
 G
 G
> alview(solveAmbiguousBases(X, random = FALSE)) # R always replaced by G
 1
 A
 G
 G
 G
> 
> 
> 
> cleanEx()
> nameEx("speciesTree")
> ### * speciesTree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: speciesTree
> ### Title: Species Tree Estimation
> ### Aliases: speciesTree
> ### Keywords: models
> 
> ### ** Examples
> 
> ### example in Liu et al. (2010):
> tr1 <- read.tree(text = "(((B:0.05,C:0.05):0.01,D:0.06):0.04,A:0.1);")
> tr2 <- read.tree(text = "(((A:0.07,C:0.07):0.02,D:0.09):0.03,B:0.12);")
> TR <- c(tr1, tr2)
> TSmax <- speciesTree(TR) # MAXTREE
> TSsha <- speciesTree(TR, mean) # shallowest divergence
> 
> kronoviz(c(tr1, tr2, TSmax, TSsha), horiz = FALSE,
+          type = "c", cex = 1.5, font = 1)
> mtext(c("Gene tree 1", "Gene tree 2", "Species tree - MAXTREE"),
+       at = -c(7.5, 4, 1))
> mtext("Species tree - Shallowest Divergence")
> layout(1)
> 
> 
> 
> cleanEx()
> nameEx("stree")
> ### * stree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stree
> ### Title: Generates Systematic Regular Trees
> ### Aliases: stree
> ### Keywords: datagen
> 
> ### ** Examples
> 
> layout(matrix(1:4, 2, 2))
> plot(stree(100))
> plot(stree(128, "balanced"))
> plot(stree(100, "left"))
> plot(stree(100, "right"))
> 
> 
> 
> cleanEx()
> nameEx("subtreeplot")
> ### * subtreeplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subtreeplot
> ### Title: Zoom on a Portion of a Phylogeny by Successive Clicks
> ### Aliases: subtreeplot
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #example 1: simple
> ##D tree1 <- rtree(50)
> ##D tree2 <- subtreeplot(tree1, wait = TRUE) # on exit, tree2 will be a subtree of tree1
> ##D 
> ##D #example 2: more than one zoom
> ##D tree1 <- rtree(60)
> ##D tree2 <- subtreeplot(subtreeplot(subtreeplot(tree1))) # allow three succssive zooms
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("subtrees")
> ### * subtrees
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subtrees
> ### Title: All subtrees of a Phylogenetic Tree
> ### Aliases: subtrees
> ### Keywords: manip
> 
> ### ** Examples
> 
> ### Random tree with 12 leaves
> phy<-rtree(12)
> par(mfrow=c(4,3))
> plot(phy, sub="Complete tree")
> 
> ### Extract the subtrees
> l<-subtrees(phy)
> 
> ### plot all the subtrees
> for (i in 1:11) plot(l[[i]], sub=paste("Node", l[[i]]$node.label[1]))
> par(mfrow=c(1,1))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("summary.phylo")
> ### * summary.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.phylo
> ### Title: Print Summary of a Phylogeny
> ### Aliases: summary.phylo Ntip Ntip.phylo Ntip.multiPhylo Nnode
> ###   Nnode.phylo Nnode.multiPhylo Nedge Nedge.phylo Nedge.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(bird.families)
> summary(bird.families)

Phylogenetic tree: bird.families 

  Number of tips: 137 
  Number of nodes: 135 
  Branch lengths:
    mean: 7.413653 
    variance: 38.49237 
    distribution summary:
   Min. 1st Qu.  Median 3rd Qu.    Max. 
   0.10    1.15    9.10   11.50   27.00 
  No root edge.
  First ten tip labels: Struthionidae 
                        Rheidae
                        Casuariidae
                        Apterygidae
                        Tinamidae
                        Cracidae
                        Megapodiidae
                        Phasianidae
                        Numididae
                        Odontophoridae
  No node labels.
> Ntip(bird.families)
[1] 137
> Nnode(bird.families)
[1] 135
> Nedge(bird.families)
[1] 271
> 
> 
> 
> cleanEx()
> nameEx("trans")
> ### * trans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trans
> ### Title: Translation from DNA to Amino Acid Sequences
> ### Aliases: trans complement
> 
> ### ** Examples
> 
> data(woodmouse)
> X <- trans(woodmouse) # not correct
Warning in trans(woodmouse) :
  sequence length not a multiple of 3: 2 nucleotides dropped
> X2 <- trans(woodmouse, 2) # using the correct code
Warning in trans(woodmouse, 2) :
  sequence length not a multiple of 3: 2 nucleotides dropped
> identical(X, X2)
[1] FALSE
> alview(X[1:2, 1:60]) # some 'Stop' codons (*)
      000000000111111111122222222223333333333444444444455555555556
      123456789012345678901234567890123456789012345678901234567890
No305 XRKTHPLLKXISHSFIDLPAPSNISS**NFGSLLGVCLIIQILTGLFLAIHYTSDTITAF
No304 I........I.N.......................I........................
> alview(X2[, 1:60])
        000000000111111111122222222223333333333444444444455555555556
        123456789012345678901234567890123456789012345678901234567890
No305   XRKTHPLLKXISHSFIDLPAPSNISSWWNFGSLLGVCLMIQILTGLFLAMHYTSDTMTAF
No304   I........I.N.......................I........................
No306   I........I.N.......................I........................
No0906S I........I.N.......................I........................
No0908S I........I.N.......................I........................
No0909S I........I.N.......................I........................
No0910S I........I.N.......................I........................
No0912S I........I.N.......................I........................
No0913S I........I.N.......................I........................
No1103S I........I.N.......................I........................
No1007S I........I.N.......................I........................
No1114S .XXXXXXXX.XXXXX.............................................
No1202S I........I.N.......................I........................
No1206S I........I.N.......................I........................
No1208S .........I.N.......................I........................
> X2
15 amino acid sequences in a matrix
All sequences of the same length: 321 

> 
> 
> 
> cleanEx()
> nameEx("trex")
> ### * trex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trex
> ### Title: Tree Explorer With Multiple Devices
> ### Aliases: trex
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D tr <- rcoal(1000)
> ##D plot(tr, show.tip.label = FALSE)
> ##D trex(tr) # left-click as many times as you want, then right-click
> ##D tr <- makeNodeLabel(tr)
> ##D trex(tr, subbg = "lightgreen") # id.
> ##D 
> ##D ## generate a random colour with control on the darkness:
> ##D rRGB <- function(a, b)
> ##D     rgb(runif(1, a, b), runif(1, a, b), runif(1, a, b))
> ##D 
> ##D ### with a random pale background:
> ##D trex(tr, subbg = rRGB(0.8, 1))
> ##D ## the above can be called many times...
> ##D graphics.off() # close all graphical devices
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("triangMtd")
> ### * triangMtd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: triangMtd
> ### Title: Tree Reconstruction Based on the Triangles Method
> ### Aliases: triangMtd triangMtds
> ### Keywords: models
> 
> ### ** Examples
> 
> data(woodmouse)
> tr <- triangMtd(dist.dna(woodmouse))
> plot(tr)
> 
> 
> 
> cleanEx()
> nameEx("unique.multiPhylo")
> ### * unique.multiPhylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unique.multiPhylo
> ### Title: Revomes Duplicate Trees
> ### Aliases: unique.multiPhylo
> ### Keywords: manip
> 
> ### ** Examples
> 
> TR <- rmtree(50, 4)
> length(unique(TR)) # not always 15...
[1] 15
> howmanytrees(4)
[1] 15
> 
> 
> 
> cleanEx()
> nameEx("updateLabel")
> ### * updateLabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: updateLabel
> ### Title: Update Labels
> ### Aliases: updateLabel updateLabel.DNAbin updateLabel.AAbin
> ###   updateLabel.character updateLabel.phylo updateLabel.evonet
> ###   updateLabel.data.frame updateLabel.matrix
> ### Keywords: manip
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## the tree by Nyakatura & Bininda-Emonds (2012, BMC Biology)
> ##D x <- "https://static-content.springer.com/esm/art"
> ##D y <- "3A10.1186"
> ##D z <- "2F1741-7007-10-12/MediaObjects/12915_2011_534_MOESM5_ESM.NEX"
> ##D ## The commande below may not print correctly in HTML because of the
> ##D ## percentage symbol; see the text or PDF help page.
> ##D url <- paste(x, y, z, sep = "##D 
> ##D TC <- read.nexus(url)
> ##D tr <- TC$carnivoreST_bestEstimate
> ##D old <- c("Uncia_uncia", "Felis_manul", "Leopardus_jacobitus")
> ##D new <- c("Panthera_uncia", "Otocolobus_manul", "Leopardus_jacobita")
> ##D tr.updated <- updateLabel(tr, old, new)
> ## End(Not run)
> 
> tr <- rtree(6)
> ## the order of the labels are randomized by this function
> old <- paste0("t", 1:6)
> new <- paste0("x", 1:6)
> updateLabel(tr, old, new)

Phylogenetic tree with 6 tips and 5 internal nodes.

Tip labels:
  x2, x5, x3, x4, x6, x1

Rooted; includes branch length(s).
> tr

Phylogenetic tree with 6 tips and 5 internal nodes.

Tip labels:
  t2, t5, t3, t4, t6, t1

Rooted; includes branch length(s).
> 
> 
> 
> cleanEx()
> nameEx("varCompPhylip")
> ### * varCompPhylip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: varCompPhylip
> ### Title: Variance Components with Orthonormal Contrasts
> ### Aliases: varCompPhylip
> ### Keywords: regression
> 
> ### ** Examples
> 
> ## Not run: 
> ##D tr <- rcoal(30)
> ##D ### Five traits, one observation per species:
> ##D x <- replicate(5, rTraitCont(tr, sigma = 1))
> ##D varCompPhylip(x, tr) # varE is small
> ##D x <- replicate(5, rnorm(30))
> ##D varCompPhylip(x, tr) # varE is large
> ##D ### Five traits, ten observations per species:
> ##D x <- replicate(30, replicate(5, rnorm(10)), simplify = FALSE)
> ##D varCompPhylip(x, tr)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("varcomp")
> ### * varcomp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: varcomp
> ### Title: Compute Variance Component Estimates
> ### Aliases: varcomp
> ### Keywords: regression dplot
> 
> ### ** Examples
> 
> data(carnivora)
> library(nlme)
> m <- lme(log10(SW) ~ 1, random = ~ 1|Order/SuperFamily/Family/Genus, data=carnivora)
> v <- varcomp(m, TRUE, TRUE)
> plot(v)
> 
> 
> 
> cleanEx()

detaching ‘package:nlme’

> nameEx("vcv.phylo")
> ### * vcv.phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcv
> ### Title: Phylogenetic Variance-covariance or Correlation Matrix
> ### Aliases: vcv vcv.phylo vcv.corPhyl
> ### Keywords: manip multivariate
> 
> ### ** Examples
> 
> tr <- rtree(5)
> ## all are the same:
> vcv(tr)
           t2        t1        t3        t4        t5
t2 0.06178627 0.0000000 0.0000000 0.0000000 0.0000000
t1 0.00000000 1.0695542 0.3825313 0.3825313 0.2059746
t3 0.00000000 0.3825313 1.5364765 0.7666350 0.2059746
t4 0.00000000 0.3825313 0.7666350 1.2643343 0.2059746
t5 0.00000000 0.2059746 0.2059746 0.2059746 0.9235931
> vcv(corBrownian(1, tr))
Warning in Initialize.corPhyl(phy, dummy.df) :
  No covariate specified, species will be taken as ordered in the data frame. To avoid this message, specify a covariate containing the species names with the 'form' argument.
           t2        t1        t3        t4        t5
t2 0.06178627 0.0000000 0.0000000 0.0000000 0.0000000
t1 0.00000000 1.0695542 0.3825313 0.3825313 0.2059746
t3 0.00000000 0.3825313 1.5364765 0.7666350 0.2059746
t4 0.00000000 0.3825313 0.7666350 1.2643343 0.2059746
t5 0.00000000 0.2059746 0.2059746 0.2059746 0.9235931
> vcv(corPagel(1, tr))
Warning in Initialize.corPhyl(phy, dummy.df) :
  No covariate specified, species will be taken as ordered in the data frame. To avoid this message, specify a covariate containing the species names with the 'form' argument.
           t2        t1        t3        t4        t5
t2 0.06178627 0.0000000 0.0000000 0.0000000 0.0000000
t1 0.00000000 1.0695542 0.3825313 0.3825313 0.2059746
t3 0.00000000 0.3825313 1.5364765 0.7666350 0.2059746
t4 0.00000000 0.3825313 0.7666350 1.2643343 0.2059746
t5 0.00000000 0.2059746 0.2059746 0.2059746 0.9235931
> 
> 
> 
> cleanEx()
> nameEx("vcv2phylo")
> ### * vcv2phylo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcv2phylo
> ### Title: Variance-Covariance Matrix to Tree
> ### Aliases: vcv2phylo
> ### Keywords: manip multivariate
> 
> ### ** Examples
> 
> tr <- rtree(10)
> V <- vcv(tr) # VCV matrix assuming Brownian motion
> z <- vcv2phylo(V)
> identical(tr, z) # FALSE
[1] FALSE
> all.equal(tr, z) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("where")
> ### * where
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: where
> ### Title: Find Patterns in DNA Sequences
> ### Aliases: where
> ### Keywords: manip
> 
> ### ** Examples
> 
> data(woodmouse)
> where(woodmouse, "tata")
$No305
[1] 661 962

$No304
[1] 232 234 318 661

$No306
[1] 232 234 318 661 962

$No0906S
[1] 232 234 318 661

$No0908S
[1] 232 234 318 454 661

$No0909S
[1] 232 234 661

$No0910S
[1] 232 234 318 661

$No0912S
[1] 232 234 661

$No0913S
[1] 232 318 661

$No1103S
[1] 232 234 661

$No1007S
[1] 232 234 661

$No1114S
[1] 232 234 296 661

$No1202S
[1] 232 234 318 661

$No1206S
[1] 232 234 318 661

$No1208S
[1] 232 234 661

> ## with AA sequences:
> x <- trans(woodmouse, 2)
Warning in trans(woodmouse, 2) :
  sequence length not a multiple of 3: 2 nucleotides dropped
> where(x, "irk")
$No305
numeric(0)

$No304
[1] 1

$No306
[1] 1

$No0906S
[1] 1

$No0908S
[1] 1

$No0909S
[1] 1

$No0910S
[1] 1

$No0912S
[1] 1

$No0913S
[1] 1

$No1103S
[1] 1

$No1007S
[1] 1

$No1114S
numeric(0)

$No1202S
[1] 1

$No1206S
[1] 1

$No1208S
numeric(0)

> 
> 
> 
> cleanEx()
> nameEx("woodmouse")
> ### * woodmouse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: woodmouse
> ### Title: Cytochrome b Gene Sequences of Woodmice
> ### Aliases: woodmouse
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(woodmouse)
> str(woodmouse)
 'DNAbin' raw [1:15, 1:965] n a a a ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:15] "No305" "No304" "No306" "No0906S" ...
  ..$ : NULL
> 
> 
> 
> cleanEx()
> nameEx("write.nexus.data")
> ### * write.nexus.data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.nexus.data
> ### Title: Write Character Data in NEXUS Format
> ### Aliases: write.nexus.data
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Write interleaved DNA data with 100 characters per line in a DATA block
> ##D data(woodmouse)
> ##D write.nexus.data(woodmouse, file= "wood.ex.nex", interleaved = TRUE, charsperline = 100)
> ##D ## Write sequential DNA data in TAXA and CHARACTERS blocks
> ##D data(cynipids)
> ##D write.nexus.data(cynipids, file = "cyn.ex.nex", format = "protein",
> ##D                  datablock = FALSE, interleaved = FALSE)
> ##D unlink(c("wood.ex.nex", "cyn.ex.nex"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("yule.cov")
> ### * yule.cov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yule.cov
> ### Title: Fits the Yule Model With Covariates
> ### Aliases: yule.cov
> ### Keywords: models
> 
> ### ** Examples
> 
> ### a simple example with some random data
> data(bird.orders)
> x <- rnorm(45) # the tree has 23 tips and 22 nodes
> ### the standard-error for x should be as large as
> ### the estimated parameter
> yule.cov(bird.orders, ~ x)

---- Yule Model with Covariates ----

    Phylogenetic tree: bird.orders 
       Number of tips: 23 
      Number of nodes: 22 
             Deviance: 92.71057 
       Log-likelihood: -46.35529 

  Parameter estimates:
             Estimate    StdErr
(Intercept) -3.199049 0.1606267
x            0.114417 0.2066675

Null Deviance: 92.86533 
  Test of the fitted model: chi^2 = 0.155   df = 1   P = 0.694 
> ### another example with a tree that has a multichotomy
> data(bird.families)
> y <- rnorm(272) # 137 tips + 135 nodes
> yule.cov(bird.families, ~ y)
Warning in nlm(function(p) dev(p), p = c(rep(0, ncol(X) - 1), -1), hessian = TRUE) :
  Inf replaced by maximum positive value

---- Yule Model with Covariates ----

    Phylogenetic tree: bird.families 
       Number of tips: 137 
      Number of nodes: 135 
             Deviance: 355.0054 
       Log-likelihood: -177.5027 

  Parameter estimates:
               Estimate     StdErr
(Intercept) -2.63925612 0.06548841
y            0.03074306 0.06801150

Null Deviance: 355.1075 
  Test of the fitted model: chi^2 = 0.102   df = 1   P = 0.749 
> 
> 
> 
> cleanEx()
> nameEx("yule.time")
> ### * yule.time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yule.time
> ### Title: Fits the Time-Dependent Yule Model
> ### Aliases: yule.time
> ### Keywords: models
> 
> ### ** Examples
> 
> ### define two models...
> birth.logis <- function(a, b) 1/(1 + exp(-a*t - b)) # logistic
> birth.step <- function(l1, l2, Tcl) { # 2 rates with one break-point
+     ans <- rep(l1, length(t))
+     ans[t > Tcl] <- l2
+     ans
+ }
> ### ... and their primitives:
> BIRTH.logis <- function(t) log(exp(-a*t) + exp(b))/a + t
> BIRTH.step <- function(t)
+ {
+     out <- numeric(length(t))
+     sel <- t <= Tcl
+     if (any(sel)) out[sel] <- t[sel] * l1
+     if (any(!sel)) out[!sel] <- Tcl * l1 + (t[!sel] - Tcl) * l2
+     out
+ }
> data(bird.families)
> ### fit both models:
> yule.time(bird.families, birth.logis)
Warning in nlm(half.dev, start, hessian = TRUE) :
  Inf replaced by maximum positive value
Warning in nlm(half.dev, start, hessian = TRUE) :
  Inf replaced by maximum positive value
$estimate
         a          b 
-0.1983452  0.7689003 

$se
         a          b 
0.01911037 0.31713316 

$loglik
[1] 108.3082

attr(,"class")
[1] "yule"
> yule.time(bird.families, birth.logis, BIRTH.logis) # same but faster
Warning in nlm(half.dev, start, hessian = TRUE) :
  NA/NaN replaced by maximum positive value
Warning in nlm(half.dev, start, hessian = TRUE) :
  NA/NaN replaced by maximum positive value
$estimate
         a          b 
-0.1983452  0.7689003 

$se
         a          b 
0.01911033 0.31713237 

$loglik
[1] 108.3082

attr(,"class")
[1] "yule"
> ## Not run: yule.time(bird.families, birth.step)  # fails
> yule.time(bird.families, birth.step, BIRTH.step,
+           opti = "nlminb", start = c(.01, .01, 100))
$estimate
          l1           l2          Tcl 
  0.06719818   0.01000000 100.00000000 

$se
NULL

$loglik
[1] 34.76978

attr(,"class")
[1] "yule"
> 
> 
> 
> cleanEx()
> nameEx("zoom")
> ### * zoom
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zoom
> ### Title: Zoom on a Portion of a Phylogeny
> ### Aliases: zoom
> ### Keywords: hplot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(chiroptera)
> ##D zoom(chiroptera, 1:20, subtree = TRUE)
> ##D zoom(chiroptera, grep("Plecotus", chiroptera$tip.label))
> ##D zoom(chiroptera, list(grep("Plecotus", chiroptera$tip.label),
> ##D                       grep("Pteropus", chiroptera$tip.label)))
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  9.936 1.486 9.952 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
