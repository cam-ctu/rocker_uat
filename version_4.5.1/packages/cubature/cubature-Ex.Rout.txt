
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "cubature"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('cubature')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("cubintegrate")
> ### * cubintegrate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cubintegrate
> ### Title: Unified Cubature Integration Interface
> ### Aliases: cubintegrate
> 
> ### ** Examples
> 
> I.1d <- function(x) {
+   sin(4*x) *
+     x * ((x * ( x * (x*x-4) + 1) - 1))
+ }
> I.1d_v <- function(x) {
+    matrix(apply(x, 2, function(z)
+        sin(4 * z) *
+        z * ((z * ( z * (z * z - 4) + 1) - 1))),
+        ncol = ncol(x))
+ }
> cubintegrate(f = I.1d, lower = -2, upper = 2, method = "pcubature")
$integral
[1] 1.635644

$error
[1] 1.332268e-15

$neval
[1] 65

$returnCode
[1] 0

> cubintegrate(f = I.1d, lower = -2, upper = 2, method = "cuhre", flags=list(verbose = 2))
Cuhre input parameters:
  ndim 1
  ncomp 1
  nvec 1
  epsrel 1e-05
  epsabs 1e-12
  flags 6
  mineval 0
  maxeval 1000000
  key 0
  statefile "(null)"

Iteration 1:  11 integrand evaluations so far
[1] 1.79496 +- 36.4275  	chisq 0 (0 df)

Iteration 2:  33 integrand evaluations so far
[1] 1.60939 +- 15.0794  	chisq 2.21553e-05 (1 df)

Iteration 3:  55 integrand evaluations so far
[1] 1.62346 +- 7.01714  	chisq 2.28586e-05 (2 df)

Iteration 4:  77 integrand evaluations so far
[1] 1.63569 +- 0.145134  	chisq 2.5197e-05 (3 df)

Iteration 5:  99 integrand evaluations so far
[1] 1.63568 +- 0.0643672  	chisq 2.51973e-05 (4 df)

Iteration 6:  121 integrand evaluations so far
[1] 1.63568 +- 0.0123924  	chisq 2.52128e-05 (5 df)

Iteration 7:  143 integrand evaluations so far
[1] 1.63566 +- 0.00587027  	chisq 2.67284e-05 (6 df)

Iteration 8:  165 integrand evaluations so far
[1] 1.63564 +- 5.32936e-05  	chisq 3.85791e-05 (7 df)

Iteration 9:  187 integrand evaluations so far
[1] 1.63564 +- 3.85904e-05  	chisq 3.8594e-05 (8 df)

Iteration 10:  209 integrand evaluations so far
[1] 1.63564 +- 2.5705e-05  	chisq 3.86238e-05 (9 df)

Iteration 11:  231 integrand evaluations so far
[1] 1.63564 +- 2.02465e-05  	chisq 3.86238e-05 (10 df)

Iteration 12:  253 integrand evaluations so far
[1] 1.63564 +- 1.51801e-05  	chisq 3.8147e-05 (11 df)
$integral
[1] 1.635644

$error
[1] 1.518009e-05

$nregions
[1] 12

$neval
[1] 253

$prob
[1] 0

$returnCode
[1] 0

> cubintegrate(f = I.1d_v, lower = -2, upper = 2, method = "hcubature", nVec = 2L)
$integral
[1] 1.635644

$error
[1] 4.024021e-09

$neval
[1] 105

$returnCode
[1] 0

> cubintegrate(f = I.1d_v, lower = -2, upper = 2, method = "cuhre", nVec = 128L)
$integral
[1] 1.635644

$error
[1] 1.518009e-05

$nregions
[1] 12

$neval
[1] 253

$prob
[1] 0

$returnCode
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("cuhre")
> ### * cuhre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cuhre
> ### Title: Integration by a Deterministic Iterative Adaptive Algorithm
> ### Aliases: cuhre
> ### Keywords: math
> 
> ### ** Examples
> 
> integrand <- function(arg) {
+   x <- arg[1]
+   y <- arg[2]
+   z <- arg[3]
+   ff <- sin(x)*cos(y)*exp(z);
+ return(ff)
+ } # End integrand
> 
> NDIM <- 3
> NCOMP <- 1
> cuhre(f = integrand,
+       lowerLimit = rep(0, NDIM),
+       upperLimit = rep(1, NDIM),
+       relTol = 1e-3, absTol= 1e-12,
+       flags = list(verbose = 2, final = 0))
Cuhre input parameters:
  ndim 3
  ncomp 1
  nvec 1
  epsrel 0.001
  epsabs 1e-12
  flags 2
  mineval 0
  maxeval 1000000
  key 0
  statefile "(null)"

Iteration 1:  127 integrand evaluations so far
[1] 0.66467 +- 7.2682e-10  	chisq 0 (0 df)

Iteration 2:  381 integrand evaluations so far
[1] 0.66467 +- 3.33018e-11  	chisq 0 (1 df)
$integral
[1] 0.6646697

$error
[1] 3.33018e-11

$nregions
[1] 2

$neval
[1] 381

$prob
[1] 0

$returnCode
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("default_args")
> ### * default_args
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_args
> ### Title: Default arguments for each integration method
> ### Aliases: default_args
> 
> ### ** Examples
> 
> default_args()
$hcubature
$hcubature$norm
[1] "INDIVIDUAL" "PAIRED"     "L2"         "L1"         "LINF"      


$pcubature
$pcubature$norm
[1] "INDIVIDUAL" "PAIRED"     "L2"         "L1"         "LINF"      


$cuhre
$cuhre$minEval
[1] 0

$cuhre$stateFile
NULL

$cuhre$flags
$cuhre$flags$verbose
[1] 0

$cuhre$flags$final
[1] 1

$cuhre$flags$smooth
[1] 0

$cuhre$flags$keep_state
[1] 0

$cuhre$flags$load_state
[1] 0

$cuhre$flags$level
[1] 0


$cuhre$key
[1] 0


$divonne
$divonne$minEval
[1] 0

$divonne$stateFile
NULL

$divonne$flags
$divonne$flags$verbose
[1] 0

$divonne$flags$final
[1] 1

$divonne$flags$smooth
[1] 0

$divonne$flags$keep_state
[1] 0

$divonne$flags$load_state
[1] 0

$divonne$flags$level
[1] 0


$divonne$rngSeed
[1] 0

$divonne$key1
[1] 47

$divonne$key2
[1] 1

$divonne$key3
[1] 1

$divonne$maxPass
[1] 5

$divonne$border
[1] 0

$divonne$maxChisq
[1] 10

$divonne$minDeviation
[1] 0.25

$divonne$xGiven
NULL

$divonne$nExtra
[1] 0

$divonne$peakFinder
NULL


$sauve
$sauve$minEval
[1] 0

$sauve$stateFile
NULL

$sauve$flags
$sauve$flags$verbose
[1] 0

$sauve$flags$final
[1] 1

$sauve$flags$smooth
[1] 0

$sauve$flags$keep_state
[1] 0

$sauve$flags$load_state
[1] 0

$sauve$flags$level
[1] 0


$sauve$rngSeed
[1] 0

$sauve$nNew
[1] 1000

$sauve$nMin
[1] 50

$sauve$flatness
[1] 50


$vegas
$vegas$minEval
[1] 0

$vegas$stateFile
NULL

$vegas$flags
$vegas$flags$verbose
[1] 0

$vegas$flags$final
[1] 1

$vegas$flags$smooth
[1] 0

$vegas$flags$keep_state
[1] 0

$vegas$flags$load_state
[1] 0

$vegas$flags$level
[1] 0


$vegas$rngSeed
[1] 0

$vegas$nStart
[1] 1000

$vegas$nIncrease
[1] 500

$vegas$nBatch
[1] 1000

$vegas$gridNo
[1] 0


> 
> 
> 
> cleanEx()
> nameEx("divonne")
> ### * divonne
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: divonne
> ### Title: Integration by Stratified Sampling for Variance Reduction
> ### Aliases: divonne
> ### Keywords: math
> 
> ### ** Examples
> 
> integrand <- function(arg, phase) {
+   x <- arg[1]
+   y <- arg[2]
+   z <- arg[3]
+   ff <- sin(x)*cos(y)*exp(z);
+ return(ff)
+ }
> divonne(integrand, relTol=1e-3,  absTol=1e-12, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
+         flags=list(verbose = 2),  key1= 47)
Divonne input parameters:
  ndim 3
  ncomp 1
  nvec 1
  epsrel 0.001
  epsabs 1e-12
  flags 6
  seed 0
  mineval 0
  maxeval 1000000
  key1 47
  key2 1
  key3 1
  maxpass 5
  border 0
  maxchisq 10
  mindeviation 0.25
  ngiven 0
  nextra 0
  statefile "(null)"

Partitioning phase:

Iteration 1 (pass 0):  8 regions
    836 integrand evaluations so far,
    406 in optimizing regions,
     70 in finding cuts
[1] 0.665011 +- 0.00470198

Iteration 2 (pass 0):  9 regions
    966 integrand evaluations so far,
    478 in optimizing regions,
     80 in finding cuts
[1] 0.664964 +- 0.00429467

Iteration 3 (pass 1):  10 regions
   1096 integrand evaluations so far,
    550 in optimizing regions,
     90 in finding cuts
[1] 0.664949 +- 0.00388393

Iteration 4 (pass 2):  11 regions
   1194 integrand evaluations so far,
    590 in optimizing regions,
    100 in finding cuts
[1] 0.664887 +- 0.0035842

Iteration 5 (pass 3):  12 regions
   1308 integrand evaluations so far,
    646 in optimizing regions,
    110 in finding cuts
[1] 0.664853 +- 0.0033385

Iteration 6 (pass 4):  13 regions
   1438 integrand evaluations so far,
    718 in optimizing regions,
    120 in finding cuts
[1] 0.664825 +- 0.0031276

Iteration 7 (pass 5):  14 regions
   1568 integrand evaluations so far,
    790 in optimizing regions,
    130 in finding cuts
[1] 0.664816 +- 0.00292074

Main integration on 14 regions with 211 samples per region.
$integral
[1] 0.6646098

$error
[1] 0.0006505917

$neval
[1] 3052

$prob
[1] 1.110223e-16

$returnCode
[1] 0

> 
> # Example with a peak-finder function
> nDim <- 3L
> peakf <- function(bounds, nMax) {
+ #  print(bounds) # matrix (ndim,2)
+   x <- matrix(0, ncol = nMax, nrow = nDim)
+    pas <- 1 / (nMax - 1)
+    # 1ier point
+    x[, 1] <- rep(0, nDim)
+    # Les autres points
+    for (i in 2L:nMax) {
+       x[, i] <- x[, (i - 1)] + pas
+     }
+   x
+ } #end peakf
> 
> divonne(integrand, relTol=1e-3,  absTol=1e-12,
+         lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
+         flags=list(verbose = 2),  peakFinder = peakf, nExtra = 4L)
Divonne input parameters:
  ndim 3
  ncomp 1
  nvec 1
  epsrel 0.001
  epsabs 1e-12
  flags 6
  seed 0
  mineval 0
  maxeval 1000000
  key1 47
  key2 1
  key3 1
  maxpass 5
  border 0
  maxchisq 10
  mindeviation 0.25
  ngiven 0
  nextra 4
  statefile "(null)"

Partitioning phase:

Iteration 1 (pass 0):  8 regions
    857 integrand evaluations so far,
    382 in optimizing regions,
     70 in finding cuts
[1] 0.665011 +- 0.00470198

Iteration 2 (pass 0):  9 regions
    993 integrand evaluations so far,
    454 in optimizing regions,
     80 in finding cuts
[1] 0.664964 +- 0.00429467

Iteration 3 (pass 1):  10 regions
   1129 integrand evaluations so far,
    526 in optimizing regions,
     90 in finding cuts
[1] 0.664949 +- 0.00388393

Iteration 4 (pass 2):  11 regions
   1233 integrand evaluations so far,
    566 in optimizing regions,
    100 in finding cuts
[1] 0.664887 +- 0.0035842

Iteration 5 (pass 3):  12 regions
   1353 integrand evaluations so far,
    622 in optimizing regions,
    110 in finding cuts
[1] 0.664853 +- 0.0033385

Iteration 6 (pass 4):  13 regions
   1489 integrand evaluations so far,
    694 in optimizing regions,
    120 in finding cuts
[1] 0.664825 +- 0.0031276

Iteration 7 (pass 5):  14 regions
   1625 integrand evaluations so far,
    766 in optimizing regions,
    130 in finding cuts
[1] 0.664816 +- 0.00292074

Main integration on 14 regions with 211 samples per region.
$integral
[1] 0.6646098

$error
[1] 0.0006505917

$neval
[1] 3109

$prob
[1] 1.110223e-16

$returnCode
[1] 0

> 
> 
> 
> cleanEx()
> nameEx("hcubature")
> ### * hcubature
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hcubature
> ### Title: Adaptive multivariate integration over hypercubes (hcubature and
> ###   pcubature)
> ### Aliases: hcubature adaptIntegrate pcubature
> ### Keywords: math
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D ## Test function 0
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 2 1e-4 0 0
> ##D ## 2-dim integral, tolerance = 0.0001
> ##D ## integrand 0: integral = 0.708073, est err = 1.70943e-05, true err = 7.69005e-09
> ##D ## #evals = 17
> ##D 
> ##D testFn0 <- function(x) {
> ##D   prod(cos(x))
> ##D }
> ##D 
> ##D hcubature(testFn0, rep(0,2), rep(1,2), tol=1e-4)
> ##D 
> ##D pcubature(testFn0, rep(0,2), rep(1,2), tol=1e-4)
> ##D 
> ##D M_2_SQRTPI <- 2/sqrt(pi)
> ##D 
> ##D ## Test function 1
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 3 1e-4 1 0
> ##D ## 3-dim integral, tolerance = 0.0001
> ##D ## integrand 1: integral = 1.00001, est err = 9.67798e-05, true err = 9.76919e-06
> ##D ## #evals = 5115
> ##D 
> ##D testFn1 <- function(x) {
> ##D   val <- sum (((1-x) / x)^2)
> ##D   scale <- prod(M_2_SQRTPI/x^2)
> ##D   exp(-val) * scale
> ##D }
> ##D 
> ##D hcubature(testFn1, rep(0, 3), rep(1, 3), tol=1e-4)
> ##D pcubature(testFn1, rep(0, 3), rep(1, 3), tol=1e-4)
> ##D 
> ##D ##
> ##D ## Test function 2
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 2 1e-4 2 0
> ##D ## 2-dim integral, tolerance = 0.0001
> ##D ## integrand 2: integral = 0.19728, est err = 1.97261e-05, true err = 4.58316e-05
> ##D ## #evals = 166141
> ##D 
> ##D testFn2 <- function(x) {
> ##D   ## discontinuous objective: volume of hypersphere
> ##D   radius <- as.double(0.50124145262344534123412)
> ##D   ifelse(sum(x*x) < radius*radius, 1, 0)
> ##D }
> ##D 
> ##D hcubature(testFn2, rep(0, 2), rep(1, 2), tol=1e-4)
> ##D pcubature(testFn2, rep(0, 2), rep(1, 2), tol=1e-4)
> ##D 
> ##D ##
> ##D ## Test function 3
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 3 1e-4 3 0
> ##D ## 3-dim integral, tolerance = 0.0001
> ##D ## integrand 3: integral = 1, est err = 0, true err = 2.22045e-16
> ##D ## #evals = 33
> ##D 
> ##D testFn3 <- function(x) {
> ##D   prod(2*x)
> ##D }
> ##D 
> ##D hcubature(testFn3, rep(0,3), rep(1,3), tol=1e-4)
> ##D pcubature(testFn3, rep(0,3), rep(1,3), tol=1e-4)
> ##D 
> ##D ##
> ##D ## Test function 4 (Gaussian centered at 1/2)
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 2 1e-4 4 0
> ##D ## 2-dim integral, tolerance = 0.0001
> ##D ## integrand 4: integral = 1, est err = 9.84399e-05, true err = 2.78894e-06
> ##D ## #evals = 1853
> ##D 
> ##D testFn4 <- function(x) {
> ##D   a <- 0.1
> ##D   s <- sum((x - 0.5)^2)
> ##D   (M_2_SQRTPI / (2. * a))^length(x) * exp (-s / (a * a))
> ##D }
> ##D 
> ##D hcubature(testFn4, rep(0,2), rep(1,2), tol=1e-4)
> ##D pcubature(testFn4, rep(0,2), rep(1,2), tol=1e-4)
> ##D 
> ##D ##
> ##D ## Test function 5 (double Gaussian)
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 3 1e-4 5 0
> ##D ## 3-dim integral, tolerance = 0.0001
> ##D ## integrand 5: integral = 0.999994, est err = 9.98015e-05, true err = 6.33407e-06
> ##D ## #evals = 59631
> ##D 
> ##D testFn5 <- function(x) {
> ##D   a <- 0.1
> ##D   s1 <- sum((x - 1/3)^2)
> ##D   s2 <- sum((x - 2/3)^2)
> ##D   0.5 * (M_2_SQRTPI / (2. * a))^length(x) * (exp(-s1 / (a * a)) + exp(-s2 / (a * a)))
> ##D }
> ##D 
> ##D hcubature(testFn5, rep(0,3), rep(1,3), tol=1e-4)
> ##D pcubature(testFn5, rep(0,3), rep(1,3), tol=1e-4)
> ##D 
> ##D ##
> ##D ## Test function 6 (Tsuda's example)
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 4 1e-4 6 0
> ##D ## 4-dim integral, tolerance = 0.0001
> ##D ## integrand 6: integral = 0.999998, est err = 9.99685e-05, true err = 1.5717e-06
> ##D ## #evals = 18753
> ##D 
> ##D testFn6 <- function(x) {
> ##D   a <- (1 + sqrt(10.0)) / 9.0
> ##D   prod(a / (a + 1) * ((a + 1) / (a + x))^2)
> ##D }
> ##D 
> ##D hcubature(testFn6, rep(0,4), rep(1,4), tol=1e-4)
> ##D pcubature(testFn6, rep(0,4), rep(1,4), tol=1e-4)
> ##D 
> ##D 
> ##D ##
> ##D ## Test function 7
> ##D ##   test integrand from W. J. Morokoff and R. E. Caflisch, "Quasi=
> ##D ##   Monte Carlo integration," J. Comput. Phys 122, 218-230 (1995).
> ##D ##   Designed for integration on [0,1]^dim, integral = 1. */
> ##D ## Compare with original cubature result of
> ##D ## ./cubature_test 3 1e-4 7 0
> ##D ## 3-dim integral, tolerance = 0.0001
> ##D ## integrand 7: integral = 1.00001, est err = 9.96657e-05, true err = 1.15994e-05
> ##D ## #evals = 7887
> ##D 
> ##D testFn7 <- function(x) {
> ##D   n <- length(x)
> ##D   p <- 1/n
> ##D   (1 + p)^n * prod(x^p)
> ##D }
> ##D 
> ##D hcubature(testFn7, rep(0,3), rep(1,3), tol=1e-4)
> ##D pcubature(testFn7, rep(0,3), rep(1,3), tol=1e-4)
> ##D 
> ##D 
> ##D ## Example from web page
> ##D ## http://ab-initio.mit.edu/wiki/index.php/Cubature
> ##D ##
> ##D ## f(x) = exp(-0.5(euclidean_norm(x)^2)) over the three-dimensional
> ##D ## hyperbcube [-2, 2]^3
> ##D ## Compare with original cubature result
> ##D testFnWeb <-  function(x) {
> ##D   exp(-0.5 * sum(x^2))
> ##D }
> ##D 
> ##D hcubature(testFnWeb, rep(-2,3), rep(2,3), tol=1e-4)
> ##D pcubature(testFnWeb, rep(-2,3), rep(2,3), tol=1e-4)
> ##D 
> ##D ## Test function I.1d from
> ##D ## Numerical integration using Wang-Landau sampling
> ##D ## Y. W. Li, T. Wust, D. P. Landau, H. Q. Lin
> ##D ## Computer Physics Communications, 2007, 524-529
> ##D ## Compare with exact answer: 1.63564436296
> ##D ##
> ##D I.1d <- function(x) {
> ##D   sin(4*x) *
> ##D     x * ((x * ( x * (x*x-4) + 1) - 1))
> ##D }
> ##D 
> ##D hcubature(I.1d, -2, 2, tol=1e-7)
> ##D pcubature(I.1d, -2, 2, tol=1e-7)
> ##D 
> ##D ## Test function I.2d from
> ##D ## Numerical integration using Wang-Landau sampling
> ##D ## Y. W. Li, T. Wust, D. P. Landau, H. Q. Lin
> ##D ## Computer Physics Communications, 2007, 524-529
> ##D ## Compare with exact answer: -0.01797992646
> ##D ##
> ##D ##
> ##D I.2d <- function(x) {
> ##D   x1 = x[1]
> ##D   x2 = x[2]
> ##D   sin(4*x1+1) * cos(4*x2) * x1 * (x1*(x1*x1)^2 - x2*(x2*x2 - x1) +2)
> ##D }
> ##D 
> ##D hcubature(I.2d, rep(-1, 2), rep(1, 2), maxEval=10000)
> ##D pcubature(I.2d, rep(-1, 2), rep(1, 2), maxEval=10000)
> ##D 
> ##D ##
> ##D ## Example of multivariate normal integration borrowed from
> ##D ## package mvtnorm (on CRAN) to check ... argument
> ##D ## Compare with output of
> ##D ## pmvnorm(lower=rep(-0.5, m), upper=c(1,4,2), mean=rep(0, m), corr=sigma, alg=Miwa())
> ##D ##     0.3341125.  Blazing quick as well!  Ours is, not unexpectedly, much slower.
> ##D ##
> ##D dmvnorm <- function (x, mean, sigma, log = FALSE) {
> ##D     if (is.vector(x)) {
> ##D         x <- matrix(x, ncol = length(x))
> ##D     }
> ##D     if (missing(mean)) {
> ##D         mean <- rep(0, length = ncol(x))
> ##D     }
> ##D     if (missing(sigma)) {
> ##D         sigma <- diag(ncol(x))
> ##D     }
> ##D     if (NCOL(x) != NCOL(sigma)) {
> ##D         stop("x and sigma have non-conforming size")
> ##D     }
> ##D     if (!isSymmetric(sigma, tol = sqrt(.Machine$double.eps),
> ##D         check.attributes = FALSE)) {
> ##D         stop("sigma must be a symmetric matrix")
> ##D     }
> ##D     if (length(mean) != NROW(sigma)) {
> ##D         stop("mean and sigma have non-conforming size")
> ##D     }
> ##D     distval <- mahalanobis(x, center = mean, cov = sigma)
> ##D     logdet <- sum(log(eigen(sigma, symmetric = TRUE, only.values = TRUE)$values))
> ##D     logretval <- -(ncol(x) * log(2 * pi) + logdet + distval)/2
> ##D     if (log)
> ##D         return(logretval)
> ##D     exp(logretval)
> ##D }
> ##D 
> ##D m <- 3
> ##D sigma <- diag(3)
> ##D sigma[2,1] <- sigma[1, 2] <- 3/5 ; sigma[3,1] <- sigma[1, 3] <- 1/3
> ##D sigma[3,2] <- sigma[2, 3] <- 11/15
> ##D hcubature(dmvnorm, lower=rep(-0.5, m), upper=c(1,4,2),
> ##D                         mean=rep(0, m), sigma=sigma, log=FALSE,
> ##D                maxEval=10000)
> ##D pcubature(dmvnorm, lower=rep(-0.5, m), upper=c(1,4,2),
> ##D                         mean=rep(0, m), sigma=sigma, log=FALSE,
> ##D                maxEval=10000)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("suave")
> ### * suave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: suave
> ### Title: Integration with SUbregion-Adaptive Vegas Algorithm
> ### Aliases: suave
> ### Keywords: math
> 
> ### ** Examples
> 
> 
> integrand <- function(arg) {
+   x <- arg[1]
+   y <- arg[2]
+   z <- arg[3]
+   ff <- sin(x)*cos(y)*exp(z);
+ return(ff)
+ } # end integrand
> suave(integrand, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
+              relTol=1e-3,  absTol=1e-12,
+              flags=list(verbose=2, final=0))
Suave input parameters:
  ndim 3
  ncomp 1
  nvec 1
  epsrel 0.001
  epsabs 1e-12
  flags 2
  seed 0
  mineval 0
  maxeval 1000000
  nnew 1000
  nmin 50
  flatness 50
  statefile "(null)"

Iteration 1:  1000 integrand evaluations so far
[1] 0.664916 +- 0.0138647  	chisq 0 (0 df)

Iteration 2:  2000 integrand evaluations so far
[1] 0.664522 +- 0.00338364  	chisq 0.00368404 (2 df)

Iteration 3:  3000 integrand evaluations so far
[1] 0.665025 +- 0.00238104  	chisq 0.0739355 (5 df)

Iteration 4:  4000 integrand evaluations so far
[1] 0.664653 +- 0.0011072  	chisq 0.228312 (8 df)

Iteration 5:  5000 integrand evaluations so far
[1] 0.664638 +- 0.000945872  	chisq 1.56745 (12 df)

Iteration 6:  6000 integrand evaluations so far
[1] 0.66473 +- 0.000749366  	chisq 5.46194 (16 df)

Iteration 7:  7000 integrand evaluations so far
[1] 0.66462 +- 0.000580976  	chisq 14.8927 (20 df)
$integral
[1] 0.6646196

$error
[1] 0.0005809762

$neval
[1] 7000

$prob
[1] 0.2174863

$returnCode
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("vegas")
> ### * vegas
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vegas
> ### Title: Integration by a Monte Carlo Algorithm
> ### Aliases: vegas
> ### Keywords: math
> 
> ### ** Examples
> 
> 
> integrand <- function(arg, weight) {
+   x <- arg[1]
+   y <- arg[2]
+   z <- arg[3]
+   ff <- sin(x)*cos(y)*exp(z);
+ return(ff)
+ } # end integrand
> vegas(integrand, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
+              relTol=1e-3,  absTol=1e-12,
+              flags=list(verbose=2, final=0))
Vegas input parameters:
  ndim 3
  ncomp 1
  nvec 1
  epsrel 0.001
  epsabs 1e-12
  flags 2
  seed 12345
  mineval 0
  maxeval 1000000
  nstart 1000
  nincrease 500
  nbatch 1000
  gridno 0
  statefile "(null)"

Iteration 1:  1000 integrand evaluations so far
[1] 0.658215 +- 0.0136627  	chisq 0 (0 df)

Iteration 2:  2500 integrand evaluations so far
[1] 0.67403 +- 0.00504613  	chisq 1.5516 (1 df)

Iteration 3:  4500 integrand evaluations so far
[1] 0.665926 +- 0.00223422  	chisq 4.76018 (2 df)

Iteration 4:  7000 integrand evaluations so far
[1] 0.665883 +- 0.00118416  	chisq 4.76069 (3 df)

Iteration 5:  10000 integrand evaluations so far
[1] 0.665433 +- 0.000828873  	chisq 5.04335 (4 df)

Iteration 6:  13500 integrand evaluations so far
[1] 0.665231 +- 0.000617027  	chisq 5.17669 (5 df)
$integral
[1] 0.6652311

$error
[1] 0.0006170268

$neval
[1] 13500

$prob
[1] 0.6053001

$returnCode
[1] 0

> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.207 0.011 0.218 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
