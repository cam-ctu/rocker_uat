
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "icenReg"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('icenReg')
Loading required package: survival
Loading required package: Rcpp
Loading required package: coda
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("IR_diabetes")
> ### * IR_diabetes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IR_diabetes
> ### Title: Interval censored time from diabetes onset to diabetic
> ###   nephronpathy
> ### Aliases: IR_diabetes
> 
> ### ** Examples
> 
>  data(IR_diabetes)
>  fit <- ic_par(cbind(left, right) ~ gender, 
+                data = IR_diabetes,
+                model = "po",
+                dist = "loglogistic")
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("cs2ic")
> ### * cs2ic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cs2ic
> ### Title: Convert current status data into interval censored format
> ### Aliases: cs2ic
> 
> ### ** Examples
> 
> 
> simData <- simCS_weib()
> # Simulate current status data
> 
> head(cs2ic(simData$time, simData$event))
             l        u
[1,] 1.1006464      Inf
[2,] 0.0000000 4.201474
[3,] 0.0000000 2.083629
[4,] 1.1167350      Inf
[5,] 1.7902109      Inf
[6,] 0.1989658      Inf
> # Converting data to current status format
> 
> fit <- ic_par(cs2ic(time, event) ~ x1 + x2, data = simData)
> # Can be used directly in formula
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("diag_baseline")
> ### * diag_baseline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diag_baseline
> ### Title: Compare parametric baseline distributions with semi-parametric
> ###   baseline
> ### Aliases: diag_baseline
> 
> ### ** Examples
> 
> data(IR_diabetes)
> fit <- ic_par(cbind(left, right) ~ gender, 
+              data = IR_diabetes)
> 
> diag_baseline(fit, lgdLocation = "topright", 
+              dist = c("exponential", "weibull", "loglogistic"))
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("getFitEsts")
> ### * getFitEsts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getFitEsts
> ### Title: Get Survival Curve Estimates from icenReg Model
> ### Aliases: getFitEsts
> 
> ### ** Examples
> 
> simdata <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+ inspections = 6, inspectLength = 1)
> fit <- ic_par(Surv(l, u, type = 'interval2') ~ x1 + x2,
+              data = simdata)
> new_data <- data.frame(x1 = c(1,2), x2 = c(-1,1))
> rownames(new_data) <- c('grp1', 'grp2')
> 
> estQ <- getFitEsts(fit, new_data, p = c(.25, .75))
> 
> estP <- getFitEsts(fit, q = 400)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ic_bayes")
> ### * ic_bayes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_bayes
> ### Title: Bayesian Regression Models for Interval Censored Data
> ### Aliases: ic_bayes
> 
> ### ** Examples
> 
> data(miceData)
> 
> flat_prior_model <- ic_bayes(cbind(l, u) ~ grp, data = miceData)
> # Default behavior is flat prior
> 
> priorFxn <- function(pars){
+  ans <- 0
+  ans <- ans + dnorm(pars[1], log = TRUE)
+  ans <- ans + dnorm(pars[3], sd = 0.25, log = TRUE)
+ }
> # Prior function puts N(0,1) prior on baseline shape parameter (first parameter)
> # flat prior on baseline scale parameter (second parameter)
> # and N(0,0.25) on regression parameter (third parameter)
> 
> inform_prior_fit <- ic_bayes(cbind(l, u) ~ grp, 
+                              data = miceData,
+                              logPriorFxn = priorFxn)
> 
> summary(flat_prior_model)

Model:  Bayesian Cox PH
Dependency structure assumed: Independence
Baseline:  weibull 
Call: ic_bayes(formula = cbind(l, u) ~ grp, data = miceData)


Iterations = 2001:6996
Thinning interval = 5 
Number of chains = 4 
Sample size per chain = 1000 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

             Mean     SD Naive SE Time-series SE
log_shape -0.6679 1.2653 0.020006        0.09499
log_scale  9.1379 3.1377 0.049611        0.39903
grpge      1.1039 0.3526 0.005575        0.01269

2. Quantiles for each variable:

            2.5%     25%     50%     75%  97.5%
log_shape -2.893 -1.9405 -0.3008  0.3944  1.030
log_scale  6.713  6.9214  7.3783 11.1818 16.105
grpge      0.381  0.8704  1.1212  1.3473  1.761

3. MAP estimates:
log_shape log_scale     grpge 
   0.5252    6.9560    0.9891 
> summary(inform_prior_fit)

Model:  Bayesian Cox PH
Dependency structure assumed: Independence
Baseline:  weibull 
Call: ic_bayes(formula = cbind(l, u) ~ grp, data = miceData, logPriorFxn = priorFxn)


Iterations = 2001:6996
Thinning interval = 5 
Number of chains = 4 
Sample size per chain = 1000 

1. Empirical mean and standard deviation for each variable,
   plus standard error of the mean:

            Mean     SD Naive SE Time-series SE
log_shape 0.7196 0.3789 0.005991       0.013825
log_scale 6.8135 0.1418 0.002241       0.006312
grpge     0.3538 0.2111 0.003337       0.005062

2. Quantiles for each variable:

             2.5%    25%    50%    75% 97.5%
log_shape -0.1772 0.5066 0.7706 0.9903 1.304
log_scale  6.6519 6.7242 6.7760 6.8583 7.206
grpge     -0.0594 0.2108 0.3489 0.4971 0.770

3. MAP estimates:
log_shape log_scale     grpge 
   0.5455    6.7590    0.2061 
> # Note tight prior on the regression pulls posterior mean toward 0
> 
> 
> 
> 
> cleanEx()
> nameEx("ic_np")
> ### * ic_np
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_np
> ### Title: Non-Parametric Estimator for Interval Censored Data
> ### Aliases: ic_np
> 
> ### ** Examples
> 
> data(miceData)
> fit <- ic_np(cbind(l, u) ~ grp, data = miceData)
> # Stratifies fits by group
> 
> plot(fit) 
> 
> 
> 
> cleanEx()
> nameEx("ic_par")
> ### * ic_par
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_par
> ### Title: Parametric Regression Models for Interval Censored Data
> ### Aliases: ic_par
> 
> ### ** Examples
> 
> data(miceData)
> 
> logist_ph_fit <- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
+                        data = miceData, dist = 'loglogistic')
> 
> logist_po_fit <- ic_par(cbind(l, u) ~ grp, 
+                         data = miceData, dist = 'loglogistic',
+                        model = 'po')
> 
> summary(logist_ph_fit)

Model:  Cox PH
Dependency structure assumed: Independence
Baseline:  loglogistic 
Call: ic_par(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    dist = "loglogistic")

          Estimate Exp(Est) Std.Error z-value       p
log_alpha   6.6310  758.500   0.08672  76.460 0.00000
log_beta    0.9596    2.611   0.38670   2.482 0.01307
grpge       0.8098    2.247   0.32280   2.509 0.01211

final llk =  -80.23726 
Iterations =  15 
> summary(logist_po_fit)

Model:  Proportional Odds
Dependency structure assumed: Independence
Baseline:  loglogistic 
Call: ic_par(formula = cbind(l, u) ~ grp, data = miceData, model = "po", 
    dist = "loglogistic")

          Estimate Exp(Est) Std.Error z-value        p
log_alpha    6.603 737.2000   0.07747  85.230 0.000000
log_beta     1.001   2.7200   0.38280   2.614 0.008949
grpge       -1.172   0.3097   0.47130  -2.487 0.012880

final llk =  -80.30575 
Iterations =  10 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ic_sample")
> ### * ic_sample
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_sample
> ### Title: Draw samples from an icenReg model
> ### Aliases: ic_sample
> 
> ### ** Examples
> 
> simdata <- simIC_weib(n = 500)
> 
> fit <- ic_par(cbind(l, u) ~ x1 + x2,
+               data = simdata)
> 
> newdata = data.frame(x1 = c(0, 1), x2 = c(1,1))
> 
> sampleResponses <- ic_sample(fit, newdata = newdata, samples = 100)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ic_sp")
> ### * ic_sp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_sp
> ### Title: Semi-Parametric models for Interval Censored Data
> ### Aliases: ic_sp
> 
> ### ** Examples
> 
> set.seed(1)
> 
> sim_data <- simIC_weib(n = 100, inspections = 5, inspectLength = 1)
> ph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, 
+                 data = sim_data)	
> # Default fits a Cox-PH model
> 
> summary(ph_fit)		

Model:  Cox PH
Dependency structure assumed: Independence
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data)

   Estimate Exp(Est)
x1   0.7791   2.1800
x2  -0.7800   0.4584

final llk =  -110.8563 
Iterations =  14 
Bootstrap Samples =  0 
WARNING: only  0  bootstrap samples used for standard errors. 
Suggest using more bootstrap samples for inference
> # Regression estimates close to true 0.5 and -0.5 values
> 
> 
> new_data <- data.frame(x1 = c(0,1), x2 = c(1, 1) )
> rownames(new_data) <- c('group 1', 'group 2')
> plot(ph_fit, new_data)
> # plotting the estimated survival curves
> 
> po_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, 
+                 data = sim_data, model = 'po')
> # fits a proportional odds model
> 
> summary(po_fit)

Model:  Proportional Odds
Dependency structure assumed: Independence
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data, 
    model = "po")

   Estimate Exp(Est)
x1   -1.150   0.3167
x2    1.174   3.2350

final llk =  -111.9402 
Iterations =  10 
Bootstrap Samples =  0 
WARNING: only  0  bootstrap samples used for standard errors. 
Suggest using more bootstrap samples for inference
> 
> # Not run: how to set up multiple cores
> # library(doParallel)
> # myCluster <- makeCluster(2) 
> # registerDoParallel(myCluster)
> # fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2,
> #              data = sim_data, useMCores = TRUE
> #              bs_samples = 500)
> # stopCluster(myCluster)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("imputeCens")
> ### * imputeCens
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: imputeCens
> ### Title: Impute Interval Censored Data from icenReg Regression Model
> ### Aliases: imputeCens
> 
> ### ** Examples
> 
> simdata <- simIC_weib(n = 500)
> 
> fit <- ic_par(cbind(l, u) ~ x1 + x2,
+               data = simdata)
> 
> imputedValues <- imputeCens(fit)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ir_clustBoot")
> ### * ir_clustBoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ir_clustBoot
> ### Title: Updates the covariance using cluster bootstrap
> ### Aliases: ir_clustBoot
> 
> ### ** Examples
> 
> # Simulating repeated measures data 
> simdata = simIC_cluster(nIDs = 10, nPerID = 4)
> 
> # Fitting with basic model
> fit = ic_par(cbind(l,u) ~ x1 + x2, data = simdata)
> fit

Model:  Cox PH
Dependency structure assumed: Independence
Baseline:  weibull 
Call: ic_par(formula = cbind(l, u) ~ x1 + x2, data = simdata)

          Estimate Exp(Est) Std.Error z-value         p
log_shape   0.9278   2.5290   0.24050   3.858 1.141e-04
log_scale   0.4893   1.6310   0.09028   5.420 5.951e-08
x1          1.7550   5.7810   0.60230   2.913 3.579e-03
x2         -0.3419   0.7104   0.24640  -1.388 1.652e-01

final llk =  -27.6929 
Iterations =  18 
> 
> # Updating covariance
> ir_clustBoot(fit, ID = simdata$ID, bs_samples = 10)
> # (Low number of bootstrap samples used for quick testing by CRAN, 
> # never use this few!!)
> 
> # Note that the SE's have changed from above
> fit

Model:  Cox PH
Dependency structure assumed: Repeated Measures
Baseline:  weibull 
Call: ic_par(formula = cbind(l, u) ~ x1 + x2, data = simdata)

          Estimate Exp(Est) Std.Error z-value         p
log_shape   0.9278   2.5290    0.2246   4.131 3.616e-05
log_scale   0.4893   1.6310    0.0696   7.031 2.052e-12
x1          1.7550   5.7810    0.7038   2.493 1.267e-02
x2         -0.3419   0.7104    0.2067  -1.654 9.816e-02

final llk =  NA: likelihood does not account for clustering 
Iterations =  18 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("lines.icenReg_fit")
> ### * lines.icenReg_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lines.icenReg_fit
> ### Title: Plotting for icenReg Fits
> ### Aliases: lines.icenReg_fit
> 
> ### ** Examples
> 
>  # Fitting mice data set
>  data(miceData)
>  miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData) 
>  
>  # Creating covariates we want plotted
>  newData <- data.frame(grp = c("ce", "ge"))
>  # Naming rows for legend
>  rownames(newData) <- c("Conventional", "Germ-Free")
>  
>  plot(miceFit, newdata = newData, 
+       col = c('blue', 'orange'))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("miceData")
> ### * miceData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: miceData
> ### Title: Lung Tumor Interval Censored Data from Hoel and Walburg 1972
> ### Aliases: miceData
> 
> ### ** Examples
> 
> data(miceData)
>  
> coxph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ grp, 
+                     bs_samples = 50,	
+                     data = miceData)
>  
> #In practice, more bootstrap samples should be used for inference
> #Keeping it quick for CRAN testing purposes 
>  
> summary(coxph_fit)

Model:  Cox PH
Dependency structure assumed: Independence
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    bs_samples = 50)

      Estimate Exp(Est) Std.Error z-value       p
grpge   0.6785    1.971    0.3984   1.703 0.08855

final llk =  -76.56894 
Iterations =  28 
Bootstrap Samples =  50 
WARNING: only  50  bootstrap samples used for standard errors. 
Suggest using more bootstrap samples for inference
> 
> 
> 
> cleanEx()
> nameEx("plot.icenReg_fit")
> ### * plot.icenReg_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.icenReg_fit
> ### Title: Plotting for icenReg Fits
> ### Aliases: plot.icenReg_fit
> 
> ### ** Examples
> 
>  # Fitting mice data set
>  data(miceData)
>  miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData) 
>  
>  # Creating covariates we want plotted
>  newData <- data.frame(grp = c("ce", "ge"))
>  # Naming rows for legend
>  rownames(newData) <- c("Conventional", "Germ-Free")
>  
>  plot(miceFit, newdata = newData, 
+       col = c('blue', 'orange'))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("predict.icenReg_fit")
> ### * predict.icenReg_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.icenReg_fit
> ### Title: Predictions from icenReg Regression Model
> ### Aliases: predict.icenReg_fit
> 
> ### ** Examples
> 
> simdata <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+                       inspections = 6,
+                       inspectLength = 1)
> 
> fit <- ic_par(cbind(l, u) ~ x1 + x2,
+               data = simdata)
> 
> imputedValues <- predict(fit)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("sampleSurv")
> ### * sampleSurv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sampleSurv
> ### Title: Samples fitted survival function
> ### Aliases: sampleSurv
> 
> ### ** Examples
> 
> data("IR_diabetes")
> fit <- ic_par(cbind(left, right) ~ gender, data = IR_diabetes)
> 
> newdata <- data.frame(gender = "male")
> time_samps <- sampleSurv(fit, newdata, 
+                          p = c(0.5, .9), 
+                          samples = 100)
> # 100 samples of the median and 90th percentile for males                        
> 
> prob_samps <- sampleSurv(fit, newdata, 
+                          q = c(10, 20),
+                          samples = 100)
> # 100 samples of the cumulative probability at t = 10 and 20 for males                        
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("simCS_weib")
> ### * simCS_weib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simCS_weib
> ### Title: Simulate Current Status Data
> ### Aliases: simCS_weib
> 
> ### ** Examples
> 
> simData <- simCS_weib()
> fit <- ic_par(cs2ic(time, event) ~ x1 + x2, data = simData)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("simDC_weib")
> ### * simDC_weib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simDC_weib
> ### Title: Simulate Doubly Censored Data
> ### Aliases: simDC_weib
> 
> ### ** Examples
> 
> simData <- simDC_weib()
> fit <- ic_par(cbind(l, u) ~ x1 + x2, data = simData)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("simIC_weib")
> ### * simIC_weib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simIC_weib
> ### Title: Simulates interval censored data from regression model with a
> ###   Weibull baseline
> ### Aliases: simIC_weib
> 
> ### ** Examples
> 
> set.seed(1)
> sim_data <- simIC_weib(n = 500, b1 = .3, b2 = -.3, model = 'ph', 
+                       shape = 2, scale = 2, inspections = 6, 
+                       inspectLength = 1)
> #simulates data from a cox-ph with beta weibull distribution.
> 
> diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, 
+            data = sim_data, model = 'po')
> diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2,
+            data = sim_data, model = 'ph')
> 
> #'ph' fit looks better than 'po'; the difference between the transformed survival
> #function looks more constant
> 
> 
> 
> cleanEx()
> nameEx("survCIs")
> ### * survCIs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: survCIs
> ### Title: Confidence/Credible intervals for survival curves
> ### Aliases: survCIs
> 
> ### ** Examples
> 
> data("IR_diabetes")
> fit <- ic_par(cbind(left, right) ~ gender, 
+                 data = IR_diabetes)
> 
> # Getting confidence intervals for survival curves
> # for males and females
> newdata <- data.frame(gender = c("male", "female"))
> rownames(newdata) <- c("Males", "Females")
> diab_cis <- survCIs(fit, newdata)
> diab_cis
Model call:
  ic_par(formula = cbind(left, right) ~ gender, data = IR_diabetes)
Credible Level = 0.95 
Rowname:  Males 
      Percentile estimate (mean) estimate (median)     lower     upper
 [1,]      0.025        5.225135          5.221808  4.755833  5.687929
 [2,]      0.075        7.776889          7.775739  7.242852  8.306276
 [3,]      0.125        9.407183          9.405695  8.841033  9.955926
 [4,]      0.175       10.703960         10.703166 10.125893 11.263777
 [5,]      0.225       11.824379         11.821540 11.239838 12.398086
 [6,]      0.275       12.837719         12.837884 12.249949 13.422395
 [7,]      0.325       13.782254         13.782794 13.178285 14.374960
 [8,]      0.375       14.682455         14.682203 14.072800 15.282533
 [9,]      0.425       15.555907         15.555945 14.938057 16.166177
[10,]      0.475       16.416667         16.417651 15.793487 17.039049
[11,]      0.525       17.277228         17.278847 16.648881 17.912890
[12,]      0.575       18.149943         18.151798 17.516175 18.793221
[13,]      0.625       19.048372         19.049640 18.401578 19.719880
[14,]      0.675       19.988981         19.990086 19.329989 20.676075
[15,]      0.725       20.993792         20.997238 20.310258 21.701485
[16,]      0.775       22.095315         22.098803 21.391592 22.843832
[17,]      0.825       23.347248         23.349567 22.600716 24.134572
[18,]      0.875       24.852544         24.854747 24.044483 25.703469
[19,]      0.925       26.862221         26.852676 25.979361 27.814327
[20,]      0.975       30.444137         30.433484 29.344793 31.598501
Rowname:  Females 
      Percentile estimate (mean) estimate (median)     lower     upper
 [1,]      0.025        4.991685          4.984287  4.552546  5.468704
 [2,]      0.075        7.431172          7.424357  6.902458  8.004787
 [3,]      0.125        8.989961          8.981274  8.412172  9.598286
 [4,]      0.175       10.229956         10.222611  9.617805 10.865419
 [5,]      0.225       11.301373         11.296349 10.663399 11.953152
 [6,]      0.275       12.270435         12.266189 11.609905 12.946210
 [7,]      0.325       13.173730         13.168359 12.497724 13.869872
 [8,]      0.375       14.034653         14.032235 13.336899 14.746009
 [9,]      0.425       14.870016         14.869149 14.150747 15.599773
[10,]      0.475       15.693261         15.692743 14.956037 16.433472
[11,]      0.525       16.516336         16.514897 15.758990 17.267488
[12,]      0.575       17.351052         17.349824 16.573056 18.125050
[13,]      0.625       18.210381         18.209176 17.418146 19.007144
[14,]      0.675       19.110072         19.107196 18.288191 19.932841
[15,]      0.725       20.071193         20.066159 19.215788 20.937197
[16,]      0.775       21.124842         21.120486 20.234261 22.030016
[17,]      0.825       22.322391         22.316761 21.376763 23.282623
[18,]      0.875       23.762331         23.756741 22.747353 24.768583
[19,]      0.925       25.684808         25.685934 24.593682 26.798277
[20,]      0.975       29.111441         29.105728 27.837935 30.440429
> 
> # Can add this to any plot
> plot(fit, newdata = newdata, 
+      cis = FALSE)
> # Would have been included by default
> lines(diab_cis, col = c("black", "red"))
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  4.161 0.864 4.166 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
