
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## This runs testme test script inst/testme/test-walkAST.R
> ## Don't edit - it was autogenerated by inst/testme/deploy.R
> globals:::testme("walkAST")
Test ‘walkAST’ ...
Sourcing 9 prologue scripts ...
01/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/001.load.R’
02/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/005.globals.R’
03/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/010.record-state.R’
04/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/030.imports.R’
05/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/050.utils.R’
06/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/090.context.R’
07/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/090.options.R’
08/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/091.envvars.R’
09/09 prologue script ‘/usr/local/lib/R/site-library/globals/testme/_prologue/995.detrius-connections.R’
Sourcing 9 prologue scripts ... done
Running test script: ‘/usr/local/lib/R/site-library/globals/testme/test-walkAST.R’

> library(globals)

> message("*** walkAST() ...")
*** walkAST() ...

> exprs <- list(null = quote(NULL), atomic = quote(1), 
+     atomic = quote("a"), atomic = quote(TRUE), assign = quote(a <- 1), 
+     assign = quote .... [TRUNCATED] 

> if (requireNamespace("methods")) {
+     exprs$s4 <- methods::getClass("MethodDefinition")
+     exprs$s7 <- asS3(methods::getClass("S4")@prototype, .... [TRUNCATED] 

> nullify <- function(e) NULL

> disp <- function(expr) {
+     cat("Expression:\n")
+     print(expr)
+     cat("str():\n")
+     try(str(expr))
+     cat(sprintf("typeof: %s\n", t .... [TRUNCATED] 

> for (kk in seq_along(exprs)) {
+     name <- names(exprs)[kk]
+     message(sprintf("- walkAST(<expression #%d (%s)>) ...", kk, 
+         sQuote(na .... [TRUNCATED] 
- walkAST(<expression #1 (‘null’)>) ...
Expression:
NULL
str():
 NULL
typeof: NULL
Expression:
NULL
str():
 NULL
typeof: NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #1 (‘null’)>) ... DONE
- walkAST(<expression #2 (‘atomic’)>) ...
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #2 (‘atomic’)>) ... DONE
- walkAST(<expression #3 (‘atomic’)>) ...
Expression:
[1] "a"
str():
 chr "a"
typeof: character
Expression:
[1] "a"
str():
 chr "a"
typeof: character
Expression:
[1] "a"
str():
 chr "a"
typeof: character
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #3 (‘atomic’)>) ... DONE
- walkAST(<expression #4 (‘atomic’)>) ...
Expression:
[1] TRUE
str():
 logi TRUE
typeof: logical
Expression:
[1] TRUE
str():
 logi TRUE
typeof: logical
Expression:
[1] TRUE
str():
 logi TRUE
typeof: logical
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #4 (‘atomic’)>) ... DONE
- walkAST(<expression #5 (‘assign’)>) ...
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
`<-`
str():
 symbol <-
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #5 (‘assign’)>) ... DONE
- walkAST(<expression #6 (‘assign’)>) ...
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
`<-`
str():
 symbol <-
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
a <- 1
str():
 language a <- 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : num 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #6 (‘assign’)>) ... DONE
- walkAST(<expression #7 (‘assign’)>) ...
Expression:
a <- b + 1
str():
 language a <- b + 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : language b + 1
Expression:
a <- b + 1
str():
 language a <- b + 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : language b + 1
Expression:
`<-`
str():
 symbol <-
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
`+`
str():
 symbol +
typeof: symbol
Expression:
b
str():
 symbol b
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
b + 1
str():
 language b + 1
typeof: language
as.list():
List of 3
 $ : symbol +
 $ : symbol b
 $ : num 1
Expression:
a <- b + 1
str():
 language a <- b + 1
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol a
 $ : language b + 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #7 (‘assign’)>) ... DONE
- walkAST(<expression #8 (‘assign’)>) ...
Expression:
x <- rnorm(20, mu = 0)
str():
 language x <- rnorm(20, mu = 0)
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol x
 $ : language rnorm(20, mu = 0)
Expression:
x <- rnorm(20, mu = 0)
str():
 language x <- rnorm(20, mu = 0)
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol x
 $ : language rnorm(20, mu = 0)
Expression:
`<-`
str():
 symbol <-
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
rnorm
str():
 symbol rnorm
typeof: symbol
Expression:
[1] 20
str():
 num 20
typeof: double
Expression:
[1] 0
str():
 num 0
typeof: double
Expression:
rnorm(20, mu = 0)
str():
 language rnorm(20, mu = 0)
typeof: language
as.list():
List of 3
 $   : symbol rnorm
 $   : num 20
 $ mu: num 0
Expression:
x <- rnorm(20, mu = 0)
str():
 language x <- rnorm(20, mu = 0)
typeof: language
as.list():
List of 3
 $ : symbol <-
 $ : symbol x
 $ : language rnorm(20, mu = 0)
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #8 (‘assign’)>) ... DONE
- walkAST(<expression #9 (‘index’)>) ...
Expression:
x[1, 1]
str():
 language x[1, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : num 1
 $ : num 1
Expression:
x[1, 1]
str():
 language x[1, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : num 1
 $ : num 1
Expression:
`[`
str():
 symbol [
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
x[1, 1]
str():
 language x[1, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : num 1
 $ : num 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #9 (‘index’)>) ... DONE
- walkAST(<expression #10 (‘index’)>) ...
Expression:
x[1:2, 1:2]
str():
 language x[1:2, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : language 1:2
 $ : language 1:2
Expression:
x[1:2, 1:2]
str():
 language x[1:2, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : language 1:2
 $ : language 1:2
Expression:
`[`
str():
 symbol [
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
`:`
str():
 symbol :
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 2
str():
 num 2
typeof: double
Expression:
1:2
str():
 language 1:2
typeof: language
as.list():
List of 3
 $ : symbol :
 $ : num 1
 $ : num 2
Expression:
`:`
str():
 symbol :
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 2
str():
 num 2
typeof: double
Expression:
1:2
str():
 language 1:2
typeof: language
as.list():
List of 3
 $ : symbol :
 $ : num 1
 $ : num 2
Expression:
x[1:2, 1:2]
str():
 language x[1:2, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : language 1:2
 $ : language 1:2
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #10 (‘index’)>) ... DONE
- walkAST(<expression #11 (‘index’)>) ...
Expression:
x[, 1:2]
str():
 language x[, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : language 1:2
Expression:
x[, 1:2]
str():
 language x[, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : language 1:2
Expression:
`[`
str():
 symbol [
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
`:`
str():
 symbol :
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 2
str():
 num 2
typeof: double
Expression:
1:2
str():
 language 1:2
typeof: language
as.list():
List of 3
 $ : symbol :
 $ : num 1
 $ : num 2
Expression:
x[, 1:2]
str():
 language x[, 1:2]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : language 1:2
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #11 (‘index’)>) ... DONE
- walkAST(<expression #12 (‘index’)>) ...
Expression:
x[, 1]
str():
 language x[, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : num 1
Expression:
x[, 1]
str():
 language x[, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : num 1
Expression:
`[`
str():
 symbol [
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
x[, 1]
str():
 language x[, 1]
typeof: language
as.list():
List of 4
 $ : symbol [
 $ : symbol x
 $ : symbol 
 $ : num 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #12 (‘index’)>) ... DONE
- walkAST(<expression #13 (‘fcn’)>) ...
Expression:
function(a = 1, b = 2) sum(c(a, b))
str():
 language function(a = 1, b = 2) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: num 2
 $ : language sum(c(a, b))
 $ : NULL
Expression:
function(a = 1, b = 2) sum(c(a, b))
str():
 language function(a = 1, b = 2) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: num 2
 $ : language sum(c(a, b))
 $ : NULL
Expression:
`function`
str():
 symbol function
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 2
str():
 num 2
typeof: double
Expression:
sum
str():
 symbol sum
typeof: symbol
Expression:
c
str():
 symbol c
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
b
str():
 symbol b
typeof: symbol
Expression:
c(a, b)
str():
 language c(a, b)
typeof: language
as.list():
List of 3
 $ : symbol c
 $ : symbol a
 $ : symbol b
Expression:
sum(c(a, b))
str():
 language sum(c(a, b))
typeof: language
as.list():
List of 2
 $ : symbol sum
 $ : language c(a, b)
Expression:
function(a = 1, b = 2) sum(c(a, b))
str():
 language function(a = 1, b = 2) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: num 2
 $ : language sum(c(a, b))
 $ : NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #13 (‘fcn’)>) ... DONE
- walkAST(<expression #14 (‘fcn’)>) ...
Expression:
function(a = 1, b) sum(c(a, b))
str():
 language function(a = 1, b) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: symbol 
 $ : language sum(c(a, b))
 $ : NULL
Expression:
function(a = 1, b) sum(c(a, b))
str():
 language function(a = 1, b) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: symbol 
 $ : language sum(c(a, b))
 $ : NULL
Expression:
`function`
str():
 symbol function
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
sum
str():
 symbol sum
typeof: symbol
Expression:
c
str():
 symbol c
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
b
str():
 symbol b
typeof: symbol
Expression:
c(a, b)
str():
 language c(a, b)
typeof: language
as.list():
List of 3
 $ : symbol c
 $ : symbol a
 $ : symbol b
Expression:
sum(c(a, b))
str():
 language sum(c(a, b))
typeof: language
as.list():
List of 2
 $ : symbol sum
 $ : language c(a, b)
Expression:
function(a = 1, b) sum(c(a, b))
str():
 language function(a = 1, b) sum(c(a, b))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 2
  ..$ a: num 1
  ..$ b: symbol 
 $ : language sum(c(a, b))
 $ : NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #14 (‘fcn’)>) ... DONE
- walkAST(<expression #15 (‘fcn’)>) ...
Expression:
function(a = 1, b = 2, ...) sum(c(a, b, ...))
str():
 language function(a = 1, b = 2, ...) sum(c(a, b, ...))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 3
  ..$ a  : num 1
  ..$ b  : num 2
  ..$ ...: symbol 
 $ : language sum(c(a, b, ...))
 $ : NULL
Expression:
function(a = 1, b = 2, ...) sum(c(a, b, ...))
str():
 language function(a = 1, b = 2, ...) sum(c(a, b, ...))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 3
  ..$ a  : num 1
  ..$ b  : num 2
  ..$ ...: symbol 
 $ : language sum(c(a, b, ...))
 $ : NULL
Expression:
`function`
str():
 symbol function
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
[1] 2
str():
 num 2
typeof: double
Expression:
sum
str():
 symbol sum
typeof: symbol
Expression:
c
str():
 symbol c
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
b
str():
 symbol b
typeof: symbol
Expression:
...
str():
 symbol ...
typeof: symbol
Expression:
c(a, b, ...)
str():
 language c(a, b, ...)
typeof: language
as.list():
List of 4
 $ : symbol c
 $ : symbol a
 $ : symbol b
 $ : symbol ...
Expression:
sum(c(a, b, ...))
str():
 language sum(c(a, b, ...))
typeof: language
as.list():
List of 2
 $ : symbol sum
 $ : language c(a, b, ...)
Expression:
function(a = 1, b = 2, ...) sum(c(a, b, ...))
str():
 language function(a = 1, b = 2, ...) sum(c(a, b, ...))
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 3
  ..$ a  : num 1
  ..$ b  : num 2
  ..$ ...: symbol 
 $ : language sum(c(a, b, ...))
 $ : NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #15 (‘fcn’)>) ... DONE
- walkAST(<expression #16 (‘fcn’)>) ...
Expression:
function(a = NULL) a
str():
 language function(a = NULL) a
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ a: NULL
 $ : symbol a
 $ : NULL
Expression:
function(a = NULL) a
str():
 language function(a = NULL) a
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ a: NULL
 $ : symbol a
 $ : NULL
Expression:
`function`
str():
 symbol function
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
function(a = NULL) a
str():
 language function(a = NULL) a
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ a: NULL
 $ : symbol a
 $ : NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #16 (‘fcn’)>) ... DONE
- walkAST(<expression #17 (‘ok’)>) ...
Expression:
function(...) sum(x, ...)
str():
 language function(...) sum(x, ...)
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ ...: symbol 
 $ : language sum(x, ...)
 $ : NULL
Expression:
function(...) sum(x, ...)
str():
 language function(...) sum(x, ...)
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ ...: symbol 
 $ : language sum(x, ...)
 $ : NULL
Expression:
`function`
str():
 symbol function
typeof: symbol
Expression:
sum
str():
 symbol sum
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
...
str():
 symbol ...
typeof: symbol
Expression:
sum(x, ...)
str():
 language sum(x, ...)
typeof: language
as.list():
List of 3
 $ : symbol sum
 $ : symbol x
 $ : symbol ...
Expression:
function(...) sum(x, ...)
str():
 language function(...) sum(x, ...)
typeof: language
as.list():
List of 4
 $ : symbol function
 $ :Dotted pair list of 1
  ..$ ...: symbol 
 $ : language sum(x, ...)
 $ : NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #17 (‘ok’)>) ... DONE
- walkAST(<expression #18 (‘warn’)>) ...
Expression:
sum(x, ...)
str():
 language sum(x, ...)
typeof: language
as.list():
List of 3
 $ : symbol sum
 $ : symbol x
 $ : symbol ...
Expression:
sum(x, ...)
str():
 language sum(x, ...)
typeof: language
as.list():
List of 3
 $ : symbol sum
 $ : symbol x
 $ : symbol ...
Expression:
sum
str():
 symbol sum
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
...
str():
 symbol ...
typeof: symbol
Expression:
sum(x, ...)
str():
 language sum(x, ...)
typeof: language
as.list():
List of 3
 $ : symbol sum
 $ : symbol x
 $ : symbol ...
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #18 (‘warn’)>) ... DONE
- walkAST(<expression #19 (‘null’)>) ...
Expression:
NULL
str():
 NULL
typeof: NULL
Expression:
NULL
str():
 NULL
typeof: NULL
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #19 (‘null’)>) ... DONE
- walkAST(<expression #20 (‘builtin’)>) ...
Expression:
function (x)  .Primitive("length")
str():
function (x)  
typeof: builtin
as.list():
List of 1
 $ : NULL
Expression:
function (x)  .Primitive("length")
str():
function (x)  
typeof: builtin
as.list():
List of 1
 $ : NULL
Expression:
function (x)  .Primitive("length")
str():
function (x)  
typeof: builtin
as.list():
List of 1
 $ : NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #20 (‘builtin’)>) ... DONE
- walkAST(<expression #21 (‘closure’)>) ...
Expression:
function () 
NULL
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : NULL
Expression:
function () 
NULL
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : NULL
Expression:
function () 
NULL
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #21 (‘closure’)>) ... DONE
- walkAST(<expression #22 (‘closure’)>) ...
Expression:
function () 
a
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : symbol a
Expression:
function () 
a
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : symbol a
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
function () 
NULL
str():
function ()  
typeof: closure
as.list():
List of 1
 $ : NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #22 (‘closure’)>) ... DONE
- walkAST(<expression #23 (‘closure’)>) ...
Expression:
function (x = 0) 
a * x
str():
function (x = 0)  
typeof: closure
as.list():
List of 2
 $ x: num 0
 $  : language a * x
Expression:
function (x = 0) 
a * x
str():
function (x = 0)  
typeof: closure
as.list():
List of 2
 $ x: num 0
 $  : language a * x
Expression:
`*`
str():
 symbol *
typeof: symbol
Expression:
a
str():
 symbol a
typeof: symbol
Expression:
x
str():
 symbol x
typeof: symbol
Expression:
a * x
str():
 language a * x
typeof: language
as.list():
List of 3
 $ : symbol *
 $ : symbol a
 $ : symbol x
Expression:
function (x = 0) 
NULL
str():
function (x = 0)  
typeof: closure
as.list():
List of 2
 $ x: num 0
 $  : NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #23 (‘closure’)>) ... DONE
- walkAST(<expression #24 (‘special’)>) ...
Expression:
function (x, base = exp(1))  .Primitive("log")
str():
function (x, base = exp(1))  
typeof: special
as.list():
List of 1
 $ : NULL
Expression:
function (x, base = exp(1))  .Primitive("log")
str():
function (x, base = exp(1))  
typeof: special
as.list():
List of 1
 $ : NULL
Expression:
function (x, base = exp(1))  .Primitive("log")
str():
function (x, base = exp(1))  
typeof: special
as.list():
List of 1
 $ : NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #24 (‘special’)>) ... DONE
- walkAST(<expression #25 (‘list’)>) ...
Expression:
FUN(a = list())
str():
 language FUN(a = list())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a: list()
Expression:
FUN(a = list())
str():
 language FUN(a = list())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a: list()
Expression:
FUN
str():
 symbol FUN
typeof: symbol
Expression:
list()
str():
 list()
typeof: list
as.list():
 list()
Expression:
FUN(a = list())
str():
 language FUN(a = list())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a: list()
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #25 (‘list’)>) ... DONE
- walkAST(<expression #26 (‘pairlist’)>) ...
Expression:
FUN(a = pairlist(a = 1))
str():
 language FUN(a = pairlist(a = 1))
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:Dotted pair list of 1
  ..$ a: num 1
Expression:
FUN(a = pairlist(a = 1))
str():
 language FUN(a = pairlist(a = 1))
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:Dotted pair list of 1
  ..$ a: num 1
Expression:
FUN
str():
 symbol FUN
typeof: symbol
Expression:
[1] 1
str():
 num 1
typeof: double
Expression:
FUN(a = pairlist(a = 1))
str():
 language FUN(a = pairlist(a = 1))
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:Dotted pair list of 1
  ..$ a: num 1
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #26 (‘pairlist’)>) ... DONE
- walkAST(<expression #27 (‘expression’)>) ...
Expression:
FUN(a = expression())
str():
 language FUN(a = expression())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:  expression()
Expression:
FUN(a = expression())
str():
 language FUN(a = expression())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:  expression()
Expression:
FUN
str():
 symbol FUN
typeof: symbol
Expression:
FUN(a = expression())
str():
 language FUN(a = expression())
typeof: language
as.list():
List of 2
 $  : symbol FUN
 $ a:  expression()
Expression:
NULL
str():
 NULL
typeof: NULL
*** walkAST() - nullify ... DONE
- walkAST(<expression #27 (‘expression’)>) ... DONE
- walkAST(<expression #28 (‘s4’)>) ...
Expression:
Class "MethodDefinition" [package "methods"]

Slots:
                                              
Name:      .Data    target   defined   generic
Class:  function signature signature character

Extends: 
Class "function", from data part
Class "OptionalFunction", by class "function", distance 2
Class "PossibleMethod", by class "function", distance 2
Class "optionalMethod", by class "function", distance 3

Known Subclasses: 
Class "derivedDefaultMethod", directly
Class "MethodWithNext", directly
Class "SealedMethodDefinition", directly
Class "MethodDefinitionWithTrace", directly
Class "internalDispatchMethod", by class "derivedDefaultMethod", distance 2
Class "MethodWithNextWithTrace", by class "MethodWithNext", distance 2
Class "derivedDefaultMethodWithTrace", by class "derivedDefaultMethod", distance 2
str():
Formal class 'classRepresentation' [package "methods"] with 11 slots
  ..@ slots     :List of 4
  .. ..$ .Data  : chr "function"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ target : chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ defined: chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ generic: chr "character"
  .. .. ..- attr(*, "package")= chr "methods"
  ..@ contains  :List of 4
  .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi TRUE
  .. .. .. ..@ distance  : num 1
  .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "OptionalFunction"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "PossibleMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "optionalMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 3
  ..@ virtual   : logi FALSE
  ..@ prototype :Formal class 'function' [package ""] with 0 slots
 list()
  .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ generic: chr(0) 
  ..@ validity  : NULL
  ..@ access    : list()
  ..@ className : chr "MethodDefinition"
  .. ..- attr(*, "package")= chr "methods"
  ..@ package   : chr "methods"
  ..@ subclasses:List of 7
  .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "internalDispatchMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  ..@ versionKey:<externalptr> 
  ..@ sealed    : logi TRUE
typeof: S4
Expression:
Class "MethodDefinition" [package "methods"]

Slots:
                                              
Name:      .Data    target   defined   generic
Class:  function signature signature character

Extends: 
Class "function", from data part
Class "OptionalFunction", by class "function", distance 2
Class "PossibleMethod", by class "function", distance 2
Class "optionalMethod", by class "function", distance 3

Known Subclasses: 
Class "derivedDefaultMethod", directly
Class "MethodWithNext", directly
Class "SealedMethodDefinition", directly
Class "MethodDefinitionWithTrace", directly
Class "internalDispatchMethod", by class "derivedDefaultMethod", distance 2
Class "MethodWithNextWithTrace", by class "MethodWithNext", distance 2
Class "derivedDefaultMethodWithTrace", by class "derivedDefaultMethod", distance 2
str():
Formal class 'classRepresentation' [package "methods"] with 11 slots
  ..@ slots     :List of 4
  .. ..$ .Data  : chr "function"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ target : chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ defined: chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ generic: chr "character"
  .. .. ..- attr(*, "package")= chr "methods"
  ..@ contains  :List of 4
  .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi TRUE
  .. .. .. ..@ distance  : num 1
  .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "OptionalFunction"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "PossibleMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "optionalMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 3
  ..@ virtual   : logi FALSE
  ..@ prototype :Formal class 'function' [package ""] with 0 slots
 list()
  .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ generic: chr(0) 
  ..@ validity  : NULL
  ..@ access    : list()
  ..@ className : chr "MethodDefinition"
  .. ..- attr(*, "package")= chr "methods"
  ..@ package   : chr "methods"
  ..@ subclasses:List of 7
  .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "internalDispatchMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  ..@ versionKey:<externalptr> 
  ..@ sealed    : logi TRUE
typeof: S4
Expression:
Class "MethodDefinition" [package "methods"]

Slots:
                                              
Name:      .Data    target   defined   generic
Class:  function signature signature character

Extends: 
Class "function", from data part
Class "OptionalFunction", by class "function", distance 2
Class "PossibleMethod", by class "function", distance 2
Class "optionalMethod", by class "function", distance 3

Known Subclasses: 
Class "derivedDefaultMethod", directly
Class "MethodWithNext", directly
Class "SealedMethodDefinition", directly
Class "MethodDefinitionWithTrace", directly
Class "internalDispatchMethod", by class "derivedDefaultMethod", distance 2
Class "MethodWithNextWithTrace", by class "MethodWithNext", distance 2
Class "derivedDefaultMethodWithTrace", by class "derivedDefaultMethod", distance 2
str():
Formal class 'classRepresentation' [package "methods"] with 11 slots
  ..@ slots     :List of 4
  .. ..$ .Data  : chr "function"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ target : chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ defined: chr "signature"
  .. .. ..- attr(*, "package")= chr "methods"
  .. ..$ generic: chr "character"
  .. .. ..- attr(*, "package")= chr "methods"
  ..@ contains  :List of 4
  .. ..$ function        :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi TRUE
  .. .. .. ..@ distance  : num 1
  .. ..$ OptionalFunction:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "OptionalFunction"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ PossibleMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "PossibleMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ optionalMethod  :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "optionalMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "function"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 3
  ..@ virtual   : logi FALSE
  ..@ prototype :Formal class 'function' [package ""] with 0 slots
 list()
  .. .. ..$ target :Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ defined:Formal class 'signature' [package "methods"] with 3 slots
  .. .. .. .. ..@ .Data  : chr(0) 
  .. .. .. .. ..@ names  : chr(0) 
  .. .. .. .. ..@ package: chr(0) 
  .. .. ..$ generic: chr(0) 
  ..@ validity  : NULL
  ..@ access    : list()
  ..@ className : chr "MethodDefinition"
  .. ..- attr(*, "package")= chr "methods"
  ..@ package   : chr "methods"
  ..@ subclasses:List of 7
  .. ..$ derivedDefaultMethod         :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodWithNext               :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ SealedMethodDefinition       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "SealedMethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ MethodDefinitionWithTrace    :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodDefinitionWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr(0) 
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 1
  .. ..$ internalDispatchMethod       :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "internalDispatchMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ MethodWithNextWithTrace      :Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "MethodWithNextWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "MethodWithNext"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  .. ..$ derivedDefaultMethodWithTrace:Formal class 'SClassExtension' [package "methods"] with 10 slots
  .. .. .. ..@ subClass  : chr "derivedDefaultMethodWithTrace"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ superClass: chr "MethodDefinition"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ package   : chr "methods"
  .. .. .. ..@ coerce    :function (from, strict = TRUE)  
  .. .. .. ..@ test      :function (object)  
  .. .. .. ..@ replace   :function (from, to, value)  
  .. .. .. ..@ simple    : logi TRUE
  .. .. .. ..@ by        : chr "derivedDefaultMethod"
  .. .. .. .. ..- attr(*, "package")= chr "methods"
  .. .. .. ..@ dataPart  : logi FALSE
  .. .. .. ..@ distance  : num 2
  ..@ versionKey:<externalptr> 
  ..@ sealed    : logi TRUE
typeof: S4
*** walkAST() - nullify ... DONE
- walkAST(<expression #28 (‘s4’)>) ... DONE
- walkAST(<expression #29 (‘s7’)>) ...
Expression:
<object>
str():
<object> 
typeof: object
Expression:
<object>
str():
<object> 
typeof: object
Expression:
<object>
str():
<object> 
typeof: object
*** walkAST() - nullify ... DONE
- walkAST(<expression #29 (‘s7’)>) ... DONE

> message("*** walkAST() - substitute = TRUE ...")
*** walkAST() - substitute = TRUE ...

> expr <- walkAST(a <- 1, substitute = TRUE)

> print(expr)
a <- 1

> message("*** walkAST() - substitute = TRUE ... DONE")
*** walkAST() - substitute = TRUE ... DONE

> message("*** walkAST() - exceptions ...")
*** walkAST() - exceptions ...

> f <- function(...) get("...")

> expr <- f(NULL)

> options(globals.walkAST.onUnknownType = "error")

> res <- tryCatch({
+     walkAST(expr)
+ }, error = identity)

> print(res)
<simpleError: Cannot walk expression. Unknown object type ‘...’>

> stopifnot(inherits(res, "simpleError"))

> options(globals.walkAST.onUnknownType = "warning")

> foo <- walkAST(expr)
Warning: Cannot walk expression. Unknown object type ‘...’

> res <- tryCatch({
+     walkAST(expr)
+ }, warning = identity)

> print(res)
<simpleWarning: Cannot walk expression. Unknown object type ‘...’>

> stopifnot(inherits(res, "simpleWarning"))

> options(globals.walkAST.onUnknownType = "error")

> message("*** walkAST() - exceptions ... DONE")
*** walkAST() - exceptions ... DONE

> message("*** walkAST() ... DONE")
*** walkAST() ... DONE
Sourcing 5 epilogue scripts ...
01/05 epilogue script ‘/usr/local/lib/R/site-library/globals/testme/_epilogue/002.undo-state.R’
02/05 epilogue script ‘/usr/local/lib/R/site-library/globals/testme/_epilogue/090.gc.R’
03/05 epilogue script ‘/usr/local/lib/R/site-library/globals/testme/_epilogue/099.session_info.R’
04/05 epilogue script ‘/usr/local/lib/R/site-library/globals/testme/_epilogue/995.detritus-connections.R’
05/05 epilogue script ‘/usr/local/lib/R/site-library/globals/testme/_epilogue/999.detritus-files.R’
Skipping, because path appears not to be an 'R CMD check' folder: ‘/tmp’
Sourcing 5 epilogue scripts ... done
Test time: user.self=0.3s, sys.self=0.01s, elapsed=0.3s, user.child=0s, sys.child=0s
Test ‘walkAST’ ... success
> 
