
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "lpSolve"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('lpSolve')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("lp")
> ### * lp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lp
> ### Title: Linear and Integer Programming
> ### Aliases: lp
> ### Keywords: optimize
> 
> ### ** Examples
> 
> #
> # Set up problem: maximize
> #   x1 + 9 x2 +   x3 subject to
> #   x1 + 2 x2 + 3 x3  <= 9
> # 3 x1 + 2 x2 + 2 x3 <= 15
> #
> f.obj <- c(1, 9, 1)
> f.con <- matrix (c(1, 2, 3, 3, 2, 2), nrow=2, byrow=TRUE)
> f.dir <- c("<=", "<=")
> f.rhs <- c(9, 15)
> #
> # Now run.
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs)
Success: the objective function is 40.5 
> ## Not run: Success: the objective function is 40.5
> lp ("max", f.obj, f.con, f.dir, f.rhs)$solution
[1] 0.0 4.5 0.0
> ## Not run: [1] 0.0 4.5 0.0
> #
> # The same problem using the dense constraint approach:
> #
> f.con.d <- matrix (c(rep (1:2,each=3), rep (1:3, 2), t(f.con)), ncol=3)
> lp ("max", f.obj, , f.dir, f.rhs, dense.const=f.con.d)
Success: the objective function is 40.5 
> ## Not run: Success: the objective function is 40.5
> #
> # Get sensitivities
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs, compute.sens=TRUE)$sens.coef.from
[1] -1e+30  2e+00 -1e+30
> ## Not run: [1] -1e+30  2e+00 -1e+30
> lp ("max", f.obj, f.con, f.dir, f.rhs, compute.sens=TRUE)$sens.coef.to  
[1] 4.50e+00 1.00e+30 1.35e+01
> ## Not run: [1] 4.50e+00 1.00e+30 1.35e+01
> #
> # Right now the dual values for the constraints and the variables are
> # combined, constraints coming first. So in this example...
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs, compute.sens=TRUE)$duals     
[1]   4.5   0.0  -3.5   0.0 -12.5
> ## Not run: [1]   4.5   0.0  -3.5   0.0 -10.5
> #
> # ...the duals of the constraints are 4.5 and 0, and of the variables,
> # -3.5, 0.0, -10.5. Here are the lower and upper limits on these:
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs, compute.sens=TRUE)$duals.from
[1] -1.776357e-15 -1.000000e+30 -1.000000e+30 -1.000000e+30 -6.000000e+00
> ## Not run: [1]  0e+00 -1e+30 -1e+30 -1e+30 -6e+00
> lp ("max", f.obj, f.con, f.dir, f.rhs, compute.sens=TRUE)$duals.to  
[1] 1.5e+01 1.0e+30 3.0e+00 1.0e+30 3.0e+00
> ## Not run: [1] 1.5e+01 1.0e+30 3.0e+00 1.0e+30 3.0e+00
> #
> # Run again, this time requiring that all three variables be integer
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs, int.vec=1:3)
Success: the objective function is 37 
> ## Not run: Success: the objective function is 37
> lp ("max", f.obj, f.con, f.dir, f.rhs, int.vec=1:3)$solution
[1] 1 4 0
> ## Not run: [1] 1 4 0
> #
> # You can get sensitivities in the integer case, but they're harder to
> # interpret.
> #
> lp ("max", f.obj, f.con, f.dir, f.rhs, int.vec=1:3, compute.sens=TRUE)$duals
[1]  1  0  0  7 -2
> ## Not run: [1] 1 0 0 7 0
> #
> # Here's an example in which we want more than one solution to a problem
> # in which all variables are binary: the 8-queens problem, 
> # with dense constraints.
> #
> chess.obj <- rep (1, 64)
> q8 <- make.q8 ()
> chess.dir <- rep (c("=", "<"), c(16, 26))
> chess.rhs <- rep (1, 42)
> lp ('max', chess.obj, , chess.dir, chess.rhs, dense.const = q8, 
+     all.bin=TRUE, num.bin.solns=3)
Success: the objective function is 8 
	 3 solutions returned
> 
> 
> 
> cleanEx()
> nameEx("lp.assign")
> ### * lp.assign
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lp.assign
> ### Title: Integer Programming for the Assignment Problem
> ### Aliases: lp.assign
> ### Keywords: optimize
> 
> ### ** Examples
> 
> assign.costs <- matrix (c(2, 7, 7, 2, 7, 7, 3, 2, 7, 2, 8, 10, 1, 9, 8, 2), 4, 4)
> ## Not run: 
> ##D > assign.costs
> ##D      [,1] [,2] [,3] [,4]
> ##D [1,]    2    7    7    1
> ##D [2,]    7    7    2    9
> ##D [3,]    7    3    8    8
> ##D [4,]    2    2   10    2
> ## End(Not run)
> lp.assign (assign.costs)
Success: the objective function is 8 
> ## Not run: Success: the objective function is 8
> lp.assign (assign.costs)$solution
     [,1] [,2] [,3] [,4]
[1,]    0    0    0    1
[2,]    0    0    1    0
[3,]    0    1    0    0
[4,]    1    0    0    0
> ## Not run: 
> ##D      [,1] [,2] [,3] [,4]
> ##D [1,]    0    0    0    1
> ##D [2,]    0    0    1    0
> ##D [3,]    0    1    0    0
> ##D [4,]    1    0    0    0
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lp.transport")
> ### * lp.transport
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lp.transport
> ### Title: Integer Programming for the Transportation Problem
> ### Aliases: lp.transport
> ### Keywords: optimize
> 
> ### ** Examples
> 
> #
> # Transportation problem, Bronson, problem 9.1, p. 86
> #
> # Set up cost matrix
> #
> costs <- matrix (10000, 8, 5); costs[4,1] <- costs[-4,5] <- 0
> costs[1,2] <- costs[2,3] <- costs[3,4] <- 7; costs[1,3] <- costs[2,4] <- 7.7
> costs[5,1] <- costs[7,3] <- 8; costs[1,4] <- 8.4; costs[6,2] <- 9
> costs[8,4] <- 10; costs[4,2:4] <- c(.7, 1.4, 2.1)
> #
> # Set up constraint signs and right-hand sides.
> #
> row.signs <- rep ("<", 8)
> row.rhs <- c(200, 300, 350, 200, 100, 50, 100, 150)
> col.signs <- rep (">", 5)
> col.rhs <- c(250, 100, 400, 500, 200)
> #
> # Run
> #
> lp.transport (costs, "min", row.signs, row.rhs, col.signs, col.rhs)
Success: the objective function is 7790 
> ## Not run: Success: the objective function is 7790
> lp.transport (costs, "min", row.signs, row.rhs, col.signs, col.rhs)$solution
     [,1] [,2] [,3] [,4] [,5]
[1,]    0  100  100    0    0
[2,]    0    0  200  100    0
[3,]    0    0    0  350    0
[4,]  200    0    0    0    0
[5,]   50    0    0    0   50
[6,]    0    0    0    0   50
[7,]    0    0  100    0    0
[8,]    0    0    0   50  100
> ## Not run: 
> ##D      [,1] [,2] [,3] [,4] [,5]
> ##D [1,]    0  100    0  100    0
> ##D [2,]    0    0  300    0    0
> ##D [3,]    0    0    0  350    0
> ##D [4,]  200    0    0    0    0
> ##D [5,]   50    0    0    0   50
> ##D [6,]    0    0    0    0   50
> ##D [7,]    0    0  100    0    0
> ##D [8,]    0    0    0   50  100
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.087 0.005 0.093 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
