
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "scales"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('scales')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("alpha")
> ### * alpha
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alpha
> ### Title: Modify colour transparency
> ### Aliases: alpha
> 
> ### ** Examples
> 
> alpha("red", 0.1)
[1] "#FF00001A"
> alpha(colours(), 0.5)
  [1] "#FFFFFF80" "#F0F8FF80" "#FAEBD780" "#FFEFDB80" "#EEDFCC80" "#CDC0B080"
  [7] "#8B837880" "#7FFFD480" "#7FFFD480" "#76EEC680" "#66CDAA80" "#458B7480"
 [13] "#F0FFFF80" "#F0FFFF80" "#E0EEEE80" "#C1CDCD80" "#838B8B80" "#F5F5DC80"
 [19] "#FFE4C480" "#FFE4C480" "#EED5B780" "#CDB79E80" "#8B7D6B80" "#00000080"
 [25] "#FFEBCD80" "#0000FF80" "#0000FF80" "#0000EE80" "#0000CD80" "#00008B80"
 [31] "#8A2BE280" "#A52A2A80" "#FF404080" "#EE3B3B80" "#CD333380" "#8B232380"
 [37] "#DEB88780" "#FFD39B80" "#EEC59180" "#CDAA7D80" "#8B735580" "#5F9EA080"
 [43] "#98F5FF80" "#8EE5EE80" "#7AC5CD80" "#53868B80" "#7FFF0080" "#7FFF0080"
 [49] "#76EE0080" "#66CD0080" "#458B0080" "#D2691E80" "#FF7F2480" "#EE762180"
 [55] "#CD661D80" "#8B451380" "#FF7F5080" "#FF725680" "#EE6A5080" "#CD5B4580"
 [61] "#8B3E2F80" "#6495ED80" "#FFF8DC80" "#FFF8DC80" "#EEE8CD80" "#CDC8B180"
 [67] "#8B887880" "#00FFFF80" "#00FFFF80" "#00EEEE80" "#00CDCD80" "#008B8B80"
 [73] "#00008B80" "#008B8B80" "#B8860B80" "#FFB90F80" "#EEAD0E80" "#CD950C80"
 [79] "#8B650880" "#A9A9A980" "#00640080" "#A9A9A980" "#BDB76B80" "#8B008B80"
 [85] "#556B2F80" "#CAFF7080" "#BCEE6880" "#A2CD5A80" "#6E8B3D80" "#FF8C0080"
 [91] "#FF7F0080" "#EE760080" "#CD660080" "#8B450080" "#9932CC80" "#BF3EFF80"
 [97] "#B23AEE80" "#9A32CD80" "#68228B80" "#8B000080" "#E9967A80" "#8FBC8F80"
[103] "#C1FFC180" "#B4EEB480" "#9BCD9B80" "#698B6980" "#483D8B80" "#2F4F4F80"
[109] "#97FFFF80" "#8DEEEE80" "#79CDCD80" "#528B8B80" "#2F4F4F80" "#00CED180"
[115] "#9400D380" "#FF149380" "#FF149380" "#EE128980" "#CD107680" "#8B0A5080"
[121] "#00BFFF80" "#00BFFF80" "#00B2EE80" "#009ACD80" "#00688B80" "#69696980"
[127] "#69696980" "#1E90FF80" "#1E90FF80" "#1C86EE80" "#1874CD80" "#104E8B80"
[133] "#B2222280" "#FF303080" "#EE2C2C80" "#CD262680" "#8B1A1A80" "#FFFAF080"
[139] "#228B2280" "#DCDCDC80" "#F8F8FF80" "#FFD70080" "#FFD70080" "#EEC90080"
[145] "#CDAD0080" "#8B750080" "#DAA52080" "#FFC12580" "#EEB42280" "#CD9B1D80"
[151] "#8B691480" "#BEBEBE80" "#00000080" "#03030380" "#05050580" "#08080880"
[157] "#0A0A0A80" "#0D0D0D80" "#0F0F0F80" "#12121280" "#14141480" "#17171780"
[163] "#1A1A1A80" "#1C1C1C80" "#1F1F1F80" "#21212180" "#24242480" "#26262680"
[169] "#29292980" "#2B2B2B80" "#2E2E2E80" "#30303080" "#33333380" "#36363680"
[175] "#38383880" "#3B3B3B80" "#3D3D3D80" "#40404080" "#42424280" "#45454580"
[181] "#47474780" "#4A4A4A80" "#4D4D4D80" "#4F4F4F80" "#52525280" "#54545480"
[187] "#57575780" "#59595980" "#5C5C5C80" "#5E5E5E80" "#61616180" "#63636380"
[193] "#66666680" "#69696980" "#6B6B6B80" "#6E6E6E80" "#70707080" "#73737380"
[199] "#75757580" "#78787880" "#7A7A7A80" "#7D7D7D80" "#7F7F7F80" "#82828280"
[205] "#85858580" "#87878780" "#8A8A8A80" "#8C8C8C80" "#8F8F8F80" "#91919180"
[211] "#94949480" "#96969680" "#99999980" "#9C9C9C80" "#9E9E9E80" "#A1A1A180"
[217] "#A3A3A380" "#A6A6A680" "#A8A8A880" "#ABABAB80" "#ADADAD80" "#B0B0B080"
[223] "#B3B3B380" "#B5B5B580" "#B8B8B880" "#BABABA80" "#BDBDBD80" "#BFBFBF80"
[229] "#C2C2C280" "#C4C4C480" "#C7C7C780" "#C9C9C980" "#CCCCCC80" "#CFCFCF80"
[235] "#D1D1D180" "#D4D4D480" "#D6D6D680" "#D9D9D980" "#DBDBDB80" "#DEDEDE80"
[241] "#E0E0E080" "#E3E3E380" "#E5E5E580" "#E8E8E880" "#EBEBEB80" "#EDEDED80"
[247] "#F0F0F080" "#F2F2F280" "#F5F5F580" "#F7F7F780" "#FAFAFA80" "#FCFCFC80"
[253] "#FFFFFF80" "#00FF0080" "#00FF0080" "#00EE0080" "#00CD0080" "#008B0080"
[259] "#ADFF2F80" "#BEBEBE80" "#00000080" "#03030380" "#05050580" "#08080880"
[265] "#0A0A0A80" "#0D0D0D80" "#0F0F0F80" "#12121280" "#14141480" "#17171780"
[271] "#1A1A1A80" "#1C1C1C80" "#1F1F1F80" "#21212180" "#24242480" "#26262680"
[277] "#29292980" "#2B2B2B80" "#2E2E2E80" "#30303080" "#33333380" "#36363680"
[283] "#38383880" "#3B3B3B80" "#3D3D3D80" "#40404080" "#42424280" "#45454580"
[289] "#47474780" "#4A4A4A80" "#4D4D4D80" "#4F4F4F80" "#52525280" "#54545480"
[295] "#57575780" "#59595980" "#5C5C5C80" "#5E5E5E80" "#61616180" "#63636380"
[301] "#66666680" "#69696980" "#6B6B6B80" "#6E6E6E80" "#70707080" "#73737380"
[307] "#75757580" "#78787880" "#7A7A7A80" "#7D7D7D80" "#7F7F7F80" "#82828280"
[313] "#85858580" "#87878780" "#8A8A8A80" "#8C8C8C80" "#8F8F8F80" "#91919180"
[319] "#94949480" "#96969680" "#99999980" "#9C9C9C80" "#9E9E9E80" "#A1A1A180"
[325] "#A3A3A380" "#A6A6A680" "#A8A8A880" "#ABABAB80" "#ADADAD80" "#B0B0B080"
[331] "#B3B3B380" "#B5B5B580" "#B8B8B880" "#BABABA80" "#BDBDBD80" "#BFBFBF80"
[337] "#C2C2C280" "#C4C4C480" "#C7C7C780" "#C9C9C980" "#CCCCCC80" "#CFCFCF80"
[343] "#D1D1D180" "#D4D4D480" "#D6D6D680" "#D9D9D980" "#DBDBDB80" "#DEDEDE80"
[349] "#E0E0E080" "#E3E3E380" "#E5E5E580" "#E8E8E880" "#EBEBEB80" "#EDEDED80"
[355] "#F0F0F080" "#F2F2F280" "#F5F5F580" "#F7F7F780" "#FAFAFA80" "#FCFCFC80"
[361] "#FFFFFF80" "#F0FFF080" "#F0FFF080" "#E0EEE080" "#C1CDC180" "#838B8380"
[367] "#FF69B480" "#FF6EB480" "#EE6AA780" "#CD609080" "#8B3A6280" "#CD5C5C80"
[373] "#FF6A6A80" "#EE636380" "#CD555580" "#8B3A3A80" "#FFFFF080" "#FFFFF080"
[379] "#EEEEE080" "#CDCDC180" "#8B8B8380" "#F0E68C80" "#FFF68F80" "#EEE68580"
[385] "#CDC67380" "#8B864E80" "#E6E6FA80" "#FFF0F580" "#FFF0F580" "#EEE0E580"
[391] "#CDC1C580" "#8B838680" "#7CFC0080" "#FFFACD80" "#FFFACD80" "#EEE9BF80"
[397] "#CDC9A580" "#8B897080" "#ADD8E680" "#BFEFFF80" "#B2DFEE80" "#9AC0CD80"
[403] "#68838B80" "#F0808080" "#E0FFFF80" "#E0FFFF80" "#D1EEEE80" "#B4CDCD80"
[409] "#7A8B8B80" "#EEDD8280" "#FFEC8B80" "#EEDC8280" "#CDBE7080" "#8B814C80"
[415] "#FAFAD280" "#D3D3D380" "#90EE9080" "#D3D3D380" "#FFB6C180" "#FFAEB980"
[421] "#EEA2AD80" "#CD8C9580" "#8B5F6580" "#FFA07A80" "#FFA07A80" "#EE957280"
[427] "#CD816280" "#8B574280" "#20B2AA80" "#87CEFA80" "#B0E2FF80" "#A4D3EE80"
[433] "#8DB6CD80" "#607B8B80" "#8470FF80" "#77889980" "#77889980" "#B0C4DE80"
[439] "#CAE1FF80" "#BCD2EE80" "#A2B5CD80" "#6E7B8B80" "#FFFFE080" "#FFFFE080"
[445] "#EEEED180" "#CDCDB480" "#8B8B7A80" "#32CD3280" "#FAF0E680" "#FF00FF80"
[451] "#FF00FF80" "#EE00EE80" "#CD00CD80" "#8B008B80" "#B0306080" "#FF34B380"
[457] "#EE30A780" "#CD299080" "#8B1C6280" "#66CDAA80" "#0000CD80" "#BA55D380"
[463] "#E066FF80" "#D15FEE80" "#B452CD80" "#7A378B80" "#9370DB80" "#AB82FF80"
[469] "#9F79EE80" "#8968CD80" "#5D478B80" "#3CB37180" "#7B68EE80" "#00FA9A80"
[475] "#48D1CC80" "#C7158580" "#19197080" "#F5FFFA80" "#FFE4E180" "#FFE4E180"
[481] "#EED5D280" "#CDB7B580" "#8B7D7B80" "#FFE4B580" "#FFDEAD80" "#FFDEAD80"
[487] "#EECFA180" "#CDB38B80" "#8B795E80" "#00008080" "#00008080" "#FDF5E680"
[493] "#6B8E2380" "#C0FF3E80" "#B3EE3A80" "#9ACD3280" "#698B2280" "#FFA50080"
[499] "#FFA50080" "#EE9A0080" "#CD850080" "#8B5A0080" "#FF450080" "#FF450080"
[505] "#EE400080" "#CD370080" "#8B250080" "#DA70D680" "#FF83FA80" "#EE7AE980"
[511] "#CD69C980" "#8B478980" "#EEE8AA80" "#98FB9880" "#9AFF9A80" "#90EE9080"
[517] "#7CCD7C80" "#548B5480" "#AFEEEE80" "#BBFFFF80" "#AEEEEE80" "#96CDCD80"
[523] "#668B8B80" "#DB709380" "#FF82AB80" "#EE799F80" "#CD688980" "#8B475D80"
[529] "#FFEFD580" "#FFDAB980" "#FFDAB980" "#EECBAD80" "#CDAF9580" "#8B776580"
[535] "#CD853F80" "#FFC0CB80" "#FFB5C580" "#EEA9B880" "#CD919E80" "#8B636C80"
[541] "#DDA0DD80" "#FFBBFF80" "#EEAEEE80" "#CD96CD80" "#8B668B80" "#B0E0E680"
[547] "#A020F080" "#9B30FF80" "#912CEE80" "#7D26CD80" "#551A8B80" "#FF000080"
[553] "#FF000080" "#EE000080" "#CD000080" "#8B000080" "#BC8F8F80" "#FFC1C180"
[559] "#EEB4B480" "#CD9B9B80" "#8B696980" "#4169E180" "#4876FF80" "#436EEE80"
[565] "#3A5FCD80" "#27408B80" "#8B451380" "#FA807280" "#FF8C6980" "#EE826280"
[571] "#CD705480" "#8B4C3980" "#F4A46080" "#2E8B5780" "#54FF9F80" "#4EEE9480"
[577] "#43CD8080" "#2E8B5780" "#FFF5EE80" "#FFF5EE80" "#EEE5DE80" "#CDC5BF80"
[583] "#8B868280" "#A0522D80" "#FF824780" "#EE794280" "#CD683980" "#8B472680"
[589] "#87CEEB80" "#87CEFF80" "#7EC0EE80" "#6CA6CD80" "#4A708B80" "#6A5ACD80"
[595] "#836FFF80" "#7A67EE80" "#6959CD80" "#473C8B80" "#70809080" "#C6E2FF80"
[601] "#B9D3EE80" "#9FB6CD80" "#6C7B8B80" "#70809080" "#FFFAFA80" "#FFFAFA80"
[607] "#EEE9E980" "#CDC9C980" "#8B898980" "#00FF7F80" "#00FF7F80" "#00EE7680"
[613] "#00CD6680" "#008B4580" "#4682B480" "#63B8FF80" "#5CACEE80" "#4F94CD80"
[619] "#36648B80" "#D2B48C80" "#FFA54F80" "#EE9A4980" "#CD853F80" "#8B5A2B80"
[625] "#D8BFD880" "#FFE1FF80" "#EED2EE80" "#CDB5CD80" "#8B7B8B80" "#FF634780"
[631] "#FF634780" "#EE5C4280" "#CD4F3980" "#8B362680" "#40E0D080" "#00F5FF80"
[637] "#00E5EE80" "#00C5CD80" "#00868B80" "#EE82EE80" "#D0209080" "#FF3E9680"
[643] "#EE3A8C80" "#CD327880" "#8B225280" "#F5DEB380" "#FFE7BA80" "#EED8AE80"
[649] "#CDBA9680" "#8B7E6680" "#F5F5F580" "#FFFF0080" "#FFFF0080" "#EEEE0080"
[655] "#CDCD0080" "#8B8B0080" "#9ACD3280"
> alpha("red", seq(0, 1, length.out = 10))
 [1] "#FF000000" "#FF00001C" "#FF000039" "#FF000055" "#FF000071" "#FF00008E"
 [7] "#FF0000AA" "#FF0000C6" "#FF0000E3" "#FF0000"  
> alpha(c("first" = "gold", "second" = "lightgray", "third" = "#cd7f32"), .5)
      first      second       third 
"#FFD70080" "#D3D3D380" "#CD7F3280" 
> 
> 
> 
> cleanEx()
> nameEx("breaks_exp")
> ### * breaks_exp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_exp
> ### Title: Breaks for exponentially transformed data
> ### Aliases: breaks_exp
> 
> ### ** Examples
> 
> # Small range
> demo_continuous(c(100, 102), transform = "exp", breaks = breaks_exp())
scale_x_continuous(transform = "exp", breaks = breaks_exp())
> # Large range
> demo_continuous(c(0, 100), transform = "exp", breaks = breaks_exp(n = 4))
scale_x_continuous(transform = "exp", breaks = breaks_exp(n = 4))
> 
> 
> 
> cleanEx()
> nameEx("breaks_extended")
> ### * breaks_extended
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_extended
> ### Title: Automatic breaks for numeric axes
> ### Aliases: breaks_extended extended_breaks
> 
> ### ** Examples
> 
> demo_continuous(c(0, 10))
scale_x_continuous()
> demo_continuous(c(0, 10), breaks = breaks_extended(3))
scale_x_continuous(breaks = breaks_extended(3))
> demo_continuous(c(0, 10), breaks = breaks_extended(10))
scale_x_continuous(breaks = breaks_extended(10))
> 
> 
> 
> cleanEx()
> nameEx("breaks_log")
> ### * breaks_log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_log
> ### Title: Breaks for log axes
> ### Aliases: breaks_log log_breaks
> 
> ### ** Examples
> 
> demo_log10(c(1, 1e5))
scale_x_log10()
> demo_log10(c(1, 1e6))
scale_x_log10()
> 
> # Request more breaks by setting n
> demo_log10(c(1, 1e6), breaks = breaks_log(6))
scale_x_log10(breaks = breaks_log(6))
> 
> # Some tricky ranges
> demo_log10(c(2000, 9000))
scale_x_log10()
> demo_log10(c(2000, 14000))
scale_x_log10()
> demo_log10(c(2000, 85000), expand = c(0, 0))
scale_x_log10(expand = c(0, 0))
> 
> # An even smaller range that requires falling back to linear breaks
> demo_log10(c(1800, 2000))
scale_x_log10()
> 
> 
> 
> cleanEx()
> nameEx("breaks_pretty")
> ### * breaks_pretty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_pretty
> ### Title: Pretty breaks for date/times
> ### Aliases: breaks_pretty
> 
> ### ** Examples
> 
> one_month <- as.POSIXct(c("2020-05-01", "2020-06-01"))
> demo_datetime(one_month)
scale_x_datetime()
> demo_datetime(one_month, breaks = breaks_pretty(2))
scale_x_datetime(breaks = breaks_pretty(2))
> demo_datetime(one_month, breaks = breaks_pretty(4))
scale_x_datetime(breaks = breaks_pretty(4))
> 
> # Tightly spaced date breaks often need custom labels too
> demo_datetime(one_month, breaks = breaks_pretty(12))
scale_x_datetime(breaks = breaks_pretty(12))
> demo_datetime(one_month,
+   breaks = breaks_pretty(12),
+   labels = label_date_short()
+ )
scale_x_datetime(breaks = breaks_pretty(12), labels = label_date_short())
> 
> 
> 
> cleanEx()
> nameEx("breaks_timespan")
> ### * breaks_timespan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_timespan
> ### Title: Breaks for timespan data
> ### Aliases: breaks_timespan
> 
> ### ** Examples
> 
> demo_timespan(seq(0, 100), breaks = breaks_timespan())
scale_x_continuous(breaks = breaks_timespan())
> 
> 
> 
> 
> cleanEx()
> nameEx("breaks_width")
> ### * breaks_width
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: breaks_width
> ### Title: Equally spaced breaks
> ### Aliases: breaks_width
> 
> ### ** Examples
> 
> demo_continuous(c(0, 100))
scale_x_continuous()
> demo_continuous(c(0, 100), breaks = breaks_width(10))
scale_x_continuous(breaks = breaks_width(10))
> demo_continuous(c(0, 100), breaks = breaks_width(20, -4))
scale_x_continuous(breaks = breaks_width(20, -4))
> demo_continuous(c(0, 100), breaks = breaks_width(20, 4))
scale_x_continuous(breaks = breaks_width(20, 4))
> 
> # This is also useful for dates
> one_month <- as.POSIXct(c("2020-05-01", "2020-06-01"))
> demo_datetime(one_month)
scale_x_datetime()
> demo_datetime(one_month, breaks = breaks_width("1 week"))
scale_x_datetime(breaks = breaks_width("1 week"))
> demo_datetime(one_month, breaks = breaks_width("5 days"))
scale_x_datetime(breaks = breaks_width("5 days"))
> # This is so useful that scale_x_datetime() has a shorthand:
> demo_datetime(one_month, date_breaks = "5 days")
scale_x_datetime(date_breaks = "5 days")
> 
> # hms times also work
> one_hour <- hms::hms(hours = 0:1)
> demo_time(one_hour)
scale_x_time()
> demo_time(one_hour, breaks = breaks_width("15 min"))
scale_x_time(breaks = breaks_width("15 min"))
> demo_time(one_hour, breaks = breaks_width("600 sec"))
scale_x_time(breaks = breaks_width("600 sec"))
> 
> # Offets are useful for years that begin on dates other than the 1st of
> # January, such as the UK financial year, which begins on the 1st of April.
> three_years <- as.POSIXct(c("2020-01-01", "2021-01-01", "2022-01-01"))
> demo_datetime(
+   three_years,
+   breaks = breaks_width("1 year", offset = "3 months")
+ )
scale_x_datetime(breaks = breaks_width("1 year", offset = "3 months"))
> 
> # The offset can be a vector, to create offsets that have compound units,
> # such as the UK fiscal (tax) year, which begins on the 6th of April.
> demo_datetime(
+   three_years,
+   breaks = breaks_width("1 year", offset = c("3 months", "5 days"))
+ )
scale_x_datetime(breaks = breaks_width("1 year", offset = c("3 months", 
    "5 days")))
> 
> 
> 
> cleanEx()
> nameEx("cbreaks")
> ### * cbreaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cbreaks
> ### Title: Compute breaks for continuous scale
> ### Aliases: cbreaks
> ### Keywords: internal
> 
> ### ** Examples
> 
> cbreaks(c(0, 100))
$breaks
[1]   0  25  50  75 100

$labels
[1] "0.0e+00" "2.5e+01" "5.0e+01" "7.5e+01" "1.0e+02"

> cbreaks(c(0, 100), breaks_pretty(3))
$breaks
[1]   0  50 100

$labels
[1] "0e+00" "5e+01" "1e+02"

> cbreaks(c(0, 100), breaks_pretty(10))
$breaks
 [1]   0  10  20  30  40  50  60  70  80  90 100

$labels
 [1] "0e+00" "1e+01" "2e+01" "3e+01" "4e+01" "5e+01" "6e+01" "7e+01" "8e+01"
[10] "9e+01" "1e+02"

> cbreaks(c(1, 100), log_breaks())
$breaks
[1]   1  10 100

$labels
[1] "1e+00" "1e+01" "1e+02"

> cbreaks(c(1, 1e4), log_breaks())
$breaks
[1]     1    10   100  1000 10000

$labels
[1] "1e+00" "1e+01" "1e+02" "1e+03" "1e+04"

> 
> cbreaks(c(0, 100), labels = math_format())
$breaks
[1]   0  25  50  75 100

$labels
expression(10^0, 10^25, 10^50, 10^75, 10^100)

> cbreaks(c(0, 1), labels = percent_format())
$breaks
[1] 0.00 0.25 0.50 0.75 1.00

$labels
[1] "0%"   "25%"  "50%"  "75%"  "100%"

> cbreaks(c(0, 1e6), labels = comma_format())
$breaks
[1]       0  250000  500000  750000 1000000

$labels
[1] "0"         "250,000"   "500,000"   "750,000"   "1,000,000"

> cbreaks(c(0, 1e6), labels = dollar_format())
$breaks
[1]       0  250000  500000  750000 1000000

$labels
[1] "$0"         "$250,000"   "$500,000"   "$750,000"   "$1,000,000"

> cbreaks(c(0, 30), labels = dollar_format())
$breaks
[1]  0 10 20 30

$labels
[1] "$0"  "$10" "$20" "$30"

> 
> # You can also specify them manually:
> cbreaks(c(0, 100), breaks = c(15, 20, 80))
$breaks
[1] 15 20 80

$labels
[1] "1.5e+01" "2.0e+01" "8.0e+01"

> cbreaks(c(0, 100), breaks = c(15, 20, 80), labels = c(1.5, 2.0, 8.0))
$breaks
[1] 15 20 80

$labels
[1] "1.5" "2"   "8"  

> cbreaks(c(0, 100),
+   breaks = c(15, 20, 80),
+   labels = expression(alpha, beta, gamma)
+ )
$breaks
[1] 15 20 80

$labels
$labels[[1]]
alpha

$labels[[2]]
beta

$labels[[3]]
gamma


> 
> 
> 
> cleanEx()
> nameEx("col2hcl")
> ### * col2hcl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: col2hcl
> ### Title: Modify standard R colour in hcl colour space.
> ### Aliases: col2hcl
> 
> ### ** Examples
> 
> reds <- rep("red", 6)
> show_col(col2hcl(reds, h = seq(0, 180, length = 6)))
> show_col(col2hcl(reds, c = seq(0, 80, length = 6)))
> show_col(col2hcl(reds, l = seq(0, 100, length = 6)))
> show_col(col2hcl(reds, alpha = seq(0, 1, length = 6)))
> 
> 
> 
> cleanEx()
> nameEx("col_mix")
> ### * col_mix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: col_mix
> ### Title: Mix colours
> ### Aliases: col_mix
> 
> ### ** Examples
> 
> col_mix("blue", "red") # purple
[1] "#800080FF"
> col_mix("blue", "red", amount = 1) # red
[1] "#FF0000FF"
> col_mix("blue", "red", amount = 0) # blue
[1] "#0000FFFF"
> 
> # Not recommended:
> col_mix("blue", "red", space = "hcl") # green!
[1] "#008800FF"
> 
> 
> 
> cleanEx()
> nameEx("col_numeric")
> ### * col_numeric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: col_numeric
> ### Title: Colour mapping
> ### Aliases: col_numeric col_bin col_quantile col_factor
> 
> ### ** Examples
> 
> pal <- col_bin("Greens", domain = 0:100)
> show_col(pal(sort(runif(10, 60, 100))))
> 
> # Exponential distribution, mapped continuously
> show_col(col_numeric("Blues", domain = NULL)(sort(rexp(16))))
> # Exponential distribution, mapped by interval
> show_col(col_bin("Blues", domain = NULL, bins = 4)(sort(rexp(16))))
> # Exponential distribution, mapped by quantile
> show_col(col_quantile("Blues", domain = NULL)(sort(rexp(16))))
> 
> # Categorical data; by default, the values being coloured span the gamut...
> show_col(col_factor("RdYlBu", domain = NULL)(LETTERS[1:5]))
> # ...unless the data is a factor, without droplevels...
> show_col(col_factor("RdYlBu", domain = NULL)(factor(LETTERS[1:5], levels = LETTERS)))
Warning in RColorBrewer::brewer.pal(n, pal) :
  n too large, allowed maximum for palette RdYlBu is 11
Returning the palette you asked for with that many colors

> # ...or the domain is stated explicitly.
> show_col(col_factor("RdYlBu", levels = LETTERS)(LETTERS[1:5]))
Warning in RColorBrewer::brewer.pal(n, pal) :
  n too large, allowed maximum for palette RdYlBu is 11
Returning the palette you asked for with that many colors

> 
> 
> 
> cleanEx()
> nameEx("colour_manip")
> ### * colour_manip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colour_manip
> ### Title: Colour manipulation
> ### Aliases: colour_manip col_shift col_lighter col_darker col_saturate
> 
> ### ** Examples
> 
> col_shift("red", 180) # teal
[1] "#00B8B8FF"
> col_lighter("red", 50) # light red
[1] "#FFFFFF"
> col_darker("red", 50) # dark red
[1] "#000000"
> col_saturate("red", -50) # brick-red
[1] "#BF4040"
> 
> 
> 
> cleanEx()
> nameEx("colour_ramp")
> ### * colour_ramp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colour_ramp
> ### Title: Fast colour interpolation
> ### Aliases: colour_ramp
> 
> ### ** Examples
> 
> ramp <- colour_ramp(c("red", "green", "blue"))
> show_col(ramp(seq(0, 1, length = 12)))
> 
> 
> 
> cleanEx()
> nameEx("compose_label")
> ### * compose_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compose_label
> ### Title: Compose two or more label formatters together
> ### Aliases: compose_label
> 
> ### ** Examples
> 
> demo_continuous(
+   c(-100, 100),
+   labels = compose_label(abs, number, \(x) paste0(x, " foobar"), toupper)
+ )
scale_x_continuous(labels = compose_label(abs, number, function(x) paste0(x, 
    " foobar"), toupper))
> 
> # Same result
> demo_continuous(
+   c(-100, 100),
+   labels = compose_label(abs, label_number(suffix = " FOOBAR"))
+ )
scale_x_continuous(labels = compose_label(abs, label_number(suffix = " FOOBAR")))
> 
> 
> 
> cleanEx()
> nameEx("cscale")
> ### * cscale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cscale
> ### Title: Continuous scale
> ### Aliases: cscale
> 
> ### ** Examples
> 
> with(mtcars, plot(disp, mpg, cex = cscale(hp, pal_rescale())))
> with(mtcars, plot(disp, mpg, cex = cscale(hp, pal_rescale(),
+   trans = transform_sqrt()
+ )))
> with(mtcars, plot(disp, mpg, cex = cscale(hp, pal_area())))
> with(mtcars, plot(disp, mpg,
+   pch = 20, cex = 5,
+   col = cscale(hp, pal_seq_gradient("grey80", "black"))
+ ))
> 
> 
> 
> cleanEx()
> nameEx("dscale")
> ### * dscale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dscale
> ### Title: Discrete scale
> ### Aliases: dscale
> 
> ### ** Examples
> 
> with(mtcars, plot(disp, mpg,
+   pch = 20, cex = 3,
+   col = dscale(factor(cyl), pal_brewer())
+ ))
> 
> 
> 
> cleanEx()
> nameEx("label_bytes")
> ### * label_bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_bytes
> ### Title: Label bytes (1 kB, 2 MB, etc)
> ### Aliases: label_bytes
> 
> ### ** Examples
> 
> demo_continuous(c(1, 1e6))
scale_x_continuous()
> demo_continuous(c(1, 1e6), labels = label_bytes())
scale_x_continuous(labels = label_bytes())
> 
> # Auto units are particularly nice on log scales
> demo_log10(c(1, 1e7), labels = label_bytes())
scale_x_log10(labels = label_bytes())
> 
> # You can also set the units
> demo_continuous(c(1, 1e6), labels = label_bytes("kB"))
scale_x_continuous(labels = label_bytes("kB"))
> 
> # You can also use binary units where a megabyte is defined as
> # (1024) ^ 2 bytes rather than (1000) ^ 2. You'll need to override
> # the default breaks to make this more informative.
> demo_continuous(c(1, 1024^2),
+   breaks = breaks_width(250 * 1024),
+   labels = label_bytes("auto_binary")
+ )
scale_x_continuous(breaks = breaks_width(250 * 1024), labels = label_bytes("auto_binary"))
> 
> 
> 
> cleanEx()
> nameEx("label_currency")
> ### * label_currency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_currency
> ### Title: Label currencies ($100, €2.50, etc)
> ### Aliases: label_currency
> 
> ### ** Examples
> 
> demo_continuous(c(0, 1), labels = label_currency())
scale_x_continuous(labels = label_currency())
> demo_continuous(c(1, 100), labels = label_currency())
scale_x_continuous(labels = label_currency())
> 
> # Customise currency display with prefix and suffix
> demo_continuous(c(1, 100), labels = label_currency(prefix = "USD "))
scale_x_continuous(labels = label_currency(prefix = "USD "))
> yen <- label_currency(
+   prefix = "¥",
+   suffix = "",
+   big.mark = ".",
+   decimal.mark = ","
+ )
> demo_continuous(c(1000, 1100), labels = yen)
scale_x_continuous(labels = yen)
> 
> # Use style_negative = "parens" for finance style display
> demo_continuous(c(-100, 100), labels = label_currency(style_negative = "parens"))
scale_x_continuous(labels = label_currency(style_negative = "parens"))
> 
> # Use scale_cut to use K/M/B where appropriate
> demo_log10(c(1, 1e16),
+   breaks = log_breaks(7, 1e3),
+   labels = label_currency(scale_cut = cut_short_scale())
+ )
scale_x_log10(breaks = log_breaks(7, 1000), labels = label_currency(scale_cut = cut_short_scale()))
> # cut_short_scale() uses B = one thousand million
> # cut_long_scale() uses B = one million million
> demo_log10(c(1, 1e16),
+   breaks = log_breaks(7, 1e3),
+   labels = label_currency(scale_cut = cut_long_scale())
+ )
scale_x_log10(breaks = log_breaks(7, 1000), labels = label_currency(scale_cut = cut_long_scale()))
> 
> # You can also define your own breaks
> gbp <- label_currency(
+   prefix = "\u00a3",
+   scale_cut = c(0, k = 1e3, m = 1e6, bn = 1e9, tn = 1e12)
+ )
> demo_log10(c(1, 1e12), breaks = log_breaks(5, 1e3), labels = gbp)
scale_x_log10(breaks = log_breaks(5, 1000), labels = gbp)
> 
> 
> 
> cleanEx()
> nameEx("label_date")
> ### * label_date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_date
> ### Title: Label date/times
> ### Aliases: label_date label_date_short label_time label_timespan
> 
> ### ** Examples
> 
> date_range <- function(start, days) {
+   start <- as.POSIXct(start)
+   c(start, start + days * 24 * 60 * 60)
+ }
> 
> two_months <- date_range("2020-05-01", 60)
> demo_datetime(two_months)
scale_x_datetime()
> demo_datetime(two_months, labels = label_date("%m/%d"))
scale_x_datetime(labels = label_date("%m/%d"))
> demo_datetime(two_months, labels = label_date("%e %b", locale = "fr"))
scale_x_datetime(labels = label_date("%e %b", locale = "fr"))
> demo_datetime(two_months, labels = label_date("%e %B", locale = "es"))
scale_x_datetime(labels = label_date("%e %B", locale = "es"))
> # ggplot2 provides a short-hand:
> demo_datetime(two_months, date_labels = "%m/%d")
scale_x_datetime(date_labels = "%m/%d")
> 
> # An alternative labelling system is label_date_short()
> demo_datetime(two_months, date_breaks = "7 days", labels = label_date_short())
scale_x_datetime(date_breaks = "7 days", labels = label_date_short())
> # This is particularly effective for dense labels
> one_year <- date_range("2020-05-01", 365)
> demo_datetime(one_year, date_breaks = "month")
scale_x_datetime(date_breaks = "month")
> demo_datetime(one_year, date_breaks = "month", labels = label_date_short())
scale_x_datetime(date_breaks = "month", labels = label_date_short())
> 
> 
> 
> cleanEx()
> nameEx("label_dictionary")
> ### * label_dictionary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_dictionary
> ### Title: Labels from lookup tables
> ### Aliases: label_dictionary
> 
> ### ** Examples
> 
> # Example lookup table
> lut <- c(
+   "4" = "four wheel drive",
+   "r" = "rear wheel drive",
+   "f" = "front wheel drive"
+ )
> 
> # Typical usage
> demo_discrete(c("4", "r", "f"), labels = label_dictionary(lut))
scale_x_discrete(labels = label_dictionary(lut))
> # By default, extra values ('w') will remain as-is
> demo_discrete(c("4", "r", "f", "w"), labels = label_dictionary(lut))
scale_x_discrete(labels = label_dictionary(lut))
> # Alternatively, you can relabel extra values
> demo_discrete(
+   c("4", "r", "f", "w"),
+   labels = label_dictionary(lut, nomatch = "unknown")
+ )
scale_x_discrete(labels = label_dictionary(lut, nomatch = "unknown"))
> 
> 
> 
> cleanEx()
> nameEx("label_glue")
> ### * label_glue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_glue
> ### Title: Interpolated labels
> ### Aliases: label_glue
> 
> ### ** Examples
> 
> # Example variables
> animal  <- "penguin"
> species <- c("Adelie",  "Chinstrap", "Emperor", "Gentoo")
> 
> # Typical use, note that {x} will become the breaks
> demo_discrete(species, labels = label_glue("The {x}\n{animal}"))
scale_x_discrete(labels = label_glue("The {x}\n{animal}"))
> # It adapts to the breaks that are present
> demo_discrete(species[-3], labels =  label_glue("The {x}\n{animal}"))
scale_x_discrete(labels = label_glue("The {x}\n{animal}"))
> # Contrary to directly glueing species + animal, which results in mislabelling!
> demo_discrete(species[-3], labels = glue::glue("The {species}\n{animal}"))
scale_x_discrete(labels = glue::glue("The {species}\n{animal}"))
> 
> 
> 
> cleanEx()
> nameEx("label_log")
> ### * label_log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_log
> ### Title: Label numbers in log format (10^3, 10^6, etc)
> ### Aliases: label_log format_log
> 
> ### ** Examples
> 
> demo_log10(c(1, 1e5), labels = label_log())
scale_x_log10(labels = label_log())
> demo_log10(c(1, 1e5), breaks = breaks_log(base = 2), labels = label_log(base = 2))
scale_x_log10(breaks = breaks_log(base = 2), labels = label_log(base = 2))
> format_log(c(0.1, 1, 10))
[1] "10^-1" "10^ 0" "10^ 1"
> 
> 
> 
> cleanEx()
> nameEx("label_number")
> ### * label_number
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_number
> ### Title: Label numbers in decimal format (e.g. 0.12, 1,234)
> ### Aliases: label_number label_comma
> 
> ### ** Examples
> 
> ## Don't show: 
> if (getRversion() >= "3.5") (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ demo_continuous(c(-1e6, 1e6))
+ demo_continuous(c(-1e6, 1e6), labels = label_number())
+ demo_continuous(c(-1e6, 1e6), labels = label_comma())
+ 
+ # Use scale to rescale very small or large numbers to generate
+ # more readable labels
+ demo_continuous(c(0, 1e6), labels = label_number())
+ demo_continuous(c(0, 1e6), labels = label_number(scale = 1 / 1e3))
+ demo_continuous(c(0, 1e-6), labels = label_number())
+ demo_continuous(c(0, 1e-6), labels = label_number(scale = 1e6))
+ 
+ #' Use scale_cut to automatically add prefixes for large/small numbers
+ demo_log10(
+   c(1, 1e9),
+   breaks = log_breaks(10),
+   labels = label_number(scale_cut = cut_short_scale())
+ )
+ demo_log10(
+   c(1, 1e9),
+   breaks = log_breaks(10),
+   labels = label_number(scale_cut = cut_si("m"))
+ )
+ demo_log10(
+   c(1e-9, 1),
+   breaks = log_breaks(10),
+   labels = label_number(scale_cut = cut_si("g"))
+ )
+ # use scale and scale_cut when data already uses SI prefix
+ # for example, if data was stored in kg
+ demo_log10(
+   c(1e-9, 1),
+   breaks = log_breaks(10),
+   labels = label_number(scale_cut = cut_si("g"), scale = 1e3)
+ )
+ 
+ #' # Use style arguments to vary the appearance of positive and negative numbers
+ demo_continuous(c(-1e3, 1e3), labels = label_number(
+   style_positive = "plus",
+   style_negative = "minus"
+ ))
+ demo_continuous(c(-1e3, 1e3), labels = label_number(style_negative = "parens"))
+ 
+ # You can use prefix and suffix for other types of display
+ demo_continuous(c(32, 212), labels = label_number(suffix = "\u00b0F"))
+ demo_continuous(c(0, 100), labels = label_number(suffix = "\u00b0C"))
+ ## Don't show: 
+ }) # examplesIf
> demo_continuous(c(-1e+06, 1e+06))
scale_x_continuous()
> demo_continuous(c(-1e+06, 1e+06), labels = label_number())
scale_x_continuous(labels = label_number())
> demo_continuous(c(-1e+06, 1e+06), labels = label_comma())
scale_x_continuous(labels = label_comma())
> demo_continuous(c(0, 1e+06), labels = label_number())
scale_x_continuous(labels = label_number())
> demo_continuous(c(0, 1e+06), labels = label_number(scale = 1/1000))
scale_x_continuous(labels = label_number(scale = 1/1000))
> demo_continuous(c(0, 1e-06), labels = label_number())
scale_x_continuous(labels = label_number())
> demo_continuous(c(0, 1e-06), labels = label_number(scale = 1e+06))
scale_x_continuous(labels = label_number(scale = 1e+06))
> demo_log10(c(1, 1e+09), breaks = log_breaks(10), labels = label_number(scale_cut = cut_short_scale()))
scale_x_log10(breaks = log_breaks(10), labels = label_number(scale_cut = cut_short_scale()))
> demo_log10(c(1, 1e+09), breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("m")))
scale_x_log10(breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("m")))
> demo_log10(c(1e-09, 1), breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("g")))
scale_x_log10(breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("g")))
> demo_log10(c(1e-09, 1), breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("g"), 
+     scale = 1000))
scale_x_log10(breaks = log_breaks(10), labels = label_number(scale_cut = cut_si("g"), 
    scale = 1000))
> demo_continuous(c(-1000, 1000), labels = label_number(style_positive = "plus", 
+     style_negative = "minus"))
scale_x_continuous(labels = label_number(style_positive = "plus", 
    style_negative = "minus"))
Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y,  :
  for '−1 000' in 'mbcsToSbcs': - substituted for − (U+2212)
Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y,  :
  for '−500' in 'mbcsToSbcs': - substituted for − (U+2212)
> demo_continuous(c(-1000, 1000), labels = label_number(style_negative = "parens"))
scale_x_continuous(labels = label_number(style_negative = "parens"))
> demo_continuous(c(32, 212), labels = label_number(suffix = "°F"))
scale_x_continuous(labels = label_number(suffix = "°F"))
> demo_continuous(c(0, 100), labels = label_number(suffix = "°C"))
scale_x_continuous(labels = label_number(suffix = "°C"))
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("label_number_auto")
> ### * label_number_auto
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_number_auto
> ### Title: Label numbers, avoiding scientific notation where possible
> ### Aliases: label_number_auto
> 
> ### ** Examples
> 
> # Very small and very large numbers get scientific notation
> demo_continuous(c(0, 1e-6), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> demo_continuous(c(0, 1e9), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> 
> # Other ranges get the numbers printed in full
> demo_continuous(c(0, 1e-3), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> demo_continuous(c(0, 1), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> demo_continuous(c(0, 1e3), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> demo_continuous(c(0, 1e6), labels = label_number_auto())
scale_x_continuous(labels = label_number_auto())
> 
> # Transformation is applied individually so you get as little
> # scientific notation as possible
> demo_log10(c(1, 1e7), labels = label_number_auto())
scale_x_log10(labels = label_number_auto())
> 
> 
> 
> cleanEx()
> nameEx("label_ordinal")
> ### * label_ordinal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_ordinal
> ### Title: Label ordinal numbers (1st, 2nd, 3rd, etc)
> ### Aliases: label_ordinal ordinal_english ordinal_french ordinal_spanish
> 
> ### ** Examples
> 
> demo_continuous(c(1, 5))
scale_x_continuous()
> demo_continuous(c(1, 5), labels = label_ordinal())
scale_x_continuous(labels = label_ordinal())
> demo_continuous(c(1, 5), labels = label_ordinal(rules = ordinal_french()))
scale_x_continuous(labels = label_ordinal(rules = ordinal_french()))
> 
> # The rules are just a set of regular expressions that are applied in turn
> ordinal_french()
$er
[1] "^1$"

$e
[1] "."

> ordinal_english()
$st
[1] "(?<!1)1$"

$nd
[1] "(?<!1)2$"

$rd
[1] "(?<!1)3$"

$th
[1] "(?<=1)[123]$"

$th
[1] "[0456789]$"

$th
[1] "."

> 
> # Note that ordinal rounds values, so you may need to adjust the breaks too
> demo_continuous(c(1, 10))
scale_x_continuous()
> demo_continuous(c(1, 10), labels = label_ordinal())
scale_x_continuous(labels = label_ordinal())
> demo_continuous(c(1, 10),
+   labels = label_ordinal(),
+   breaks = breaks_width(2)
+ )
scale_x_continuous(labels = label_ordinal(), breaks = breaks_width(2))
> 
> 
> 
> cleanEx()
> nameEx("label_parse")
> ### * label_parse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_parse
> ### Title: Label with mathematical annotations
> ### Aliases: label_parse label_math
> 
> ### ** Examples
> 
> # Use label_parse() with discrete scales
> greek <- c("alpha", "beta", "gamma")
> demo_discrete(greek)
scale_x_discrete()
> demo_discrete(greek, labels = label_parse())
scale_x_discrete(labels = label_parse())
> 
> # Use label_math() with continuous scales
> demo_continuous(c(1, 5))
scale_x_continuous()
> demo_continuous(c(1, 5), labels = label_math(alpha[.x]))
scale_x_continuous(labels = label_math(alpha[.x]))
> demo_continuous(c(1, 5), labels = label_math())
scale_x_continuous(labels = label_math())
> 
> 
> 
> cleanEx()
> nameEx("label_percent")
> ### * label_percent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_percent
> ### Title: Label percentages (2.5%, 50%, etc)
> ### Aliases: label_percent
> 
> ### ** Examples
> 
> demo_continuous(c(0, 1))
scale_x_continuous()
> demo_continuous(c(0, 1), labels = label_percent())
scale_x_continuous(labels = label_percent())
> 
> # Use prefix and suffix to create your own variants
> french_percent <- label_percent(
+   decimal.mark = ",",
+   suffix = " %"
+ )
> demo_continuous(c(0, .01), labels = french_percent)
scale_x_continuous(labels = french_percent)
> 
> 
> 
> cleanEx()
> nameEx("label_pvalue")
> ### * label_pvalue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_pvalue
> ### Title: Label p-values (e.g. <0.001, 0.25, p >= 0.99)
> ### Aliases: label_pvalue
> 
> ### ** Examples
> 
> demo_continuous(c(0, 1))
scale_x_continuous()
> demo_continuous(c(0, 1), labels = label_pvalue())
scale_x_continuous(labels = label_pvalue())
> demo_continuous(c(0, 1), labels = label_pvalue(accuracy = 0.1))
scale_x_continuous(labels = label_pvalue(accuracy = 0.1))
> demo_continuous(c(0, 1), labels = label_pvalue(add_p = TRUE))
scale_x_continuous(labels = label_pvalue(add_p = TRUE))
> 
> # Or provide your own prefixes
> prefix <- c("p < ", "p = ", "p > ")
> demo_continuous(c(0, 1), labels = label_pvalue(prefix = prefix))
scale_x_continuous(labels = label_pvalue(prefix = prefix))
> 
> 
> 
> cleanEx()
> nameEx("label_scientific")
> ### * label_scientific
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_scientific
> ### Title: Label numbers with scientific notation (e.g. 1e05, 1.5e-02)
> ### Aliases: label_scientific
> 
> ### ** Examples
> 
> demo_continuous(c(1, 10))
scale_x_continuous()
> demo_continuous(c(1, 10), labels = label_scientific())
scale_x_continuous(labels = label_scientific())
> demo_continuous(c(1, 10), labels = label_scientific(digits = 3))
scale_x_continuous(labels = label_scientific(digits = 3))
> 
> demo_log10(c(1, 1e9))
scale_x_log10()
> 
> 
> 
> cleanEx()
> nameEx("label_wrap")
> ### * label_wrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: label_wrap
> ### Title: Label strings by wrapping across multiple lines
> ### Aliases: label_wrap
> 
> ### ** Examples
> 
> x <- c(
+   "this is a long label",
+   "this is another long label",
+   "this a label this is even longer"
+ )
> demo_discrete(x)
scale_x_discrete()
> demo_discrete(x, labels = label_wrap(10))
scale_x_discrete(labels = label_wrap(10))
> demo_discrete(x, labels = label_wrap(20))
scale_x_discrete(labels = label_wrap(20))
> 
> 
> 
> cleanEx()
> nameEx("minor_breaks_log")
> ### * minor_breaks_log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: minor_breaks_log
> ### Title: Minor breaks for log-10 axes
> ### Aliases: minor_breaks_log
> 
> ### ** Examples
> 
> # Standard usage with log10 scale
> demo_log10(c(1, 1e10), minor_breaks = minor_breaks_log())
scale_x_log10(minor_breaks = minor_breaks_log())
> # Increasing detail over many powers
> demo_log10(c(1, 1e10), minor_breaks = minor_breaks_log(detail = 1))
scale_x_log10(minor_breaks = minor_breaks_log(detail = 1))
> # Adjusting until where to draw minor breaks
> demo_continuous(
+   c(-1000, 1000),
+   transform = asinh_trans(),
+   minor_breaks = minor_breaks_log(smallest = 1)
+ )
scale_x_continuous(transform = asinh_trans(), minor_breaks = minor_breaks_log(smallest = 1))
> 
> 
> 
> cleanEx()
> nameEx("minor_breaks_width")
> ### * minor_breaks_width
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: minor_breaks_width
> ### Title: Minor breaks
> ### Aliases: minor_breaks_width minor_breaks_n
> 
> ### ** Examples
> 
> demo_log10(c(1, 1e6))
scale_x_log10()
> if (FALSE) {
+   # Requires https://github.com/tidyverse/ggplot2/pull/3591
+   demo_log10(c(1, 1e6), minor_breaks = minor_breaks_n(10))
+ }
> 
> 
> 
> cleanEx()
> nameEx("muted")
> ### * muted
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: muted
> ### Title: Mute standard colour
> ### Aliases: muted
> 
> ### ** Examples
> 
> muted("red")
[1] "#832424"
> muted("blue")
[1] "#3A3A98"
> show_col(c("red", "blue", muted("red"), muted("blue")))
> 
> 
> 
> cleanEx()
> nameEx("new_continuous_palette")
> ### * new_continuous_palette
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_continuous_palette
> ### Title: Constructors for palettes
> ### Aliases: new_continuous_palette new_discrete_palette is_pal
> ###   is_continuous_pal is_discrete_pal is_colour_pal is_numeric_pal
> ###   palette_nlevels palette_na_safe palette_type as_discrete_pal
> ###   as_continuous_pal
> 
> ### ** Examples
> 
> # Creating a new discrete palette
> new_discrete_palette(
+   fun = grDevices::terrain.colors,
+   type = "colour", nlevels = 255
+ )
function (n, alpha, rev = FALSE) 
{
    if ((n <- as.integer(n[1L])) > 0) {
        k <- n%/%2
        h <- c(4/12, 2/12, 0/12)
        s <- c(1, 1, 0)
        v <- c(0.65, 0.9, 0.95)
        alpha <- if (missing(alpha) || is.null(alpha)) 
            NULL
        else rep_len(alpha, n)
        cols <- c(hsv(h = seq.int(h[1L], h[2L], length.out = k), 
            s = seq.int(s[1L], s[2L], length.out = k), v = seq.int(v[1L], 
                v[2L], length.out = k), alpha = alpha[seq_len(k)]), 
            hsv(h = seq.int(h[2L], h[3L], length.out = n - k + 
                1)[-1L], s = seq.int(s[2L], s[3L], length.out = n - 
                k + 1)[-1L], v = seq.int(v[2L], v[3L], length.out = n - 
                k + 1)[-1L], alpha = alpha[k + seq_len(n - k)]))
        if (rev) 
            rev(cols)
        else cols
    }
    else character()
}
<bytecode: 0x55eb938d49b8>
<environment: namespace:grDevices>
attr(,"class")
[1] "pal_discrete" "scales_pal"   "function"    
attr(,"type")
[1] "colour"
attr(,"nlevels")
[1] 255
> 
> # Creating a new continuous palette
> new_continuous_palette(
+   fun = function(x) rescale(x, to = c(1, 0)),
+   type = "numeric", na_safe = FALSE
+ )
function (x) 
rescale(x, to = c(1, 0))
attr(,"class")
[1] "pal_continuous" "scales_pal"     "function"      
attr(,"type")
[1] "numeric"
attr(,"na_safe")
[1] FALSE
> 
> # Testing palette properties
> is_continuous_pal(pal_seq_gradient())
[1] TRUE
> is_discrete_pal(pal_viridis())
[1] TRUE
> is_numeric_pal(pal_area())
[1] TRUE
> is_colour_pal(pal_manual(c("red", "green")))
[1] TRUE
> is_pal(transform_log10())
[1] FALSE
> 
> # Extracting properties
> palette_nlevels(pal_viridis())
[1] 255
> palette_na_safe(colour_ramp(c("red", "green"), na.color = "grey50"))
[1] TRUE
> palette_type(pal_shape())
[1] "shape"
> 
> # Switching discrete to continuous
> pal <- as_continuous_pal(pal_viridis())
> show_col(pal(c(0, 0.1, 0.2, 0.4, 1)))
> 
> # Switching continuous to discrete
> pal <- as_discrete_pal(pal_div_gradient())
> show_col(pal(9))
> 
> 
> 
> cleanEx()
> nameEx("number_options")
> ### * number_options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: number_options
> ### Title: Number options
> ### Aliases: number_options
> 
> ### ** Examples
> 
> # Default number formatting
> x <- c(0.1, 1, 1000)
> label_number()(x)
[1] "0.1"     "1.0"     "1 000.0"
> 
> # Now again with new options set
> number_options(style_positive = "plus", decimal.mark = ",")
> label_number()(x)
[1] "+0,1"     "+1,0"     "+1 000,0"
> 
> # The options are the argument names with a 'scales.'-prefix
> options("scales.style_positive")
$scales.style_positive
[1] "plus"

> 
> # Resetting the options to their defaults
> number_options()
> label_number()(x)
[1] "0.1"     "1.0"     "1 000.0"
> 
> 
> 
> cleanEx()
> nameEx("oob")
> ### * oob
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: oob
> ### Title: Out of bounds handling
> ### Aliases: oob oob_censor oob_censor_any oob_discard oob_squish
> ###   oob_squish_any oob_squish_infinite oob_keep censor discard squish
> ###   squish_infinite
> 
> ### ** Examples
> 
> # Censoring replaces out of bounds values with NAs
> oob_censor(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1] -Inf   NA  0.5  1.0   NA   NA  Inf
> oob_censor_any(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1]  NA  NA 0.5 1.0  NA  NA  NA
> 
> # Squishing replaces out of bounds values with the nearest range limit
> oob_squish(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1] -Inf  0.0  0.5  1.0  1.0   NA  Inf
> oob_squish_any(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1] 0.0 0.0 0.5 1.0 1.0  NA 1.0
> oob_squish_infinite(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1]  0.0 -1.0  0.5  1.0  2.0   NA  1.0
> 
> # Keeping does not alter values
> oob_keep(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1] -Inf -1.0  0.5  1.0  2.0   NA  Inf
> 
> # Discarding will remove out of bounds values
> oob_discard(c(-Inf, -1, 0.5, 1, 2, NA, Inf))
[1] 0.5 1.0  NA
> 
> 
> 
> cleanEx()
> nameEx("pal_brewer")
> ### * pal_brewer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_brewer
> ### Title: Colour Brewer palette (discrete)
> ### Aliases: pal_brewer brewer_pal
> 
> ### ** Examples
> 
> show_col(pal_brewer()(10))
Warning in RColorBrewer::brewer.pal(n, pal) :
  n too large, allowed maximum for palette Blues is 9
Returning the palette you asked for with that many colors

> show_col(pal_brewer("div")(5))
> show_col(pal_brewer(palette = "Greens")(5))
> 
> # Can use with gradient_n to create a continuous gradient
> cols <- pal_brewer("div")(5)
> show_col(pal_gradient_n(cols)(seq(0, 1, length.out = 30)))
> 
> 
> 
> cleanEx()
> nameEx("pal_dichromat")
> ### * pal_dichromat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_dichromat
> ### Title: Dichromat (colour-blind) palette (discrete)
> ### Aliases: pal_dichromat dichromat_pal
> 
> ### ** Examples
> 
> if (requireNamespace("dichromat", quietly = TRUE)) {
+   show_col(pal_dichromat("BluetoOrange.10")(10))
+   show_col(pal_dichromat("BluetoOrange.10")(5))
+ 
+   # Can use with gradient_n to create a continuous gradient
+   cols <- pal_dichromat("DarkRedtoBlue.12")(12)
+   show_col(pal_gradient_n(cols)(seq(0, 1, length.out = 30)))
+ }
> 
> 
> 
> cleanEx()
> nameEx("pal_div_gradient")
> ### * pal_div_gradient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_div_gradient
> ### Title: Diverging colour gradient (continuous).
> ### Aliases: pal_div_gradient div_gradient_pal
> 
> ### ** Examples
> 
> x <- seq(-1, 1, length.out = 100)
> r <- sqrt(outer(x^2, x^2, "+"))
> image(r, col = pal_div_gradient()(seq(0, 1, length.out = 12)))
> image(r, col = pal_div_gradient()(seq(0, 1, length.out = 30)))
> image(r, col = pal_div_gradient()(seq(0, 1, length.out = 100)))
> 
> pal <- pal_div_gradient(low = "#2E6A70")
> image(r, col = pal(seq(0, 1, length.out = 100)))
> 
> 
> 
> cleanEx()
> nameEx("pal_grey")
> ### * pal_grey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_grey
> ### Title: Grey scale palette (discrete)
> ### Aliases: pal_grey grey_pal
> 
> ### ** Examples
> 
> show_col(pal_grey()(25))
> show_col(pal_grey(0, 1)(25))
> 
> 
> 
> cleanEx()
> nameEx("pal_hue")
> ### * pal_hue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_hue
> ### Title: Hue palette (discrete)
> ### Aliases: pal_hue hue_pal
> 
> ### ** Examples
> 
> show_col(pal_hue()(4))
> show_col(pal_hue()(9))
> show_col(pal_hue(l = 90)(9))
> show_col(pal_hue(l = 30)(9))
> 
> show_col(pal_hue()(9))
> show_col(pal_hue(direction = -1)(9))
> show_col(pal_hue(h.start = 30)(9))
> show_col(pal_hue(h.start = 90)(9))
> 
> show_col(pal_hue()(9))
> show_col(pal_hue(h = c(0, 90))(9))
> show_col(pal_hue(h = c(90, 180))(9))
> show_col(pal_hue(h = c(180, 270))(9))
> show_col(pal_hue(h = c(270, 360))(9))
> 
> 
> 
> cleanEx()
> nameEx("pal_seq_gradient")
> ### * pal_seq_gradient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_seq_gradient
> ### Title: Sequential colour gradient palette (continuous)
> ### Aliases: pal_seq_gradient seq_gradient_pal
> 
> ### ** Examples
> 
> x <- seq(0, 1, length.out = 25)
> show_col(pal_seq_gradient()(x))
> show_col(pal_seq_gradient("white", "black")(x))
> 
> show_col(pal_seq_gradient("white", "#90503F")(x))
> 
> 
> 
> cleanEx()
> nameEx("pal_viridis")
> ### * pal_viridis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pal_viridis
> ### Title: Viridis palette
> ### Aliases: pal_viridis viridis_pal
> 
> ### ** Examples
> 
> show_col(pal_viridis()(10))
> show_col(pal_viridis(direction = -1)(6))
> show_col(pal_viridis(begin = 0.2, end = 0.8)(4))
> show_col(pal_viridis(option = "plasma")(6))
> 
> 
> 
> cleanEx()
> nameEx("regular_minor_breaks")
> ### * regular_minor_breaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regular_minor_breaks
> ### Title: Minor breaks
> ### Aliases: regular_minor_breaks
> ### Keywords: internal
> 
> ### ** Examples
> 
> m <- extended_breaks()(c(1, 10))
> regular_minor_breaks()(m, c(1, 10), n = 2)
[1]  0.00  1.25  2.50  3.75  5.00  6.25  7.50  8.75 10.00
> 
> n <- extended_breaks()(c(0, -9))
> regular_minor_breaks(reverse = TRUE)(n, c(0, -9), n = 2)
[1] -10.00  -8.75  -7.50  -6.25  -5.00  -3.75  -2.50  -1.25   0.00
> 
> 
> 
> cleanEx()
> nameEx("rescale")
> ### * rescale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale
> ### Title: Rescale continuous vector to have specified minimum and maximum
> ### Aliases: rescale rescale.numeric rescale.dist rescale.logical
> ###   rescale.POSIXt rescale.Date rescale.integer64 rescale.difftime
> ###   rescale.AsIs
> ### Keywords: manip
> 
> ### ** Examples
> 
> rescale(1:100)
  [1] 0.00000000 0.01010101 0.02020202 0.03030303 0.04040404 0.05050505
  [7] 0.06060606 0.07070707 0.08080808 0.09090909 0.10101010 0.11111111
 [13] 0.12121212 0.13131313 0.14141414 0.15151515 0.16161616 0.17171717
 [19] 0.18181818 0.19191919 0.20202020 0.21212121 0.22222222 0.23232323
 [25] 0.24242424 0.25252525 0.26262626 0.27272727 0.28282828 0.29292929
 [31] 0.30303030 0.31313131 0.32323232 0.33333333 0.34343434 0.35353535
 [37] 0.36363636 0.37373737 0.38383838 0.39393939 0.40404040 0.41414141
 [43] 0.42424242 0.43434343 0.44444444 0.45454545 0.46464646 0.47474747
 [49] 0.48484848 0.49494949 0.50505051 0.51515152 0.52525253 0.53535354
 [55] 0.54545455 0.55555556 0.56565657 0.57575758 0.58585859 0.59595960
 [61] 0.60606061 0.61616162 0.62626263 0.63636364 0.64646465 0.65656566
 [67] 0.66666667 0.67676768 0.68686869 0.69696970 0.70707071 0.71717172
 [73] 0.72727273 0.73737374 0.74747475 0.75757576 0.76767677 0.77777778
 [79] 0.78787879 0.79797980 0.80808081 0.81818182 0.82828283 0.83838384
 [85] 0.84848485 0.85858586 0.86868687 0.87878788 0.88888889 0.89898990
 [91] 0.90909091 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596
 [97] 0.96969697 0.97979798 0.98989899 1.00000000
> rescale(runif(50))
 [1] 0.25765383 0.36660990 0.57174657 0.91446402 0.19242572 0.90443035
 [7] 0.95173218 0.66162190 0.62924251 0.04945852 0.19681261 0.16674889
[13] 0.68842275 0.37885275 0.77305969 0.49494237 0.71969017 1.00000000
[19] 0.37469488 0.78083044 0.94154324 0.20311598 0.65229755 0.11462745
[25] 0.25940342 0.38090726 0.00000000 0.37709932 0.87510140 0.33413735
[31] 0.47898031 0.59904553 0.49069314 0.17662185 0.83185475 0.66945923
[37] 0.79799382 0.09662930 0.72591637 0.40662002 0.82528662 0.64758268
[43] 0.78643846 0.55149442 0.52766574 0.79300296 0.01015913 0.47402377
[49] 0.73470805 0.69425680
> rescale(1)
[1] 0.5
> 
> 
> 
> cleanEx()
> nameEx("rescale_max")
> ### * rescale_max
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale_max
> ### Title: Rescale numeric vector to have specified maximum
> ### Aliases: rescale_max
> 
> ### ** Examples
> 
> rescale_max(1:100)
  [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15
 [16] 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30
 [31] 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45
 [46] 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60
 [61] 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75
 [76] 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90
 [91] 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00
> rescale_max(runif(50))
 [1] 0.26767520 0.37516041 0.57752782 0.91561872 0.20332765 0.90572050
 [7] 0.95238377 0.66618987 0.63424758 0.06229044 0.20765532 0.17799745
[13] 0.69262892 0.38723799 0.77612329 0.50176044 0.72347424 1.00000000
[19] 0.38313625 0.78378914 0.94233238 0.21387359 0.65699139 0.12657962
[25] 0.26940118 0.38926476 0.01349960 0.38550822 0.87678748 0.34312623
[31] 0.48601387 0.60445825 0.49756858 0.18773713 0.83412464 0.67392139
[37] 0.80072082 0.10882444 0.72961639 0.41463041 0.82764518 0.65234017
[43] 0.78932146 0.55754906 0.53404207 0.79579734 0.02352158 0.48112424
[49] 0.73828938 0.69838421
> rescale_max(1)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("rescale_mid")
> ### * rescale_mid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale_mid
> ### Title: Rescale vector to have specified minimum, midpoint, and maximum
> ### Aliases: rescale_mid rescale_mid.numeric rescale_mid.logical
> ###   rescale_mid.dist rescale_mid.POSIXt rescale_mid.Date
> ###   rescale_mid.integer64 rescale_mid.AsIs
> 
> ### ** Examples
> 
> rescale_mid(1:100, mid = 50.5)
  [1] 0.00000000 0.01010101 0.02020202 0.03030303 0.04040404 0.05050505
  [7] 0.06060606 0.07070707 0.08080808 0.09090909 0.10101010 0.11111111
 [13] 0.12121212 0.13131313 0.14141414 0.15151515 0.16161616 0.17171717
 [19] 0.18181818 0.19191919 0.20202020 0.21212121 0.22222222 0.23232323
 [25] 0.24242424 0.25252525 0.26262626 0.27272727 0.28282828 0.29292929
 [31] 0.30303030 0.31313131 0.32323232 0.33333333 0.34343434 0.35353535
 [37] 0.36363636 0.37373737 0.38383838 0.39393939 0.40404040 0.41414141
 [43] 0.42424242 0.43434343 0.44444444 0.45454545 0.46464646 0.47474747
 [49] 0.48484848 0.49494949 0.50505051 0.51515152 0.52525253 0.53535354
 [55] 0.54545455 0.55555556 0.56565657 0.57575758 0.58585859 0.59595960
 [61] 0.60606061 0.61616162 0.62626263 0.63636364 0.64646465 0.65656566
 [67] 0.66666667 0.67676768 0.68686869 0.69696970 0.70707071 0.71717172
 [73] 0.72727273 0.73737374 0.74747475 0.75757576 0.76767677 0.77777778
 [79] 0.78787879 0.79797980 0.80808081 0.81818182 0.82828283 0.83838384
 [85] 0.84848485 0.85858586 0.86868687 0.87878788 0.88888889 0.89898990
 [91] 0.90909091 0.91919192 0.92929293 0.93939394 0.94949495 0.95959596
 [97] 0.96969697 0.97979798 0.98989899 1.00000000
> rescale_mid(runif(50), mid = 0.5)
 [1] 0.261650303 0.370019805 0.574052105 0.914924509 0.196773356 0.904944855
 [7] 0.951992030 0.663443586 0.631238508 0.054575828 0.201136631 0.171234763
[13] 0.690100152 0.382196741 0.774281436 0.497661385 0.721199240 1.000000000
[19] 0.378061258 0.782010351 0.941857944 0.207406066 0.654169432 0.119393917
[25] 0.263390479 0.384240195 0.005383576 0.380452749 0.875773801 0.337722072
[31] 0.481785259 0.601204098 0.493435035 0.181054573 0.832759974 0.671238718
[37] 0.799081333 0.101492665 0.727391923 0.409814524 0.826227198 0.649479947
[43] 0.787588185 0.553908980 0.530208591 0.794117348 0.015488014 0.476855405
[49] 0.736136268 0.695902794
> rescale_mid(1)
[1] 0.5
> 
> 
> 
> cleanEx()
> nameEx("rescale_none")
> ### * rescale_none
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rescale_none
> ### Title: Don't perform rescaling
> ### Aliases: rescale_none
> 
> ### ** Examples
> 
> rescale_none(1:100)
  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
 [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
 [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72
 [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
 [91]  91  92  93  94  95  96  97  98  99 100
> 
> 
> 
> cleanEx()
> nameEx("show_col")
> ### * show_col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: show_col
> ### Title: Show colours
> ### Aliases: show_col
> ### Keywords: internal
> 
> ### ** Examples
> 
> show_col(pal_hue()(9))
> show_col(pal_hue()(9), borders = NA)
> 
> show_col(pal_viridis()(16))
> show_col(pal_viridis()(16), labels = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("trans_breaks")
> ### * trans_breaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trans_breaks
> ### Title: Pretty breaks on transformed scale
> ### Aliases: trans_breaks
> ### Keywords: internal
> 
> ### ** Examples
> 
> trans_breaks("log10", function(x) 10^x)(c(1, 1e6))
[1] 1e+00 1e+01 1e+02 1e+03 1e+04 1e+05 1e+06
> trans_breaks("sqrt", function(x) x^2)(c(1, 100))
[1]   0   4  16  36  64 100
> trans_breaks(function(x) 1 / x, function(x) 1 / x)(c(1, 100))
[1]      Inf 5.000000 2.500000 1.666667 1.250000 1.000000
> trans_breaks(function(x) -x, function(x) -x)(c(1, 100))
[1] 100  80  60  40  20   0
> 
> 
> 
> cleanEx()
> nameEx("trans_format")
> ### * trans_format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trans_format
> ### Title: Format labels after transformation
> ### Aliases: trans_format
> ### Keywords: internal
> 
> ### ** Examples
> 
> tf <- trans_format("log10", scientific_format())
> tf(10^1:6)
[1] "1.00e+00" "9.54e-01" "9.03e-01" "8.45e-01" "7.78e-01"
> 
> 
> 
> cleanEx()
> nameEx("transform_asinh")
> ### * transform_asinh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_asinh
> ### Title: Inverse Hyperbolic Sine transformation
> ### Aliases: transform_asinh asinh_trans
> 
> ### ** Examples
> 
> plot(transform_asinh(), xlim = c(-1e2, 1e2))
> 
> 
> 
> cleanEx()
> nameEx("transform_asn")
> ### * transform_asn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_asn
> ### Title: Arc-sin square root transformation
> ### Aliases: transform_asn asn_trans
> 
> ### ** Examples
> 
> plot(transform_asn(), xlim = c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_atanh")
> ### * transform_atanh
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_atanh
> ### Title: Arc-tangent transformation
> ### Aliases: transform_atanh atanh_trans
> 
> ### ** Examples
> 
> plot(transform_atanh(), xlim = c(-1, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_boxcox")
> ### * transform_boxcox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_boxcox
> ### Title: Box-Cox & modulus transformations
> ### Aliases: transform_boxcox boxcox_trans transform_modulus modulus_trans
> 
> ### ** Examples
> 
> plot(transform_boxcox(-1), xlim = c(0, 10))
> plot(transform_boxcox(0), xlim = c(0, 10))
> plot(transform_boxcox(1), xlim = c(0, 10))
> plot(transform_boxcox(2), xlim = c(0, 10))
> 
> plot(transform_modulus(-1), xlim = c(-10, 10))
> plot(transform_modulus(0), xlim = c(-10, 10))
> plot(transform_modulus(1), xlim = c(-10, 10))
> plot(transform_modulus(2), xlim = c(-10, 10))
> 
> 
> 
> cleanEx()
> nameEx("transform_compose")
> ### * transform_compose
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_compose
> ### Title: Compose two or more transformations together
> ### Aliases: transform_compose compose_trans
> 
> ### ** Examples
> 
> demo_continuous(10^c(-2:4), trans = "log10", labels = label_log())
scale_x_continuous(trans = "log10", labels = label_log())
> demo_continuous(10^c(-2:4), trans = c("log10", "reverse"), labels = label_log())
scale_x_continuous(trans = c("log10", "reverse"), labels = label_log())
> 
> 
> 
> cleanEx()
> nameEx("transform_date")
> ### * transform_date
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_date
> ### Title: Transformation for dates (class Date)
> ### Aliases: transform_date date_trans
> 
> ### ** Examples
> 
> years <- seq(as.Date("1910/1/1"), as.Date("1999/1/1"), "years")
> t <- transform_date()
> t$transform(years)
 [1] -21915 -21550 -21185 -20819 -20454 -20089 -19724 -19358 -18993 -18628
[11] -18263 -17897 -17532 -17167 -16802 -16436 -16071 -15706 -15341 -14975
[21] -14610 -14245 -13880 -13514 -13149 -12784 -12419 -12053 -11688 -11323
[31] -10958 -10592 -10227  -9862  -9497  -9131  -8766  -8401  -8036  -7670
[41]  -7305  -6940  -6575  -6209  -5844  -5479  -5114  -4748  -4383  -4018
[51]  -3653  -3287  -2922  -2557  -2192  -1826  -1461  -1096   -731   -365
[61]      0    365    730   1096   1461   1826   2191   2557   2922   3287
[71]   3652   4018   4383   4748   5113   5479   5844   6209   6574   6940
[81]   7305   7670   8035   8401   8766   9131   9496   9862  10227  10592
> t$inverse(t$transform(years))
 [1] "1910-01-01" "1911-01-01" "1912-01-01" "1913-01-01" "1914-01-01"
 [6] "1915-01-01" "1916-01-01" "1917-01-01" "1918-01-01" "1919-01-01"
[11] "1920-01-01" "1921-01-01" "1922-01-01" "1923-01-01" "1924-01-01"
[16] "1925-01-01" "1926-01-01" "1927-01-01" "1928-01-01" "1929-01-01"
[21] "1930-01-01" "1931-01-01" "1932-01-01" "1933-01-01" "1934-01-01"
[26] "1935-01-01" "1936-01-01" "1937-01-01" "1938-01-01" "1939-01-01"
[31] "1940-01-01" "1941-01-01" "1942-01-01" "1943-01-01" "1944-01-01"
[36] "1945-01-01" "1946-01-01" "1947-01-01" "1948-01-01" "1949-01-01"
[41] "1950-01-01" "1951-01-01" "1952-01-01" "1953-01-01" "1954-01-01"
[46] "1955-01-01" "1956-01-01" "1957-01-01" "1958-01-01" "1959-01-01"
[51] "1960-01-01" "1961-01-01" "1962-01-01" "1963-01-01" "1964-01-01"
[56] "1965-01-01" "1966-01-01" "1967-01-01" "1968-01-01" "1969-01-01"
[61] "1970-01-01" "1971-01-01" "1972-01-01" "1973-01-01" "1974-01-01"
[66] "1975-01-01" "1976-01-01" "1977-01-01" "1978-01-01" "1979-01-01"
[71] "1980-01-01" "1981-01-01" "1982-01-01" "1983-01-01" "1984-01-01"
[76] "1985-01-01" "1986-01-01" "1987-01-01" "1988-01-01" "1989-01-01"
[81] "1990-01-01" "1991-01-01" "1992-01-01" "1993-01-01" "1994-01-01"
[86] "1995-01-01" "1996-01-01" "1997-01-01" "1998-01-01" "1999-01-01"
> t$format(t$breaks(range(years)))
[1] "1900" "1920" "1940" "1960" "1980" "2000"
> 
> 
> 
> cleanEx()
> nameEx("transform_exp")
> ### * transform_exp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_exp
> ### Title: Exponential transformation (inverse of log transformation)
> ### Aliases: transform_exp exp_trans
> 
> ### ** Examples
> 
> plot(transform_exp(0.5), xlim = c(-2, 2))
> plot(transform_exp(1), xlim = c(-2, 2))
> plot(transform_exp(2), xlim = c(-2, 2))
> plot(transform_exp(), xlim = c(-2, 2))
> 
> 
> 
> cleanEx()
> nameEx("transform_identity")
> ### * transform_identity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_identity
> ### Title: Identity transformation (do nothing)
> ### Aliases: transform_identity identity_trans
> 
> ### ** Examples
> 
> plot(transform_identity(), xlim = c(-1, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_log")
> ### * transform_log
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_log
> ### Title: Log transformations
> ### Aliases: transform_log transform_log10 transform_log2 transform_log1p
> ###   log_trans log10_trans log2_trans log1p_trans transform_pseudo_log
> ###   pseudo_log_trans
> 
> ### ** Examples
> 
> plot(transform_log2(), xlim = c(0, 5))
> plot(transform_log(), xlim = c(0, 5))
> plot(transform_log10(), xlim = c(0, 5))
> 
> plot(transform_log(), xlim = c(0, 2))
> plot(transform_log1p(), xlim = c(-1, 1))
> 
> # The pseudo-log is defined for all real numbers
> plot(transform_pseudo_log(), xlim = c(-5, 5))
> lines(transform_log(), xlim = c(0, 5), col = "red")
> 
> # For large positives numbers it's very close to log
> plot(transform_pseudo_log(), xlim = c(1, 20))
> lines(transform_log(), xlim = c(1, 20), col = "red")
> 
> 
> 
> cleanEx()
> nameEx("transform_probability")
> ### * transform_probability
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_probability
> ### Title: Probability transformation
> ### Aliases: transform_probability transform_logit transform_probit
> ###   probability_trans logit_trans probit_trans
> 
> ### ** Examples
> 
> plot(transform_logit(), xlim = c(0, 1))
> plot(transform_probit(), xlim = c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_reciprocal")
> ### * transform_reciprocal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_reciprocal
> ### Title: Reciprocal transformation
> ### Aliases: transform_reciprocal reciprocal_trans
> 
> ### ** Examples
> 
> plot(transform_reciprocal(), xlim = c(0, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_reverse")
> ### * transform_reverse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_reverse
> ### Title: Reverse transformation
> ### Aliases: transform_reverse reverse_trans
> 
> ### ** Examples
> 
> plot(transform_reverse(), xlim = c(-1, 1))
> 
> 
> 
> cleanEx()
> nameEx("transform_sqrt")
> ### * transform_sqrt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_sqrt
> ### Title: Square-root transformation
> ### Aliases: transform_sqrt sqrt_trans
> 
> ### ** Examples
> 
> plot(transform_sqrt(), xlim = c(0, 5))
> 
> 
> 
> cleanEx()
> nameEx("transform_time")
> ### * transform_time
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_time
> ### Title: Transformation for date-times (class POSIXt)
> ### Aliases: transform_time time_trans
> 
> ### ** Examples
> 
> hours <- seq(ISOdate(2000, 3, 20, tz = ""), by = "hour", length.out = 10)
> t <- transform_time()
> t$transform(hours)
 [1] 953553600 953557200 953560800 953564400 953568000 953571600 953575200
 [8] 953578800 953582400 953586000
> t$inverse(t$transform(hours))
 [1] "2000-03-20 12:00:00 UTC" "2000-03-20 13:00:00 UTC"
 [3] "2000-03-20 14:00:00 UTC" "2000-03-20 15:00:00 UTC"
 [5] "2000-03-20 16:00:00 UTC" "2000-03-20 17:00:00 UTC"
 [7] "2000-03-20 18:00:00 UTC" "2000-03-20 19:00:00 UTC"
 [9] "2000-03-20 20:00:00 UTC" "2000-03-20 21:00:00 UTC"
> t$format(t$breaks(range(hours)))
[1] "12:00" "15:00" "18:00" "21:00"
> 
> 
> 
> cleanEx()
> nameEx("transform_timespan")
> ### * transform_timespan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_timespan
> ### Title: Transformation for times (class hms)
> ### Aliases: transform_timespan timespan_trans transform_hms hms_trans
> 
> ### ** Examples
> 
> # transform_timespan allows you to specify the time unit numeric data is
> # interpreted in
> trans_min <- transform_timespan("mins")
> demo_timespan(seq(0, 100), trans = trans_min)
scale_x_continuous(trans = trans_min)
> # Input already in difftime format is interpreted correctly
> demo_timespan(as.difftime(seq(0, 100), units = "secs"), trans = trans_min)
scale_x_continuous(trans = trans_min)
> 
> if (require("hms")) {
+   # transform_hms always assumes seconds
+   hms <- round(runif(10) * 86400)
+   t <- transform_hms()
+   t$transform(hms)
+   t$inverse(t$transform(hms))
+   t$breaks(hms)
+   # The break labels also follow the hms format
+   demo_timespan(hms, trans = t)
+ }
Loading required package: hms
scale_x_continuous(trans = t)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:hms’

> nameEx("transform_yj")
> ### * transform_yj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transform_yj
> ### Title: Yeo-Johnson transformation
> ### Aliases: transform_yj yj_trans
> 
> ### ** Examples
> 
> plot(transform_yj(-1), xlim = c(-10, 10))
> plot(transform_yj(0), xlim = c(-10, 10))
> plot(transform_yj(1), xlim = c(-10, 10))
> plot(transform_yj(2), xlim = c(-10, 10))
> 
> 
> 
> cleanEx()
> nameEx("unit_format")
> ### * unit_format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unit_format
> ### Title: Unit labels
> ### Aliases: unit_format
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Label with units
> demo_continuous(c(0, 1), labels = unit_format(unit = "m"))
scale_x_continuous(labels = unit_format(unit = "m"))
> # Labels in kg, but original data in g
> km <- unit_format(unit = "km", scale = 1e-3, digits = 2)
> demo_continuous(c(0, 2500), labels = km)
scale_x_continuous(labels = km)
> 
> 
> 
> cleanEx()
> nameEx("zero_range")
> ### * zero_range
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zero_range
> ### Title: Determine if range of vector is close to zero, with a specified
> ###   tolerance
> ### Aliases: zero_range
> 
> ### ** Examples
> 
> eps <- .Machine$double.eps
> zero_range(c(1, 1 + eps))
[1] TRUE
> zero_range(c(1, 1 + 99 * eps))
[1] TRUE
> zero_range(c(1, 1 + 1001 * eps))
[1] FALSE
> zero_range(c(1, 1 + 2 * eps), tol = eps)
[1] FALSE
> 
> # Scaling up or down all the values has no effect since the values
> # are rescaled to 1 before checking against tol
> zero_range(100000 * c(1, 1 + eps))
[1] TRUE
> zero_range(100000 * c(1, 1 + 1001 * eps))
[1] FALSE
> zero_range(.00001 * c(1, 1 + eps))
[1] TRUE
> zero_range(.00001 * c(1, 1 + 1001 * eps))
[1] FALSE
> 
> # NA values
> zero_range(c(1, NA)) # NA
[1] NA
> zero_range(c(1, NaN)) # NA
[1] NA
> 
> # Infinite values
> zero_range(c(1, Inf)) # FALSE
[1] FALSE
> zero_range(c(-Inf, Inf)) # FALSE
[1] FALSE
> zero_range(c(Inf, Inf)) # TRUE
[1] TRUE
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  10.1 0.11 10.215 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
