
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "brms"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('brms')
Loading required package: Rcpp
Loading 'brms' package (version 2.22.0). Useful instructions
can be found by typing help('brms'). A more detailed introduction
to the package is available through vignette('brms_overview').

Attaching package: ‘brms’

The following object is masked from ‘package:stats’:

    ar

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("R2D2")
> ### * R2D2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: R2D2
> ### Title: R2D2 Priors in 'brms'
> ### Aliases: R2D2
> 
> ### ** Examples
> 
> set_prior(R2D2(mean_R2 = 0.8, prec_R2 = 10))
b ~ R2D2(mean_R2 = 0.8, prec_R2 = 10)
> 
> # specify the R2D2 prior across multiple parameter classes
> set_prior(R2D2(mean_R2 = 0.8, prec_R2 = 10, main = TRUE), class = "b") +
+   set_prior(R2D2(), class = "sd")
                                          prior class coef group resp dpar
 R2D2(mean_R2 = 0.8, prec_R2 = 10, main = TRUE)     b                     
                                         R2D2()    sd                     
 nlpar   lb   ub source
       <NA> <NA>   user
       <NA> <NA>   user
> 
> 
> 
> 
> cleanEx()
> nameEx("VarCorr.brmsfit")
> ### * VarCorr.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: VarCorr.brmsfit
> ### Title: Extract Variance and Correlation Components
> ### Aliases: VarCorr.brmsfit VarCorr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
> ##D            data = epilepsy, family = gaussian(), chains = 2)
> ##D VarCorr(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("add_criterion")
> ### * add_criterion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_criterion
> ### Title: Add model fit criteria to model objects
> ### Aliases: add_criterion add_criterion.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ Trt, data = epilepsy)
> ##D # add both LOO and WAIC at once
> ##D fit <- add_criterion(fit, c("loo", "waic"))
> ##D print(fit$criteria$loo)
> ##D print(fit$criteria$waic)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("addition-terms")
> ### * addition-terms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addition-terms
> ### Title: Additional Response Information
> ### Aliases: addition-terms se weights trials thres cat dec cens trunc
> ###   index rate subset vreal vint resp_se resp_weights resp_trials
> ###   resp_thres resp_cat resp_dec resp_bhaz resp_cens resp_trunc resp_mi
> ###   resp_index resp_rate resp_subset resp_vreal resp_vint
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Random effects meta-analysis
> ##D nstudies <- 20
> ##D true_effects <- rnorm(nstudies, 0.5, 0.2)
> ##D sei <- runif(nstudies, 0.05, 0.3)
> ##D outcomes <- rnorm(nstudies, true_effects, sei)
> ##D data1 <- data.frame(outcomes, sei)
> ##D fit1 <- brm(outcomes | se(sei, sigma = TRUE) ~ 1,
> ##D             data = data1)
> ##D summary(fit1)
> ##D 
> ##D ## Probit regression using the binomial family
> ##D n <- sample(1:10, 100, TRUE)  # number of trials
> ##D success <- rbinom(100, size = n, prob = 0.4)
> ##D x <- rnorm(100)
> ##D data2 <- data.frame(n, success, x)
> ##D fit2 <- brm(success | trials(n) ~ x, data = data2,
> ##D             family = binomial("probit"))
> ##D summary(fit2)
> ##D 
> ##D ## Survival regression modeling the time between the first
> ##D ## and second recurrence of an infection in kidney patients.
> ##D fit3 <- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
> ##D             data = kidney, family = lognormal())
> ##D summary(fit3)
> ##D 
> ##D ## Poisson model with truncated counts
> ##D fit4 <- brm(count | trunc(ub = 104) ~ zBase * Trt,
> ##D             data = epilepsy, family = poisson())
> ##D summary(fit4)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("ar")
> ### * ar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ar
> ### Title: Set up AR(p) correlation structures
> ### Aliases: ar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("LakeHuron")
> ##D LakeHuron <- as.data.frame(LakeHuron)
> ##D fit <- brm(x ~ ar(p = 2), data = LakeHuron)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("arma")
> ### * arma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arma
> ### Title: Set up ARMA(p,q) correlation structures
> ### Aliases: arma
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("LakeHuron")
> ##D LakeHuron <- as.data.frame(LakeHuron)
> ##D fit <- brm(x ~ arma(p = 2, q = 1), data = LakeHuron)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("autocor-terms")
> ### * autocor-terms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autocor-terms
> ### Title: Autocorrelation structures
> ### Aliases: autocor-terms
> 
> ### ** Examples
> 
> # specify autocor terms within the formula
> y ~ x + arma(p = 1, q = 1) + car(M)
y ~ x + arma(p = 1, q = 1) + car(M)
> 
> # specify autocor terms in the 'autocor' argument
> bf(y ~ x, autocor = ~ arma(p = 1, q = 1) + car(M))
y ~ x 
autocor ~ arma(p = 1, q = 1) + car(M)
> 
> # specify autocor terms via 'acformula'
> bf(y ~ x) + acformula(~ arma(p = 1, q = 1) + car(M))
y ~ x 
autocor ~ arma(p = 1, q = 1) + car(M)
> 
> 
> 
> cleanEx()
> nameEx("bayes_R2.brmsfit")
> ### * bayes_R2.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayes_R2.brmsfit
> ### Title: Compute a Bayesian version of R-squared for regression models
> ### Aliases: bayes_R2.brmsfit bayes_R2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(mpg ~ wt + cyl, data = mtcars)
> ##D summary(fit)
> ##D bayes_R2(fit)
> ##D 
> ##D # compute R2 with new data
> ##D nd <- data.frame(mpg = c(10, 20, 30), wt = c(4, 3, 2), cyl = c(8, 6, 4))
> ##D bayes_R2(fit, newdata = nd)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bayes_factor.brmsfit")
> ### * bayes_factor.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayes_factor.brmsfit
> ### Title: Bayes Factors from Marginal Likelihoods
> ### Aliases: bayes_factor.brmsfit bayes_factor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with the treatment effect
> ##D fit1 <- brm(
> ##D   count ~ zAge + zBase + Trt,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_all_pars = TRUE
> ##D )
> ##D summary(fit1)
> ##D 
> ##D # model without the treatment effect
> ##D fit2 <- brm(
> ##D   count ~ zAge + zBase,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_all_pars = TRUE
> ##D )
> ##D summary(fit2)
> ##D 
> ##D # compute the bayes factor
> ##D bayes_factor(fit1, fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bridge_sampler.brmsfit")
> ### * bridge_sampler.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bridge_sampler.brmsfit
> ### Title: Log Marginal Likelihood via Bridge Sampling
> ### Aliases: bridge_sampler.brmsfit bridge_sampler
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with the treatment effect
> ##D fit1 <- brm(
> ##D   count ~ zAge + zBase + Trt,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_pars = save_pars(all = TRUE)
> ##D )
> ##D summary(fit1)
> ##D bridge_sampler(fit1)
> ##D 
> ##D # model without the treatment effect
> ##D fit2 <- brm(
> ##D   count ~ zAge + zBase,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_pars = save_pars(all = TRUE)
> ##D )
> ##D summary(fit2)
> ##D bridge_sampler(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("brm")
> ### * brm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brm
> ### Title: Fit Bayesian Generalized (Non-)Linear Multivariate Multilevel
> ###   Models
> ### Aliases: brm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Poisson regression for the number of seizures in epileptic patients
> ##D fit1 <- brm(
> ##D   count ~ zBase * Trt + (1|patient),
> ##D   data = epilepsy, family = poisson(),
> ##D   prior = prior(normal(0, 10), class = b) +
> ##D     prior(cauchy(0, 2), class = sd)
> ##D )
> ##D 
> ##D # generate a summary of the results
> ##D summary(fit1)
> ##D 
> ##D # plot the MCMC chains as well as the posterior distributions
> ##D plot(fit1)
> ##D 
> ##D # predict responses based on the fitted model
> ##D head(predict(fit1))
> ##D 
> ##D # plot conditional effects for each predictor
> ##D plot(conditional_effects(fit1), ask = FALSE)
> ##D 
> ##D # investigate model fit
> ##D loo(fit1)
> ##D pp_check(fit1)
> ##D 
> ##D 
> ##D # Ordinal regression modeling patient's rating of inhaler instructions
> ##D # category specific effects are estimated for variable 'treat'
> ##D fit2 <- brm(rating ~ period + carry + cs(treat),
> ##D             data = inhaler, family = sratio("logit"),
> ##D             prior = set_prior("normal(0,5)"), chains = 2)
> ##D summary(fit2)
> ##D plot(fit2, ask = FALSE)
> ##D WAIC(fit2)
> ##D 
> ##D 
> ##D # Survival regression modeling the time between the first
> ##D # and second recurrence of an infection in kidney patients.
> ##D fit3 <- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
> ##D             data = kidney, family = lognormal())
> ##D summary(fit3)
> ##D plot(fit3, ask = FALSE)
> ##D plot(conditional_effects(fit3), ask = FALSE)
> ##D 
> ##D 
> ##D # Probit regression using the binomial family
> ##D ntrials <- sample(1:10, 100, TRUE)
> ##D success <- rbinom(100, size = ntrials, prob = 0.4)
> ##D x <- rnorm(100)
> ##D data4 <- data.frame(ntrials, success, x)
> ##D fit4 <- brm(success | trials(ntrials) ~ x, data = data4,
> ##D             family = binomial("probit"))
> ##D summary(fit4)
> ##D 
> ##D 
> ##D # Non-linear Gaussian model
> ##D fit5 <- brm(
> ##D   bf(cum ~ ult * (1 - exp(-(dev/theta)^omega)),
> ##D      ult ~ 1 + (1|AY), omega ~ 1, theta ~ 1,
> ##D      nl = TRUE),
> ##D   data = loss, family = gaussian(),
> ##D   prior = c(
> ##D     prior(normal(5000, 1000), nlpar = "ult"),
> ##D     prior(normal(1, 2), nlpar = "omega"),
> ##D     prior(normal(45, 10), nlpar = "theta")
> ##D   ),
> ##D   control = list(adapt_delta = 0.9)
> ##D )
> ##D summary(fit5)
> ##D conditional_effects(fit5)
> ##D 
> ##D 
> ##D # Normal model with heterogeneous variances
> ##D data_het <- data.frame(
> ##D   y = c(rnorm(50), rnorm(50, 1, 2)),
> ##D   x = factor(rep(c("a", "b"), each = 50))
> ##D )
> ##D fit6 <- brm(bf(y ~ x, sigma ~ 0 + x), data = data_het)
> ##D summary(fit6)
> ##D plot(fit6)
> ##D conditional_effects(fit6)
> ##D 
> ##D # extract estimated residual SDs of both groups
> ##D sigmas <- exp(as.data.frame(fit6, variable = "^b_sigma_", regex = TRUE))
> ##D ggplot(stack(sigmas), aes(values)) +
> ##D   geom_density(aes(fill = ind))
> ##D 
> ##D 
> ##D # Quantile regression predicting the 25%-quantile
> ##D fit7 <- brm(bf(y ~ x, quantile = 0.25), data = data_het,
> ##D             family = asym_laplace())
> ##D summary(fit7)
> ##D conditional_effects(fit7)
> ##D 
> ##D 
> ##D # use the future package for more flexible parallelization
> ##D library(future)
> ##D plan(multisession, workers = 4)
> ##D fit7 <- update(fit7, future = TRUE)
> ##D 
> ##D 
> ##D # fit a model manually via rstan
> ##D scode <- stancode(count ~ Trt, data = epilepsy)
> ##D sdata <- standata(count ~ Trt, data = epilepsy)
> ##D stanfit <- rstan::stan(model_code = scode, data = sdata)
> ##D # feed the Stan model back into brms
> ##D fit8 <- brm(count ~ Trt, data = epilepsy, empty = TRUE)
> ##D fit8$fit <- stanfit
> ##D fit8 <- rename_pars(fit8)
> ##D summary(fit8)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("brm_multiple")
> ### * brm_multiple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brm_multiple
> ### Title: Run the same 'brms' model on multiple datasets
> ### Aliases: brm_multiple
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(mice)
> ##D m <- 5
> ##D imp <- mice(nhanes2, m = m)
> ##D 
> ##D # fit the model using mice and lm
> ##D fit_imp1 <- with(lm(bmi ~ age + hyp + chl), data = imp)
> ##D summary(pool(fit_imp1))
> ##D 
> ##D # fit the model using brms
> ##D fit_imp2 <- brm_multiple(bmi ~ age + hyp + chl, data = imp, chains = 1)
> ##D summary(fit_imp2)
> ##D plot(fit_imp2, variable = "^b_", regex = TRUE)
> ##D 
> ##D # investigate convergence of the original models
> ##D library(posterior)
> ##D draws <- as_draws_array(fit_imp2)
> ##D # every dataset has just one chain here
> ##D draws_per_dat <- lapply(1:m, \(i) subset_draws(draws, chain = i))
> ##D lapply(draws_per_dat, summarise_draws, default_convergence_measures())
> ##D 
> ##D # use the future package for parallelization
> ##D library(future)
> ##D plan(multisession, workers = 4)
> ##D fit_imp3 <- brm_multiple(bmi ~ age + hyp + chl, data = imp, chains = 1)
> ##D summary(fit_imp3)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("brmsfamily")
> ### * brmsfamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brmsfamily
> ### Title: Special Family Functions for 'brms' Models
> ### Aliases: brmsfamily student bernoulli beta_binomial negbinomial
> ###   geometric lognormal shifted_lognormal skew_normal exponential weibull
> ###   frechet gen_extreme_value exgaussian wiener Beta dirichlet
> ###   logistic_normal von_mises asym_laplace cox hurdle_poisson
> ###   hurdle_negbinomial hurdle_gamma hurdle_lognormal hurdle_cumulative
> ###   zero_inflated_beta zero_one_inflated_beta zero_inflated_poisson
> ###   zero_inflated_negbinomial zero_inflated_binomial
> ###   zero_inflated_beta_binomial categorical multinomial cumulative sratio
> ###   cratio acat
> 
> ### ** Examples
> 
>  # create a family object
>  (fam1 <- student("log"))

Family: student 
Link function: log 

>  # alternatively use the brmsfamily function
>  (fam2 <- brmsfamily("student", "log"))

Family: student 
Link function: log 

>  # both leads to the same object
>  identical(fam1, fam2)
[1] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("brmsformula-helpers")
> ### * brmsformula-helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brmsformula-helpers
> ### Title: Linear and Non-linear formulas in 'brms'
> ### Aliases: brmsformula-helpers bf-helpers nlf lf set_nl set_rescor
> ###   acformula set_mecor
> 
> ### ** Examples
> 
> # add more formulas to the model
> bf(y ~ 1) +
+   nlf(sigma ~ a * exp(b * x)) +
+   lf(a ~ x, b ~ z + (1|g)) +
+   gaussian()
y ~ 1 
sigma ~ a * exp(b * x)
a ~ x
b ~ z + (1 | g)
> 
> # specify 'nl' later on
> bf(y ~ a * inv_logit(x * b)) +
+   lf(a + b ~ z) +
+   set_nl(TRUE)
y ~ a * inv_logit(x * b) 
a ~ z
b ~ z
> 
> # specify a multivariate model
> bf(y1 ~ x + (1|g)) +
+   bf(y2 ~ z) +
+   set_rescor(TRUE)
y1 ~ x + (1 | g) 
y2 ~ z 
> 
> # add autocorrelation terms
> bf(y ~ x) + acformula(~ arma(p = 1, q = 1) + car(W))
y ~ x 
autocor ~ arma(p = 1, q = 1) + car(W)
> 
> 
> 
> cleanEx()
> nameEx("brmsformula")
> ### * brmsformula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brmsformula
> ### Title: Set up a model formula for use in 'brms'
> ### Aliases: brmsformula bf
> 
> ### ** Examples
> 
> # multilevel model with smoothing terms
> brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2))
y ~ x1 * x2 + s(z) + (1 + x1 | 1) + (1 | g2) 
> 
> # additionally predict 'sigma'
> brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2),
+             sigma ~ x1 + (1|g2))
y ~ x1 * x2 + s(z) + (1 + x1 | 1) + (1 | g2) 
sigma ~ x1 + (1 | g2)
> 
> # use the shorter alias 'bf'
> (formula1 <- brmsformula(y ~ x + (x|g)))
y ~ x + (x | g) 
> (formula2 <- bf(y ~ x + (x|g)))
y ~ x + (x | g) 
> # will be TRUE
> identical(formula1, formula2)
[1] TRUE
> 
> # incorporate censoring
> bf(y | cens(censor_variable) ~ predictors)
y | cens(censor_variable) ~ predictors 
> 
> # define a simple non-linear model
> bf(y ~ a1 - a2^x, a1 + a2 ~ 1, nl = TRUE)
y ~ a1 - a2^x 
a1 ~ 1
a2 ~ 1
> 
> # predict a1 and a2 differently
> bf(y ~ a1 - a2^x, a1 ~ 1, a2 ~ x + (x|g), nl = TRUE)
y ~ a1 - a2^x 
a1 ~ 1
a2 ~ x + (x | g)
> 
> # correlated group-level effects across parameters
> bf(y ~ a1 - a2^x, a1 ~ 1 + (1 |2| g), a2 ~ x + (x |2| g), nl = TRUE)
y ~ a1 - a2^x 
a1 ~ 1 + (1 | 2 | g)
a2 ~ x + (x | 2 | g)
> # alternative but equivalent way to specify the above model
> bf(y ~ a1 - a2^x, a1 ~ 1 + (1 | gr(g, id = 2)),
+    a2 ~ x + (x | gr(g, id = 2)), nl = TRUE)
y ~ a1 - a2^x 
a1 ~ 1 + (1 | gr(g, id = 2))
a2 ~ x + (x | gr(g, id = 2))
> 
> # define a multivariate model
> bf(mvbind(y1, y2) ~ x * z + (1|g))
y1 ~ x * z + (1 | g) 
y2 ~ x * z + (1 | g) 
> 
> # define a zero-inflated model
> # also predicting the zero-inflation part
> bf(y ~ x * z + (1+x|ID1|g), zi ~ x + (1|ID1|g))
y ~ x * z + (1 + x | ID1 | g) 
zi ~ x + (1 | ID1 | g)
> 
> # specify a predictor as monotonic
> bf(y ~ mo(x) + more_predictors)
y ~ mo(x) + more_predictors 
> 
> # for ordinal models only
> # specify a predictor as category specific
> bf(y ~ cs(x) + more_predictors)
y ~ cs(x) + more_predictors 
> # add a category specific group-level intercept
> bf(y ~ cs(x) + (cs(1)|g))
y ~ cs(x) + (cs(1) | g) 
> # specify parameter 'disc'
> bf(y ~ person + item, disc ~ item)
y ~ person + item 
disc ~ item
> 
> # specify variables containing measurement error
> bf(y ~ me(x, sdx))
y ~ me(x, sdx) 
> 
> # specify predictors on all parameters of the wiener diffusion model
> # the main formula models the drift rate 'delta'
> bf(rt | dec(decision) ~ x, bs ~ x, ndt ~ x, bias ~ x)
rt | dec(decision) ~ x 
bs ~ x
ndt ~ x
bias ~ x
> 
> # fix the bias parameter to 0.5
> bf(rt | dec(decision) ~ x, bias = 0.5)
rt | dec(decision) ~ x 
bias = 0.5
> 
> # specify different predictors for different mixture components
> mix <- mixture(gaussian, gaussian)
Setting order = 'mu' for mixtures of the same family.
> bf(y ~ 1, mu1 ~ x, mu2 ~ z, family = mix)
y ~ 1 
mu1 ~ x
mu2 ~ z
> 
> # fix both residual standard deviations to the same value
> bf(y ~ x, sigma2 = "sigma1", family = mix)
y ~ x 
sigma2 = sigma1
> 
> # use the '+' operator to specify models
> bf(y ~ 1) +
+   nlf(sigma ~ a * exp(b * x), a ~ x) +
+   lf(b ~ z + (1|g), dpar = "sigma") +
+   gaussian()
Warning: Arguments '...' and 'flist' in nlf() will be reworked at some point. Please avoid using them if possible.
Warning: Argument 'dpar' is no longer necessary and ignored.
y ~ 1 
sigma ~ a * exp(b * x)
a ~ x
b ~ z + (1 | g)
> 
> # specify a multivariate model using the '+' operator
> bf(y1 ~ x + (1|g)) +
+   gaussian() + cor_ar(~1|g) +
+   bf(y2 ~ z) + poisson()
Warning: Using 'cor_brms' objects for 'autocor' is deprecated. Please see ?cor_brms for details.
y1 ~ x + (1 | g) 
autocor ~ arma(time = NA, gr = g, p = 1, q = 0, cov = FALSE)
y2 ~ z 
> 
> # specify correlated residuals of a gaussian and a poisson model
> form1 <- bf(y1 ~ 1 + x + (1|c|obs), sigma = 1) + gaussian()
> form2 <- bf(y2 ~ 1 + x + (1|c|obs)) + poisson()
> 
> # model missing values in predictors
> bf(bmi ~ age * mi(chl)) +
+   bf(chl | mi() ~ age) +
+   set_rescor(FALSE)
bmi ~ age * mi(chl) 
chl | mi() ~ age 
> 
> # model sigma as a function of the mean
> bf(y ~ eta, nl = TRUE) +
+   lf(eta ~ 1 + x) +
+   nlf(sigma ~ tau * sqrt(eta)) +
+   lf(tau ~ 1)
y ~ eta 
eta ~ 1 + x
sigma ~ tau * sqrt(eta)
tau ~ 1
> 
> 
> 
> 
> cleanEx()
> nameEx("car")
> ### * car
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: car
> ### Title: Spatial conditional autoregressive (CAR) structures
> ### Aliases: car
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # generate some spatial data
> ##D east <- north <- 1:10
> ##D Grid <- expand.grid(east, north)
> ##D K <- nrow(Grid)
> ##D 
> ##D # set up distance and neighbourhood matrices
> ##D distance <- as.matrix(dist(Grid))
> ##D W <- array(0, c(K, K))
> ##D W[distance == 1] <- 1
> ##D rownames(W) <- 1:nrow(W)
> ##D 
> ##D # generate the covariates and response data
> ##D x1 <- rnorm(K)
> ##D x2 <- rnorm(K)
> ##D theta <- rnorm(K, sd = 0.05)
> ##D phi <- rmulti_normal(
> ##D   1, mu = rep(0, K), Sigma = 0.4 * exp(-0.1 * distance)
> ##D )
> ##D eta <- x1 + x2 + phi
> ##D prob <- exp(eta) / (1 + exp(eta))
> ##D size <- rep(50, K)
> ##D y <- rbinom(n = K, size = size, prob = prob)
> ##D g <- 1:length(y)
> ##D dat <- data.frame(y, size, x1, x2, g)
> ##D 
> ##D # fit a CAR model
> ##D fit <- brm(y | trials(size) ~ x1 + x2 + car(W, gr = g),
> ##D            data = dat, data2 = list(W = W),
> ##D            family = binomial())
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("coef.brmsfit")
> ### * coef.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef.brmsfit
> ### Title: Extract Model Coefficients
> ### Aliases: coef.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
> ##D            data = epilepsy, family = gaussian(), chains = 2)
> ##D ## extract population and group-level coefficients separately
> ##D fixef(fit)
> ##D ranef(fit)
> ##D ## extract combined coefficients
> ##D coef(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("compare_ic")
> ### * compare_ic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare_ic
> ### Title: Compare Information Criteria of Different Models
> ### Aliases: compare_ic
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler)
> ##D waic1 <- waic(fit1)
> ##D 
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler)
> ##D waic2 <- waic(fit2)
> ##D 
> ##D # compare both models
> ##D compare_ic(waic1, waic2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("conditional_effects.brmsfit")
> ### * conditional_effects.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conditional_effects.brmsfit
> ### Title: Display Conditional Effects of Predictors
> ### Aliases: conditional_effects.brmsfit marginal_effects
> ###   marginal_effects.brmsfit conditional_effects
> ###   plot.brms_conditional_effects
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1 | patient),
> ##D            data = epilepsy, family = poisson())
> ##D 
> ##D ## plot all conditional effects
> ##D plot(conditional_effects(fit), ask = FALSE)
> ##D 
> ##D ## change colours to grey scale
> ##D library(ggplot2)
> ##D ce <- conditional_effects(fit, "zBase:Trt")
> ##D plot(ce, plot = FALSE)[[1]] +
> ##D   scale_color_grey() +
> ##D   scale_fill_grey()
> ##D 
> ##D ## only plot the conditional interaction effect of 'zBase:Trt'
> ##D ## for different values for 'zAge'
> ##D conditions <- data.frame(zAge = c(-1, 0, 1))
> ##D plot(conditional_effects(fit, effects = "zBase:Trt",
> ##D                          conditions = conditions))
> ##D 
> ##D ## also incorporate group-level effects variance over patients
> ##D ## also add data points and a rug representation of predictor values
> ##D plot(conditional_effects(fit, effects = "zBase:Trt",
> ##D                          conditions = conditions, re_formula = NULL),
> ##D      points = TRUE, rug = TRUE)
> ##D 
> ##D ## change handling of two-way interactions
> ##D int_conditions <- list(
> ##D   zBase = setNames(c(-2, 1, 0), c("b", "c", "a"))
> ##D )
> ##D conditional_effects(fit, effects = "Trt:zBase",
> ##D                     int_conditions = int_conditions)
> ##D conditional_effects(fit, effects = "Trt:zBase",
> ##D                     int_conditions = list(zBase = quantile))
> ##D 
> ##D ## fit a model to illustrate how to plot 3-way interactions
> ##D fit3way <- brm(count ~ zAge * zBase * Trt, data = epilepsy)
> ##D conditions <- make_conditions(fit3way, "zAge")
> ##D conditional_effects(fit3way, "zBase:Trt", conditions = conditions)
> ##D ## only include points close to the specified values of zAge
> ##D ce <- conditional_effects(
> ##D   fit3way, "zBase:Trt", conditions = conditions,
> ##D   select_points = 0.1
> ##D )
> ##D plot(ce, points = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("conditional_smooths.brmsfit")
> ### * conditional_smooths.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conditional_smooths.brmsfit
> ### Title: Display Smooth Terms
> ### Aliases: conditional_smooths.brmsfit marginal_smooths
> ###   marginal_smooths.brmsfit conditional_smooths
> 
> ### ** Examples
> 
> ## Not run: 
> ##D set.seed(0)
> ##D dat <- mgcv::gamSim(1, n = 200, scale = 2)
> ##D fit <- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
> ##D # show all smooth terms
> ##D plot(conditional_smooths(fit), rug = TRUE, ask = FALSE)
> ##D # show only the smooth term s(x2)
> ##D plot(conditional_smooths(fit, smooths = "s(x2)"), ask = FALSE)
> ##D 
> ##D # fit and plot a two-dimensional smooth term
> ##D fit2 <- brm(y ~ t2(x0, x2), data = dat)
> ##D ms <- conditional_smooths(fit2)
> ##D plot(ms, stype = "contour")
> ##D plot(ms, stype = "raster")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("constant")
> ### * constant
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: constant
> ### Title: Constant priors in 'brms'
> ### Aliases: constant
> 
> ### ** Examples
> 
> stancode(count ~ Base + Age, data = epilepsy,
+          prior = prior(constant(1), class = "b"))
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  vector[Kc] b;  // regression coefficients
  real lprior = 0;  // prior contributions to the log posterior
  b = rep_vector(1, rows(b));
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # will fail parsing because brms will try to broadcast a vector into a vector
> stancode(count ~ Base + Age, data = epilepsy,
+          prior = prior(constant(alpha), class = "b"),
+          stanvars = stanvar(c(1, 0), name = "alpha"))
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
  vector[2] alpha;
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  vector[Kc] b;  // regression coefficients
  real lprior = 0;  // prior contributions to the log posterior
  b = rep_vector(alpha, rows(b));
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> stancode(count ~ Base + Age, data = epilepsy,
+          prior = prior(constant(alpha, broadcast = FALSE), class = "b"),
+          stanvars = stanvar(c(1, 0), name = "alpha"))
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
  vector[2] alpha;
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  vector[Kc] b;  // regression coefficients
  real lprior = 0;  // prior contributions to the log posterior
  b = alpha;
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_ar")
> ### * cor_ar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_ar
> ### Title: (Deprecated) AR(p) correlation structure
> ### Aliases: cor_ar
> 
> ### ** Examples
> 
> cor_ar(~visit|patient, p = 2)
arma(~visit | patient, 2, 0)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_arma")
> ### * cor_arma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_arma
> ### Title: (Deprecated) ARMA(p,q) correlation structure
> ### Aliases: cor_arma cor_arma-class
> 
> ### ** Examples
> 
> cor_arma(~ visit | patient, p = 2, q = 2)
arma(~visit | patient, 2, 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_car")
> ### * cor_car
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_car
> ### Title: (Deprecated) Spatial conditional autoregressive (CAR) structures
> ### Aliases: cor_car cor_icar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # generate some spatial data
> ##D east <- north <- 1:10
> ##D Grid <- expand.grid(east, north)
> ##D K <- nrow(Grid)
> ##D 
> ##D # set up distance and neighbourhood matrices
> ##D distance <- as.matrix(dist(Grid))
> ##D W <- array(0, c(K, K))
> ##D W[distance == 1] <- 1
> ##D 
> ##D # generate the covariates and response data
> ##D x1 <- rnorm(K)
> ##D x2 <- rnorm(K)
> ##D theta <- rnorm(K, sd = 0.05)
> ##D phi <- rmulti_normal(
> ##D   1, mu = rep(0, K), Sigma = 0.4 * exp(-0.1 * distance)
> ##D )
> ##D eta <- x1 + x2 + phi
> ##D prob <- exp(eta) / (1 + exp(eta))
> ##D size <- rep(50, K)
> ##D y <- rbinom(n = K, size = size, prob = prob)
> ##D dat <- data.frame(y, size, x1, x2)
> ##D 
> ##D # fit a CAR model
> ##D fit <- brm(y | trials(size) ~ x1 + x2, data = dat,
> ##D            family = binomial(), autocor = cor_car(W))
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_cosy")
> ### * cor_cosy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_cosy
> ### Title: (Deprecated) Compound Symmetry (COSY) Correlation Structure
> ### Aliases: cor_cosy cor_cosy-class
> 
> ### ** Examples
> 
> cor_cosy(~ visit | patient)
cosy(~visit | patient)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_fixed")
> ### * cor_fixed
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_fixed
> ### Title: (Deprecated) Fixed user-defined covariance matrices
> ### Aliases: cor_fixed cov_fixed
> 
> ### ** Examples
> 
> ## Not run: 
> ##D dat <- data.frame(y = rnorm(3))
> ##D V <- cbind(c(0.5, 0.3, 0.2), c(0.3, 1, 0.1), c(0.2, 0.1, 0.2))
> ##D fit <- brm(y~1, data = dat, autocor = cor_fixed(V))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_ma")
> ### * cor_ma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_ma
> ### Title: (Deprecated) MA(q) correlation structure
> ### Aliases: cor_ma
> 
> ### ** Examples
> 
> cor_ma(~visit|patient, q = 2)
arma(~visit | patient, 0, 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("cor_sar")
> ### * cor_sar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor_sar
> ### Title: (Deprecated) Spatial simultaneous autoregressive (SAR)
> ###   structures
> ### Aliases: cor_sar cor_lagsar cor_errorsar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(oldcol, package = "spdep")
> ##D fit1 <- brm(CRIME ~ INC + HOVAL, data = COL.OLD,
> ##D             autocor = cor_lagsar(COL.nb),
> ##D             chains = 2, cores = 2)
> ##D summary(fit1)
> ##D plot(fit1)
> ##D 
> ##D fit2 <- brm(CRIME ~ INC + HOVAL, data = COL.OLD,
> ##D             autocor = cor_errorsar(COL.nb),
> ##D             chains = 2, cores = 2)
> ##D summary(fit2)
> ##D plot(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cosy")
> ### * cosy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cosy
> ### Title: Set up COSY correlation structures
> ### Aliases: cosy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("lh")
> ##D lh <- as.data.frame(lh)
> ##D fit <- brm(x ~ cosy(), data = lh)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("create_priorsense_data.brmsfit")
> ### * create_priorsense_data.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create_priorsense_data.brmsfit
> ### Title: Prior sensitivity: Create priorsense data
> ### Aliases: create_priorsense_data.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # fit a model with non-uniform priors
> ##D fit <- brm(rating ~ treat + period + carry,
> ##D            data = inhaler, family = sratio(),
> ##D            prior = set_prior("normal(0, 0.5)"))
> ##D summary(fit)
> ##D 
> ##D # The following code requires the 'priorsense' package to be installed:
> ##D library(priorsense)
> ##D 
> ##D # perform power-scaling of the prior
> ##D powerscale(fit, alpha = 1.5, component = "prior")
> ##D 
> ##D # perform power-scaling sensitivity checks
> ##D powerscale_sensitivity(fit)
> ##D 
> ##D # create power-scaling sensitivity plots (for one variable)
> ##D powerscale_plot_dens(fit, variable = "b_treat")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cs")
> ### * cs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cs
> ### Title: Category Specific Predictors in 'brms' Models
> ### Aliases: cs cse
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ period + carry + cs(treat),
> ##D            data = inhaler, family = sratio("cloglog"),
> ##D            prior = set_prior("normal(0,5)"), chains = 2)
> ##D summary(fit)
> ##D plot(fit, ask = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("custom_family")
> ### * custom_family
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: custom_family
> ### Title: Custom Families in 'brms' Models
> ### Aliases: custom_family customfamily
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## demonstrate how to fit a beta-binomial model
> ##D ## generate some fake data
> ##D phi <- 0.7
> ##D n <- 300
> ##D z <- rnorm(n, sd = 0.2)
> ##D ntrials <- sample(1:10, n, replace = TRUE)
> ##D eta <- 1 + z
> ##D mu <- exp(eta) / (1 + exp(eta))
> ##D a <- mu * phi
> ##D b <- (1 - mu) * phi
> ##D p <- rbeta(n, a, b)
> ##D y <- rbinom(n, ntrials, p)
> ##D dat <- data.frame(y, z, ntrials)
> ##D 
> ##D # define a custom family
> ##D beta_binomial2 <- custom_family(
> ##D   "beta_binomial2", dpars = c("mu", "phi"),
> ##D   links = c("logit", "log"), lb = c(NA, 0),
> ##D   type = "int", vars = "vint1[n]"
> ##D )
> ##D 
> ##D # define the corresponding Stan density function
> ##D stan_density <- "
> ##D   real beta_binomial2_lpmf(int y, real mu, real phi, int N) {
> ##D     return beta_binomial_lpmf(y | N, mu * phi, (1 - mu) * phi);
> ##D   }
> ##D "
> ##D stanvars <- stanvar(scode = stan_density, block = "functions")
> ##D 
> ##D # fit the model
> ##D fit <- brm(y | vint(ntrials) ~ z, data = dat,
> ##D            family = beta_binomial2, stanvars = stanvars)
> ##D summary(fit)
> ##D 
> ##D 
> ##D # define a *vectorized* custom family (no loop over observations)
> ##D # notice also that 'vint' no longer has an observation index
> ##D beta_binomial2_vec <- custom_family(
> ##D   "beta_binomial2", dpars = c("mu", "phi"),
> ##D   links = c("logit", "log"), lb = c(NA, 0),
> ##D   type = "int", vars = "vint1", loop = FALSE
> ##D )
> ##D 
> ##D # define the corresponding Stan density function
> ##D stan_density_vec <- "
> ##D   real beta_binomial2_lpmf(array[] int y, vector mu, real phi, array[] int N) {
> ##D     return beta_binomial_lpmf(y | N, mu * phi, (1 - mu) * phi);
> ##D   }
> ##D "
> ##D stanvars_vec <- stanvar(scode = stan_density_vec, block = "functions")
> ##D 
> ##D # fit the model
> ##D fit_vec <- brm(y | vint(ntrials) ~ z, data = dat,
> ##D            family = beta_binomial2_vec,
> ##D            stanvars = stanvars_vec)
> ##D summary(fit_vec)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("default_prior")
> ### * default_prior
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_prior
> ### Title: Default priors for Bayesian models
> ### Aliases: default_prior get_prior
> 
> ### ** Examples
> 
> ## get all parameters and parameters classes to define priors on
> (prior <- default_prior(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
+                         data = epilepsy, family = poisson()))
                  prior     class       coef   group resp dpar nlpar lb ub
                 (flat)         b                                         
                 (flat)         b       Trt1                              
                 (flat)         b       zAge                              
                 (flat)         b      zBase                              
                 (flat)         b zBase:Trt1                              
 student_t(3, 1.4, 2.5) Intercept                                         
   student_t(3, 0, 2.5)        sd                                     0   
   student_t(3, 0, 2.5)        sd                obs                  0   
   student_t(3, 0, 2.5)        sd  Intercept     obs                  0   
   student_t(3, 0, 2.5)        sd            patient                  0   
   student_t(3, 0, 2.5)        sd  Intercept patient                  0   
       source
      default
 (vectorized)
 (vectorized)
 (vectorized)
 (vectorized)
      default
      default
 (vectorized)
 (vectorized)
 (vectorized)
 (vectorized)
> 
> 
> 
> 
> cleanEx()
> nameEx("default_prior.default")
> ### * default_prior.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_prior.default
> ### Title: Default Priors for 'brms' Models
> ### Aliases: default_prior.default
> 
> ### ** Examples
> 
> # get all parameters and parameters classes to define priors on
> (prior <- default_prior(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
+                         data = epilepsy, family = poisson()))
                  prior     class       coef   group resp dpar nlpar lb ub
                 (flat)         b                                         
                 (flat)         b       Trt1                              
                 (flat)         b       zAge                              
                 (flat)         b      zBase                              
                 (flat)         b zBase:Trt1                              
 student_t(3, 1.4, 2.5) Intercept                                         
   student_t(3, 0, 2.5)        sd                                     0   
   student_t(3, 0, 2.5)        sd                obs                  0   
   student_t(3, 0, 2.5)        sd  Intercept     obs                  0   
   student_t(3, 0, 2.5)        sd            patient                  0   
   student_t(3, 0, 2.5)        sd  Intercept patient                  0   
       source
      default
 (vectorized)
 (vectorized)
 (vectorized)
 (vectorized)
      default
      default
 (vectorized)
 (vectorized)
 (vectorized)
 (vectorized)
> 
> # define a prior on all population-level effects a once
> prior$prior[1] <- "normal(0,10)"
> 
> # define a specific prior on the population-level effect of Trt
> prior$prior[5] <- "student_t(10, 0, 5)"
> 
> # verify that the priors indeed found their way into Stan's model code
> stancode(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
+          data = epilepsy, family = poisson(),
+          prior = prior)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  // data for group-level effects of ID 2
  int<lower=1> N_2;  // number of grouping levels
  int<lower=1> M_2;  // number of coefficients per level
  array[N] int<lower=1> J_2;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_2_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
  vector<lower=0>[M_2] sd_2;  // group-level standard deviations
  array[M_2] vector[N_2] z_2;  // standardized group-level effects
}
transformed parameters {
  vector[N_1] r_1_1;  // actual group-level effects
  vector[N_2] r_2_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  r_2_1 = (sd_2[1] * (z_2[1]));
  lprior += normal_lpdf(b[1] | 0,10);
  lprior += normal_lpdf(b[2] | 0,10);
  lprior += normal_lpdf(b[3] | 0,10);
  lprior += student_t_lpdf(b[4] | 10, 0, 5);
  lprior += student_t_lpdf(Intercept | 3, 1.4, 2.5);
  lprior += student_t_lpdf(sd_1 | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
  lprior += student_t_lpdf(sd_2 | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Intercept;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n] + r_2_1[J_2[n]] * Z_2_1[n];
    }
    target += poisson_log_glm_lpmf(Y | Xc, mu, b);
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
  target += std_normal_lpdf(z_2[1]);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> 
> 
> 
> cleanEx()
> nameEx("density_ratio")
> ### * density_ratio
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density_ratio
> ### Title: Compute Density Ratios
> ### Aliases: density_ratio
> 
> ### ** Examples
> 
> x <- rnorm(10000)
> y <- rnorm(10000, mean = 1)
> density_ratio(x, y, point = c(0, 1))
[1] 1.6045440 0.6065714
> 
> 
> 
> 
> cleanEx()
> nameEx("diagnostic-quantities")
> ### * diagnostic-quantities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diagnostic-quantities
> ### Title: Extract Diagnostic Quantities of 'brms' Models
> ### Aliases: diagnostic-quantities log_posterior nuts_params rhat
> ###   neff_ratio log_posterior.brmsfit nuts_params.brmsfit rhat.brmsfit
> ###   neff_ratio.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(time ~ age * sex, data = kidney)
> ##D 
> ##D lp <- log_posterior(fit)
> ##D head(lp)
> ##D 
> ##D np <- nuts_params(fit)
> ##D str(np)
> ##D # extract the number of divergence transitions
> ##D sum(subset(np, Parameter == "divergent__")$Value)
> ##D 
> ##D head(rhat(fit))
> ##D head(neff_ratio(fit))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("draws-brms")
> ### * draws-brms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draws-brms
> ### Title: Transform 'brmsfit' to 'draws' objects
> ### Aliases: draws-brms as_draws as_draws_matrix as_draws_array as_draws_df
> ###   as_draws_rvars as_draws_list as_draws.brmsfit as_draws_matrix.brmsfit
> ###   as_draws_array.brmsfit as_draws_df.brmsfit as_draws_list.brmsfit
> ###   as_draws_rvars.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = poisson())
> ##D 
> ##D # extract posterior draws in an array format
> ##D (draws_fit <- as_draws_array(fit))
> ##D posterior::summarize_draws(draws_fit)
> ##D 
> ##D # extract only certain variables
> ##D as_draws_array(fit, variable = "r_patient")
> ##D as_draws_array(fit, variable = "^b_", regex = TRUE)
> ##D 
> ##D # extract posterior draws in a random variables format
> ##D as_draws_rvars(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("emmeans-brms-helpers")
> ### * emmeans-brms-helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: emmeans-brms-helpers
> ### Title: Support Functions for 'emmeans'
> ### Aliases: emmeans-brms-helpers recover_data.brmsfit emm_basis.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit1 <- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
> ##D             data = kidney, family = lognormal())
> ##D summary(fit1)
> ##D 
> ##D # summarize via 'emmeans'
> ##D library(emmeans)
> ##D rg <- ref_grid(fit1)
> ##D em <- emmeans(rg, "disease")
> ##D summary(em, point.est = mean)
> ##D 
> ##D # obtain estimates for the posterior predictive distribution's mean
> ##D epred <- emmeans(fit1, "disease", epred = TRUE)
> ##D summary(epred, point.est = mean)
> ##D 
> ##D 
> ##D # model with transformed response variable
> ##D fit2 <- brm(log(mpg) ~ factor(cyl), data = mtcars)
> ##D summary(fit2)
> ##D 
> ##D # results will be on the log scale by default
> ##D emmeans(fit2, ~ cyl)
> ##D # log transform is detected and can be adjusted automatically
> ##D emmeans(fit2, ~ cyl, epred = TRUE, type = "response")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("epilepsy")
> ### * epilepsy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: epilepsy
> ### Title: Epileptic seizure counts
> ### Aliases: epilepsy
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## poisson regression without random effects.
> ##D fit1 <- brm(count ~ zAge + zBase * Trt,
> ##D             data = epilepsy, family = poisson())
> ##D summary(fit1)
> ##D plot(fit1)
> ##D 
> ##D ## poisson regression with varying intercepts of patients
> ##D ## as well as normal priors for overall effects parameters.
> ##D fit2 <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D             data = epilepsy, family = poisson(),
> ##D             prior = set_prior("normal(0,5)"))
> ##D summary(fit2)
> ##D plot(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fcor")
> ### * fcor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fcor
> ### Title: Fixed residual correlation (FCOR) structures
> ### Aliases: fcor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D dat <- data.frame(y = rnorm(3))
> ##D V <- cbind(c(0.5, 0.3, 0.2), c(0.3, 1, 0.1), c(0.2, 0.1, 0.2))
> ##D fit <- brm(y ~ 1 + fcor(V), data = dat, data2 = list(V = V))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fitted.brmsfit")
> ### * fitted.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted.brmsfit
> ### Title: Expected Values of the Posterior Predictive Distribution
> ### Aliases: fitted.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler)
> ##D 
> ##D ## compute expected predictions
> ##D fitted_values <- fitted(fit)
> ##D head(fitted_values)
> ##D 
> ##D ## plot expected predictions against actual response
> ##D dat <- as.data.frame(cbind(Y = standata(fit)$Y, fitted_values))
> ##D ggplot(dat) + geom_point(aes(x = Estimate, y = Y))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fixef.brmsfit")
> ### * fixef.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixef.brmsfit
> ### Title: Extract Population-Level Estimates
> ### Aliases: fixef.brmsfit fixef
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(time | cens(censored) ~ age + sex + disease,
> ##D            data = kidney, family = "exponential")
> ##D fixef(fit)
> ##D # extract only some coefficients
> ##D fixef(fit, pars = c("age", "sex"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("get_dpar")
> ### * get_dpar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_dpar
> ### Title: Draws of a Distributional Parameter
> ### Aliases: get_dpar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D posterior_predict_my_dist <- function(i, prep, ...) {
> ##D   mu <- brms::get_dpar(prep, "mu", i = i)
> ##D   mypar <- brms::get_dpar(prep, "mypar", i = i)
> ##D   my_rng(mu, mypar)
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("get_refmodel.brmsfit")
> ### * get_refmodel.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_refmodel.brmsfit
> ### Title: Projection Predictive Variable Selection: Get Reference Model
> ### Aliases: get_refmodel.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # fit a simple model
> ##D fit <- brm(count ~ zAge + zBase * Trt,
> ##D            data = epilepsy, family = poisson())
> ##D summary(fit)
> ##D 
> ##D # The following code requires the 'projpred' package to be installed:
> ##D library(projpred)
> ##D 
> ##D # perform variable selection without cross-validation
> ##D vs <- varsel(fit)
> ##D summary(vs)
> ##D plot(vs)
> ##D 
> ##D # perform variable selection with cross-validation
> ##D cv_vs <- cv_varsel(fit)
> ##D summary(cv_vs)
> ##D plot(cv_vs)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("gp")
> ### * gp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gp
> ### Title: Set up Gaussian process terms in 'brms'
> ### Aliases: gp
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # simulate data using the mgcv package
> ##D dat <- mgcv::gamSim(1, n = 30, scale = 2)
> ##D 
> ##D # fit a simple GP model
> ##D fit1 <- brm(y ~ gp(x2), dat, chains = 2)
> ##D summary(fit1)
> ##D me1 <- conditional_effects(fit1, ndraws = 200, spaghetti = TRUE)
> ##D plot(me1, ask = FALSE, points = TRUE)
> ##D 
> ##D # fit a more complicated GP model and use an approximate GP for x2
> ##D fit2 <- brm(y ~ gp(x0) + x1 + gp(x2, k = 10) + x3, dat, chains = 2)
> ##D summary(fit2)
> ##D me2 <- conditional_effects(fit2, ndraws = 200, spaghetti = TRUE)
> ##D plot(me2, ask = FALSE, points = TRUE)
> ##D 
> ##D # fit a multivariate GP model with Matern 3/2 kernel
> ##D fit3 <- brm(y ~ gp(x1, x2, cov = "matern32"), dat, chains = 2)
> ##D summary(fit3)
> ##D me3 <- conditional_effects(fit3, ndraws = 200, spaghetti = TRUE)
> ##D plot(me3, ask = FALSE, points = TRUE)
> ##D 
> ##D # compare model fit
> ##D loo(fit1, fit2, fit3)
> ##D 
> ##D # simulate data with a factor covariate
> ##D dat2 <- mgcv::gamSim(4, n = 90, scale = 2)
> ##D 
> ##D # fit separate gaussian processes for different levels of 'fac'
> ##D fit4 <- brm(y ~ gp(x2, by = fac), dat2, chains = 2)
> ##D summary(fit4)
> ##D plot(conditional_effects(fit4), points = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("gr")
> ### * gr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gr
> ### Title: Set up basic grouping terms in 'brms'
> ### Aliases: gr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model using basic lme4-style formula
> ##D fit1 <- brm(count ~ Trt + (1|patient), data = epilepsy)
> ##D summary(fit1)
> ##D 
> ##D # equivalent model using 'gr' which is called anyway internally
> ##D fit2 <- brm(count ~ Trt + (1|gr(patient)), data = epilepsy)
> ##D summary(fit2)
> ##D 
> ##D # include Trt as a by variable
> ##D fit3 <- brm(count ~ Trt + (1|gr(patient, by = Trt)), data = epilepsy)
> ##D summary(fit3)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("horseshoe")
> ### * horseshoe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: horseshoe
> ### Title: Regularized horseshoe priors in 'brms'
> ### Aliases: horseshoe
> 
> ### ** Examples
> 
> set_prior(horseshoe(df = 3, par_ratio = 0.1))
b ~ horseshoe(df = 3, par_ratio = 0.1)
> 
> # specify the horseshoe prior across multiple parameter classes
> set_prior(horseshoe(df = 3, par_ratio = 0.1, main = TRUE), class = "b") +
+   set_prior(horseshoe(), class = "sd")
                                           prior class coef group resp dpar
 horseshoe(df = 3, par_ratio = 0.1, main = TRUE)     b                     
                                     horseshoe()    sd                     
 nlpar   lb   ub source
       <NA> <NA>   user
       <NA> <NA>   user
> 
> 
> 
> 
> cleanEx()
> nameEx("hypothesis.brmsfit")
> ### * hypothesis.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hypothesis.brmsfit
> ### Title: Non-Linear Hypothesis Testing
> ### Aliases: hypothesis.brmsfit hypothesis hypothesis.default
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## define priors
> ##D prior <- c(set_prior("normal(0,2)", class = "b"),
> ##D            set_prior("student_t(10,0,1)", class = "sigma"),
> ##D            set_prior("student_t(10,0,1)", class = "sd"))
> ##D 
> ##D ## fit a linear mixed effects models
> ##D fit <- brm(time ~ age + sex + disease + (1 + age|patient),
> ##D            data = kidney, family = lognormal(),
> ##D            prior = prior, sample_prior = "yes",
> ##D            control = list(adapt_delta = 0.95))
> ##D 
> ##D ## perform two-sided hypothesis testing
> ##D (hyp1 <- hypothesis(fit, "sexfemale = age + diseasePKD"))
> ##D plot(hyp1)
> ##D hypothesis(fit, "exp(age) - 3 = 0", alpha = 0.01)
> ##D 
> ##D ## perform one-sided hypothesis testing
> ##D hypothesis(fit, "diseasePKD + diseaseGN - 3 < 0")
> ##D 
> ##D hypothesis(fit, "age < Intercept",
> ##D            class = "sd", group  = "patient")
> ##D 
> ##D ## test the amount of random intercept variance on all variance
> ##D h <- paste("sd_patient__Intercept^2 / (sd_patient__Intercept^2 +",
> ##D            "sd_patient__age^2 + sigma^2) = 0")
> ##D (hyp2 <- hypothesis(fit, h, class = NULL))
> ##D plot(hyp2)
> ##D 
> ##D ## test more than one hypothesis at once
> ##D h <- c("diseaseGN = diseaseAN", "2 * diseaseGN - diseasePKD = 0")
> ##D (hyp3 <- hypothesis(fit, h))
> ##D plot(hyp3, ignore_prior = TRUE)
> ##D 
> ##D ## compute hypotheses for all levels of a grouping factor
> ##D hypothesis(fit, "age = 0", scope = "coef", group = "patient")
> ##D 
> ##D ## use the default method
> ##D dat <- as.data.frame(fit)
> ##D str(dat)
> ##D hypothesis(dat, "b_age > 0")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("inhaler")
> ### * inhaler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inhaler
> ### Title: Clarity of inhaler instructions
> ### Aliases: inhaler
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## ordinal regression with family "sratio"
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler, family = sratio(),
> ##D             prior = set_prior("normal(0,5)"))
> ##D summary(fit1)
> ##D plot(fit1)
> ##D 
> ##D ## ordinal regression with family "cumulative"
> ##D ## and random intercept over subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D               data = inhaler, family = cumulative(),
> ##D               prior = set_prior("normal(0,5)"))
> ##D summary(fit2)
> ##D plot(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("kfold.brmsfit")
> ### * kfold.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kfold.brmsfit
> ### Title: K-Fold Cross-Validation
> ### Aliases: kfold.brmsfit kfold
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
> ##D            data = epilepsy, family = poisson())
> ##D # throws warning about some pareto k estimates being too high
> ##D (loo1 <- loo(fit1))
> ##D # perform 10-fold cross validation
> ##D (kfold1 <- kfold(fit1, chains = 1))
> ##D 
> ##D # use joint likelihoods per fold for ELPD evaluation
> ##D kfold(fit1, chains = 1, joint = "fold")
> ##D 
> ##D # use the future package for parallelization of models
> ##D # that is to fit models belonging to different folds in parallel
> ##D library(future)
> ##D plan(multisession, workers = 4)
> ##D kfold(fit1, chains = 1)
> ##D plan(sequential)
> ##D 
> ##D ## to avoid recompilations when running kfold() on a 'cmdstanr'-backend fit
> ##D ## in a fresh R session, set option 'cmdstanr_write_stan_file_dir' before
> ##D ## creating the initial 'brmsfit'
> ##D ## CAUTION: the following code creates some files in the current working
> ##D ## directory: two 'model_<hash>.stan' files, one 'model_<hash>(.exe)'
> ##D ## executable, and one 'fit_cmdstanr_<some_number>.rds' file
> ##D set.seed(7)
> ##D fname <- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
> ##D options(cmdstanr_write_stan_file_dir = getwd())
> ##D fit_cmdstanr <- brm(rate ~ conc + state, data = Puromycin,
> ##D                     backend = "cmdstanr", file = fname)
> ##D 
> ##D # now restart the R session and run the following (after attaching 'brms')
> ##D set.seed(7)
> ##D fname <- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
> ##D fit_cmdstanr <- brm(rate ~ conc + state,
> ##D                     data = Puromycin,
> ##D                     backend = "cmdstanr",
> ##D                     file = fname)
> ##D kfold_cmdstanr <- kfold(fit_cmdstanr, K = 2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("kfold_predict")
> ### * kfold_predict
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kfold_predict
> ### Title: Predictions from K-Fold Cross-Validation
> ### Aliases: kfold_predict
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = poisson())
> ##D 
> ##D # perform k-fold cross validation
> ##D (kf <- kfold(fit, save_fits = TRUE, chains = 1))
> ##D 
> ##D # define a loss function
> ##D rmse <- function(y, yrep) {
> ##D   yrep_mean <- colMeans(yrep)
> ##D   sqrt(mean((yrep_mean - y)^2))
> ##D }
> ##D 
> ##D # predict responses and evaluate the loss
> ##D kfp <- kfold_predict(kf)
> ##D rmse(y = kfp$y, yrep = kfp$yrep)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("kidney")
> ### * kidney
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kidney
> ### Title: Infections in kidney patients
> ### Aliases: kidney
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## performing surivival analysis using the "weibull" family
> ##D fit1 <- brm(time | cens(censored) ~ age + sex + disease,
> ##D             data = kidney, family = weibull, init = "0")
> ##D summary(fit1)
> ##D plot(fit1)
> ##D 
> ##D ## adding random intercepts over patients
> ##D fit2 <- brm(time | cens(censored) ~ age + sex + disease + (1|patient),
> ##D             data = kidney, family = weibull(), init = "0",
> ##D             prior = set_prior("cauchy(0,2)", class = "sd"))
> ##D summary(fit2)
> ##D plot(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("launch_shinystan.brmsfit")
> ### * launch_shinystan.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: launch_shinystan.brmsfit
> ### Title: Interface to 'shinystan'
> ### Aliases: launch_shinystan.brmsfit launch_shinystan
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler, family = "gaussian")
> ##D launch_shinystan(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo.brmsfit")
> ### * loo.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo.brmsfit
> ### Title: Efficient approximate leave-one-out cross-validation (LOO)
> ### Aliases: loo.brmsfit loo LOO LOO.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler)
> ##D (loo1 <- loo(fit1))
> ##D 
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler)
> ##D (loo2 <- loo(fit2))
> ##D 
> ##D # compare both models
> ##D loo_compare(loo1, loo2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_R2.brmsfit")
> ### * loo_R2.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_R2.brmsfit
> ### Title: Compute a LOO-adjusted R-squared for regression models
> ### Aliases: loo_R2.brmsfit loo_R2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(mpg ~ wt + cyl, data = mtcars)
> ##D summary(fit)
> ##D loo_R2(fit)
> ##D 
> ##D # compute R2 with new data
> ##D nd <- data.frame(mpg = c(10, 20, 30), wt = c(4, 3, 2), cyl = c(8, 6, 4))
> ##D loo_R2(fit, newdata = nd)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_compare.brmsfit")
> ### * loo_compare.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_compare.brmsfit
> ### Title: Model comparison with the 'loo' package
> ### Aliases: loo_compare.brmsfit loo_compare
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler)
> ##D fit1 <- add_criterion(fit1, "waic")
> ##D 
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler)
> ##D fit2 <- add_criterion(fit2, "waic")
> ##D 
> ##D # compare both models
> ##D loo_compare(fit1, fit2, criterion = "waic")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_model_weights.brmsfit")
> ### * loo_model_weights.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_model_weights.brmsfit
> ### Title: Model averaging via stacking or pseudo-BMA weighting.
> ### Aliases: loo_model_weights.brmsfit loo_model_weights
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler, family = "gaussian")
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler, family = "gaussian")
> ##D loo_model_weights(fit1, fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_moment_match.brmsfit")
> ### * loo_moment_match.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_moment_match.brmsfit
> ### Title: Moment matching for efficient approximate leave-one-out
> ###   cross-validation
> ### Aliases: loo_moment_match.brmsfit loo_moment_match loo_moment_match.loo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D             data = epilepsy, family = poisson(),
> ##D             save_pars = save_pars(all = TRUE))
> ##D 
> ##D # throws warning about some pareto k estimates being too high
> ##D (loo1 <- loo(fit1))
> ##D 
> ##D # no more warnings after moment matching
> ##D (mmloo1 <- loo_moment_match(fit1, loo = loo1))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_predict.brmsfit")
> ### * loo_predict.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_predict.brmsfit
> ### Title: Compute Weighted Expectations Using LOO
> ### Aliases: loo_predict.brmsfit loo_predict loo_epred loo_linpred
> ###   loo_predictive_interval loo_epred.brmsfit loo_linpred.brmsfit
> ###   loo_predictive_interval.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## data from help("lm")
> ##D ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
> ##D trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
> ##D d <- data.frame(
> ##D   weight = c(ctl, trt),
> ##D   group = gl(2, 10, 20, labels = c("Ctl", "Trt"))
> ##D )
> ##D fit <- brm(weight ~ group, data = d)
> ##D loo_predictive_interval(fit, prob = 0.8)
> ##D 
> ##D ## optionally log-weights can be pre-computed and reused
> ##D psis <- loo::psis(-log_lik(fit), cores = 2)
> ##D loo_predictive_interval(fit, prob = 0.8, psis_object = psis)
> ##D loo_predict(fit, type = "var", psis_object = psis)
> ##D loo_epred(fit, type = "var", psis_object = psis)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loo_subsample.brmsfit")
> ### * loo_subsample.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loo_subsample.brmsfit
> ### Title: Efficient approximate leave-one-out cross-validation (LOO) using
> ###   subsampling
> ### Aliases: loo_subsample.brmsfit loo_subsample
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler)
> ##D (loo1 <- loo_subsample(fit1))
> ##D 
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler)
> ##D (loo2 <- loo_subsample(fit2))
> ##D 
> ##D # compare both models
> ##D loo_compare(loo1, loo2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("loss")
> ### * loss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loss
> ### Title: Cumulative Insurance Loss Payments
> ### Aliases: loss
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # non-linear model to predict cumulative loss payments
> ##D fit_loss <- brm(
> ##D   bf(cum ~ ult * (1 - exp(-(dev/theta)^omega)),
> ##D      ult ~ 1 + (1|AY), omega ~ 1, theta ~ 1,
> ##D      nl = TRUE),
> ##D   data = loss, family = gaussian(),
> ##D   prior = c(
> ##D     prior(normal(5000, 1000), nlpar = "ult"),
> ##D     prior(normal(1, 2), nlpar = "omega"),
> ##D     prior(normal(45, 10), nlpar = "theta")
> ##D   ),
> ##D   control = list(adapt_delta = 0.9)
> ##D )
> ##D 
> ##D # basic summaries
> ##D summary(fit_loss)
> ##D conditional_effects(fit_loss)
> ##D 
> ##D # plot predictions per origin year
> ##D conditions <- data.frame(AY = unique(loss$AY))
> ##D rownames(conditions) <- unique(loss$AY)
> ##D me_loss <- conditional_effects(
> ##D   fit_loss, conditions = conditions,
> ##D   re_formula = NULL, method = "predict"
> ##D )
> ##D plot(me_loss, ncol = 5, points = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("ma")
> ### * ma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ma
> ### Title: Set up MA(q) correlation structures
> ### Aliases: ma
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("LakeHuron")
> ##D LakeHuron <- as.data.frame(LakeHuron)
> ##D fit <- brm(x ~ ma(p = 2), data = LakeHuron)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("make_conditions")
> ### * make_conditions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_conditions
> ### Title: Prepare Fully Crossed Conditions
> ### Aliases: make_conditions
> 
> ### ** Examples
> 
> df <- data.frame(x = c("a", "b"), y = rnorm(10))
> make_conditions(df, vars = c("x", "y"))
  x          y            cond__
1 a -0.6483832 x = a & y = -0.65
2 a  0.1322028  x = a & y = 0.13
3 a  0.9127887  x = a & y = 0.91
4 b -0.6483832 x = b & y = -0.65
5 b  0.1322028  x = b & y = 0.13
6 b  0.9127887  x = b & y = 0.91
> 
> 
> 
> 
> cleanEx()
> nameEx("mcmc_plot.brmsfit")
> ### * mcmc_plot.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mcmc_plot.brmsfit
> ### Title: MCMC Plots Implemented in 'bayesplot'
> ### Aliases: mcmc_plot.brmsfit stanplot stanplot.brmsfit mcmc_plot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D model <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D              data = epilepsy, family = "poisson")
> ##D 
> ##D # plot posterior intervals
> ##D mcmc_plot(model)
> ##D 
> ##D # only show population-level effects in the plots
> ##D mcmc_plot(model, variable = "^b_", regex = TRUE)
> ##D 
> ##D # show histograms of the posterior distributions
> ##D mcmc_plot(model, type = "hist")
> ##D 
> ##D # plot some diagnostics of the sampler
> ##D mcmc_plot(model, type = "neff")
> ##D mcmc_plot(model, type = "rhat")
> ##D 
> ##D # plot some diagnostics specific to the NUTS sampler
> ##D mcmc_plot(model, type = "nuts_acceptance")
> ##D mcmc_plot(model, type = "nuts_divergence")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("me")
> ### * me
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: me
> ### Title: Predictors with Measurement Error in 'brms' Models
> ### Aliases: me
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # sample some data
> ##D N <- 100
> ##D dat <- data.frame(
> ##D   y = rnorm(N), x1 = rnorm(N),
> ##D   x2 = rnorm(N), sdx = abs(rnorm(N, 1))
> ##D  )
> ##D # fit a simple error-in-variables model
> ##D fit1 <- brm(y ~ me(x1, sdx) + me(x2, sdx), data = dat,
> ##D             save_pars = save_pars(latent = TRUE))
> ##D summary(fit1)
> ##D 
> ##D # turn off modeling of correlations
> ##D bform <- bf(y ~ me(x1, sdx) + me(x2, sdx)) + set_mecor(FALSE)
> ##D fit2 <- brm(bform, data = dat, save_pars = save_pars(latent = TRUE))
> ##D summary(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mi")
> ### * mi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mi
> ### Title: Predictors with Missing Values in 'brms' Models
> ### Aliases: mi
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("nhanes", package = "mice")
> ##D N <- nrow(nhanes)
> ##D 
> ##D # simple model with missing data
> ##D bform1 <- bf(bmi | mi() ~ age * mi(chl)) +
> ##D   bf(chl | mi() ~ age) +
> ##D   set_rescor(FALSE)
> ##D 
> ##D fit1 <- brm(bform1, data = nhanes)
> ##D 
> ##D summary(fit1)
> ##D plot(conditional_effects(fit1, resp = "bmi"), ask = FALSE)
> ##D loo(fit1, newdata = na.omit(fit1$data))
> ##D 
> ##D # simulate some measurement noise
> ##D nhanes$se <- rexp(N, 2)
> ##D 
> ##D # measurement noise can be handled within 'mi' terms
> ##D # with or without the presence of missing values
> ##D bform2 <- bf(bmi | mi() ~ age * mi(chl)) +
> ##D   bf(chl | mi(se) ~ age) +
> ##D   set_rescor(FALSE)
> ##D 
> ##D fit2 <- brm(bform2, data = nhanes)
> ##D 
> ##D summary(fit2)
> ##D plot(conditional_effects(fit2, resp = "bmi"), ask = FALSE)
> ##D 
> ##D # 'mi' terms can also be used when some responses are subsetted
> ##D nhanes$sub <- TRUE
> ##D nhanes$sub[1:2] <- FALSE
> ##D nhanes$id <- 1:N
> ##D nhanes$idx <- sample(3:N, N, TRUE)
> ##D 
> ##D # this requires the addition term 'index' being specified
> ##D # in the subsetted part of the model
> ##D bform3 <- bf(bmi | mi() ~ age * mi(chl, idx)) +
> ##D   bf(chl | mi(se) + subset(sub) + index(id) ~ age) +
> ##D   set_rescor(FALSE)
> ##D 
> ##D fit3 <- brm(bform3, data = nhanes)
> ##D 
> ##D summary(fit3)
> ##D plot(conditional_effects(fit3, resp = "bmi"), ask = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mixture")
> ### * mixture
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixture
> ### Title: Finite Mixture Families in 'brms'
> ### Aliases: mixture
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## simulate some data
> ##D set.seed(1234)
> ##D dat <- data.frame(
> ##D   y = c(rnorm(200), rnorm(100, 6)),
> ##D   x = rnorm(300),
> ##D   z = sample(0:1, 300, TRUE)
> ##D )
> ##D 
> ##D ## fit a simple normal mixture model
> ##D mix <- mixture(gaussian, gaussian)
> ##D prior <- c(
> ##D   prior(normal(0, 7), Intercept, dpar = mu1),
> ##D   prior(normal(5, 7), Intercept, dpar = mu2)
> ##D )
> ##D fit1 <- brm(bf(y ~ x + z), dat, family = mix,
> ##D             prior = prior, chains = 2)
> ##D summary(fit1)
> ##D pp_check(fit1)
> ##D 
> ##D ## use different predictors for the components
> ##D fit2 <- brm(bf(y ~ 1, mu1 ~ x, mu2 ~ z), dat, family = mix,
> ##D             prior = prior, chains = 2)
> ##D summary(fit2)
> ##D 
> ##D ## fix the mixing proportions
> ##D fit3 <- brm(bf(y ~ x + z, theta1 = 1, theta2 = 2),
> ##D             dat, family = mix, prior = prior,
> ##D             init = 0, chains = 2)
> ##D summary(fit3)
> ##D pp_check(fit3)
> ##D 
> ##D ## predict the mixing proportions
> ##D fit4 <- brm(bf(y ~ x + z, theta2 ~ x),
> ##D             dat, family = mix, prior = prior,
> ##D             init = 0, chains = 2)
> ##D summary(fit4)
> ##D pp_check(fit4)
> ##D 
> ##D ## compare model fit
> ##D loo(fit1, fit2, fit3, fit4)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mm")
> ### * mm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mm
> ### Title: Set up multi-membership grouping terms in 'brms'
> ### Aliases: mm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # simulate some data
> ##D dat <- data.frame(
> ##D  y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100),
> ##D  g1 = sample(1:10, 100, TRUE), g2 = sample(1:10, 100, TRUE)
> ##D )
> ##D 
> ##D # multi-membership model with two members per group and equal weights
> ##D fit1 <- brm(y ~ x1 + (1|mm(g1, g2)), data = dat)
> ##D summary(fit1)
> ##D 
> ##D # weight the first member two times for than the second member
> ##D dat$w1 <- rep(2, 100)
> ##D dat$w2 <- rep(1, 100)
> ##D fit2 <- brm(y ~ x1 + (1|mm(g1, g2, weights = cbind(w1, w2))), data = dat)
> ##D summary(fit2)
> ##D 
> ##D # multi-membership model with level specific covariate values
> ##D dat$xc <- (dat$x1 + dat$x2) / 2
> ##D fit3 <- brm(y ~ xc + (1 + mmc(x1, x2) | mm(g1, g2)), data = dat)
> ##D summary(fit3)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mmc")
> ### * mmc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mmc
> ### Title: Multi-Membership Covariates
> ### Aliases: mmc
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # simulate some data
> ##D dat <- data.frame(
> ##D   y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100),
> ##D   g1 = sample(1:10, 100, TRUE), g2 = sample(1:10, 100, TRUE)
> ##D )
> ##D 
> ##D # multi-membership model with level specific covariate values
> ##D dat$xc <- (dat$x1 + dat$x2) / 2
> ##D fit <- brm(y ~ xc + (1 + mmc(x1, x2) | mm(g1, g2)), data = dat)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mo")
> ### * mo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mo
> ### Title: Monotonic Predictors in 'brms' Models
> ### Aliases: mo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # generate some data
> ##D income_options <- c("below_20", "20_to_40", "40_to_100", "greater_100")
> ##D income <- factor(sample(income_options, 100, TRUE),
> ##D                  levels = income_options, ordered = TRUE)
> ##D mean_ls <- c(30, 60, 70, 75)
> ##D ls <- mean_ls[income] + rnorm(100, sd = 7)
> ##D dat <- data.frame(income, ls)
> ##D 
> ##D # fit a simple monotonic model
> ##D fit1 <- brm(ls ~ mo(income), data = dat)
> ##D summary(fit1)
> ##D plot(fit1, N = 6)
> ##D plot(conditional_effects(fit1), points = TRUE)
> ##D 
> ##D # model interaction with other variables
> ##D dat$x <- sample(c("a", "b", "c"), 100, TRUE)
> ##D fit2 <- brm(ls ~ mo(income)*x, data = dat)
> ##D summary(fit2)
> ##D plot(conditional_effects(fit2), points = TRUE)
> ##D 
> ##D # ensure conditional monotonicity
> ##D fit3 <- brm(ls ~ mo(income, id = "i")*x, data = dat)
> ##D summary(fit3)
> ##D plot(conditional_effects(fit3), points = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("model_weights.brmsfit")
> ### * model_weights.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model_weights.brmsfit
> ### Title: Model Weighting Methods
> ### Aliases: model_weights.brmsfit model_weights
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with 'treat' as predictor
> ##D fit1 <- brm(rating ~ treat + period + carry, data = inhaler)
> ##D summary(fit1)
> ##D 
> ##D # model without 'treat' as predictor
> ##D fit2 <- brm(rating ~ period + carry, data = inhaler)
> ##D summary(fit2)
> ##D 
> ##D # obtain Akaike weights based on the WAIC
> ##D model_weights(fit1, fit2, weights = "waic")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("mvbind")
> ### * mvbind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mvbind
> ### Title: Bind response variables in multivariate models
> ### Aliases: mvbind
> 
> ### ** Examples
> 
> bf(mvbind(y1, y2) ~ x)
y1 ~ x 
y2 ~ x 
> 
> 
> 
> 
> cleanEx()
> nameEx("mvbrmsformula")
> ### * mvbrmsformula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mvbrmsformula
> ### Title: Set up a multivariate model formula for use in 'brms'
> ### Aliases: mvbrmsformula mvbf
> 
> ### ** Examples
> 
> bf1 <- bf(y1 ~ x + (1|g))
> bf2 <- bf(y2 ~ s(z))
> mvbf(bf1, bf2)
y1 ~ x + (1 | g) 
y2 ~ s(z) 
> 
> 
> 
> 
> cleanEx()
> nameEx("opencl")
> ### * opencl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: opencl
> ### Title: GPU support in Stan via OpenCL
> ### Aliases: opencl
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # this model just serves as an illustration
> ##D # OpenCL may not actually speed things up here
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = poisson(),
> ##D            chains = 2, cores = 2, opencl = opencl(c(0, 0)),
> ##D            backend = "cmdstanr")
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("pairs.brmsfit")
> ### * pairs.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pairs.brmsfit
> ### Title: Create a matrix of output plots from a 'brmsfit' object
> ### Aliases: pairs.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt
> ##D            + (1|patient) + (1|visit),
> ##D            data = epilepsy, family = "poisson")
> ##D pairs(fit, variable = variables(fit)[1:3])
> ##D pairs(fit, variable = "^sd_", regex = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("plot.brmsfit")
> ### * plot.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.brmsfit
> ### Title: Trace and Density Plots for MCMC Draws
> ### Aliases: plot.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt
> ##D            + (1|patient) + (1|visit),
> ##D            data = epilepsy, family = "poisson")
> ##D plot(fit)
> ##D ## plot population-level effects only
> ##D plot(fit, variable = "^b_", regex = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("post_prob.brmsfit")
> ### * post_prob.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: post_prob.brmsfit
> ### Title: Posterior Model Probabilities from Marginal Likelihoods
> ### Aliases: post_prob.brmsfit post_prob
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with the treatment effect
> ##D fit1 <- brm(
> ##D   count ~ zAge + zBase + Trt,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_all_pars = TRUE
> ##D )
> ##D summary(fit1)
> ##D 
> ##D # model without the treatent effect
> ##D fit2 <- brm(
> ##D   count ~ zAge + zBase,
> ##D   data = epilepsy, family = negbinomial(),
> ##D   prior = prior(normal(0, 1), class = b),
> ##D   save_all_pars = TRUE
> ##D )
> ##D summary(fit2)
> ##D 
> ##D # compute the posterior model probabilities
> ##D post_prob(fit1, fit2)
> ##D 
> ##D # specify prior model probabilities
> ##D post_prob(fit1, fit2, prior_prob = c(0.8, 0.2))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_average.brmsfit")
> ### * posterior_average.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_average.brmsfit
> ### Title: Posterior draws of parameters averaged across models
> ### Aliases: posterior_average.brmsfit posterior_average
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with 'treat' as predictor
> ##D fit1 <- brm(rating ~ treat + period + carry, data = inhaler)
> ##D summary(fit1)
> ##D 
> ##D # model without 'treat' as predictor
> ##D fit2 <- brm(rating ~ period + carry, data = inhaler)
> ##D summary(fit2)
> ##D 
> ##D # compute model-averaged posteriors of overlapping parameters
> ##D posterior_average(fit1, fit2, weights = "waic")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_epred.brmsfit")
> ### * posterior_epred.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_epred.brmsfit
> ### Title: Draws from the Expected Value of the Posterior Predictive
> ###   Distribution
> ### Aliases: posterior_epred.brmsfit pp_expect posterior_epred
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler)
> ##D 
> ##D ## compute expected predictions
> ##D ppe <- posterior_epred(fit)
> ##D str(ppe)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_interval.brmsfit")
> ### * posterior_interval.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_interval.brmsfit
> ### Title: Compute posterior uncertainty intervals
> ### Aliases: posterior_interval.brmsfit posterior_interval
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt,
> ##D            data = epilepsy, family = negbinomial())
> ##D posterior_interval(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_linpred.brmsfit")
> ### * posterior_linpred.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_linpred.brmsfit
> ### Title: Posterior Draws of the Linear Predictor
> ### Aliases: posterior_linpred.brmsfit posterior_linpred
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler)
> ##D 
> ##D ## extract linear predictor values
> ##D pl <- posterior_linpred(fit)
> ##D str(pl)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_predict.brmsfit")
> ### * posterior_predict.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_predict.brmsfit
> ### Title: Draws from the Posterior Predictive Distribution
> ### Aliases: posterior_predict.brmsfit posterior_predict
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(time | cens(censored) ~ age + sex + (1 + age || patient),
> ##D            data = kidney, family = "exponential", init = "0")
> ##D 
> ##D ## predicted responses
> ##D pp <- posterior_predict(fit)
> ##D str(pp)
> ##D 
> ##D ## predicted responses excluding the group-level effect of age
> ##D pp <- posterior_predict(fit, re_formula = ~ (1 | patient))
> ##D str(pp)
> ##D 
> ##D ## predicted responses of patient 1 for new data
> ##D newdata <- data.frame(
> ##D   sex = factor(c("male", "female")),
> ##D   age = c(20, 50),
> ##D   patient = c(1, 1)
> ##D )
> ##D pp <- posterior_predict(fit, newdata = newdata)
> ##D str(pp)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_samples.brmsfit")
> ### * posterior_samples.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_samples.brmsfit
> ### Title: (Deprecated) Extract Posterior Samples
> ### Aliases: posterior_samples.brmsfit posterior_samples
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler, family = "cumulative")
> ##D 
> ##D # extract posterior samples of population-level effects
> ##D samples1 <- posterior_samples(fit, pars = "^b")
> ##D head(samples1)
> ##D 
> ##D # extract posterior samples of group-level standard deviations
> ##D samples2 <- posterior_samples(fit, pars = "^sd_")
> ##D head(samples2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_smooths.brmsfit")
> ### * posterior_smooths.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_smooths.brmsfit
> ### Title: Posterior Predictions of Smooth Terms
> ### Aliases: posterior_smooths.brmsfit posterior_smooths
> 
> ### ** Examples
> 
> ## Not run: 
> ##D set.seed(0)
> ##D dat <- mgcv::gamSim(1, n = 200, scale = 2)
> ##D fit <- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
> ##D summary(fit)
> ##D 
> ##D newdata <- data.frame(x2 = seq(0, 1, 10))
> ##D str(posterior_smooths(fit, smooth = "s(x2)", newdata = newdata))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_summary")
> ### * posterior_summary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_summary
> ### Title: Summarize Posterior draws
> ### Aliases: posterior_summary posterior_summary.default
> ###   posterior_summary.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(time ~ age * sex, data = kidney)
> ##D posterior_summary(fit)
> ##D 
> ##D # recommended workflow using posterior
> ##D library(posterior)
> ##D draws <- as_draws_array(fit)
> ##D summarise_draws(draws, default_summary_measures())
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("posterior_table")
> ### * posterior_table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: posterior_table
> ### Title: Table Creation for Posterior Draws
> ### Aliases: posterior_table
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ period + carry + treat,
> ##D            data = inhaler, family = cumulative())
> ##D pr <- predict(fit, summary = FALSE)
> ##D posterior_table(pr)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("pp_average.brmsfit")
> ### * pp_average.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp_average.brmsfit
> ### Title: Posterior predictive draws averaged across models
> ### Aliases: pp_average.brmsfit pp_average
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with 'treat' as predictor
> ##D fit1 <- brm(rating ~ treat + period + carry, data = inhaler)
> ##D summary(fit1)
> ##D 
> ##D # model without 'treat' as predictor
> ##D fit2 <- brm(rating ~ period + carry, data = inhaler)
> ##D summary(fit2)
> ##D 
> ##D # compute model-averaged predicted values
> ##D (df <- unique(inhaler[, c("treat", "period", "carry")]))
> ##D pp_average(fit1, fit2, newdata = df)
> ##D 
> ##D # compute model-averaged fitted values
> ##D pp_average(fit1, fit2, method = "fitted", newdata = df)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("pp_check.brmsfit")
> ### * pp_check.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp_check.brmsfit
> ### Title: Posterior Predictive Checks for 'brmsfit' Objects
> ### Aliases: pp_check.brmsfit pp_check
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <-  brm(count ~ zAge + zBase * Trt
> ##D             + (1|patient) + (1|obs),
> ##D             data = epilepsy, family = poisson())
> ##D 
> ##D pp_check(fit)  # shows dens_overlay plot by default
> ##D pp_check(fit, type = "error_hist", ndraws = 11)
> ##D pp_check(fit, type = "scatter_avg", ndraws = 100)
> ##D pp_check(fit, type = "stat_2d")
> ##D pp_check(fit, type = "rootogram")
> ##D pp_check(fit, type = "loo_pit")
> ##D 
> ##D ## get an overview of all valid types
> ##D pp_check(fit, type = "xyz")
> ##D 
> ##D ## get a plot without the observed data
> ##D pp_check(fit, prefix = "ppd")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("pp_mixture.brmsfit")
> ### * pp_mixture.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp_mixture.brmsfit
> ### Title: Posterior Probabilities of Mixture Component Memberships
> ### Aliases: pp_mixture.brmsfit pp_mixture
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## simulate some data
> ##D set.seed(1234)
> ##D dat <- data.frame(
> ##D   y = c(rnorm(100), rnorm(50, 2)),
> ##D   x = rnorm(150)
> ##D )
> ##D ## fit a simple normal mixture model
> ##D mix <- mixture(gaussian, nmix = 2)
> ##D prior <- c(
> ##D   prior(normal(0, 5), Intercept, nlpar = mu1),
> ##D   prior(normal(0, 5), Intercept, nlpar = mu2),
> ##D   prior(dirichlet(2, 2), theta)
> ##D )
> ##D fit1 <- brm(bf(y ~ x), dat, family = mix,
> ##D             prior = prior, chains = 2, init = 0)
> ##D summary(fit1)
> ##D 
> ##D ## compute the membership probabilities
> ##D ppm <- pp_mixture(fit1)
> ##D str(ppm)
> ##D 
> ##D ## extract point estimates for each observation
> ##D head(ppm[, 1, ])
> ##D 
> ##D ## classify every observation according to
> ##D ## the most likely component
> ##D apply(ppm[, 1, ], 1, which.max)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("predict.brmsfit")
> ### * predict.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.brmsfit
> ### Title: Draws from the Posterior Predictive Distribution
> ### Aliases: predict.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(time | cens(censored) ~ age + sex + (1 + age || patient),
> ##D            data = kidney, family = "exponential", init = "0")
> ##D 
> ##D ## predicted responses
> ##D pp <- predict(fit)
> ##D head(pp)
> ##D 
> ##D ## predicted responses excluding the group-level effect of age
> ##D pp <- predict(fit, re_formula = ~ (1 | patient))
> ##D head(pp)
> ##D 
> ##D ## predicted responses of patient 1 for new data
> ##D newdata <- data.frame(
> ##D   sex = factor(c("male", "female")),
> ##D   age = c(20, 50),
> ##D   patient = c(1, 1)
> ##D )
> ##D predict(fit, newdata = newdata)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("predictive_error.brmsfit")
> ### * predictive_error.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictive_error.brmsfit
> ### Title: Posterior Draws of Predictive Errors
> ### Aliases: predictive_error.brmsfit predictive_error
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler, cores = 2)
> ##D 
> ##D ## extract predictive errors
> ##D pe <- predictive_error(fit)
> ##D str(pe)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("predictive_interval.brmsfit")
> ### * predictive_interval.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictive_interval.brmsfit
> ### Title: Predictive Intervals
> ### Aliases: predictive_interval.brmsfit predictive_interval
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zBase, data = epilepsy, family = poisson())
> ##D predictive_interval(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("prior_draws.brmsfit")
> ### * prior_draws.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prior_draws.brmsfit
> ### Title: Extract Prior Draws
> ### Aliases: prior_draws.brmsfit prior_samples prior_draws
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler, family = "cumulative",
> ##D            prior = set_prior("normal(0,2)", class = "b"),
> ##D            sample_prior = TRUE)
> ##D 
> ##D # extract all prior draws
> ##D draws1 <- prior_draws(fit)
> ##D head(draws1)
> ##D 
> ##D # extract prior draws for the coefficient of 'treat'
> ##D draws2 <- prior_draws(fit, "b_treat")
> ##D head(draws2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("prior_summary.brmsfit")
> ### * prior_summary.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prior_summary.brmsfit
> ### Title: Priors of 'brms' models
> ### Aliases: prior_summary.brmsfit prior_summary
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(
> ##D   count ~ zAge + zBase * Trt + (1|patient) + (1|obs),
> ##D   data = epilepsy, family = poisson(),
> ##D   prior = prior(student_t(5,0,10), class = b) +
> ##D     prior(cauchy(0,2), class = sd)
> ##D )
> ##D 
> ##D prior_summary(fit)
> ##D prior_summary(fit, all = FALSE)
> ##D print(prior_summary(fit, all = FALSE), show_df = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("psis.brmsfit")
> ### * psis.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psis.brmsfit
> ### Title: Pareto smoothed importance sampling (PSIS)
> ### Aliases: psis.brmsfit psis
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(rating ~ treat + period + carry, data = inhaler)
> ##D psis(fit)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ranef.brmsfit")
> ### * ranef.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranef.brmsfit
> ### Title: Extract Group-Level Estimates
> ### Aliases: ranef.brmsfit ranef
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
> ##D            data = epilepsy, family = gaussian(), chains = 2)
> ##D ranef(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("read_csv_as_stanfit")
> ### * read_csv_as_stanfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_csv_as_stanfit
> ### Title: Read CmdStan CSV files as a brms-formatted stanfit object
> ### Aliases: read_csv_as_stanfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # fit a model manually via cmdstanr
> ##D scode <- stancode(count ~ Trt, data = epilepsy)
> ##D sdata <- standata(count ~ Trt, data = epilepsy)
> ##D mod <- cmdstanr::cmdstan_model(cmdstanr::write_stan_file(scode))
> ##D stanfit <- mod$sample(data = sdata)
> ##D 
> ##D # feed the Stan model back into brms
> ##D fit <- brm(count ~ Trt, data = epilepsy, empty = TRUE, backend = 'cmdstanr')
> ##D fit$fit <- read_csv_as_stanfit(stanfit$output_files(), model = mod)
> ##D fit <- rename_pars(fit)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("reloo.brmsfit")
> ### * reloo.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reloo.brmsfit
> ### Title: Compute exact cross-validation for problematic observations
> ### Aliases: reloo.brmsfit reloo.loo reloo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D             data = epilepsy, family = poisson())
> ##D 
> ##D # throws warning about some pareto k estimates being too high
> ##D (loo1 <- loo(fit1))
> ##D 
> ##D # no more warnings after reloo
> ##D (reloo1 <- reloo(fit1, loo = loo1, chains = 1))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("rename_pars")
> ### * rename_pars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rename_pars
> ### Title: Rename parameters in brmsfit objects
> ### Aliases: rename_pars
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # fit a model manually via rstan
> ##D scode <- stancode(count ~ Trt, data = epilepsy)
> ##D sdata <- standata(count ~ Trt, data = epilepsy)
> ##D stanfit <- rstan::stan(model_code = scode, data = sdata)
> ##D 
> ##D # feed the Stan model back into brms
> ##D fit <- brm(count ~ Trt, data = epilepsy, empty = TRUE)
> ##D fit$fit <- stanfit
> ##D fit <- rename_pars(fit)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("residuals.brmsfit")
> ### * residuals.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: residuals.brmsfit
> ### Title: Posterior Draws of Residuals/Predictive Errors
> ### Aliases: residuals.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## fit a model
> ##D fit <- brm(rating ~ treat + period + carry + (1|subject),
> ##D            data = inhaler, cores = 2)
> ##D 
> ##D ## extract residuals/predictive errors
> ##D res <- residuals(fit)
> ##D head(res)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("s")
> ### * s
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: s
> ### Title: Defining smooths in 'brms' formulas
> ### Aliases: s t2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # simulate some data
> ##D dat <- mgcv::gamSim(1, n = 200, scale = 2)
> ##D 
> ##D # fit univariate smooths for all predictors
> ##D fit1 <- brm(y ~ s(x0) + s(x1) + s(x2) + s(x3),
> ##D             data = dat, chains = 2)
> ##D summary(fit1)
> ##D plot(conditional_smooths(fit1), ask = FALSE)
> ##D 
> ##D # fit a more complicated smooth model
> ##D fit2 <- brm(y ~ t2(x0, x1) + s(x2, by = x3),
> ##D             data = dat, chains = 2)
> ##D summary(fit2)
> ##D plot(conditional_smooths(fit2), ask = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sar")
> ### * sar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sar
> ### Title: Spatial simultaneous autoregressive (SAR) structures
> ### Aliases: sar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(oldcol, package = "spdep")
> ##D fit1 <- brm(CRIME ~ INC + HOVAL + sar(COL.nb, type = "lag"),
> ##D             data = COL.OLD, data2 = list(COL.nb = COL.nb),
> ##D             chains = 2, cores = 2)
> ##D summary(fit1)
> ##D plot(fit1)
> ##D 
> ##D fit2 <- brm(CRIME ~ INC + HOVAL + sar(COL.nb, type = "error"),
> ##D             data = COL.OLD, data2 = list(COL.nb = COL.nb),
> ##D             chains = 2, cores = 2)
> ##D summary(fit2)
> ##D plot(fit2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("save_pars")
> ### * save_pars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: save_pars
> ### Title: Control Saving of Parameter Draws
> ### Aliases: save_pars
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # don't store group-level coefficients
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = poisson(),
> ##D            save_pars = save_pars(group = FALSE))
> ##D variables(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("set_prior")
> ### * set_prior
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_prior
> ### Title: Prior Definitions for 'brms' Models
> ### Aliases: set_prior brmsprior brmsprior-class prior prior_ prior_string
> ###   empty_prior
> 
> ### ** Examples
> 
> ## use alias functions
> (prior1 <- prior(cauchy(0, 1), class = sd))
sd ~ cauchy(0, 1)
> (prior2 <- prior_(~cauchy(0, 1), class = ~sd))
sd ~ cauchy(0, 1)
> (prior3 <- prior_string("cauchy(0, 1)", class = "sd"))
sd ~ cauchy(0, 1)
> identical(prior1, prior2)
[1] TRUE
> identical(prior1, prior3)
[1] TRUE
> 
> # check which parameters can have priors
> default_prior(rating ~ treat + period + carry + (1|subject),
+              data = inhaler, family = cumulative())
                prior     class      coef   group resp dpar nlpar lb ub
               (flat)         b                                        
               (flat)         b     carry                              
               (flat)         b    period                              
               (flat)         b     treat                              
 student_t(3, 0, 2.5) Intercept                                        
 student_t(3, 0, 2.5) Intercept         1                              
 student_t(3, 0, 2.5) Intercept         2                              
 student_t(3, 0, 2.5) Intercept         3                              
 student_t(3, 0, 2.5)        sd                                    0   
 student_t(3, 0, 2.5)        sd           subject                  0   
 student_t(3, 0, 2.5)        sd Intercept subject                  0   
       source
      default
 (vectorized)
 (vectorized)
 (vectorized)
      default
 (vectorized)
 (vectorized)
 (vectorized)
      default
 (vectorized)
 (vectorized)
> 
> # define some priors
> bprior <- c(prior_string("normal(0,10)", class = "b"),
+             prior(normal(1,2), class = b, coef = treat),
+             prior_(~cauchy(0,2), class = ~sd,
+                    group = ~subject, coef = ~Intercept))
> 
> # verify that the priors indeed found their way into Stan's model code
> stancode(rating ~ treat + period + carry + (1|subject),
+          data = inhaler, family = cumulative(),
+          prior = bprior)
// generated with brms 2.22.0
functions {
  /* cumulative-logit log-PDF for a single response
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: ordinal thresholds
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {
     int nthres = num_elements(thres);
     if (y == 1) {
       return log_inv_logit(disc * (thres[1] - mu));
     } else if (y == nthres + 1) {
       return log1m_inv_logit(disc * (thres[nthres] - mu));
     } else {
       return log_inv_logit_diff(disc * (thres[y] - mu), disc * (thres[y - 1] - mu));
     }
   }
  /* cumulative-logit log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, array[] int j) {
     return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);
   }
  /* ordered-logistic log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real ordered_logistic_merged_lpmf(int y, real mu, vector thres, array[] int j) {
     return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);
   }

}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=2> nthres;  // number of thresholds
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X
  vector[Kc] means_X;  // column means of X before centering
  for (i in 1:K) {
    means_X[i] = mean(X[, i]);
    Xc[, i] = X[, i] - means_X[i];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  ordered[nthres] Intercept;  // temporary thresholds for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
}
transformed parameters {
  real disc = 1;  // discrimination parameters
  vector[N_1] r_1_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  lprior += normal_lpdf(b[1] | 1, 2);
  lprior += normal_lpdf(b[2] | 0,10);
  lprior += normal_lpdf(b[3] | 0,10);
  lprior += student_t_lpdf(Intercept | 3, 0, 2.5);
  lprior += cauchy_lpdf(sd_1[1] | 0, 2)
    - 1 * cauchy_lccdf(0 | 0, 2);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Xc * b;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n];
    }
    for (n in 1:N) {
      target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);
    }
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
}
generated quantities {
  // compute actual thresholds
  vector[nthres] b_Intercept = Intercept + dot_product(means_X, b);
}
> 
> # use the horseshoe prior to model sparsity in regression coefficients
> stancode(count ~ zAge + zBase * Trt,
+          data = epilepsy, family = poisson(),
+          prior = set_prior("horseshoe(3)"))
// generated with brms 2.22.0
functions {
  /* Efficient computation of the horseshoe scale parameters
   * see Appendix C.1 in https://projecteuclid.org/euclid.ejs/1513306866
   * Args:
   *   lambda: local shrinkage parameters
   *   tau: global shrinkage parameter
   *   c2: slap regularization parameter
   * Returns:
   *   scale parameter vector of the horseshoe prior
   */
  vector scales_horseshoe(vector lambda, real tau, real c2) {
    int K = rows(lambda);
    vector[K] lambda2 = square(lambda);
    vector[K] lambda_tilde = sqrt(c2 * lambda2 ./ (c2 + tau^2 * lambda2));
    return lambda_tilde * tau;
  }
}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int<lower=1> Kscales;  // number of local scale parameters
  // data for the horseshoe prior
  real<lower=0> hs_df;  // local degrees of freedom
  real<lower=0> hs_df_global;  // global degrees of freedom
  real<lower=0> hs_df_slab;  // slab degrees of freedom
  real<lower=0> hs_scale_global;  // global prior scale
  real<lower=0> hs_scale_slab;  // slab prior scale
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] zb;  // unscaled coefficients
  real Intercept;  // temporary intercept for centered predictors
  // horseshoe shrinkage parameters
  real<lower=0> hs_global;  // global shrinkage parameter
  real<lower=0> hs_slab;  // slab regularization parameter
  vector<lower=0>[Kscales] hs_local;  // local parameters for the horseshoe prior
}
transformed parameters {
  vector[Kc] b;  // scaled coefficients
  vector<lower=0>[Kc] sdb;  // SDs of the coefficients
  vector<lower=0>[Kscales] scales;  // local horseshoe scale parameters
  real lprior = 0;  // prior contributions to the log posterior
  // compute horseshoe scale parameters
  scales = scales_horseshoe(hs_local, hs_global, hs_scale_slab^2 * hs_slab);
  sdb = scales[(1):(Kc)];
  b = zb .* sdb;  // scale coefficients
  lprior += student_t_lpdf(Intercept | 3, 1.4, 2.5);
  lprior += student_t_lpdf(hs_global | hs_df_global, 0, hs_scale_global)
    - 1 * log(0.5);
  lprior += inv_gamma_lpdf(hs_slab | 0.5 * hs_df_slab, 0.5 * hs_df_slab);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += poisson_log_glm_lpmf(Y | Xc, Intercept, b);
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(zb);
  target += student_t_lpdf(hs_local | hs_df, 0, 1)
    - rows(hs_local) * log(0.5);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # fix certain priors to constants
> bprior <- prior(constant(1), class = "b") +
+   prior(constant(2), class = "b", coef = "zBase") +
+   prior(constant(0.5), class = "sd")
> stancode(count ~ zAge + zBase + (1 | patient),
+               data = epilepsy, prior = bprior)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
}
transformed parameters {
  vector[Kc] b;  // regression coefficients
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  vector[N_1] r_1_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  b[1] = 1;
  b[2] = 2;
  sd_1 = rep_vector(0.5, rows(sd_1));
  r_1_1 = (sd_1[1] * (z_1[1]));
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Intercept;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n];
    }
    target += normal_id_glm_lpdf(Y | Xc, mu, b, sigma);
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # pass priors to Stan without checking
> prior <- prior_string("target += normal_lpdf(b[1] | 0, 1)", check = FALSE)
> stancode(count ~ Trt, data = epilepsy, prior = prior)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
  target += normal_lpdf(b[1] | 0, 1);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # define priors in a vectorized manner
> # useful in particular for categorical or multivariate models
> set_prior("normal(0, 2)", dpar = c("muX", "muY", "muZ"))
        prior class coef group resp dpar nlpar   lb   ub source
 normal(0, 2)     b                  muX       <NA> <NA>   user
 normal(0, 2)     b                  muY       <NA> <NA>   user
 normal(0, 2)     b                  muZ       <NA> <NA>   user
> 
> 
> 
> 
> cleanEx()
> nameEx("stancode")
> ### * stancode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stancode
> ### Title: Stan Code for Bayesian models
> ### Aliases: stancode make_stancode
> 
> ### ** Examples
> 
> stancode(rating ~ treat + period + carry + (1|subject),
+          data = inhaler, family = "cumulative")
// generated with brms 2.22.0
functions {
  /* cumulative-logit log-PDF for a single response
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: ordinal thresholds
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {
     int nthres = num_elements(thres);
     if (y == 1) {
       return log_inv_logit(disc * (thres[1] - mu));
     } else if (y == nthres + 1) {
       return log1m_inv_logit(disc * (thres[nthres] - mu));
     } else {
       return log_inv_logit_diff(disc * (thres[y] - mu), disc * (thres[y - 1] - mu));
     }
   }
  /* cumulative-logit log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, array[] int j) {
     return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);
   }
  /* ordered-logistic log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real ordered_logistic_merged_lpmf(int y, real mu, vector thres, array[] int j) {
     return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);
   }

}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=2> nthres;  // number of thresholds
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X
  vector[Kc] means_X;  // column means of X before centering
  for (i in 1:K) {
    means_X[i] = mean(X[, i]);
    Xc[, i] = X[, i] - means_X[i];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  ordered[nthres] Intercept;  // temporary thresholds for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
}
transformed parameters {
  real disc = 1;  // discrimination parameters
  vector[N_1] r_1_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  lprior += student_t_lpdf(Intercept | 3, 0, 2.5);
  lprior += student_t_lpdf(sd_1 | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Xc * b;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n];
    }
    for (n in 1:N) {
      target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);
    }
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
}
generated quantities {
  // compute actual thresholds
  vector[nthres] b_Intercept = Intercept + dot_product(means_X, b);
}
> 
> 
> 
> 
> cleanEx()
> nameEx("stancode.default")
> ### * stancode.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stancode.default
> ### Title: Stan Code for 'brms' Models
> ### Aliases: stancode.default
> 
> ### ** Examples
> 
> stancode(rating ~ treat + period + carry + (1|subject),
+          data = inhaler, family = "cumulative")
// generated with brms 2.22.0
functions {
  /* cumulative-logit log-PDF for a single response
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: ordinal thresholds
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {
     int nthres = num_elements(thres);
     if (y == 1) {
       return log_inv_logit(disc * (thres[1] - mu));
     } else if (y == nthres + 1) {
       return log1m_inv_logit(disc * (thres[nthres] - mu));
     } else {
       return log_inv_logit_diff(disc * (thres[y] - mu), disc * (thres[y - 1] - mu));
     }
   }
  /* cumulative-logit log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, array[] int j) {
     return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);
   }
  /* ordered-logistic log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real ordered_logistic_merged_lpmf(int y, real mu, vector thres, array[] int j) {
     return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);
   }

}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=2> nthres;  // number of thresholds
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X
  vector[Kc] means_X;  // column means of X before centering
  for (i in 1:K) {
    means_X[i] = mean(X[, i]);
    Xc[, i] = X[, i] - means_X[i];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  ordered[nthres] Intercept;  // temporary thresholds for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
}
transformed parameters {
  real disc = 1;  // discrimination parameters
  vector[N_1] r_1_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  lprior += student_t_lpdf(Intercept | 3, 0, 2.5);
  lprior += student_t_lpdf(sd_1 | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Xc * b;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n];
    }
    for (n in 1:N) {
      target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);
    }
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
}
generated quantities {
  // compute actual thresholds
  vector[nthres] b_Intercept = Intercept + dot_product(means_X, b);
}
> 
> stancode(count ~ zAge + zBase * Trt + (1|patient),
+          data = epilepsy, family = "poisson")
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
}
transformed parameters {
  vector[N_1] r_1_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  lprior += student_t_lpdf(Intercept | 3, 1.4, 2.5);
  lprior += student_t_lpdf(sd_1 | 3, 0, 2.5)
    - 1 * student_t_lccdf(0 | 3, 0, 2.5);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Intercept;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n];
    }
    target += poisson_log_glm_lpmf(Y | Xc, mu, b);
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> 
> 
> 
> cleanEx()
> nameEx("standata")
> ### * standata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: standata
> ### Title: Stan data for Bayesian models
> ### Aliases: standata make_standata
> 
> ### ** Examples
> 
> sdata1 <- standata(rating ~ treat + period + carry + (1|subject),
+                    data = inhaler, family = "cumulative")
> str(sdata1)
List of 13
 $ N         : int 572
 $ Y         : num [1:572(1d)] 1 1 1 1 1 1 1 1 1 1 ...
 $ nthres    : int 3
 $ K         : int 3
 $ Kc        : num 3
 $ X         : num [1:572, 1:3] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:572] "1" "2" "3" "4" ...
  .. ..$ : chr [1:3] "treat" "period" "carry"
 $ Z_1_1     : num [1:572(1d)] 1 1 1 1 1 1 1 1 1 1 ...
  ..- attr(*, "dimnames")=List of 1
  .. ..$ : chr [1:572] "1" "2" "3" "4" ...
 $ disc      : num 1
 $ J_1       : int [1:572(1d)] 1 2 3 4 5 6 7 8 9 10 ...
 $ N_1       : int 286
 $ M_1       : int 1
 $ NC_1      : int 0
 $ prior_only: int 0
 - attr(*, "class")= chr [1:2] "standata" "list"
> 
> 
> 
> 
> cleanEx()
> nameEx("standata.default")
> ### * standata.default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: standata.default
> ### Title: Data for 'brms' Models
> ### Aliases: standata.default
> 
> ### ** Examples
> 
> sdata1 <- standata(rating ~ treat + period + carry + (1|subject),
+                    data = inhaler, family = "cumulative")
> str(sdata1)
List of 13
 $ N         : int 572
 $ Y         : num [1:572(1d)] 1 1 1 1 1 1 1 1 1 1 ...
 $ nthres    : int 3
 $ K         : int 3
 $ Kc        : num 3
 $ X         : num [1:572, 1:3] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:572] "1" "2" "3" "4" ...
  .. ..$ : chr [1:3] "treat" "period" "carry"
 $ Z_1_1     : num [1:572(1d)] 1 1 1 1 1 1 1 1 1 1 ...
  ..- attr(*, "dimnames")=List of 1
  .. ..$ : chr [1:572] "1" "2" "3" "4" ...
 $ disc      : num 1
 $ J_1       : int [1:572(1d)] 1 2 3 4 5 6 7 8 9 10 ...
 $ N_1       : int 286
 $ M_1       : int 1
 $ NC_1      : int 0
 $ prior_only: int 0
 - attr(*, "class")= chr [1:2] "standata" "list"
> 
> sdata2 <- standata(count ~ zAge + zBase * Trt + (1|patient),
+                    data = epilepsy, family = "poisson")
> str(sdata2)
List of 11
 $ N         : int 236
 $ Y         : num [1:236(1d)] 5 3 2 4 7 5 6 40 5 14 ...
 $ K         : int 5
 $ Kc        : num 4
 $ X         : num [1:236, 1:5] 1 1 1 1 1 1 1 1 1 1 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:236] "1" "2" "3" "4" ...
  .. ..$ : chr [1:5] "Intercept" "zAge" "zBase" "Trt1" ...
  ..- attr(*, "assign")= int [1:5] 0 1 2 3 4
  ..- attr(*, "contrasts")=List of 1
  .. ..$ Trt: num [1:2, 1] 0 1
  .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. ..$ : chr [1:2] "0" "1"
  .. .. .. ..$ : chr "1"
 $ Z_1_1     : num [1:236(1d)] 1 1 1 1 1 1 1 1 1 1 ...
  ..- attr(*, "dimnames")=List of 1
  .. ..$ : chr [1:236] "1" "2" "3" "4" ...
 $ J_1       : int [1:236(1d)] 1 2 3 4 5 6 7 8 9 10 ...
 $ N_1       : int 59
 $ M_1       : int 1
 $ NC_1      : int 0
 $ prior_only: int 0
 - attr(*, "class")= chr [1:2] "standata" "list"
> 
> 
> 
> 
> cleanEx()
> nameEx("stanvar")
> ### * stanvar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stanvar
> ### Title: User-defined variables passed to Stan
> ### Aliases: stanvar stanvars
> 
> ### ** Examples
> 
> bprior <- prior(normal(mean_intercept, 10), class = "Intercept")
> stanvars <- stanvar(5, name = "mean_intercept")
> stancode(count ~ Trt, epilepsy, prior = bprior,
+          stanvars = stanvars)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
  real mean_intercept;
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += normal_lpdf(Intercept | mean_intercept, 10);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # define a multi-normal prior with known covariance matrix
> bprior <- prior(multi_normal(M, V), class = "b")
> stanvars <- stanvar(rep(0, 2), "M", scode = "  vector[K] M;") +
+   stanvar(diag(2), "V", scode = "  matrix[K, K] V;")
> stancode(count ~ Trt + zBase, epilepsy,
+          prior = bprior, stanvars = stanvars)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
    vector[K] M;
    matrix[K, K] V;
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += multi_normal_lpdf(b | M, V);
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # define a hierachical prior on the regression coefficients
> bprior <- set_prior("normal(0, tau)", class = "b") +
+   set_prior("target += normal_lpdf(tau | 0, 10)", check = FALSE)
> stanvars <- stanvar(scode = "real<lower=0> tau;",
+                     block = "parameters")
> stancode(count ~ Trt + zBase, epilepsy,
+          prior = bprior, stanvars = stanvars)
// generated with brms 2.22.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
  real<lower=0> tau;
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += normal_lpdf(b | 0, tau);
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += normal_id_glm_lpdf(Y | Xc, Intercept, b, sigma);
  }
  // priors including constants
  target += lprior;
  target += normal_lpdf(tau | 0, 10);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> # ensure that 'tau' is passed to the likelihood of a threaded model
> # not necessary for this example but may be necessary in other cases
> stanvars <- stanvar(scode = "real<lower=0> tau;",
+                     block = "parameters", pll_args = "real tau")
> stancode(count ~ Trt + zBase, epilepsy,
+          stanvars = stanvars, threads = threading(2))
// generated with brms 2.22.0
functions {
  /* integer sequence of values
   * Args:
   *   start: starting integer
   *   end: ending integer
   * Returns:
   *   an integer sequence from start to end
   */
  array[] int sequence(int start, int end) {
    array[end - start + 1] int seq;
    for (n in 1:num_elements(seq)) {
      seq[n] = n + start - 1;
    }
    return seq;
  }
  // compute partial sums of the log-likelihood
  real partial_log_lik_lpmf(array[] int seq, int start, int end, data vector Y, data matrix Xc, vector b, real Intercept, real sigma, real tau) {
    real ptarget = 0;
    int N = end - start + 1;
    ptarget += normal_id_glm_lpdf(Y[start:end] | Xc[start:end], Intercept, b, sigma);
    return ptarget;
  }
}
data {
  int<lower=1> N;  // total number of observations
  vector[N] Y;  // response variable
  int<lower=1> K;  // number of population-level effects
  matrix[N, K] X;  // population-level design matrix
  int<lower=1> Kc;  // number of population-level effects after centering
  int grainsize;  // grainsize for threading
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  matrix[N, Kc] Xc;  // centered version of X without an intercept
  vector[Kc] means_X;  // column means of X before centering
  array[N] int seq = sequence(1, N);
  for (i in 2:K) {
    means_X[i - 1] = mean(X[, i]);
    Xc[, i - 1] = X[, i] - means_X[i - 1];
  }
}
parameters {
  vector[Kc] b;  // regression coefficients
  real Intercept;  // temporary intercept for centered predictors
  real<lower=0> sigma;  // dispersion parameter
  real<lower=0> tau;
}
transformed parameters {
  real lprior = 0;  // prior contributions to the log posterior
  lprior += student_t_lpdf(Intercept | 3, 4, 4.4);
  lprior += student_t_lpdf(sigma | 3, 0, 4.4)
    - 1 * student_t_lccdf(0 | 3, 0, 4.4);
}
model {
  // likelihood including constants
  if (!prior_only) {
    target += reduce_sum(partial_log_lik_lpmf, seq, grainsize, Y, Xc, b, Intercept, sigma, tau);
  }
  // priors including constants
  target += lprior;
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept - dot_product(means_X, b);
}
> 
> 
> 
> 
> cleanEx()
> nameEx("theme_black")
> ### * theme_black
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theme_black
> ### Title: (Deprecated) Black Theme for 'ggplot2' Graphics
> ### Aliases: theme_black
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # change default ggplot theme
> ##D ggplot2::theme_set(theme_black())
> ##D 
> ##D # change default bayesplot color scheme
> ##D bayesplot::color_scheme_set("viridisC")
> ##D 
> ##D # fit a simple model
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = poisson(), chains = 2)
> ##D summary(fit)
> ##D 
> ##D # create various plots
> ##D plot(marginal_effects(fit), ask = FALSE)
> ##D pp_check(fit)
> ##D mcmc_plot(fit, type = "hex", variable = c("b_Intercept", "b_Trt1"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("threading")
> ### * threading
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: threading
> ### Title: Threading in Stan
> ### Aliases: threading
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # this model just serves as an illustration
> ##D # threading may not actually speed things up here
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1|patient),
> ##D            data = epilepsy, family = negbinomial(),
> ##D            chains = 1, threads = threading(2, grainsize = 100),
> ##D            backend = "cmdstanr")
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("unstr")
> ### * unstr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unstr
> ### Title: Set up UNSTR correlation structures
> ### Aliases: unstr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # add an unstructured correlation matrix for visits within the same patient
> ##D fit <- brm(count ~ Trt + unstr(visit, patient), data = epilepsy)
> ##D summary(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("update.brmsfit")
> ### * update.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.brmsfit
> ### Title: Update 'brms' models
> ### Aliases: update.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit1 <- brm(time | cens(censored) ~ age * sex + disease + (1|patient),
> ##D             data = kidney, family = gaussian("log"))
> ##D summary(fit1)
> ##D 
> ##D ## remove effects of 'disease'
> ##D fit2 <- update(fit1, formula. = ~ . - disease)
> ##D summary(fit2)
> ##D 
> ##D ## remove the group specific term of 'patient' and
> ##D ## change the data (just take a subset in this example)
> ##D fit3 <- update(fit1, formula. = ~ . - (1|patient),
> ##D                newdata = kidney[1:38, ])
> ##D summary(fit3)
> ##D 
> ##D ## use another family and add population-level priors
> ##D fit4 <- update(fit1, family = weibull(), init = "0",
> ##D                prior = set_prior("normal(0,5)"))
> ##D summary(fit4)
> ##D 
> ##D ## to avoid a recompilation when updating a 'cmdstanr'-backend fit in a fresh
> ##D ## R session, set option 'cmdstanr_write_stan_file_dir' before creating the
> ##D ## initial 'brmsfit'
> ##D ## CAUTION: the following code creates some files in the current working
> ##D ## directory: two 'model_<hash>.stan' files, one 'model_<hash>(.exe)'
> ##D ## executable, and one 'fit_cmdstanr_<some_number>.rds' file
> ##D set.seed(7)
> ##D fname <- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
> ##D options(cmdstanr_write_stan_file_dir = getwd())
> ##D fit_cmdstanr <- brm(rate ~ conc + state,
> ##D                     data = Puromycin,
> ##D                     backend = "cmdstanr",
> ##D                     file = fname)
> ##D # now restart the R session and run the following (after attaching 'brms')
> ##D set.seed(7)
> ##D fname <- paste0("fit_cmdstanr_", sample.int(.Machine$integer.max, 1))
> ##D fit_cmdstanr <- brm(rate ~ conc + state,
> ##D                     data = Puromycin,
> ##D                     backend = "cmdstanr",
> ##D                     file = fname)
> ##D upd_cmdstanr <- update(fit_cmdstanr,
> ##D                        formula. = rate ~ conc)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("update.brmsfit_multiple")
> ### * update.brmsfit_multiple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update.brmsfit_multiple
> ### Title: Update 'brms' models based on multiple data sets
> ### Aliases: update.brmsfit_multiple
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(mice)
> ##D imp <- mice(nhanes2)
> ##D 
> ##D # initially fit the model
> ##D fit_imp1 <- brm_multiple(bmi ~ age + hyp + chl, data = imp, chains = 1)
> ##D summary(fit_imp1)
> ##D 
> ##D # update the model using fewer predictors
> ##D fit_imp2 <- update(fit_imp1, formula. = . ~ hyp + chl, newdata = imp)
> ##D summary(fit_imp2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("update_adterms")
> ### * update_adterms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_adterms
> ### Title: Update Formula Addition Terms
> ### Aliases: update_adterms
> 
> ### ** Examples
> 
> form <- y | trials(size) ~ x
> update_adterms(form, ~ trials(10))
y | trials(10) ~ x
> update_adterms(form, ~ weights(w))
y | trials(size) + weights(w) ~ x
> update_adterms(form, ~ weights(w), action = "replace")
y | weights(w) ~ x
> update_adterms(y ~ x, ~ trials(10))
y | trials(10) ~ x
> 
> 
> 
> 
> cleanEx()
> nameEx("validate_prior")
> ### * validate_prior
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validate_prior
> ### Title: Validate Prior for 'brms' Models
> ### Aliases: validate_prior
> 
> ### ** Examples
> 
> prior1 <- prior(normal(0,10), class = b) +
+   prior(cauchy(0,2), class = sd)
> validate_prior(prior1, count ~ zAge + zBase * Trt + (1|patient),
+                data = epilepsy, family = poisson())
                  prior     class       coef   group resp dpar nlpar lb ub
          normal(0, 10)         b                                         
          normal(0, 10)         b       Trt1                              
          normal(0, 10)         b       zAge                              
          normal(0, 10)         b      zBase                              
          normal(0, 10)         b zBase:Trt1                              
 student_t(3, 1.4, 2.5) Intercept                                         
           cauchy(0, 2)        sd                                     0   
           cauchy(0, 2)        sd            patient                  0   
           cauchy(0, 2)        sd  Intercept patient                  0   
       source
         user
 (vectorized)
 (vectorized)
 (vectorized)
 (vectorized)
      default
         user
 (vectorized)
 (vectorized)
> 
> 
> 
> 
> cleanEx()
> nameEx("vcov.brmsfit")
> ### * vcov.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.brmsfit
> ### Title: Covariance and Correlation Matrix of Population-Level Effects
> ### Aliases: vcov.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fit <- brm(count ~ zAge + zBase * Trt + (1+Trt|visit),
> ##D            data = epilepsy, family = gaussian(), chains = 2)
> ##D vcov(fit)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("waic.brmsfit")
> ### * waic.brmsfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: waic.brmsfit
> ### Title: Widely Applicable Information Criterion (WAIC)
> ### Aliases: waic.brmsfit waic WAIC WAIC.brmsfit
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # model with population-level effects only
> ##D fit1 <- brm(rating ~ treat + period + carry,
> ##D             data = inhaler)
> ##D (waic1 <- waic(fit1))
> ##D 
> ##D # model with an additional varying intercept for subjects
> ##D fit2 <- brm(rating ~ treat + period + carry + (1|subject),
> ##D             data = inhaler)
> ##D (waic2 <- waic(fit2))
> ##D 
> ##D # compare both models
> ##D loo_compare(waic1, waic2)
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.534 0.159 3.703 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
